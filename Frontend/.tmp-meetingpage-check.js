var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn2, res) => function __init() {
  return fn2 && (res = (0, fn2[__getOwnPropNames(fn2)[0]])(fn2 = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all3) => {
  for (var name in all3)
    __defProp(target, name, { get: all3[name], enumerable: true });
};
var __copyProps = (to2, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to2, key) && key !== except)
        __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to2;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS({
  "node_modules/react/cjs/react.development.js"(exports, module) {
    "use strict";
    (function() {
      function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component4.prototype, methodName, {
          get: function() {
            console.warn(
              "%s(...) is deprecated in plain JavaScript React classes. %s",
              info[0],
              info[1]
            );
          }
        });
      }
      function getIteratorFn(maybeIterable) {
        if (null === maybeIterable || "object" !== typeof maybeIterable)
          return null;
        maybeIterable = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable["@@iterator"];
        return "function" === typeof maybeIterable ? maybeIterable : null;
      }
      function warnNoop(publicInstance, callerName) {
        publicInstance = (publicInstance = publicInstance.constructor) && (publicInstance.displayName || publicInstance.name) || "ReactClass";
        var warningKey = publicInstance + "." + callerName;
        didWarnStateUpdateForUnmountedComponent[warningKey] || (console.error(
          "Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.",
          callerName,
          publicInstance
        ), didWarnStateUpdateForUnmountedComponent[warningKey] = true);
      }
      function Component4(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function ComponentDummy() {
      }
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      function noop2() {
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        try {
          testStringCoercion(value);
          var JSCompiler_inline_result = false;
        } catch (e2) {
          JSCompiler_inline_result = true;
        }
        if (JSCompiler_inline_result) {
          JSCompiler_inline_result = console;
          var JSCompiler_temp_const = JSCompiler_inline_result.error;
          var JSCompiler_inline_result$jscomp$0 = "function" === typeof Symbol && Symbol.toStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          JSCompiler_temp_const.call(
            JSCompiler_inline_result,
            "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
            JSCompiler_inline_result$jscomp$0
          );
          return testStringCoercion(value);
        }
      }
      function getComponentNameFromType(type) {
        if (null == type) return null;
        if ("function" === typeof type)
          return type.$$typeof === REACT_CLIENT_REFERENCE ? null : type.displayName || type.name || null;
        if ("string" === typeof type) return type;
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
          case REACT_ACTIVITY_TYPE:
            return "Activity";
        }
        if ("object" === typeof type)
          switch ("number" === typeof type.tag && console.error(
            "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
          ), type.$$typeof) {
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_CONTEXT_TYPE:
              return type.displayName || "Context";
            case REACT_CONSUMER_TYPE:
              return (type._context.displayName || "Context") + ".Consumer";
            case REACT_FORWARD_REF_TYPE:
              var innerType = type.render;
              type = type.displayName;
              type || (type = innerType.displayName || innerType.name || "", type = "" !== type ? "ForwardRef(" + type + ")" : "ForwardRef");
              return type;
            case REACT_MEMO_TYPE:
              return innerType = type.displayName || null, null !== innerType ? innerType : getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE:
              innerType = type._payload;
              type = type._init;
              try {
                return getComponentNameFromType(type(innerType));
              } catch (x2) {
              }
          }
        return null;
      }
      function getTaskName(type) {
        if (type === REACT_FRAGMENT_TYPE) return "<>";
        if ("object" === typeof type && null !== type && type.$$typeof === REACT_LAZY_TYPE)
          return "<...>";
        try {
          var name = getComponentNameFromType(type);
          return name ? "<" + name + ">" : "<...>";
        } catch (x2) {
          return "<...>";
        }
      }
      function getOwner() {
        var dispatcher = ReactSharedInternals.A;
        return null === dispatcher ? null : dispatcher.getOwner();
      }
      function UnknownOwner() {
        return Error("react-stack-top-frame");
      }
      function hasValidKey(config) {
        if (hasOwnProperty2.call(config, "key")) {
          var getter = Object.getOwnPropertyDescriptor(config, "key").get;
          if (getter && getter.isReactWarning) return false;
        }
        return void 0 !== config.key;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        function warnAboutAccessingKey() {
          specialPropKeyWarningShown || (specialPropKeyWarningShown = true, console.error(
            "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
            displayName
          ));
        }
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function elementRefGetterWithDeprecationWarning() {
        var componentName = getComponentNameFromType(this.type);
        didWarnAboutElementRef[componentName] || (didWarnAboutElementRef[componentName] = true, console.error(
          "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
        ));
        componentName = this.props.ref;
        return void 0 !== componentName ? componentName : null;
      }
      function ReactElement(type, key, props, owner, debugStack, debugTask) {
        var refProp = props.ref;
        type = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          props,
          _owner: owner
        };
        null !== (void 0 !== refProp ? refProp : null) ? Object.defineProperty(type, "ref", {
          enumerable: false,
          get: elementRefGetterWithDeprecationWarning
        }) : Object.defineProperty(type, "ref", { enumerable: false, value: null });
        type._store = {};
        Object.defineProperty(type._store, "validated", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: 0
        });
        Object.defineProperty(type, "_debugInfo", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: null
        });
        Object.defineProperty(type, "_debugStack", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugStack
        });
        Object.defineProperty(type, "_debugTask", {
          configurable: false,
          enumerable: false,
          writable: true,
          value: debugTask
        });
        Object.freeze && (Object.freeze(type.props), Object.freeze(type));
        return type;
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        newKey = ReactElement(
          oldElement.type,
          newKey,
          oldElement.props,
          oldElement._owner,
          oldElement._debugStack,
          oldElement._debugTask
        );
        oldElement._store && (newKey._store.validated = oldElement._store.validated);
        return newKey;
      }
      function validateChildKeys(node) {
        isValidElement2(node) ? node._store && (node._store.validated = 1) : "object" === typeof node && null !== node && node.$$typeof === REACT_LAZY_TYPE && ("fulfilled" === node._payload.status ? isValidElement2(node._payload.value) && node._payload.value._store && (node._payload.value._store.validated = 1) : node._store && (node._store.validated = 1));
      }
      function isValidElement2(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      function escape(key) {
        var escaperLookup = { "=": "=0", ":": "=2" };
        return "$" + key.replace(/[=:]/g, function(match) {
          return escaperLookup[match];
        });
      }
      function getElementKey(element, index) {
        return "object" === typeof element && null !== element && null != element.key ? (checkKeyStringCoercion(element.key), escape("" + element.key)) : index.toString(36);
      }
      function resolveThenable(thenable) {
        switch (thenable.status) {
          case "fulfilled":
            return thenable.value;
          case "rejected":
            throw thenable.reason;
          default:
            switch ("string" === typeof thenable.status ? thenable.then(noop2, noop2) : (thenable.status = "pending", thenable.then(
              function(fulfilledValue) {
                "pending" === thenable.status && (thenable.status = "fulfilled", thenable.value = fulfilledValue);
              },
              function(error2) {
                "pending" === thenable.status && (thenable.status = "rejected", thenable.reason = error2);
              }
            )), thenable.status) {
              case "fulfilled":
                return thenable.value;
              case "rejected":
                throw thenable.reason;
            }
        }
        throw thenable;
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if ("undefined" === type || "boolean" === type) children = null;
        var invokeCallback = false;
        if (null === children) invokeCallback = true;
        else
          switch (type) {
            case "bigint":
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
                  break;
                case REACT_LAZY_TYPE:
                  return invokeCallback = children._init, mapIntoArray(
                    invokeCallback(children._payload),
                    array,
                    escapedPrefix,
                    nameSoFar,
                    callback
                  );
              }
          }
        if (invokeCallback) {
          invokeCallback = children;
          callback = callback(invokeCallback);
          var childKey = "" === nameSoFar ? "." + getElementKey(invokeCallback, 0) : nameSoFar;
          isArrayImpl(callback) ? (escapedPrefix = "", null != childKey && (escapedPrefix = childKey.replace(userProvidedKeyEscapeRegex, "$&/") + "/"), mapIntoArray(callback, array, escapedPrefix, "", function(c2) {
            return c2;
          })) : null != callback && (isValidElement2(callback) && (null != callback.key && (invokeCallback && invokeCallback.key === callback.key || checkKeyStringCoercion(callback.key)), escapedPrefix = cloneAndReplaceKey(
            callback,
            escapedPrefix + (null == callback.key || invokeCallback && invokeCallback.key === callback.key ? "" : ("" + callback.key).replace(
              userProvidedKeyEscapeRegex,
              "$&/"
            ) + "/") + childKey
          ), "" !== nameSoFar && null != invokeCallback && isValidElement2(invokeCallback) && null == invokeCallback.key && invokeCallback._store && !invokeCallback._store.validated && (escapedPrefix._store.validated = 2), callback = escapedPrefix), array.push(callback));
          return 1;
        }
        invokeCallback = 0;
        childKey = "" === nameSoFar ? "." : nameSoFar + ":";
        if (isArrayImpl(children))
          for (var i2 = 0; i2 < children.length; i2++)
            nameSoFar = children[i2], type = childKey + getElementKey(nameSoFar, i2), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if (i2 = getIteratorFn(children), "function" === typeof i2)
          for (i2 === children.entries && (didWarnAboutMaps || console.warn(
            "Using Maps as children is not supported. Use an array of keyed ReactElements instead."
          ), didWarnAboutMaps = true), children = i2.call(children), i2 = 0; !(nameSoFar = children.next()).done; )
            nameSoFar = nameSoFar.value, type = childKey + getElementKey(nameSoFar, i2++), invokeCallback += mapIntoArray(
              nameSoFar,
              array,
              escapedPrefix,
              type,
              callback
            );
        else if ("object" === type) {
          if ("function" === typeof children.then)
            return mapIntoArray(
              resolveThenable(children),
              array,
              escapedPrefix,
              nameSoFar,
              callback
            );
          array = String(children);
          throw Error(
            "Objects are not valid as a React child (found: " + ("[object Object]" === array ? "object with keys {" + Object.keys(children).join(", ") + "}" : array) + "). If you meant to render a collection of children, use an array instead."
          );
        }
        return invokeCallback;
      }
      function mapChildren(children, func, context) {
        if (null == children) return children;
        var result = [], count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function lazyInitializer(payload) {
        if (-1 === payload._status) {
          var ioInfo = payload._ioInfo;
          null != ioInfo && (ioInfo.start = ioInfo.end = performance.now());
          ioInfo = payload._result;
          var thenable = ioInfo();
          thenable.then(
            function(moduleObject) {
              if (0 === payload._status || -1 === payload._status) {
                payload._status = 1;
                payload._result = moduleObject;
                var _ioInfo = payload._ioInfo;
                null != _ioInfo && (_ioInfo.end = performance.now());
                void 0 === thenable.status && (thenable.status = "fulfilled", thenable.value = moduleObject);
              }
            },
            function(error2) {
              if (0 === payload._status || -1 === payload._status) {
                payload._status = 2;
                payload._result = error2;
                var _ioInfo2 = payload._ioInfo;
                null != _ioInfo2 && (_ioInfo2.end = performance.now());
                void 0 === thenable.status && (thenable.status = "rejected", thenable.reason = error2);
              }
            }
          );
          ioInfo = payload._ioInfo;
          if (null != ioInfo) {
            ioInfo.value = thenable;
            var displayName = thenable.displayName;
            "string" === typeof displayName && (ioInfo.name = displayName);
          }
          -1 === payload._status && (payload._status = 0, payload._result = thenable);
        }
        if (1 === payload._status)
          return ioInfo = payload._result, void 0 === ioInfo && console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?",
            ioInfo
          ), "default" in ioInfo || console.error(
            "lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))",
            ioInfo
          ), ioInfo.default;
        throw payload._result;
      }
      function resolveDispatcher() {
        var dispatcher = ReactSharedInternals.H;
        null === dispatcher && console.error(
          "Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."
        );
        return dispatcher;
      }
      function releaseAsyncTransition() {
        ReactSharedInternals.asyncTransitions--;
      }
      function enqueueTask(task) {
        if (null === enqueueTaskImpl)
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            enqueueTaskImpl = (module && module[requireString]).call(
              module,
              "timers"
            ).setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              false === didWarnAboutMessageChannel && (didWarnAboutMessageChannel = true, "undefined" === typeof MessageChannel && console.error(
                "This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."
              ));
              var channel = new MessageChannel();
              channel.port1.onmessage = callback;
              channel.port2.postMessage(void 0);
            };
          }
        return enqueueTaskImpl(task);
      }
      function aggregateErrors(errors) {
        return 1 < errors.length && "function" === typeof AggregateError ? new AggregateError(errors) : errors[0];
      }
      function popActScope(prevActQueue, prevActScopeDepth) {
        prevActScopeDepth !== actScopeDepth - 1 && console.error(
          "You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "
        );
        actScopeDepth = prevActScopeDepth;
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        var queue = ReactSharedInternals.actQueue;
        if (null !== queue)
          if (0 !== queue.length)
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                return recursivelyFlushAsyncActWork(returnValue, resolve, reject);
              });
              return;
            } catch (error2) {
              ReactSharedInternals.thrownErrors.push(error2);
            }
          else ReactSharedInternals.actQueue = null;
        0 < ReactSharedInternals.thrownErrors.length ? (queue = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, reject(queue)) : resolve(returnValue);
      }
      function flushActQueue(queue) {
        if (!isFlushing) {
          isFlushing = true;
          var i2 = 0;
          try {
            for (; i2 < queue.length; i2++) {
              var callback = queue[i2];
              do {
                ReactSharedInternals.didUsePromise = false;
                var continuation = callback(false);
                if (null !== continuation) {
                  if (ReactSharedInternals.didUsePromise) {
                    queue[i2] = callback;
                    queue.splice(0, i2);
                    return;
                  }
                  callback = continuation;
                } else break;
              } while (1);
            }
            queue.length = 0;
          } catch (error2) {
            queue.splice(0, i2 + 1), ReactSharedInternals.thrownErrors.push(error2);
          } finally {
            isFlushing = false;
          }
        }
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var REACT_ELEMENT_TYPE = /* @__PURE__ */ Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = /* @__PURE__ */ Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = /* @__PURE__ */ Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = /* @__PURE__ */ Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = /* @__PURE__ */ Symbol.for("react.profiler"), REACT_CONSUMER_TYPE = /* @__PURE__ */ Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = /* @__PURE__ */ Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = /* @__PURE__ */ Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = /* @__PURE__ */ Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = /* @__PURE__ */ Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = /* @__PURE__ */ Symbol.for("react.memo"), REACT_LAZY_TYPE = /* @__PURE__ */ Symbol.for("react.lazy"), REACT_ACTIVITY_TYPE = /* @__PURE__ */ Symbol.for("react.activity"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, didWarnStateUpdateForUnmountedComponent = {}, ReactNoopUpdateQueue = {
        isMounted: function() {
          return false;
        },
        enqueueForceUpdate: function(publicInstance) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance) {
          warnNoop(publicInstance, "setState");
        }
      }, assign = Object.assign, emptyObject = {};
      Object.freeze(emptyObject);
      Component4.prototype.isReactComponent = {};
      Component4.prototype.setState = function(partialState, callback) {
        if ("object" !== typeof partialState && "function" !== typeof partialState && null != partialState)
          throw Error(
            "takes an object of state variables to update or a function which returns an object of state variables."
          );
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component4.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      var deprecatedAPIs = {
        isMounted: [
          "isMounted",
          "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."
        ],
        replaceState: [
          "replaceState",
          "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."
        ]
      };
      for (fnName in deprecatedAPIs)
        deprecatedAPIs.hasOwnProperty(fnName) && defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
      ComponentDummy.prototype = Component4.prototype;
      deprecatedAPIs = PureComponent.prototype = new ComponentDummy();
      deprecatedAPIs.constructor = PureComponent;
      assign(deprecatedAPIs, Component4.prototype);
      deprecatedAPIs.isPureReactComponent = true;
      var isArrayImpl = Array.isArray, REACT_CLIENT_REFERENCE = /* @__PURE__ */ Symbol.for("react.client.reference"), ReactSharedInternals = {
        H: null,
        A: null,
        T: null,
        S: null,
        actQueue: null,
        asyncTransitions: 0,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false,
        didUsePromise: false,
        thrownErrors: [],
        getCurrentStack: null,
        recentlyCreatedOwnerStacks: 0
      }, hasOwnProperty2 = Object.prototype.hasOwnProperty, createTask = console.createTask ? console.createTask : function() {
        return null;
      };
      deprecatedAPIs = {
        react_stack_bottom_frame: function(callStackForError) {
          return callStackForError();
        }
      };
      var specialPropKeyWarningShown, didWarnAboutOldJSXRuntime;
      var didWarnAboutElementRef = {};
      var unknownOwnerDebugStack = deprecatedAPIs.react_stack_bottom_frame.bind(
        deprecatedAPIs,
        UnknownOwner
      )();
      var unknownOwnerDebugTask = createTask(getTaskName(UnknownOwner));
      var didWarnAboutMaps = false, userProvidedKeyEscapeRegex = /\/+/g, reportGlobalError = "function" === typeof reportError ? reportError : function(error2) {
        if ("object" === typeof window && "function" === typeof window.ErrorEvent) {
          var event = new window.ErrorEvent("error", {
            bubbles: true,
            cancelable: true,
            message: "object" === typeof error2 && null !== error2 && "string" === typeof error2.message ? String(error2.message) : String(error2),
            error: error2
          });
          if (!window.dispatchEvent(event)) return;
        } else if ("object" === typeof process && "function" === typeof process.emit) {
          process.emit("uncaughtException", error2);
          return;
        }
        console.error(error2);
      }, didWarnAboutMessageChannel = false, enqueueTaskImpl = null, actScopeDepth = 0, didWarnNoAwaitAct = false, isFlushing = false, queueSeveralMicrotasks = "function" === typeof queueMicrotask ? function(callback) {
        queueMicrotask(function() {
          return queueMicrotask(callback);
        });
      } : enqueueTask;
      deprecatedAPIs = Object.freeze({
        __proto__: null,
        c: function(size) {
          return resolveDispatcher().useMemoCache(size);
        }
      });
      var fnName = {
        map: mapChildren,
        forEach: function(children, forEachFunc, forEachContext) {
          mapChildren(
            children,
            function() {
              forEachFunc.apply(this, arguments);
            },
            forEachContext
          );
        },
        count: function(children) {
          var n2 = 0;
          mapChildren(children, function() {
            n2++;
          });
          return n2;
        },
        toArray: function(children) {
          return mapChildren(children, function(child) {
            return child;
          }) || [];
        },
        only: function(children) {
          if (!isValidElement2(children))
            throw Error(
              "React.Children.only expected to receive a single React element child."
            );
          return children;
        }
      };
      exports.Activity = REACT_ACTIVITY_TYPE;
      exports.Children = fnName;
      exports.Component = Component4;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = ReactSharedInternals;
      exports.__COMPILER_RUNTIME = deprecatedAPIs;
      exports.act = function(callback) {
        var prevActQueue = ReactSharedInternals.actQueue, prevActScopeDepth = actScopeDepth;
        actScopeDepth++;
        var queue = ReactSharedInternals.actQueue = null !== prevActQueue ? prevActQueue : [], didAwaitActCall = false;
        try {
          var result = callback();
        } catch (error2) {
          ReactSharedInternals.thrownErrors.push(error2);
        }
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw popActScope(prevActQueue, prevActScopeDepth), callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        if (null !== result && "object" === typeof result && "function" === typeof result.then) {
          var thenable = result;
          queueSeveralMicrotasks(function() {
            didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
              "You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"
            ));
          });
          return {
            then: function(resolve, reject) {
              didAwaitActCall = true;
              thenable.then(
                function(returnValue) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  if (0 === prevActScopeDepth) {
                    try {
                      flushActQueue(queue), enqueueTask(function() {
                        return recursivelyFlushAsyncActWork(
                          returnValue,
                          resolve,
                          reject
                        );
                      });
                    } catch (error$0) {
                      ReactSharedInternals.thrownErrors.push(error$0);
                    }
                    if (0 < ReactSharedInternals.thrownErrors.length) {
                      var _thrownError = aggregateErrors(
                        ReactSharedInternals.thrownErrors
                      );
                      ReactSharedInternals.thrownErrors.length = 0;
                      reject(_thrownError);
                    }
                  } else resolve(returnValue);
                },
                function(error2) {
                  popActScope(prevActQueue, prevActScopeDepth);
                  0 < ReactSharedInternals.thrownErrors.length ? (error2 = aggregateErrors(
                    ReactSharedInternals.thrownErrors
                  ), ReactSharedInternals.thrownErrors.length = 0, reject(error2)) : reject(error2);
                }
              );
            }
          };
        }
        var returnValue$jscomp$0 = result;
        popActScope(prevActQueue, prevActScopeDepth);
        0 === prevActScopeDepth && (flushActQueue(queue), 0 !== queue.length && queueSeveralMicrotasks(function() {
          didAwaitActCall || didWarnNoAwaitAct || (didWarnNoAwaitAct = true, console.error(
            "A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"
          ));
        }), ReactSharedInternals.actQueue = null);
        if (0 < ReactSharedInternals.thrownErrors.length)
          throw callback = aggregateErrors(ReactSharedInternals.thrownErrors), ReactSharedInternals.thrownErrors.length = 0, callback;
        return {
          then: function(resolve, reject) {
            didAwaitActCall = true;
            0 === prevActScopeDepth ? (ReactSharedInternals.actQueue = queue, enqueueTask(function() {
              return recursivelyFlushAsyncActWork(
                returnValue$jscomp$0,
                resolve,
                reject
              );
            })) : resolve(returnValue$jscomp$0);
          }
        };
      };
      exports.cache = function(fn2) {
        return function() {
          return fn2.apply(null, arguments);
        };
      };
      exports.cacheSignal = function() {
        return null;
      };
      exports.captureOwnerStack = function() {
        var getCurrentStack = ReactSharedInternals.getCurrentStack;
        return null === getCurrentStack ? null : getCurrentStack();
      };
      exports.cloneElement = function(element, config, children) {
        if (null === element || void 0 === element)
          throw Error(
            "The argument must be a React element, but you passed " + element + "."
          );
        var props = assign({}, element.props), key = element.key, owner = element._owner;
        if (null != config) {
          var JSCompiler_inline_result;
          a: {
            if (hasOwnProperty2.call(config, "ref") && (JSCompiler_inline_result = Object.getOwnPropertyDescriptor(
              config,
              "ref"
            ).get) && JSCompiler_inline_result.isReactWarning) {
              JSCompiler_inline_result = false;
              break a;
            }
            JSCompiler_inline_result = void 0 !== config.ref;
          }
          JSCompiler_inline_result && (owner = getOwner());
          hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key);
          for (propName in config)
            !hasOwnProperty2.call(config, propName) || "key" === propName || "__self" === propName || "__source" === propName || "ref" === propName && void 0 === config.ref || (props[propName] = config[propName]);
        }
        var propName = arguments.length - 2;
        if (1 === propName) props.children = children;
        else if (1 < propName) {
          JSCompiler_inline_result = Array(propName);
          for (var i2 = 0; i2 < propName; i2++)
            JSCompiler_inline_result[i2] = arguments[i2 + 2];
          props.children = JSCompiler_inline_result;
        }
        props = ReactElement(
          element.type,
          key,
          props,
          owner,
          element._debugStack,
          element._debugTask
        );
        for (key = 2; key < arguments.length; key++)
          validateChildKeys(arguments[key]);
        return props;
      };
      exports.createContext = function(defaultValue) {
        defaultValue = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null
        };
        defaultValue.Provider = defaultValue;
        defaultValue.Consumer = {
          $$typeof: REACT_CONSUMER_TYPE,
          _context: defaultValue
        };
        defaultValue._currentRenderer = null;
        defaultValue._currentRenderer2 = null;
        return defaultValue;
      };
      exports.createElement = function(type, config, children) {
        for (var i2 = 2; i2 < arguments.length; i2++)
          validateChildKeys(arguments[i2]);
        i2 = {};
        var key = null;
        if (null != config)
          for (propName in didWarnAboutOldJSXRuntime || !("__self" in config) || "key" in config || (didWarnAboutOldJSXRuntime = true, console.warn(
            "Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform"
          )), hasValidKey(config) && (checkKeyStringCoercion(config.key), key = "" + config.key), config)
            hasOwnProperty2.call(config, propName) && "key" !== propName && "__self" !== propName && "__source" !== propName && (i2[propName] = config[propName]);
        var childrenLength = arguments.length - 2;
        if (1 === childrenLength) i2.children = children;
        else if (1 < childrenLength) {
          for (var childArray = Array(childrenLength), _i2 = 0; _i2 < childrenLength; _i2++)
            childArray[_i2] = arguments[_i2 + 2];
          Object.freeze && Object.freeze(childArray);
          i2.children = childArray;
        }
        if (type && type.defaultProps)
          for (propName in childrenLength = type.defaultProps, childrenLength)
            void 0 === i2[propName] && (i2[propName] = childrenLength[propName]);
        key && defineKeyPropWarningGetter(
          i2,
          "function" === typeof type ? type.displayName || type.name || "Unknown" : type
        );
        var propName = 1e4 > ReactSharedInternals.recentlyCreatedOwnerStacks++;
        return ReactElement(
          type,
          key,
          i2,
          getOwner(),
          propName ? Error("react-stack-top-frame") : unknownOwnerDebugStack,
          propName ? createTask(getTaskName(type)) : unknownOwnerDebugTask
        );
      };
      exports.createRef = function() {
        var refObject = { current: null };
        Object.seal(refObject);
        return refObject;
      };
      exports.forwardRef = function(render) {
        null != render && render.$$typeof === REACT_MEMO_TYPE ? console.error(
          "forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))."
        ) : "function" !== typeof render ? console.error(
          "forwardRef requires a render function but was given %s.",
          null === render ? "null" : typeof render
        ) : 0 !== render.length && 2 !== render.length && console.error(
          "forwardRef render functions accept exactly two parameters: props and ref. %s",
          1 === render.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."
        );
        null != render && null != render.defaultProps && console.error(
          "forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?"
        );
        var elementType = { $$typeof: REACT_FORWARD_REF_TYPE, render }, ownName;
        Object.defineProperty(elementType, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            render.name || render.displayName || (Object.defineProperty(render, "name", { value: name }), render.displayName = name);
          }
        });
        return elementType;
      };
      exports.isValidElement = isValidElement2;
      exports.lazy = function(ctor) {
        ctor = { _status: -1, _result: ctor };
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: ctor,
          _init: lazyInitializer
        }, ioInfo = {
          name: "lazy",
          start: -1,
          end: -1,
          value: null,
          owner: null,
          debugStack: Error("react-stack-top-frame"),
          debugTask: console.createTask ? console.createTask("lazy()") : null
        };
        ctor._ioInfo = ioInfo;
        lazyType._debugInfo = [{ awaited: ioInfo }];
        return lazyType;
      };
      exports.memo = function(type, compare) {
        null == type && console.error(
          "memo: The first argument must be a component. Instead received: %s",
          null === type ? "null" : typeof type
        );
        compare = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: void 0 === compare ? null : compare
        };
        var ownName;
        Object.defineProperty(compare, "displayName", {
          enumerable: false,
          configurable: true,
          get: function() {
            return ownName;
          },
          set: function(name) {
            ownName = name;
            type.name || type.displayName || (Object.defineProperty(type, "name", { value: name }), type.displayName = name);
          }
        });
        return compare;
      };
      exports.startTransition = function(scope) {
        var prevTransition = ReactSharedInternals.T, currentTransition = {};
        currentTransition._updatedFibers = /* @__PURE__ */ new Set();
        ReactSharedInternals.T = currentTransition;
        try {
          var returnValue = scope(), onStartTransitionFinish = ReactSharedInternals.S;
          null !== onStartTransitionFinish && onStartTransitionFinish(currentTransition, returnValue);
          "object" === typeof returnValue && null !== returnValue && "function" === typeof returnValue.then && (ReactSharedInternals.asyncTransitions++, returnValue.then(releaseAsyncTransition, releaseAsyncTransition), returnValue.then(noop2, reportGlobalError));
        } catch (error2) {
          reportGlobalError(error2);
        } finally {
          null === prevTransition && currentTransition._updatedFibers && (scope = currentTransition._updatedFibers.size, currentTransition._updatedFibers.clear(), 10 < scope && console.warn(
            "Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."
          )), null !== prevTransition && null !== currentTransition.types && (null !== prevTransition.types && prevTransition.types !== currentTransition.types && console.error(
            "We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."
          ), prevTransition.types = currentTransition.types), ReactSharedInternals.T = prevTransition;
        }
      };
      exports.unstable_useCacheRefresh = function() {
        return resolveDispatcher().useCacheRefresh();
      };
      exports.use = function(usable) {
        return resolveDispatcher().use(usable);
      };
      exports.useActionState = function(action, initialState, permalink) {
        return resolveDispatcher().useActionState(
          action,
          initialState,
          permalink
        );
      };
      exports.useCallback = function(callback, deps) {
        return resolveDispatcher().useCallback(callback, deps);
      };
      exports.useContext = function(Context) {
        var dispatcher = resolveDispatcher();
        Context.$$typeof === REACT_CONSUMER_TYPE && console.error(
          "Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"
        );
        return dispatcher.useContext(Context);
      };
      exports.useDebugValue = function(value, formatterFn) {
        return resolveDispatcher().useDebugValue(value, formatterFn);
      };
      exports.useDeferredValue = function(value, initialValue) {
        return resolveDispatcher().useDeferredValue(value, initialValue);
      };
      exports.useEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useEffect(create, deps);
      };
      exports.useEffectEvent = function(callback) {
        return resolveDispatcher().useEffectEvent(callback);
      };
      exports.useId = function() {
        return resolveDispatcher().useId();
      };
      exports.useImperativeHandle = function(ref, create, deps) {
        return resolveDispatcher().useImperativeHandle(ref, create, deps);
      };
      exports.useInsertionEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useInsertionEffect(create, deps);
      };
      exports.useLayoutEffect = function(create, deps) {
        null == create && console.warn(
          "React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"
        );
        return resolveDispatcher().useLayoutEffect(create, deps);
      };
      exports.useMemo = function(create, deps) {
        return resolveDispatcher().useMemo(create, deps);
      };
      exports.useOptimistic = function(passthrough, reducer) {
        return resolveDispatcher().useOptimistic(passthrough, reducer);
      };
      exports.useReducer = function(reducer, initialArg, init) {
        return resolveDispatcher().useReducer(reducer, initialArg, init);
      };
      exports.useRef = function(initialValue) {
        return resolveDispatcher().useRef(initialValue);
      };
      exports.useState = function(initialState) {
        return resolveDispatcher().useState(initialState);
      };
      exports.useSyncExternalStore = function(subscribe, getSnapshot, getServerSnapshot) {
        return resolveDispatcher().useSyncExternalStore(
          subscribe,
          getSnapshot,
          getServerSnapshot
        );
      };
      exports.useTransition = function() {
        return resolveDispatcher().useTransition();
      };
      exports.version = "19.2.4";
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS({
  "node_modules/react/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_development();
    }
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    var s2 = 1e3;
    var m2 = s2 * 60;
    var h2 = m2 * 60;
    var d2 = h2 * 24;
    var w2 = d2 * 7;
    var y2 = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n2 = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n2 * y2;
        case "weeks":
        case "week":
        case "w":
          return n2 * w2;
        case "days":
        case "day":
        case "d":
          return n2 * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n2 * h2;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n2 * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n2 * s2;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n2;
        default:
          return void 0;
      }
    }
    function fmtShort(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return Math.round(ms2 / d2) + "d";
      }
      if (msAbs >= h2) {
        return Math.round(ms2 / h2) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms2 / m2) + "m";
      }
      if (msAbs >= s2) {
        return Math.round(ms2 / s2) + "s";
      }
      return ms2 + "ms";
    }
    function fmtLong(ms2) {
      var msAbs = Math.abs(ms2);
      if (msAbs >= d2) {
        return plural(ms2, msAbs, d2, "day");
      }
      if (msAbs >= h2) {
        return plural(ms2, msAbs, h2, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms2, msAbs, m2, "minute");
      }
      if (msAbs >= s2) {
        return plural(ms2, msAbs, s2, "second");
      }
      return ms2 + " ms";
    }
    function plural(ms2, msAbs, n2, name) {
      var isPlural = msAbs >= n2 * 1.5;
      return Math.round(ms2 / n2) + " " + name + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i2 = 0; i2 < namespace.length; i2++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i2);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms2 = curr - (prevTime || curr);
          self2.diff = ms2;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend2;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v2) => {
            enableOverride = v2;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend2(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(/\s+/g, ",").split(",").filter(Boolean);
        for (const ns2 of split) {
          if (ns2[0] === "-") {
            createDebug.skips.push(ns2.slice(1));
          } else {
            createDebug.names.push(ns2);
          }
        }
      }
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns2 of createDebug.names) {
          if (matchesTemplate(name, ns2)) {
            return true;
          }
        }
        return false;
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c2 = "color: " + this.color;
      args.splice(1, 0, c2, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c2);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r2;
      try {
        r2 = exports.storage.getItem("debug") || exports.storage.getItem("DEBUG");
      } catch (error2) {
      }
      if (!r2 && typeof process !== "undefined" && "env" in process) {
        r2 = process.env.DEBUG;
      }
      return r2;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v2) {
      try {
        return JSON.stringify(v2);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  }
});

// node_modules/mediasoup-client/lib/types.js
var require_types = __commonJS({
  "node_modules/mediasoup-client/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
  }
});

// node_modules/mediasoup-client/lib/Logger.js
var require_Logger = __commonJS({
  "node_modules/mediasoup-client/lib/Logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    var debug_1 = require_browser();
    var APP_NAME = "mediasoup-client";
    var Logger = class {
      _debug;
      _warn;
      _error;
      constructor(prefix) {
        if (prefix) {
          this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
          this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
          this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        } else {
          this._debug = (0, debug_1.default)(APP_NAME);
          this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
          this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
      }
      get debug() {
        return this._debug;
      }
      get warn() {
        return this._warn;
      }
      get error() {
        return this._error;
      }
    };
    exports.Logger = Logger;
  }
});

// node_modules/events-alias/events.js
var require_events = __commonJS({
  "node_modules/events-alias/events.js"(exports, module) {
    "use strict";
    var R2 = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R2 && typeof R2.apply === "function" ? R2.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R2 && typeof R2.ownKeys === "function") {
      ReflectOwnKeys = R2.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning2) {
      if (console && console.warn) console.warn(warning2);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n2) {
      if (typeof n2 !== "number" || n2 < 0 || NumberIsNaN(n2)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n2 + ".");
      }
      this._maxListeners = n2;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i2 = 1; i2 < arguments.length; i2++) args.push(arguments[i2]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er2;
        if (args.length > 0)
          er2 = args[0];
        if (er2 instanceof Error) {
          throw er2;
        }
        var err = new Error("Unhandled error." + (er2 ? " (" + er2.message + ")" : ""));
        err.context = er2;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i2 = 0; i2 < len; ++i2)
          ReflectApply(listeners[i2], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m2;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m2 = _getMaxListeners(target);
        if (m2 > 0 && existing.length > m2 && !existing.warned) {
          existing.warned = true;
          var w2 = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w2.name = "MaxListenersExceededWarning";
          w2.emitter = target;
          w2.type = type;
          w2.count = existing.length;
          ProcessEmitWarning(w2);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i2, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i2 = list.length - 1; i2 >= 0; i2--) {
          if (list[i2] === listener || list[i2].listener === listener) {
            originalListener = list[i2].listener;
            position = i2;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i2;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i2 = 0; i2 < keys.length; ++i2) {
          key = keys[i2];
          if (key === "removeListener") continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i2 = listeners.length - 1; i2 >= 0; i2--) {
          this.removeListener(type, listeners[i2]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n2) {
      var copy = new Array(n2);
      for (var i2 = 0; i2 < n2; ++i2)
        copy[i2] = arr[i2];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i2 = 0; i2 < ret.length; ++i2) {
        ret[i2] = arr[i2].listener || arr[i2];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/mediasoup-client/lib/enhancedEvents.js
var require_enhancedEvents = __commonJS({
  "node_modules/mediasoup-client/lib/enhancedEvents.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnhancedEventEmitter = void 0;
    var events_alias_1 = require_events();
    var Logger_1 = require_Logger();
    var enhancedEventEmitterLogger = new Logger_1.Logger("EnhancedEventEmitter");
    var EnhancedEventEmitter = class extends events_alias_1.EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(Infinity);
      }
      /**
       * Empties all stored event listeners.
       */
      close() {
        super.removeAllListeners();
      }
      emit(eventName, ...args) {
        return super.emit(eventName, ...args);
      }
      /**
       * Special addition to the EventEmitter API.
       */
      safeEmit(eventName, ...args) {
        try {
          return super.emit(eventName, ...args);
        } catch (error2) {
          enhancedEventEmitterLogger.error("safeEmit() | event listener threw an error [eventName:%s]:%o", eventName, error2);
          try {
            super.emit("listenererror", eventName, error2);
          } catch (error22) {
          }
          return Boolean(super.listenerCount(eventName));
        }
      }
      on(eventName, listener) {
        super.on(eventName, listener);
        return this;
      }
      off(eventName, listener) {
        super.off(eventName, listener);
        return this;
      }
      addListener(eventName, listener) {
        super.on(eventName, listener);
        return this;
      }
      prependListener(eventName, listener) {
        super.prependListener(eventName, listener);
        return this;
      }
      once(eventName, listener) {
        super.once(eventName, listener);
        return this;
      }
      prependOnceListener(eventName, listener) {
        super.prependOnceListener(eventName, listener);
        return this;
      }
      removeListener(eventName, listener) {
        super.off(eventName, listener);
        return this;
      }
      removeAllListeners(eventName) {
        super.removeAllListeners(eventName);
        return this;
      }
      listenerCount(eventName) {
        return super.listenerCount(eventName);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      rawListeners(eventName) {
        return super.rawListeners(eventName);
      }
    };
    exports.EnhancedEventEmitter = EnhancedEventEmitter;
  }
});

// node_modules/mediasoup-client/lib/errors.js
var require_errors = __commonJS({
  "node_modules/mediasoup-client/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidStateError = exports.UnsupportedError = void 0;
    var UnsupportedError = class _UnsupportedError extends Error {
      constructor(message) {
        super(message);
        this.name = "UnsupportedError";
        if (Error.hasOwnProperty("captureStackTrace")) {
          Error.captureStackTrace(this, _UnsupportedError);
        } else {
          this.stack = new Error(message).stack;
        }
      }
    };
    exports.UnsupportedError = UnsupportedError;
    var InvalidStateError = class _InvalidStateError extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidStateError";
        if (Error.hasOwnProperty("captureStackTrace")) {
          Error.captureStackTrace(this, _InvalidStateError);
        } else {
          this.stack = new Error(message).stack;
        }
      }
    };
    exports.InvalidStateError = InvalidStateError;
  }
});

// node_modules/mediasoup-client/lib/utils.js
var require_utils = __commonJS({
  "node_modules/mediasoup-client/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = clone;
    exports.generateRandomNumber = generateRandomNumber;
    exports.deepFreeze = deepFreeze;
    function clone(value) {
      if (value === void 0) {
        return void 0;
      } else if (Number.isNaN(value)) {
        return NaN;
      } else if (typeof structuredClone === "function") {
        return structuredClone(value);
      } else {
        return JSON.parse(JSON.stringify(value));
      }
    }
    function generateRandomNumber() {
      return Math.round(Math.random() * 1e7);
    }
    function deepFreeze(data2) {
      const propNames = Reflect.ownKeys(data2);
      for (const name of propNames) {
        const value = data2[name];
        if (value && typeof value === "object" || typeof value === "function") {
          deepFreeze(value);
        }
      }
      return Object.freeze(data2);
    }
  }
});

// node_modules/h264-profile-level-id/lib/Logger.js
var require_Logger2 = __commonJS({
  "node_modules/h264-profile-level-id/lib/Logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    var debug_1 = require_browser();
    var APP_NAME = "h264-profile-level-id";
    var Logger = class {
      _debug;
      _warn;
      _error;
      constructor(prefix) {
        if (prefix) {
          this._debug = (0, debug_1.default)(`${APP_NAME}:${prefix}`);
          this._warn = (0, debug_1.default)(`${APP_NAME}:WARN:${prefix}`);
          this._error = (0, debug_1.default)(`${APP_NAME}:ERROR:${prefix}`);
        } else {
          this._debug = (0, debug_1.default)(APP_NAME);
          this._warn = (0, debug_1.default)(`${APP_NAME}:WARN`);
          this._error = (0, debug_1.default)(`${APP_NAME}:ERROR`);
        }
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
      }
      get debug() {
        return this._debug;
      }
      get warn() {
        return this._warn;
      }
      get error() {
        return this._error;
      }
    };
    exports.Logger = Logger;
  }
});

// node_modules/h264-profile-level-id/lib/index.js
var require_lib = __commonJS({
  "node_modules/h264-profile-level-id/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProfileLevelId = exports.Level = exports.Profile = void 0;
    exports.parseProfileLevelId = parseProfileLevelId;
    exports.profileLevelIdToString = profileLevelIdToString;
    exports.profileToString = profileToString;
    exports.levelToString = levelToString;
    exports.parseSdpProfileLevelId = parseSdpProfileLevelId;
    exports.isSameProfile = isSameProfile;
    exports.isSameProfileAndLevel = isSameProfileAndLevel;
    exports.generateProfileLevelIdStringForAnswer = generateProfileLevelIdStringForAnswer;
    exports.supportedLevel = supportedLevel;
    var Logger_1 = require_Logger2();
    var logger = new Logger_1.Logger();
    var Profile;
    (function(Profile2) {
      Profile2[Profile2["ConstrainedBaseline"] = 1] = "ConstrainedBaseline";
      Profile2[Profile2["Baseline"] = 2] = "Baseline";
      Profile2[Profile2["Main"] = 3] = "Main";
      Profile2[Profile2["ConstrainedHigh"] = 4] = "ConstrainedHigh";
      Profile2[Profile2["High"] = 5] = "High";
      Profile2[Profile2["PredictiveHigh444"] = 6] = "PredictiveHigh444";
    })(Profile || (exports.Profile = Profile = {}));
    var Level;
    (function(Level2) {
      Level2[Level2["L1_b"] = 0] = "L1_b";
      Level2[Level2["L1"] = 10] = "L1";
      Level2[Level2["L1_1"] = 11] = "L1_1";
      Level2[Level2["L1_2"] = 12] = "L1_2";
      Level2[Level2["L1_3"] = 13] = "L1_3";
      Level2[Level2["L2"] = 20] = "L2";
      Level2[Level2["L2_1"] = 21] = "L2_1";
      Level2[Level2["L2_2"] = 22] = "L2_2";
      Level2[Level2["L3"] = 30] = "L3";
      Level2[Level2["L3_1"] = 31] = "L3_1";
      Level2[Level2["L3_2"] = 32] = "L3_2";
      Level2[Level2["L4"] = 40] = "L4";
      Level2[Level2["L4_1"] = 41] = "L4_1";
      Level2[Level2["L4_2"] = 42] = "L4_2";
      Level2[Level2["L5"] = 50] = "L5";
      Level2[Level2["L5_1"] = 51] = "L5_1";
      Level2[Level2["L5_2"] = 52] = "L5_2";
    })(Level || (exports.Level = Level = {}));
    var ProfileLevelId = class {
      profile;
      level;
      constructor(profile, level) {
        this.profile = profile;
        this.level = level;
      }
    };
    exports.ProfileLevelId = ProfileLevelId;
    var DefaultProfileLevelId = new ProfileLevelId(Profile.ConstrainedBaseline, Level.L3_1);
    var BitPattern = class {
      mask;
      masked_value;
      constructor(str) {
        this.mask = ~byteMaskString("x", str);
        this.masked_value = byteMaskString("1", str);
      }
      isMatch(value) {
        return this.masked_value === (value & this.mask);
      }
    };
    var ProfilePattern = class {
      profile_idc;
      profile_iop;
      profile;
      constructor(profile_idc, profile_iop, profile) {
        this.profile_idc = profile_idc;
        this.profile_iop = profile_iop;
        this.profile = profile;
      }
    };
    var ProfilePatterns = [
      new ProfilePattern(66, new BitPattern("x1xx0000"), Profile.ConstrainedBaseline),
      new ProfilePattern(77, new BitPattern("1xxx0000"), Profile.ConstrainedBaseline),
      new ProfilePattern(88, new BitPattern("11xx0000"), Profile.ConstrainedBaseline),
      new ProfilePattern(66, new BitPattern("x0xx0000"), Profile.Baseline),
      new ProfilePattern(88, new BitPattern("10xx0000"), Profile.Baseline),
      new ProfilePattern(77, new BitPattern("0x0x0000"), Profile.Main),
      new ProfilePattern(100, new BitPattern("00000000"), Profile.High),
      new ProfilePattern(100, new BitPattern("00001100"), Profile.ConstrainedHigh),
      new ProfilePattern(244, new BitPattern("00000000"), Profile.PredictiveHigh444)
    ];
    var LevelConstraints = [
      {
        max_macroblocks_per_second: 1485,
        max_macroblock_frame_size: 99,
        level: Level.L1
      },
      {
        max_macroblocks_per_second: 1485,
        max_macroblock_frame_size: 99,
        level: Level.L1_b
      },
      {
        max_macroblocks_per_second: 3e3,
        max_macroblock_frame_size: 396,
        level: Level.L1_1
      },
      {
        max_macroblocks_per_second: 6e3,
        max_macroblock_frame_size: 396,
        level: Level.L1_2
      },
      {
        max_macroblocks_per_second: 11880,
        max_macroblock_frame_size: 396,
        level: Level.L1_3
      },
      {
        max_macroblocks_per_second: 11880,
        max_macroblock_frame_size: 396,
        level: Level.L2
      },
      {
        max_macroblocks_per_second: 19800,
        max_macroblock_frame_size: 792,
        level: Level.L2_1
      },
      {
        max_macroblocks_per_second: 20250,
        max_macroblock_frame_size: 1620,
        level: Level.L2_2
      },
      {
        max_macroblocks_per_second: 40500,
        max_macroblock_frame_size: 1620,
        level: Level.L3
      },
      {
        max_macroblocks_per_second: 108e3,
        max_macroblock_frame_size: 3600,
        level: Level.L3_1
      },
      {
        max_macroblocks_per_second: 216e3,
        max_macroblock_frame_size: 5120,
        level: Level.L3_2
      },
      {
        max_macroblocks_per_second: 245760,
        max_macroblock_frame_size: 8192,
        level: Level.L4
      },
      {
        max_macroblocks_per_second: 245760,
        max_macroblock_frame_size: 8192,
        level: Level.L4_1
      },
      {
        max_macroblocks_per_second: 522240,
        max_macroblock_frame_size: 8704,
        level: Level.L4_2
      },
      {
        max_macroblocks_per_second: 589824,
        max_macroblock_frame_size: 22080,
        level: Level.L5
      },
      {
        max_macroblocks_per_second: 983040,
        max_macroblock_frame_size: 36864,
        level: Level.L5_1
      },
      {
        max_macroblocks_per_second: 2073600,
        max_macroblock_frame_size: 36864,
        level: Level.L5_2
      }
    ];
    function parseProfileLevelId(str) {
      const ConstraintSet3Flag = 16;
      if (typeof str !== "string" || str.length !== 6) {
        return void 0;
      }
      const profile_level_id_numeric = parseInt(str, 16);
      if (profile_level_id_numeric === 0) {
        return void 0;
      }
      const level_idc = profile_level_id_numeric & 255;
      const profile_iop = profile_level_id_numeric >> 8 & 255;
      const profile_idc = profile_level_id_numeric >> 16 & 255;
      let level;
      switch (level_idc) {
        case Level.L1_1: {
          level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level.L1_b : Level.L1_1;
          break;
        }
        case Level.L1:
        case Level.L1_2:
        case Level.L1_3:
        case Level.L2:
        case Level.L2_1:
        case Level.L2_2:
        case Level.L3:
        case Level.L3_1:
        case Level.L3_2:
        case Level.L4:
        case Level.L4_1:
        case Level.L4_2:
        case Level.L5:
        case Level.L5_1:
        case Level.L5_2: {
          level = level_idc;
          break;
        }
        // Unrecognized level_idc.
        default: {
          logger.warn(`parseProfileLevelId() | unrecognized level_idc [str:${str}, level_idc:${level_idc}]`);
          return void 0;
        }
      }
      for (const pattern of ProfilePatterns) {
        if (profile_idc === pattern.profile_idc && pattern.profile_iop.isMatch(profile_iop)) {
          logger.debug(`parseProfileLevelId() | result [str:${str}, profile:${pattern.profile}, level:${level}]`);
          return new ProfileLevelId(pattern.profile, level);
        }
      }
      logger.warn(`parseProfileLevelId() | unrecognized profile_idc/profile_iop combination [str:${str}, profile_idc:${profile_idc}, profile_iop:${profile_iop}]`);
      return void 0;
    }
    function profileLevelIdToString(profile_level_id) {
      if (profile_level_id.level == Level.L1_b) {
        switch (profile_level_id.profile) {
          case Profile.ConstrainedBaseline: {
            return "42f00b";
          }
          case Profile.Baseline: {
            return "42100b";
          }
          case Profile.Main: {
            return "4d100b";
          }
          // Level 1_b is not allowed for other profiles.
          default: {
            logger.warn(`profileLevelIdToString() | Level 1_b not is allowed for profile ${profile_level_id.profile}`);
            return void 0;
          }
        }
      }
      let profile_idc_iop_string;
      switch (profile_level_id.profile) {
        case Profile.ConstrainedBaseline: {
          profile_idc_iop_string = "42e0";
          break;
        }
        case Profile.Baseline: {
          profile_idc_iop_string = "4200";
          break;
        }
        case Profile.Main: {
          profile_idc_iop_string = "4d00";
          break;
        }
        case Profile.ConstrainedHigh: {
          profile_idc_iop_string = "640c";
          break;
        }
        case Profile.High: {
          profile_idc_iop_string = "6400";
          break;
        }
        case Profile.PredictiveHigh444: {
          profile_idc_iop_string = "f400";
          break;
        }
        default: {
          logger.warn(`profileLevelIdToString() | unrecognized profile ${profile_level_id.profile}`);
          return void 0;
        }
      }
      let levelStr = profile_level_id.level.toString(16);
      if (levelStr.length === 1) {
        levelStr = `0${levelStr}`;
      }
      return `${profile_idc_iop_string}${levelStr}`;
    }
    function profileToString(profile) {
      switch (profile) {
        case Profile.ConstrainedBaseline: {
          return "ConstrainedBaseline";
        }
        case Profile.Baseline: {
          return "Baseline";
        }
        case Profile.Main: {
          return "Main";
        }
        case Profile.ConstrainedHigh: {
          return "ConstrainedHigh";
        }
        case Profile.High: {
          return "High";
        }
        case Profile.PredictiveHigh444: {
          return "PredictiveHigh444";
        }
        default: {
          logger.warn(`profileToString() | unrecognized profile ${profile}`);
          return void 0;
        }
      }
    }
    function levelToString(level) {
      switch (level) {
        case Level.L1_b: {
          return "1b";
        }
        case Level.L1: {
          return "1";
        }
        case Level.L1_1: {
          return "1.1";
        }
        case Level.L1_2: {
          return "1.2";
        }
        case Level.L1_3: {
          return "1.3";
        }
        case Level.L2: {
          return "2";
        }
        case Level.L2_1: {
          return "2.1";
        }
        case Level.L2_2: {
          return "2.2";
        }
        case Level.L3: {
          return "3";
        }
        case Level.L3_1: {
          return "3.1";
        }
        case Level.L3_2: {
          return "3.2";
        }
        case Level.L4: {
          return "4";
        }
        case Level.L4_1: {
          return "4.1";
        }
        case Level.L4_2: {
          return "4.2";
        }
        case Level.L5: {
          return "5";
        }
        case Level.L5_1: {
          return "5.1";
        }
        case Level.L5_2: {
          return "5.2";
        }
        default: {
          logger.warn(`levelToString() | unrecognized level ${level}`);
          return void 0;
        }
      }
    }
    function parseSdpProfileLevelId(params = {}) {
      const profile_level_id = params["profile-level-id"];
      return profile_level_id ? parseProfileLevelId(profile_level_id) : DefaultProfileLevelId;
    }
    function isSameProfile(params1 = {}, params2 = {}) {
      const profile_level_id_1 = parseSdpProfileLevelId(params1);
      const profile_level_id_2 = parseSdpProfileLevelId(params2);
      return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile);
    }
    function isSameProfileAndLevel(params1 = {}, params2 = {}) {
      const profile_level_id_1 = parseSdpProfileLevelId(params1);
      const profile_level_id_2 = parseSdpProfileLevelId(params2);
      return Boolean(profile_level_id_1 && profile_level_id_2 && profile_level_id_1.profile === profile_level_id_2.profile && profile_level_id_1.level == profile_level_id_2.level);
    }
    function generateProfileLevelIdStringForAnswer(local_supported_params = {}, remote_offered_params = {}) {
      if (!local_supported_params["profile-level-id"] && !remote_offered_params["profile-level-id"]) {
        logger.warn("generateProfileLevelIdStringForAnswer() | profile-level-id missing in local and remote params");
        return void 0;
      }
      const local_profile_level_id = parseSdpProfileLevelId(local_supported_params);
      const remote_profile_level_id = parseSdpProfileLevelId(remote_offered_params);
      if (!local_profile_level_id) {
        throw new TypeError("invalid local_profile_level_id");
      }
      if (!remote_profile_level_id) {
        throw new TypeError("invalid remote_profile_level_id");
      }
      if (local_profile_level_id.profile !== remote_profile_level_id.profile) {
        throw new TypeError("H264 Profile mismatch");
      }
      const level_asymmetry_allowed = isLevelAsymmetryAllowed(local_supported_params) && isLevelAsymmetryAllowed(remote_offered_params);
      const local_level = local_profile_level_id.level;
      const remote_level = remote_profile_level_id.level;
      const min_level = minLevel(local_level, remote_level);
      const answer_level = level_asymmetry_allowed ? local_level : min_level;
      logger.debug(`generateProfileLevelIdStringForAnswer() | result [profile:${local_profile_level_id.profile}, level:${answer_level}]`);
      return profileLevelIdToString(new ProfileLevelId(local_profile_level_id.profile, answer_level));
    }
    function supportedLevel(max_frame_pixel_count, max_fps) {
      const PixelsPerMacroblock = 16 * 16;
      for (let i2 = LevelConstraints.length - 1; i2 >= 0; --i2) {
        const level_constraint = LevelConstraints[i2];
        if (level_constraint.max_macroblock_frame_size * PixelsPerMacroblock <= max_frame_pixel_count && level_constraint.max_macroblocks_per_second <= max_fps * level_constraint.max_macroblock_frame_size) {
          logger.debug(`supportedLevel() | result [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}, level:${level_constraint.level}]`);
          return level_constraint.level;
        }
      }
      logger.warn(`supportedLevel() | no level supported [max_frame_pixel_count:${max_frame_pixel_count}, max_fps:${max_fps}]`);
      return void 0;
    }
    function byteMaskString(c2, str) {
      return Number(str[0] === c2) << 7 | Number(str[1] === c2) << 6 | Number(str[2] === c2) << 5 | Number(str[3] === c2) << 4 | Number(str[4] === c2) << 3 | Number(str[5] === c2) << 2 | Number(str[6] === c2) << 1 | Number(str[7] === c2) << 0;
    }
    function isLessLevel(a2, b2) {
      if (a2 === Level.L1_b) {
        return b2 !== Level.L1 && b2 !== Level.L1_b;
      }
      if (b2 === Level.L1_b) {
        return a2 !== Level.L1;
      }
      return a2 < b2;
    }
    function minLevel(a2, b2) {
      return isLessLevel(a2, b2) ? a2 : b2;
    }
    function isLevelAsymmetryAllowed(params = {}) {
      const level_asymmetry_allowed = params["level-asymmetry-allowed"];
      return level_asymmetry_allowed === true || level_asymmetry_allowed === 1 || level_asymmetry_allowed === "1";
    }
  }
});

// node_modules/mediasoup-client/lib/ortc.js
var require_ortc = __commonJS({
  "node_modules/mediasoup-client/lib/ortc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAndNormalizeRtpCapabilities = validateAndNormalizeRtpCapabilities;
    exports.validateAndNormalizeRtpParameters = validateAndNormalizeRtpParameters;
    exports.validateAndNormalizeSctpStreamParameters = validateAndNormalizeSctpStreamParameters;
    exports.validateSctpCapabilities = validateSctpCapabilities;
    exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
    exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
    exports.getSendingRtpParameters = getSendingRtpParameters;
    exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
    exports.reduceCodecs = reduceCodecs;
    exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
    exports.canSend = canSend;
    exports.canReceive = canReceive;
    var h264 = require_lib();
    var utils = require_utils();
    var RTP_PROBATOR_MID = "probator";
    var RTP_PROBATOR_SSRC = 1234;
    var RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
    function validateAndNormalizeRtpCapabilities(caps) {
      if (typeof caps !== "object") {
        throw new TypeError("caps is not an object");
      }
      if (caps.codecs && !Array.isArray(caps.codecs)) {
        throw new TypeError("caps.codecs is not an array");
      } else if (!caps.codecs) {
        caps.codecs = [];
      }
      for (const codec of caps.codecs) {
        validateAndNormalizeRtpCodecCapability(codec);
      }
      if (caps.headerExtensions && !Array.isArray(caps.headerExtensions)) {
        throw new TypeError("caps.headerExtensions is not an array");
      } else if (!caps.headerExtensions) {
        caps.headerExtensions = [];
      }
      for (const ext of caps.headerExtensions) {
        validateAndNormalizeRtpHeaderExtension(ext);
      }
    }
    function validateAndNormalizeRtpParameters(params) {
      if (typeof params !== "object") {
        throw new TypeError("params is not an object");
      }
      if (params.mid && typeof params.mid !== "string") {
        throw new TypeError("params.mid is not a string");
      }
      if (!Array.isArray(params.codecs)) {
        throw new TypeError("missing params.codecs");
      }
      for (const codec of params.codecs) {
        validateAndNormalizeRtpCodecParameters(codec);
      }
      if (params.headerExtensions && !Array.isArray(params.headerExtensions)) {
        throw new TypeError("params.headerExtensions is not an array");
      } else if (!params.headerExtensions) {
        params.headerExtensions = [];
      }
      for (const ext of params.headerExtensions) {
        validateRtpHeaderExtensionParameters(ext);
      }
      if (params.encodings && !Array.isArray(params.encodings)) {
        throw new TypeError("params.encodings is not an array");
      } else if (!params.encodings) {
        params.encodings = [];
      }
      for (const encoding of params.encodings) {
        validateAndNormalizeRtpEncodingParameters(encoding);
      }
      if (params.rtcp && typeof params.rtcp !== "object") {
        throw new TypeError("params.rtcp is not an object");
      } else if (!params.rtcp) {
        params.rtcp = {};
      }
      validateAndNormalizeRtcpParameters(params.rtcp);
    }
    function validateAndNormalizeSctpStreamParameters(params) {
      if (typeof params !== "object") {
        throw new TypeError("params is not an object");
      }
      if (typeof params.streamId !== "number") {
        throw new TypeError("missing params.streamId");
      }
      let orderedGiven = false;
      if (typeof params.ordered === "boolean") {
        orderedGiven = true;
      } else {
        params.ordered = true;
      }
      if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== "number") {
        throw new TypeError("invalid params.maxPacketLifeTime");
      }
      if (params.maxRetransmits && typeof params.maxRetransmits !== "number") {
        throw new TypeError("invalid params.maxRetransmits");
      }
      if (params.maxPacketLifeTime && params.maxRetransmits) {
        throw new TypeError("cannot provide both maxPacketLifeTime and maxRetransmits");
      }
      if (orderedGiven && params.ordered && (params.maxPacketLifeTime || params.maxRetransmits)) {
        throw new TypeError("cannot be ordered with maxPacketLifeTime or maxRetransmits");
      } else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
        params.ordered = false;
      }
      if (params.label && typeof params.label !== "string") {
        throw new TypeError("invalid params.label");
      }
      if (params.protocol && typeof params.protocol !== "string") {
        throw new TypeError("invalid params.protocol");
      }
    }
    function validateSctpCapabilities(caps) {
      if (typeof caps !== "object") {
        throw new TypeError("caps is not an object");
      }
      if (!caps.numStreams || typeof caps.numStreams !== "object") {
        throw new TypeError("missing caps.numStreams");
      }
      validateNumSctpStreams(caps.numStreams);
    }
    function getExtendedRtpCapabilities(localCaps, remoteCaps, preferLocalCodecsOrder) {
      const extendedRtpCapabilities = {
        codecs: [],
        headerExtensions: []
      };
      if (preferLocalCodecsOrder) {
        for (const localCodec of localCaps.codecs ?? []) {
          if (isRtxCodec(localCodec)) {
            continue;
          }
          const matchingRemoteCodec = (remoteCaps.codecs ?? []).find((remoteCodec) => matchCodecs(remoteCodec, localCodec, { strict: true, modify: true }));
          if (!matchingRemoteCodec) {
            continue;
          }
          const extendedCodec = {
            kind: localCodec.kind,
            mimeType: localCodec.mimeType,
            clockRate: localCodec.clockRate,
            channels: localCodec.channels,
            localPayloadType: localCodec.preferredPayloadType,
            localRtxPayloadType: void 0,
            remotePayloadType: matchingRemoteCodec.preferredPayloadType,
            remoteRtxPayloadType: void 0,
            localParameters: localCodec.parameters ?? {},
            remoteParameters: matchingRemoteCodec.parameters ?? {},
            rtcpFeedback: reduceRtcpFeedback(localCodec, matchingRemoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        }
      } else {
        for (const remoteCodec of remoteCaps.codecs ?? []) {
          if (isRtxCodec(remoteCodec)) {
            continue;
          }
          const matchingLocalCodec = (localCaps.codecs ?? []).find((localCodec) => matchCodecs(localCodec, remoteCodec, { strict: true, modify: true }));
          if (!matchingLocalCodec) {
            continue;
          }
          const extendedCodec = {
            kind: matchingLocalCodec.kind,
            mimeType: matchingLocalCodec.mimeType,
            clockRate: matchingLocalCodec.clockRate,
            channels: matchingLocalCodec.channels,
            localPayloadType: matchingLocalCodec.preferredPayloadType,
            localRtxPayloadType: void 0,
            remotePayloadType: remoteCodec.preferredPayloadType,
            remoteRtxPayloadType: void 0,
            localParameters: matchingLocalCodec.parameters ?? {},
            remoteParameters: remoteCodec.parameters ?? {},
            rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
        }
      }
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const matchingLocalRtxCodec = localCaps.codecs.find((localCodec) => isRtxCodec(localCodec) && localCodec.parameters?.["apt"] === extendedCodec.localPayloadType);
        const matchingRemoteRtxCodec = remoteCaps.codecs.find((remoteCodec) => isRtxCodec(remoteCodec) && remoteCodec.parameters?.["apt"] === extendedCodec.remotePayloadType);
        if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
          extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
          extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
        }
      }
      for (const remoteExt of remoteCaps.headerExtensions) {
        const matchingLocalExt = localCaps.headerExtensions.find((localExt) => matchHeaderExtensions(localExt, remoteExt));
        if (!matchingLocalExt) {
          continue;
        }
        const extendedExt = {
          kind: remoteExt.kind,
          uri: remoteExt.uri,
          sendId: matchingLocalExt.preferredId,
          recvId: remoteExt.preferredId,
          encrypt: matchingLocalExt.preferredEncrypt ?? false,
          direction: "sendrecv"
        };
        switch (remoteExt.direction) {
          case "sendrecv": {
            extendedExt.direction = "sendrecv";
            break;
          }
          case "recvonly": {
            extendedExt.direction = "sendonly";
            break;
          }
          case "sendonly": {
            extendedExt.direction = "recvonly";
            break;
          }
          case "inactive": {
            extendedExt.direction = "inactive";
            break;
          }
        }
        extendedRtpCapabilities.headerExtensions.push(extendedExt);
      }
      return extendedRtpCapabilities;
    }
    function getRecvRtpCapabilities(extendedRtpCapabilities) {
      const rtpCapabilities = {
        codecs: [],
        headerExtensions: []
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
        const codec = {
          kind: extendedCodec.kind,
          mimeType: extendedCodec.mimeType,
          preferredPayloadType: extendedCodec.remotePayloadType,
          clockRate: extendedCodec.clockRate,
          channels: extendedCodec.channels,
          parameters: extendedCodec.localParameters,
          rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpCapabilities.codecs.push(codec);
        if (!extendedCodec.remoteRtxPayloadType) {
          continue;
        }
        const rtxCodec = {
          kind: extendedCodec.kind,
          mimeType: `${extendedCodec.kind}/rtx`,
          preferredPayloadType: extendedCodec.remoteRtxPayloadType,
          clockRate: extendedCodec.clockRate,
          parameters: {
            apt: extendedCodec.remotePayloadType
          },
          rtcpFeedback: []
        };
        rtpCapabilities.codecs.push(rtxCodec);
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        if (extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "recvonly") {
          continue;
        }
        const ext = {
          kind: extendedExtension.kind,
          uri: extendedExtension.uri,
          preferredId: extendedExtension.recvId,
          preferredEncrypt: extendedExtension.encrypt ?? false,
          direction: extendedExtension.direction
        };
        rtpCapabilities.headerExtensions.push(ext);
      }
      return rtpCapabilities;
    }
    function getSendingRtpParameters(kind, extendedRtpCapabilities) {
      const rtpParameters = {
        mid: void 0,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
          continue;
        }
        const codec = {
          mimeType: extendedCodec.mimeType,
          payloadType: extendedCodec.localPayloadType,
          clockRate: extendedCodec.clockRate,
          channels: extendedCodec.channels,
          parameters: extendedCodec.localParameters,
          rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        if (extendedCodec.localRtxPayloadType) {
          const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            payloadType: extendedCodec.localRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
              apt: extendedCodec.localPayloadType
            },
            rtcpFeedback: []
          };
          rtpParameters.codecs.push(rtxCodec);
        }
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
          continue;
        }
        const ext = {
          uri: extendedExtension.uri,
          id: extendedExtension.sendId,
          encrypt: extendedExtension.encrypt,
          parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
      }
      return rtpParameters;
    }
    function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
      const rtpParameters = {
        mid: void 0,
        codecs: [],
        headerExtensions: [],
        encodings: [],
        rtcp: {}
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
        if (extendedCodec.kind !== kind) {
          continue;
        }
        const codec = {
          mimeType: extendedCodec.mimeType,
          payloadType: extendedCodec.localPayloadType,
          clockRate: extendedCodec.clockRate,
          channels: extendedCodec.channels,
          parameters: extendedCodec.remoteParameters,
          rtcpFeedback: extendedCodec.rtcpFeedback
        };
        rtpParameters.codecs.push(codec);
        if (extendedCodec.localRtxPayloadType) {
          const rtxCodec = {
            mimeType: `${extendedCodec.kind}/rtx`,
            payloadType: extendedCodec.localRtxPayloadType,
            clockRate: extendedCodec.clockRate,
            parameters: {
              apt: extendedCodec.localPayloadType
            },
            rtcpFeedback: []
          };
          rtpParameters.codecs.push(rtxCodec);
        }
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
        if (extendedExtension.kind && extendedExtension.kind !== kind || extendedExtension.direction !== "sendrecv" && extendedExtension.direction !== "sendonly") {
          continue;
        }
        const ext = {
          uri: extendedExtension.uri,
          id: extendedExtension.sendId,
          encrypt: extendedExtension.encrypt,
          parameters: {}
        };
        rtpParameters.headerExtensions.push(ext);
      }
      if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01")) {
        for (const codec of rtpParameters.codecs) {
          codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "goog-remb");
        }
      } else if (rtpParameters.headerExtensions.some((ext) => ext.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time")) {
        for (const codec of rtpParameters.codecs) {
          codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc");
        }
      } else {
        for (const codec of rtpParameters.codecs) {
          codec.rtcpFeedback = (codec.rtcpFeedback ?? []).filter((fb) => fb.type !== "transport-cc" && fb.type !== "goog-remb");
        }
      }
      return rtpParameters;
    }
    function reduceCodecs(codecs, capCodec) {
      const filteredCodecs = [];
      if (!capCodec) {
        filteredCodecs.push(codecs[0]);
        if (isRtxCodec(codecs[1])) {
          filteredCodecs.push(codecs[1]);
        }
      } else {
        for (let idx = 0; idx < codecs.length; ++idx) {
          if (matchCodecs(codecs[idx], capCodec, { strict: true })) {
            filteredCodecs.push(codecs[idx]);
            if (isRtxCodec(codecs[idx + 1])) {
              filteredCodecs.push(codecs[idx + 1]);
            }
            break;
          }
        }
        if (filteredCodecs.length === 0) {
          throw new TypeError("no matching codec found");
        }
      }
      return filteredCodecs;
    }
    function generateProbatorRtpParameters(videoRtpParameters) {
      videoRtpParameters = utils.clone(videoRtpParameters);
      validateAndNormalizeRtpParameters(videoRtpParameters);
      const rtpParameters = {
        mid: RTP_PROBATOR_MID,
        codecs: [],
        headerExtensions: [],
        encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
        rtcp: { cname: "probator" }
      };
      rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
      rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
      rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
      return rtpParameters;
    }
    function canSend(kind, rtpCapabilities) {
      return (rtpCapabilities.codecs ?? []).some((codec) => codec.kind === kind);
    }
    function canReceive(rtpParameters, rtpCapabilities) {
      validateAndNormalizeRtpParameters(rtpParameters);
      if (rtpParameters.codecs.length === 0) {
        return false;
      }
      const firstMediaCodec = rtpParameters.codecs[0];
      return (rtpCapabilities.codecs ?? []).some((codec) => codec.preferredPayloadType === firstMediaCodec.payloadType);
    }
    function validateAndNormalizeRtpCodecCapability(codec) {
      const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
      if (typeof codec !== "object") {
        throw new TypeError("codec is not an object");
      }
      if (!codec.mimeType || typeof codec.mimeType !== "string") {
        throw new TypeError("missing codec.mimeType");
      }
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch) {
        throw new TypeError("invalid codec.mimeType");
      }
      codec.kind = mimeTypeMatch[1].toLowerCase();
      if (typeof codec.preferredPayloadType !== "number") {
        throw new TypeError("missing codec.preferredPayloadType");
      }
      if (typeof codec.clockRate !== "number") {
        throw new TypeError("missing codec.clockRate");
      }
      if (codec.kind === "audio") {
        if (typeof codec.channels !== "number") {
          codec.channels = 1;
        }
      } else {
        delete codec.channels;
      }
      if (!codec.parameters || typeof codec.parameters !== "object") {
        codec.parameters = {};
      }
      for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === void 0) {
          codec.parameters[key] = "";
          value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") {
          throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        if (key === "apt") {
          if (typeof value !== "number") {
            throw new TypeError("invalid codec apt parameter");
          }
        }
      }
      if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
      }
      for (const fb of codec.rtcpFeedback) {
        validateAndNormalizeRtcpFeedback(fb);
      }
    }
    function validateAndNormalizeRtcpFeedback(fb) {
      if (typeof fb !== "object") {
        throw new TypeError("fb is not an object");
      }
      if (!fb.type || typeof fb.type !== "string") {
        throw new TypeError("missing fb.type");
      }
      if (!fb.parameter || typeof fb.parameter !== "string") {
        fb.parameter = "";
      }
    }
    function validateAndNormalizeRtpHeaderExtension(ext) {
      if (typeof ext !== "object") {
        throw new TypeError("ext is not an object");
      }
      if (ext.kind !== "audio" && ext.kind !== "video") {
        throw new TypeError("invalid ext.kind");
      }
      if (!ext.uri || typeof ext.uri !== "string") {
        throw new TypeError("missing ext.uri");
      }
      if (typeof ext.preferredId !== "number") {
        throw new TypeError("missing ext.preferredId");
      }
      if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== "boolean") {
        throw new TypeError("invalid ext.preferredEncrypt");
      } else if (!ext.preferredEncrypt) {
        ext.preferredEncrypt = false;
      }
      if (ext.direction && typeof ext.direction !== "string") {
        throw new TypeError("invalid ext.direction");
      } else if (!ext.direction) {
        ext.direction = "sendrecv";
      }
    }
    function validateAndNormalizeRtpCodecParameters(codec) {
      const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
      if (typeof codec !== "object") {
        throw new TypeError("codec is not an object");
      }
      if (!codec.mimeType || typeof codec.mimeType !== "string") {
        throw new TypeError("missing codec.mimeType");
      }
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch) {
        throw new TypeError("invalid codec.mimeType");
      }
      if (typeof codec.payloadType !== "number") {
        throw new TypeError("missing codec.payloadType");
      }
      if (typeof codec.clockRate !== "number") {
        throw new TypeError("missing codec.clockRate");
      }
      const kind = mimeTypeMatch[1].toLowerCase();
      if (kind === "audio") {
        if (typeof codec.channels !== "number") {
          codec.channels = 1;
        }
      } else {
        delete codec.channels;
      }
      if (!codec.parameters || typeof codec.parameters !== "object") {
        codec.parameters = {};
      }
      for (const key of Object.keys(codec.parameters)) {
        let value = codec.parameters[key];
        if (value === void 0) {
          codec.parameters[key] = "";
          value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") {
          throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
        }
        if (key === "apt") {
          if (typeof value !== "number") {
            throw new TypeError("invalid codec apt parameter");
          }
        }
      }
      if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback)) {
        codec.rtcpFeedback = [];
      }
      for (const fb of codec.rtcpFeedback) {
        validateAndNormalizeRtcpFeedback(fb);
      }
    }
    function validateRtpHeaderExtensionParameters(ext) {
      if (typeof ext !== "object") {
        throw new TypeError("ext is not an object");
      }
      if (!ext.uri || typeof ext.uri !== "string") {
        throw new TypeError("missing ext.uri");
      }
      if (typeof ext.id !== "number") {
        throw new TypeError("missing ext.id");
      }
      if (ext.encrypt && typeof ext.encrypt !== "boolean") {
        throw new TypeError("invalid ext.encrypt");
      } else if (!ext.encrypt) {
        ext.encrypt = false;
      }
      if (!ext.parameters || typeof ext.parameters !== "object") {
        ext.parameters = {};
      }
      for (const key of Object.keys(ext.parameters)) {
        let value = ext.parameters[key];
        if (value === void 0) {
          ext.parameters[key] = "";
          value = "";
        }
        if (typeof value !== "string" && typeof value !== "number") {
          throw new TypeError("invalid header extension parameter");
        }
      }
    }
    function validateAndNormalizeRtpEncodingParameters(encoding) {
      if (typeof encoding !== "object") {
        throw new TypeError("encoding is not an object");
      }
      if (encoding.ssrc && typeof encoding.ssrc !== "number") {
        throw new TypeError("invalid encoding.ssrc");
      }
      if (encoding.rid && typeof encoding.rid !== "string") {
        throw new TypeError("invalid encoding.rid");
      }
      if (encoding.rtx && typeof encoding.rtx !== "object") {
        throw new TypeError("invalid encoding.rtx");
      } else if (encoding.rtx) {
        if (typeof encoding.rtx.ssrc !== "number") {
          throw new TypeError("missing encoding.rtx.ssrc");
        }
      }
      if (!encoding.dtx || typeof encoding.dtx !== "boolean") {
        encoding.dtx = false;
      }
      if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== "string") {
        throw new TypeError("invalid encoding.scalabilityMode");
      }
    }
    function validateAndNormalizeRtcpParameters(rtcp) {
      if (typeof rtcp !== "object") {
        throw new TypeError("rtcp is not an object");
      }
      if (rtcp.cname && typeof rtcp.cname !== "string") {
        throw new TypeError("invalid rtcp.cname");
      }
      if (!rtcp.reducedSize || typeof rtcp.reducedSize !== "boolean") {
        rtcp.reducedSize = true;
      }
    }
    function validateNumSctpStreams(numStreams) {
      if (typeof numStreams !== "object") {
        throw new TypeError("numStreams is not an object");
      }
      if (typeof numStreams.OS !== "number") {
        throw new TypeError("missing numStreams.OS");
      }
      if (typeof numStreams.MIS !== "number") {
        throw new TypeError("missing numStreams.MIS");
      }
    }
    function isRtxCodec(codec) {
      if (!codec) {
        return false;
      }
      return /.+\/rtx$/i.test(codec.mimeType);
    }
    function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
      const aMimeType = aCodec.mimeType.toLowerCase();
      const bMimeType = bCodec.mimeType.toLowerCase();
      if (aMimeType !== bMimeType) {
        return false;
      }
      if (aCodec.clockRate !== bCodec.clockRate) {
        return false;
      }
      if (aCodec.channels !== bCodec.channels) {
        return false;
      }
      switch (aMimeType) {
        case "video/h264": {
          if (strict) {
            const aPacketizationMode = aCodec.parameters["packetization-mode"] ?? 0;
            const bPacketizationMode = bCodec.parameters["packetization-mode"] ?? 0;
            if (aPacketizationMode !== bPacketizationMode) {
              return false;
            }
            if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters)) {
              return false;
            }
            let selectedProfileLevelId;
            try {
              selectedProfileLevelId = h264.generateProfileLevelIdStringForAnswer(aCodec.parameters, bCodec.parameters);
            } catch (error2) {
              return false;
            }
            if (modify) {
              if (selectedProfileLevelId) {
                aCodec.parameters["profile-level-id"] = selectedProfileLevelId;
                bCodec.parameters["profile-level-id"] = selectedProfileLevelId;
              } else {
                delete aCodec.parameters["profile-level-id"];
                delete bCodec.parameters["profile-level-id"];
              }
            }
          }
          break;
        }
        case "video/vp9": {
          if (strict) {
            const aProfileId = aCodec.parameters["profile-id"] ?? 0;
            const bProfileId = bCodec.parameters["profile-id"] ?? 0;
            if (aProfileId !== bProfileId) {
              return false;
            }
          }
          break;
        }
      }
      return true;
    }
    function matchHeaderExtensions(aExt, bExt) {
      if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind) {
        return false;
      }
      if (aExt.uri !== bExt.uri) {
        return false;
      }
      return true;
    }
    function reduceRtcpFeedback(codecA, codecB) {
      const reducedRtcpFeedback = [];
      for (const aFb of codecA.rtcpFeedback ?? []) {
        const matchingBFb = (codecB.rtcpFeedback ?? []).find((bFb) => bFb.type === aFb.type && (bFb.parameter === aFb.parameter || !bFb.parameter && !aFb.parameter));
        if (matchingBFb) {
          reducedRtcpFeedback.push(matchingBFb);
        }
      }
      return reducedRtcpFeedback;
    }
  }
});

// node_modules/awaitqueue/lib/Logger.js
var require_Logger3 = __commonJS({
  "node_modules/awaitqueue/lib/Logger.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Logger = void 0;
    var debug = require_browser();
    var LIB_NAME = "awaitqueue";
    var Logger = class {
      _debug;
      _warn;
      _error;
      constructor(prefix) {
        if (prefix) {
          this._debug = debug(`${LIB_NAME}:${prefix}`);
          this._warn = debug(`${LIB_NAME}:WARN:${prefix}`);
          this._error = debug(`${LIB_NAME}:ERROR:${prefix}`);
        } else {
          this._debug = debug(LIB_NAME);
          this._warn = debug(`${LIB_NAME}:WARN`);
          this._error = debug(`${LIB_NAME}:ERROR`);
        }
        this._debug.log = console.info.bind(console);
        this._warn.log = console.warn.bind(console);
        this._error.log = console.error.bind(console);
      }
      get debug() {
        return this._debug;
      }
      get warn() {
        return this._warn;
      }
      get error() {
        return this._error;
      }
    };
    exports.Logger = Logger;
  }
});

// node_modules/awaitqueue/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/awaitqueue/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = void 0;
    var AwaitQueueStoppedError = class _AwaitQueueStoppedError extends Error {
      constructor(message) {
        super(message ?? "queue stopped");
        this.name = "AwaitQueueStoppedError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AwaitQueueStoppedError);
        }
      }
    };
    exports.AwaitQueueStoppedError = AwaitQueueStoppedError;
    var AwaitQueueRemovedTaskError = class _AwaitQueueRemovedTaskError extends Error {
      constructor(message) {
        super(message ?? "queue task removed");
        this.name = "AwaitQueueRemovedTaskError";
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AwaitQueueRemovedTaskError);
        }
      }
    };
    exports.AwaitQueueRemovedTaskError = AwaitQueueRemovedTaskError;
  }
});

// node_modules/awaitqueue/lib/AwaitQueue.js
var require_AwaitQueue = __commonJS({
  "node_modules/awaitqueue/lib/AwaitQueue.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwaitQueue = void 0;
    var Logger_1 = require_Logger3();
    var errors_1 = require_errors2();
    var logger = new Logger_1.Logger("AwaitQueue");
    var AwaitQueue = class {
      // Queue of pending tasks (map of PendingTasks indexed by id).
      pendingTasks = /* @__PURE__ */ new Map();
      // Incrementing PendingTask id.
      nextTaskId = 0;
      constructor() {
        logger.debug("constructor()");
      }
      get size() {
        return this.pendingTasks.size;
      }
      async push(task, name, options) {
        name = name ?? task.name;
        logger.debug(`push() [name:${name}, options:%o]`, options);
        if (typeof task !== "function") {
          throw new TypeError("given task is not a function");
        }
        if (name) {
          try {
            Object.defineProperty(task, "name", { value: name });
          } catch (error2) {
          }
        }
        return new Promise((resolve, reject) => {
          if (name && options?.removeOngoingTasksWithSameName) {
            for (const pendingTask2 of this.pendingTasks.values()) {
              if (pendingTask2.name === name) {
                pendingTask2.reject(new errors_1.AwaitQueueRemovedTaskError(), {
                  canExecuteNextTask: false
                });
              }
            }
          }
          const pendingTask = {
            id: this.nextTaskId++,
            task,
            name,
            enqueuedAt: Date.now(),
            executedAt: void 0,
            completed: false,
            resolve: (result) => {
              if (pendingTask.completed) {
                return;
              }
              pendingTask.completed = true;
              this.pendingTasks.delete(pendingTask.id);
              logger.debug(`resolving task [name:${pendingTask.name}]`);
              resolve(result);
              const [nextPendingTask] = this.pendingTasks.values();
              if (nextPendingTask && !nextPendingTask.executedAt) {
                void this.execute(nextPendingTask);
              }
            },
            reject: (error2, { canExecuteNextTask }) => {
              if (pendingTask.completed) {
                return;
              }
              pendingTask.completed = true;
              this.pendingTasks.delete(pendingTask.id);
              logger.debug(`rejecting task [name:${pendingTask.name}]: %s`, String(error2));
              reject(error2);
              if (canExecuteNextTask) {
                const [nextPendingTask] = this.pendingTasks.values();
                if (nextPendingTask && !nextPendingTask.executedAt) {
                  void this.execute(nextPendingTask);
                }
              }
            }
          };
          this.pendingTasks.set(pendingTask.id, pendingTask);
          if (this.pendingTasks.size === 1) {
            void this.execute(pendingTask);
          }
        });
      }
      stop() {
        logger.debug("stop()");
        for (const pendingTask of this.pendingTasks.values()) {
          logger.debug(`stop() | stopping task [name:${pendingTask.name}]`);
          pendingTask.reject(new errors_1.AwaitQueueStoppedError(), {
            canExecuteNextTask: false
          });
        }
      }
      remove(taskIdx) {
        logger.debug(`remove() [taskIdx:${taskIdx}]`);
        const pendingTask = Array.from(this.pendingTasks.values())[taskIdx];
        if (!pendingTask) {
          logger.debug(`stop() | no task with given idx [taskIdx:${taskIdx}]`);
          return;
        }
        pendingTask.reject(new errors_1.AwaitQueueRemovedTaskError(), {
          canExecuteNextTask: true
        });
      }
      dump() {
        const now = Date.now();
        let idx = 0;
        return Array.from(this.pendingTasks.values()).map((pendingTask) => ({
          idx: idx++,
          task: pendingTask.task,
          name: pendingTask.name,
          enqueuedTime: pendingTask.executedAt ? pendingTask.executedAt - pendingTask.enqueuedAt : now - pendingTask.enqueuedAt,
          executionTime: pendingTask.executedAt ? now - pendingTask.executedAt : 0
        }));
      }
      async execute(pendingTask) {
        logger.debug(`execute() [name:${pendingTask.name}]`);
        if (pendingTask.executedAt) {
          throw new Error("task already being executed");
        }
        pendingTask.executedAt = Date.now();
        try {
          const result = await pendingTask.task();
          pendingTask.resolve(result);
        } catch (error2) {
          pendingTask.reject(error2, { canExecuteNextTask: true });
        }
      }
    };
    exports.AwaitQueue = AwaitQueue;
  }
});

// node_modules/awaitqueue/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/awaitqueue/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwaitQueueRemovedTaskError = exports.AwaitQueueStoppedError = exports.AwaitQueue = void 0;
    var AwaitQueue_1 = require_AwaitQueue();
    Object.defineProperty(exports, "AwaitQueue", { enumerable: true, get: function() {
      return AwaitQueue_1.AwaitQueue;
    } });
    var errors_1 = require_errors2();
    Object.defineProperty(exports, "AwaitQueueStoppedError", { enumerable: true, get: function() {
      return errors_1.AwaitQueueStoppedError;
    } });
    Object.defineProperty(exports, "AwaitQueueRemovedTaskError", { enumerable: true, get: function() {
      return errors_1.AwaitQueueRemovedTaskError;
    } });
  }
});

// node_modules/mediasoup-client/lib/Producer.js
var require_Producer = __commonJS({
  "node_modules/mediasoup-client/lib/Producer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Producer = void 0;
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var errors_1 = require_errors();
    var logger = new Logger_1.Logger("Producer");
    var Producer = class extends enhancedEvents_1.EnhancedEventEmitter {
      // Id.
      _id;
      // Local id.
      _localId;
      // Closed flag.
      _closed = false;
      // Associated RTCRtpSender.
      _rtpSender;
      // Local track.
      _track;
      // Producer kind.
      _kind;
      // RTP parameters.
      _rtpParameters;
      // Paused flag.
      _paused;
      // Video max spatial layer.
      _maxSpatialLayer;
      // Whether the Producer should call stop() in given tracks.
      _stopTracks;
      // Whether the Producer should set track.enabled = false when paused.
      _disableTrackOnPause;
      // Whether we should mark the transceiver as inactive when paused.
      _zeroRtpOnPause;
      // App custom data.
      _appData;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
        super();
        logger.debug("constructor()");
        this._id = id;
        this._localId = localId;
        this._rtpSender = rtpSender;
        this._track = track;
        this._kind = track.kind;
        this._rtpParameters = rtpParameters;
        this._paused = disableTrackOnPause ? !track.enabled : false;
        this._maxSpatialLayer = void 0;
        this._stopTracks = stopTracks;
        this._disableTrackOnPause = disableTrackOnPause;
        this._zeroRtpOnPause = zeroRtpOnPause;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
      }
      /**
       * Producer id.
       */
      get id() {
        return this._id;
      }
      /**
       * Local id.
       */
      get localId() {
        return this._localId;
      }
      /**
       * Whether the Producer is closed.
       */
      get closed() {
        return this._closed;
      }
      /**
       * Media kind.
       */
      get kind() {
        return this._kind;
      }
      /**
       * Associated RTCRtpSender.
       */
      get rtpSender() {
        return this._rtpSender;
      }
      /**
       * The associated track.
       */
      get track() {
        return this._track;
      }
      /**
       * RTP parameters.
       */
      get rtpParameters() {
        return this._rtpParameters;
      }
      /**
       * Whether the Producer is paused.
       */
      get paused() {
        return this._paused;
      }
      /**
       * Max spatial layer.
       *
       * @type {Number | undefined}
       */
      get maxSpatialLayer() {
        return this._maxSpatialLayer;
      }
      /**
       * App custom data.
       */
      get appData() {
        return this._appData;
      }
      /**
       * App custom data setter.
       */
      set appData(appData) {
        this._appData = appData;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Closes the Producer.
       */
      close() {
        if (this._closed) {
          return;
        }
        logger.debug("close()");
        this._closed = true;
        this.destroyTrack();
        this.emit("@close");
        this._observer.safeEmit("close");
        super.close();
        this._observer.close();
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
        if (this._closed) {
          return;
        }
        logger.debug("transportClosed()");
        this._closed = true;
        this.destroyTrack();
        this.safeEmit("transportclose");
        this._observer.safeEmit("close");
      }
      /**
       * Get associated RTCRtpSender stats.
       */
      async getStats() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        }
        return new Promise((resolve, reject) => {
          this.safeEmit("@getstats", resolve, reject);
        });
      }
      /**
       * Pauses sending media.
       */
      pause() {
        logger.debug("pause()");
        if (this._closed) {
          logger.error("pause() | Producer closed");
          return;
        }
        this._paused = true;
        if (this._track && this._disableTrackOnPause) {
          this._track.enabled = false;
        }
        if (this._zeroRtpOnPause) {
          new Promise((resolve, reject) => {
            this.safeEmit("@pause", resolve, reject);
          }).catch(() => {
          });
        }
        this._observer.safeEmit("pause");
      }
      /**
       * Resumes sending media.
       */
      resume() {
        logger.debug("resume()");
        if (this._closed) {
          logger.error("resume() | Producer closed");
          return;
        }
        this._paused = false;
        if (this._track && this._disableTrackOnPause) {
          this._track.enabled = true;
        }
        if (this._zeroRtpOnPause) {
          new Promise((resolve, reject) => {
            this.safeEmit("@resume", resolve, reject);
          }).catch(() => {
          });
        }
        this._observer.safeEmit("resume");
      }
      /**
       * Replaces the current track with a new one or null.
       */
      async replaceTrack({ track }) {
        logger.debug("replaceTrack() [track:%o]", track);
        if (this._closed) {
          if (track && this._stopTracks) {
            try {
              track.stop();
            } catch (error2) {
            }
          }
          throw new errors_1.InvalidStateError("closed");
        } else if (track?.readyState === "ended") {
          throw new errors_1.InvalidStateError("track ended");
        }
        if (track === this._track) {
          logger.debug("replaceTrack() | same track, ignored");
          return;
        }
        await new Promise((resolve, reject) => {
          this.safeEmit("@replacetrack", track, resolve, reject);
        });
        this.destroyTrack();
        this._track = track;
        if (this._track && this._disableTrackOnPause) {
          if (!this._paused) {
            this._track.enabled = true;
          } else if (this._paused) {
            this._track.enabled = false;
          }
        }
        this.handleTrack();
      }
      /**
       * Sets the video max spatial layer to be sent.
       */
      async setMaxSpatialLayer(spatialLayer) {
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (this._kind !== "video") {
          throw new errors_1.UnsupportedError("not a video Producer");
        } else if (typeof spatialLayer !== "number") {
          throw new TypeError("invalid spatialLayer");
        }
        if (spatialLayer === this._maxSpatialLayer) {
          return;
        }
        await new Promise((resolve, reject) => {
          this.safeEmit("@setmaxspatiallayer", spatialLayer, resolve, reject);
        }).catch(() => {
        });
        this._maxSpatialLayer = spatialLayer;
      }
      async setRtpEncodingParameters(params) {
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (typeof params !== "object") {
          throw new TypeError("invalid params");
        }
        await new Promise((resolve, reject) => {
          this.safeEmit("@setrtpencodingparameters", params, resolve, reject);
        });
      }
      onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit("trackended");
        this._observer.safeEmit("trackended");
      }
      handleTrack() {
        if (!this._track) {
          return;
        }
        this._track.addEventListener("ended", this.onTrackEnded);
      }
      destroyTrack() {
        if (!this._track) {
          return;
        }
        try {
          this._track.removeEventListener("ended", this.onTrackEnded);
          if (this._stopTracks) {
            this._track.stop();
          }
        } catch (error2) {
        }
      }
    };
    exports.Producer = Producer;
  }
});

// node_modules/mediasoup-client/lib/Consumer.js
var require_Consumer = __commonJS({
  "node_modules/mediasoup-client/lib/Consumer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Consumer = void 0;
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var errors_1 = require_errors();
    var logger = new Logger_1.Logger("Consumer");
    var Consumer = class extends enhancedEvents_1.EnhancedEventEmitter {
      // Id.
      _id;
      // Local id.
      _localId;
      // Associated Producer id.
      _producerId;
      // Closed flag.
      _closed = false;
      // Associated RTCRtpReceiver.
      _rtpReceiver;
      // Remote track.
      _track;
      // RTP parameters.
      _rtpParameters;
      // Paused flag.
      _paused;
      // App custom data.
      _appData;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
        super();
        logger.debug("constructor()");
        this._id = id;
        this._localId = localId;
        this._producerId = producerId;
        this._rtpReceiver = rtpReceiver;
        this._track = track;
        this._rtpParameters = rtpParameters;
        this._paused = !track.enabled;
        this._appData = appData ?? {};
        this.onTrackEnded = this.onTrackEnded.bind(this);
        this.handleTrack();
      }
      /**
       * Consumer id.
       */
      get id() {
        return this._id;
      }
      /**
       * Local id.
       */
      get localId() {
        return this._localId;
      }
      /**
       * Associated Producer id.
       */
      get producerId() {
        return this._producerId;
      }
      /**
       * Whether the Consumer is closed.
       */
      get closed() {
        return this._closed;
      }
      /**
       * Media kind.
       */
      get kind() {
        return this._track.kind;
      }
      /**
       * Associated RTCRtpReceiver.
       */
      get rtpReceiver() {
        return this._rtpReceiver;
      }
      /**
       * The associated track.
       */
      get track() {
        return this._track;
      }
      /**
       * RTP parameters.
       */
      get rtpParameters() {
        return this._rtpParameters;
      }
      /**
       * Whether the Consumer is paused.
       */
      get paused() {
        return this._paused;
      }
      /**
       * App custom data.
       */
      get appData() {
        return this._appData;
      }
      /**
       * App custom data setter.
       */
      set appData(appData) {
        this._appData = appData;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Closes the Consumer.
       */
      close() {
        if (this._closed) {
          return;
        }
        logger.debug("close()");
        this._closed = true;
        this.destroyTrack();
        this.emit("@close");
        this._observer.safeEmit("close");
        super.close();
        this._observer.close();
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
        if (this._closed) {
          return;
        }
        logger.debug("transportClosed()");
        this._closed = true;
        this.destroyTrack();
        this.safeEmit("transportclose");
        this._observer.safeEmit("close");
      }
      /**
       * Get associated RTCRtpReceiver stats.
       */
      async getStats() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        }
        return new Promise((resolve, reject) => {
          this.safeEmit("@getstats", resolve, reject);
        });
      }
      /**
       * Pauses receiving media.
       */
      pause() {
        logger.debug("pause()");
        if (this._closed) {
          logger.error("pause() | Consumer closed");
          return;
        }
        if (this._paused) {
          logger.debug("pause() | Consumer is already paused");
          return;
        }
        this._paused = true;
        this._track.enabled = false;
        this.emit("@pause");
        this._observer.safeEmit("pause");
      }
      /**
       * Resumes receiving media.
       */
      resume() {
        logger.debug("resume()");
        if (this._closed) {
          logger.error("resume() | Consumer closed");
          return;
        }
        if (!this._paused) {
          logger.debug("resume() | Consumer is already resumed");
          return;
        }
        this._paused = false;
        this._track.enabled = true;
        this.emit("@resume");
        this._observer.safeEmit("resume");
      }
      onTrackEnded() {
        logger.debug('track "ended" event');
        this.safeEmit("trackended");
        this._observer.safeEmit("trackended");
      }
      handleTrack() {
        this._track.addEventListener("ended", this.onTrackEnded);
      }
      destroyTrack() {
        try {
          this._track.removeEventListener("ended", this.onTrackEnded);
          this._track.stop();
        } catch (error2) {
        }
      }
    };
    exports.Consumer = Consumer;
  }
});

// node_modules/mediasoup-client/lib/DataProducer.js
var require_DataProducer = __commonJS({
  "node_modules/mediasoup-client/lib/DataProducer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataProducer = void 0;
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var errors_1 = require_errors();
    var logger = new Logger_1.Logger("DataProducer");
    var DataProducer = class extends enhancedEvents_1.EnhancedEventEmitter {
      // Id.
      _id;
      // The underlying RTCDataChannel instance.
      _dataChannel;
      // Closed flag.
      _closed = false;
      // SCTP stream parameters.
      _sctpStreamParameters;
      // App custom data.
      _appData;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      constructor({ id, dataChannel, sctpStreamParameters, appData }) {
        super();
        logger.debug("constructor()");
        this._id = id;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
      }
      /**
       * DataProducer id.
       */
      get id() {
        return this._id;
      }
      /**
       * Whether the DataProducer is closed.
       */
      get closed() {
        return this._closed;
      }
      /**
       * SCTP stream parameters.
       */
      get sctpStreamParameters() {
        return this._sctpStreamParameters;
      }
      /**
       * DataChannel readyState.
       */
      get readyState() {
        return this._dataChannel.readyState;
      }
      /**
       * DataChannel label.
       */
      get label() {
        return this._dataChannel.label;
      }
      /**
       * DataChannel protocol.
       */
      get protocol() {
        return this._dataChannel.protocol;
      }
      /**
       * DataChannel bufferedAmount.
       */
      get bufferedAmount() {
        return this._dataChannel.bufferedAmount;
      }
      /**
       * DataChannel bufferedAmountLowThreshold.
       */
      get bufferedAmountLowThreshold() {
        return this._dataChannel.bufferedAmountLowThreshold;
      }
      /**
       * Set DataChannel bufferedAmountLowThreshold.
       */
      set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
        this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
      }
      /**
       * App custom data.
       */
      get appData() {
        return this._appData;
      }
      /**
       * App custom data setter.
       */
      set appData(appData) {
        this._appData = appData;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Closes the DataProducer.
       */
      close() {
        if (this._closed) {
          return;
        }
        logger.debug("close()");
        this._closed = true;
        this._dataChannel.close();
        this.emit("@close");
        this._observer.safeEmit("close");
        super.close();
        this._observer.close();
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
        if (this._closed) {
          return;
        }
        logger.debug("transportClosed()");
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit("transportclose");
        this._observer.safeEmit("close");
      }
      /**
       * Send a message.
       *
       * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      send(data2) {
        logger.debug("send()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        }
        this._dataChannel.send(data2);
      }
      handleDataChannel() {
        this._dataChannel.addEventListener("open", () => {
          if (this._closed) {
            return;
          }
          logger.debug('DataChannel "open" event');
          this.safeEmit("open");
        });
        this._dataChannel.addEventListener("error", (event) => {
          if (this._closed) {
            return;
          }
          const error2 = event.error ?? new Error("unknown DataChannel error");
          if (event.error?.errorDetail === "sctp-failure") {
            logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", event.error?.sctpCauseCode, event.error.message);
          } else {
            logger.error('DataChannel "error" event: %o', error2);
          }
          this.safeEmit("error", error2);
        });
        this._dataChannel.addEventListener("close", () => {
          if (this._closed) {
            return;
          }
          logger.warn('DataChannel "close" event');
          this._closed = true;
          this.emit("@close");
          this.safeEmit("close");
          this._observer.safeEmit("close");
        });
        this._dataChannel.addEventListener("message", () => {
          if (this._closed) {
            return;
          }
          logger.warn('DataChannel "message" event in a DataProducer, message discarded');
        });
        this._dataChannel.addEventListener("bufferedamountlow", () => {
          if (this._closed) {
            return;
          }
          this.safeEmit("bufferedamountlow");
        });
      }
    };
    exports.DataProducer = DataProducer;
  }
});

// node_modules/mediasoup-client/lib/DataConsumer.js
var require_DataConsumer = __commonJS({
  "node_modules/mediasoup-client/lib/DataConsumer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataConsumer = void 0;
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var logger = new Logger_1.Logger("DataConsumer");
    var DataConsumer = class extends enhancedEvents_1.EnhancedEventEmitter {
      // Id.
      _id;
      // Associated DataProducer Id.
      _dataProducerId;
      // The underlying RTCDataChannel instance.
      _dataChannel;
      // Closed flag.
      _closed = false;
      // SCTP stream parameters.
      _sctpStreamParameters;
      // App custom data.
      _appData;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
        super();
        logger.debug("constructor()");
        this._id = id;
        this._dataProducerId = dataProducerId;
        this._dataChannel = dataChannel;
        this._sctpStreamParameters = sctpStreamParameters;
        this._appData = appData ?? {};
        this.handleDataChannel();
      }
      /**
       * DataConsumer id.
       */
      get id() {
        return this._id;
      }
      /**
       * Associated DataProducer id.
       */
      get dataProducerId() {
        return this._dataProducerId;
      }
      /**
       * Whether the DataConsumer is closed.
       */
      get closed() {
        return this._closed;
      }
      /**
       * SCTP stream parameters.
       */
      get sctpStreamParameters() {
        return this._sctpStreamParameters;
      }
      /**
       * DataChannel readyState.
       */
      get readyState() {
        return this._dataChannel.readyState;
      }
      /**
       * DataChannel label.
       */
      get label() {
        return this._dataChannel.label;
      }
      /**
       * DataChannel protocol.
       */
      get protocol() {
        return this._dataChannel.protocol;
      }
      /**
       * DataChannel binaryType.
       */
      get binaryType() {
        return this._dataChannel.binaryType;
      }
      /**
       * Set DataChannel binaryType.
       */
      set binaryType(binaryType) {
        this._dataChannel.binaryType = binaryType;
      }
      /**
       * App custom data.
       */
      get appData() {
        return this._appData;
      }
      /**
       * App custom data setter.
       */
      set appData(appData) {
        this._appData = appData;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Closes the DataConsumer.
       */
      close() {
        if (this._closed) {
          return;
        }
        logger.debug("close()");
        this._closed = true;
        this._dataChannel.close();
        this.emit("@close");
        this._observer.safeEmit("close");
        super.close();
        this._observer.close();
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
        if (this._closed) {
          return;
        }
        logger.debug("transportClosed()");
        this._closed = true;
        this._dataChannel.close();
        this.safeEmit("transportclose");
        this._observer.safeEmit("close");
      }
      handleDataChannel() {
        this._dataChannel.addEventListener("open", () => {
          if (this._closed) {
            return;
          }
          logger.debug('DataChannel "open" event');
          this.safeEmit("open");
        });
        this._dataChannel.addEventListener("error", (event) => {
          if (this._closed) {
            return;
          }
          const error2 = event.error ?? new Error("unknown DataChannel error");
          if (event.error?.errorDetail === "sctp-failure") {
            logger.error("DataChannel SCTP error [sctpCauseCode:%s]: %s", event.error?.sctpCauseCode, event.error.message);
          } else {
            logger.error('DataChannel "error" event: %o', error2);
          }
          this.safeEmit("error", error2);
        });
        this._dataChannel.addEventListener("close", () => {
          if (this._closed) {
            return;
          }
          logger.warn('DataChannel "close" event');
          this._closed = true;
          this.emit("@close");
          this.safeEmit("close");
          this._observer.safeEmit("close");
        });
        this._dataChannel.addEventListener("message", (event) => {
          if (this._closed) {
            return;
          }
          this.safeEmit("message", event.data);
        });
      }
    };
    exports.DataConsumer = DataConsumer;
  }
});

// node_modules/mediasoup-client/lib/Transport.js
var require_Transport = __commonJS({
  "node_modules/mediasoup-client/lib/Transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transport = void 0;
    var awaitqueue_1 = require_lib2();
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var errors_1 = require_errors();
    var utils = require_utils();
    var ortc = require_ortc();
    var Producer_1 = require_Producer();
    var Consumer_1 = require_Consumer();
    var DataProducer_1 = require_DataProducer();
    var DataConsumer_1 = require_DataConsumer();
    var logger = new Logger_1.Logger("Transport");
    var ConsumerCreationTask = class {
      consumerOptions;
      promise;
      resolve;
      reject;
      constructor(consumerOptions) {
        this.consumerOptions = consumerOptions;
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
    };
    var Transport = class extends enhancedEvents_1.EnhancedEventEmitter {
      // Id.
      _id;
      // Closed flag.
      _closed = false;
      // Direction.
      _direction;
      // Callback for sending Transports to request sending extended RTP capabilities
      // on demand.
      _getSendExtendedRtpCapabilities;
      // Recv RTP capabilities.
      _recvRtpCapabilities;
      // Whether we can produce audio/video based on computed extended RTP
      // capabilities.
      _canProduceByKind;
      // SCTP max message size if enabled, null otherwise.
      _maxSctpMessageSize;
      // RTC handler isntance.
      _handler;
      // Transport ICE gathering state.
      _iceGatheringState = "new";
      // Transport connection state.
      _connectionState = "new";
      // App custom data.
      _appData;
      // Map of Producers indexed by id.
      _producers = /* @__PURE__ */ new Map();
      // Map of Consumers indexed by id.
      _consumers = /* @__PURE__ */ new Map();
      // Map of DataProducers indexed by id.
      _dataProducers = /* @__PURE__ */ new Map();
      // Map of DataConsumers indexed by id.
      _dataConsumers = /* @__PURE__ */ new Map();
      // Whether the Consumer for RTP probation has been created.
      _probatorConsumerCreated = false;
      // AwaitQueue instance to make async tasks happen sequentially.
      _awaitQueue = new awaitqueue_1.AwaitQueue();
      // Consumer creation tasks awaiting to be processed.
      _pendingConsumerTasks = [];
      // Consumer creation in progress flag.
      _consumerCreationInProgress = false;
      // Consumers pending to be paused.
      _pendingPauseConsumers = /* @__PURE__ */ new Map();
      // Consumer pause in progress flag.
      _consumerPauseInProgress = false;
      // Consumers pending to be resumed.
      _pendingResumeConsumers = /* @__PURE__ */ new Map();
      // Consumer resume in progress flag.
      _consumerResumeInProgress = false;
      // Consumers pending to be closed.
      _pendingCloseConsumers = /* @__PURE__ */ new Map();
      // Consumer close in progress flag.
      _consumerCloseInProgress = false;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData, handlerFactory, getSendExtendedRtpCapabilities, recvRtpCapabilities, canProduceByKind }) {
        super();
        logger.debug("constructor() [id:%s, direction:%s]", id, direction);
        this._id = id;
        this._direction = direction;
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._recvRtpCapabilities = recvRtpCapabilities;
        this._canProduceByKind = canProduceByKind;
        this._maxSctpMessageSize = sctpParameters ? sctpParameters.maxMessageSize : null;
        const clonedAdditionalSettings = utils.clone(additionalSettings) ?? {};
        delete clonedAdditionalSettings.iceServers;
        delete clonedAdditionalSettings.iceTransportPolicy;
        delete clonedAdditionalSettings.bundlePolicy;
        delete clonedAdditionalSettings.rtcpMuxPolicy;
        this._handler = handlerFactory.factory({
          direction,
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          iceServers,
          iceTransportPolicy,
          additionalSettings: clonedAdditionalSettings,
          getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities
        });
        this._appData = appData ?? {};
        this.handleHandler();
      }
      /**
       * Transport id.
       */
      get id() {
        return this._id;
      }
      /**
       * Whether the Transport is closed.
       */
      get closed() {
        return this._closed;
      }
      /**
       * Transport direction.
       */
      get direction() {
        return this._direction;
      }
      /**
       * RTC handler instance.
       */
      get handler() {
        return this._handler;
      }
      /**
       * ICE gathering state.
       */
      get iceGatheringState() {
        return this._iceGatheringState;
      }
      /**
       * Connection state.
       */
      get connectionState() {
        return this._connectionState;
      }
      /**
       * App custom data.
       */
      get appData() {
        return this._appData;
      }
      /**
       * App custom data setter.
       */
      set appData(appData) {
        this._appData = appData;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Close the Transport.
       */
      close() {
        if (this._closed) {
          return;
        }
        logger.debug("close()");
        this._closed = true;
        this._awaitQueue.stop();
        this._handler.close();
        this._connectionState = "closed";
        for (const producer of this._producers.values()) {
          producer.transportClosed();
        }
        this._producers.clear();
        for (const consumer of this._consumers.values()) {
          consumer.transportClosed();
        }
        this._consumers.clear();
        for (const dataProducer of this._dataProducers.values()) {
          dataProducer.transportClosed();
        }
        this._dataProducers.clear();
        for (const dataConsumer of this._dataConsumers.values()) {
          dataConsumer.transportClosed();
        }
        this._dataConsumers.clear();
        this._observer.safeEmit("close");
        super.close();
        this._observer.close();
      }
      /**
       * Get associated Transport (RTCPeerConnection) stats.
       *
       * @returns {RTCStatsReport}
       */
      async getStats() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        }
        return this._handler.getTransportStats();
      }
      /**
       * Restart ICE connection.
       */
      async restartIce({ iceParameters }) {
        logger.debug("restartIce()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (!iceParameters) {
          throw new TypeError("missing iceParameters");
        }
        return this._awaitQueue.push(async () => await this._handler.restartIce(iceParameters), "transport.restartIce()");
      }
      /**
       * Update ICE servers.
       */
      async updateIceServers({ iceServers } = {}) {
        logger.debug("updateIceServers()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (!Array.isArray(iceServers)) {
          throw new TypeError("missing iceServers");
        }
        return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), "transport.updateIceServers()");
      }
      /**
       * Create a Producer.
       */
      async produce({ track, streamId, encodings, codecOptions, headerExtensionOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, onRtpSender, appData = {} } = {}) {
        logger.debug("produce() [track:%o]", track);
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (!track) {
          throw new TypeError("missing track");
        } else if (this._direction !== "send") {
          throw new errors_1.UnsupportedError("not a sending Transport");
        } else if (!this._canProduceByKind[track.kind]) {
          throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
        } else if (track.readyState === "ended") {
          throw new errors_1.InvalidStateError("track ended");
        } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
          throw new TypeError('no "connect" listener set into this transport');
        } else if (this.listenerCount("produce") === 0) {
          throw new TypeError('no "produce" listener set into this transport');
        } else if (appData && typeof appData !== "object") {
          throw new TypeError("if given, appData must be an object");
        }
        return this._awaitQueue.push(async () => {
          let normalizedEncodings;
          if (encodings && !Array.isArray(encodings)) {
            throw TypeError("encodings must be an array");
          } else if (encodings?.length === 0) {
            normalizedEncodings = void 0;
          } else if (encodings) {
            normalizedEncodings = encodings.map((encoding) => {
              const normalizedEncoding = {
                active: true
              };
              if (encoding.active === false) {
                normalizedEncoding.active = false;
              }
              if (typeof encoding.dtx === "boolean") {
                normalizedEncoding.dtx = encoding.dtx;
              }
              if (typeof encoding.scalabilityMode === "string") {
                normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
              }
              if (typeof encoding.scaleResolutionDownBy === "number") {
                normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
              }
              if (typeof encoding.maxBitrate === "number") {
                normalizedEncoding.maxBitrate = encoding.maxBitrate;
              }
              if (typeof encoding.maxFramerate === "number") {
                normalizedEncoding.maxFramerate = encoding.maxFramerate;
              }
              if (typeof encoding.adaptivePtime === "boolean") {
                normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
              }
              if (typeof encoding.priority === "string") {
                normalizedEncoding.priority = encoding.priority;
              }
              if (typeof encoding.networkPriority === "string") {
                normalizedEncoding.networkPriority = encoding.networkPriority;
              }
              return normalizedEncoding;
            });
          }
          const { localId, rtpParameters, rtpSender } = await this._handler.send({
            track,
            streamId,
            encodings: normalizedEncodings,
            codecOptions,
            headerExtensionOptions,
            codec,
            onRtpSender
          });
          try {
            ortc.validateAndNormalizeRtpParameters(rtpParameters);
            const { id } = await new Promise((resolve, reject) => {
              this.safeEmit("produce", {
                kind: track.kind,
                rtpParameters,
                appData
              }, resolve, reject);
            });
            const producer = new Producer_1.Producer({
              id,
              localId,
              rtpSender,
              track,
              rtpParameters,
              stopTracks,
              disableTrackOnPause,
              zeroRtpOnPause,
              appData
            });
            this._producers.set(producer.id, producer);
            this.handleProducer(producer);
            this._observer.safeEmit("newproducer", producer);
            return producer;
          } catch (error2) {
            this._handler.stopSending(localId).catch(() => {
            });
            throw error2;
          }
        }, "transport.produce()").catch((error2) => {
          if (stopTracks) {
            try {
              track.stop();
            } catch (error22) {
            }
          }
          throw error2;
        });
      }
      /**
       * Create a Consumer to consume a remote Producer.
       */
      async consume({ id, producerId, kind, rtpParameters, streamId, onRtpReceiver, appData = {} }) {
        logger.debug("consume()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (this._direction !== "recv") {
          throw new errors_1.UnsupportedError("not a receiving Transport");
        } else if (typeof id !== "string") {
          throw new TypeError("missing id");
        } else if (typeof producerId !== "string") {
          throw new TypeError("missing producerId");
        } else if (kind !== "audio" && kind !== "video") {
          throw new TypeError(`invalid kind '${kind}'`);
        } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
          throw new TypeError('no "connect" listener set into this transport');
        } else if (appData && typeof appData !== "object") {
          throw new TypeError("if given, appData must be an object");
        }
        const clonedRtpParameters = utils.clone(rtpParameters);
        const canConsume = ortc.canReceive(clonedRtpParameters, this._recvRtpCapabilities);
        if (!canConsume) {
          throw new errors_1.UnsupportedError("cannot consume this Producer");
        }
        const consumerCreationTask = new ConsumerCreationTask({
          id,
          producerId,
          kind,
          rtpParameters: clonedRtpParameters,
          streamId,
          onRtpReceiver,
          appData
        });
        this._pendingConsumerTasks.push(consumerCreationTask);
        queueMicrotask(() => {
          if (this._closed) {
            return;
          }
          if (this._consumerCreationInProgress === false) {
            this.createPendingConsumers();
          }
        });
        return consumerCreationTask.promise;
      }
      /**
       * Create a DataProducer
       */
      async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = "", protocol = "", appData = {} } = {}) {
        logger.debug("produceData()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (this._direction !== "send") {
          throw new errors_1.UnsupportedError("not a sending Transport");
        } else if (!this._maxSctpMessageSize) {
          throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
        } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
          throw new TypeError('no "connect" listener set into this transport');
        } else if (this.listenerCount("producedata") === 0) {
          throw new TypeError('no "producedata" listener set into this transport');
        } else if (appData && typeof appData !== "object") {
          throw new TypeError("if given, appData must be an object");
        }
        if (maxPacketLifeTime || maxRetransmits) {
          ordered = false;
        }
        return this._awaitQueue.push(async () => {
          const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
            ordered,
            maxPacketLifeTime,
            maxRetransmits,
            label,
            protocol
          });
          ortc.validateAndNormalizeSctpStreamParameters(sctpStreamParameters);
          const { id } = await new Promise((resolve, reject) => {
            this.safeEmit("producedata", {
              sctpStreamParameters,
              label,
              protocol,
              appData
            }, resolve, reject);
          });
          const dataProducer = new DataProducer_1.DataProducer({
            id,
            dataChannel,
            sctpStreamParameters,
            appData
          });
          this._dataProducers.set(dataProducer.id, dataProducer);
          this.handleDataProducer(dataProducer);
          this._observer.safeEmit("newdataproducer", dataProducer);
          return dataProducer;
        }, "transport.produceData()");
      }
      /**
       * Create a DataConsumer
       */
      async consumeData({ id, dataProducerId, sctpStreamParameters, label = "", protocol = "", appData = {} }) {
        logger.debug("consumeData()");
        if (this._closed) {
          throw new errors_1.InvalidStateError("closed");
        } else if (this._direction !== "recv") {
          throw new errors_1.UnsupportedError("not a receiving Transport");
        } else if (!this._maxSctpMessageSize) {
          throw new errors_1.UnsupportedError("SCTP not enabled by remote Transport");
        } else if (typeof id !== "string") {
          throw new TypeError("missing id");
        } else if (typeof dataProducerId !== "string") {
          throw new TypeError("missing dataProducerId");
        } else if (this.listenerCount("connect") === 0 && this._connectionState === "new") {
          throw new TypeError('no "connect" listener set into this transport');
        } else if (appData && typeof appData !== "object") {
          throw new TypeError("if given, appData must be an object");
        }
        const clonedSctpStreamParameters = utils.clone(sctpStreamParameters);
        ortc.validateAndNormalizeSctpStreamParameters(clonedSctpStreamParameters);
        return this._awaitQueue.push(async () => {
          const { dataChannel } = await this._handler.receiveDataChannel({
            sctpStreamParameters: clonedSctpStreamParameters,
            label,
            protocol
          });
          const dataConsumer = new DataConsumer_1.DataConsumer({
            id,
            dataProducerId,
            dataChannel,
            sctpStreamParameters: clonedSctpStreamParameters,
            appData
          });
          this._dataConsumers.set(dataConsumer.id, dataConsumer);
          this.handleDataConsumer(dataConsumer);
          this._observer.safeEmit("newdataconsumer", dataConsumer);
          return dataConsumer;
        }, "transport.consumeData()");
      }
      // This method is guaranteed to never throw.
      createPendingConsumers() {
        this._consumerCreationInProgress = true;
        this._awaitQueue.push(async () => {
          if (this._pendingConsumerTasks.length === 0) {
            logger.debug("createPendingConsumers() | there is no Consumer to be created");
            return;
          }
          const pendingConsumerTasks = [...this._pendingConsumerTasks];
          this._pendingConsumerTasks = [];
          let videoConsumerForProbator = void 0;
          const optionsList = [];
          for (const task of pendingConsumerTasks) {
            const { id, kind, rtpParameters, streamId, onRtpReceiver } = task.consumerOptions;
            optionsList.push({
              trackId: id,
              kind,
              rtpParameters,
              streamId,
              onRtpReceiver
            });
          }
          try {
            const results = await this._handler.receive(optionsList);
            for (let idx = 0; idx < results.length; ++idx) {
              const task = pendingConsumerTasks[idx];
              const result = results[idx];
              const { id, producerId, kind, rtpParameters, appData } = task.consumerOptions;
              const { localId, rtpReceiver, track } = result;
              const consumer = new Consumer_1.Consumer({
                id,
                localId,
                producerId,
                rtpReceiver,
                track,
                rtpParameters,
                appData
              });
              this._consumers.set(consumer.id, consumer);
              this.handleConsumer(consumer);
              if (!this._probatorConsumerCreated && !videoConsumerForProbator && kind === "video") {
                videoConsumerForProbator = consumer;
              }
              this._observer.safeEmit("newconsumer", consumer);
              task.resolve(consumer);
            }
          } catch (error2) {
            for (const task of pendingConsumerTasks) {
              task.reject(error2);
            }
          }
          if (videoConsumerForProbator) {
            try {
              const probatorRtpParameters = ortc.generateProbatorRtpParameters(videoConsumerForProbator.rtpParameters);
              await this._handler.receive([
                {
                  trackId: "probator",
                  kind: "video",
                  rtpParameters: probatorRtpParameters
                }
              ]);
              logger.debug("createPendingConsumers() | Consumer for RTP probation created");
              this._probatorConsumerCreated = true;
            } catch (error2) {
              logger.error("createPendingConsumers() | failed to create Consumer for RTP probation:%o", error2);
            }
          }
        }, "transport.createPendingConsumers()").then(() => {
          this._consumerCreationInProgress = false;
          if (this._pendingConsumerTasks.length > 0) {
            this.createPendingConsumers();
          }
        }).catch(() => {
        });
      }
      pausePendingConsumers() {
        this._consumerPauseInProgress = true;
        this._awaitQueue.push(async () => {
          if (this._pendingPauseConsumers.size === 0) {
            logger.debug("pausePendingConsumers() | there is no Consumer to be paused");
            return;
          }
          const pendingPauseConsumers = Array.from(this._pendingPauseConsumers.values());
          this._pendingPauseConsumers.clear();
          try {
            const localIds = pendingPauseConsumers.map((consumer) => consumer.localId);
            await this._handler.pauseReceiving(localIds);
          } catch (error2) {
            logger.error("pausePendingConsumers() | failed to pause Consumers:", error2);
          }
        }, "transport.pausePendingConsumers()").then(() => {
          this._consumerPauseInProgress = false;
          if (this._pendingPauseConsumers.size > 0) {
            this.pausePendingConsumers();
          }
        }).catch(() => {
        });
      }
      resumePendingConsumers() {
        this._consumerResumeInProgress = true;
        this._awaitQueue.push(async () => {
          if (this._pendingResumeConsumers.size === 0) {
            logger.debug("resumePendingConsumers() | there is no Consumer to be resumed");
            return;
          }
          const pendingResumeConsumers = Array.from(this._pendingResumeConsumers.values());
          this._pendingResumeConsumers.clear();
          try {
            const localIds = pendingResumeConsumers.map((consumer) => consumer.localId);
            await this._handler.resumeReceiving(localIds);
          } catch (error2) {
            logger.error("resumePendingConsumers() | failed to resume Consumers:", error2);
          }
        }, "transport.resumePendingConsumers()").then(() => {
          this._consumerResumeInProgress = false;
          if (this._pendingResumeConsumers.size > 0) {
            this.resumePendingConsumers();
          }
        }).catch(() => {
        });
      }
      closePendingConsumers() {
        this._consumerCloseInProgress = true;
        this._awaitQueue.push(async () => {
          if (this._pendingCloseConsumers.size === 0) {
            logger.debug("closePendingConsumers() | there is no Consumer to be closed");
            return;
          }
          const pendingCloseConsumers = Array.from(this._pendingCloseConsumers.values());
          this._pendingCloseConsumers.clear();
          try {
            await this._handler.stopReceiving(pendingCloseConsumers.map((consumer) => consumer.localId));
          } catch (error2) {
            logger.error("closePendingConsumers() | failed to close Consumers:", error2);
          }
        }, "transport.closePendingConsumers()").then(() => {
          this._consumerCloseInProgress = false;
          if (this._pendingCloseConsumers.size > 0) {
            this.closePendingConsumers();
          }
        }).catch(() => {
        });
      }
      handleHandler() {
        const handler = this._handler;
        handler.on("@connect", ({ dtlsParameters }, callback, errback) => {
          if (this._closed) {
            errback(new errors_1.InvalidStateError("closed"));
            return;
          }
          this.safeEmit("connect", { dtlsParameters }, callback, errback);
        });
        handler.on("@icegatheringstatechange", (iceGatheringState) => {
          if (iceGatheringState === this._iceGatheringState) {
            return;
          }
          logger.debug("ICE gathering state changed to %s", iceGatheringState);
          this._iceGatheringState = iceGatheringState;
          if (!this._closed) {
            this.safeEmit("icegatheringstatechange", iceGatheringState);
          }
        });
        handler.on("@icecandidateerror", (event) => {
          logger.warn(`ICE candidate error [url:${event.url}, localAddress:${event.address}, localPort:${event.port}]: ${event.errorCode} "${event.errorText}"`);
          this.safeEmit("icecandidateerror", event);
        });
        handler.on("@connectionstatechange", (connectionState) => {
          if (connectionState === this._connectionState) {
            return;
          }
          logger.debug("connection state changed to %s", connectionState);
          this._connectionState = connectionState;
          if (!this._closed) {
            this.safeEmit("connectionstatechange", connectionState);
          }
        });
      }
      handleProducer(producer) {
        producer.on("@close", () => {
          this._producers.delete(producer.id);
          if (this._closed) {
            return;
          }
          this._awaitQueue.push(async () => await this._handler.stopSending(producer.localId), "producer @close event").catch((error2) => logger.warn("producer.close() failed:%o", error2));
        });
        producer.on("@pause", (callback, errback) => {
          this._awaitQueue.push(async () => await this._handler.pauseSending(producer.localId), "producer @pause event").then(callback).catch(errback);
        });
        producer.on("@resume", (callback, errback) => {
          this._awaitQueue.push(async () => await this._handler.resumeSending(producer.localId), "producer @resume event").then(callback).catch(errback);
        });
        producer.on("@replacetrack", (track, callback, errback) => {
          this._awaitQueue.push(async () => await this._handler.replaceTrack(producer.localId, track), "producer @replacetrack event").then(callback).catch(errback);
        });
        producer.on("@setmaxspatiallayer", (spatialLayer, callback, errback) => {
          this._awaitQueue.push(async () => await this._handler.setMaxSpatialLayer(producer.localId, spatialLayer), "producer @setmaxspatiallayer event").then(callback).catch(errback);
        });
        producer.on("@setrtpencodingparameters", (params, callback, errback) => {
          this._awaitQueue.push(async () => await this._handler.setRtpEncodingParameters(producer.localId, params), "producer @setrtpencodingparameters event").then(callback).catch(errback);
        });
        producer.on("@getstats", (callback, errback) => {
          if (this._closed) {
            return errback(new errors_1.InvalidStateError("closed"));
          }
          this._handler.getSenderStats(producer.localId).then(callback).catch(errback);
        });
      }
      handleConsumer(consumer) {
        consumer.on("@close", () => {
          this._consumers.delete(consumer.id);
          this._pendingPauseConsumers.delete(consumer.id);
          this._pendingResumeConsumers.delete(consumer.id);
          if (this._closed) {
            return;
          }
          this._pendingCloseConsumers.set(consumer.id, consumer);
          if (this._consumerCloseInProgress === false) {
            this.closePendingConsumers();
          }
        });
        consumer.on("@pause", () => {
          if (this._pendingResumeConsumers.has(consumer.id)) {
            this._pendingResumeConsumers.delete(consumer.id);
          }
          this._pendingPauseConsumers.set(consumer.id, consumer);
          queueMicrotask(() => {
            if (this._closed) {
              return;
            }
            if (this._consumerPauseInProgress === false) {
              this.pausePendingConsumers();
            }
          });
        });
        consumer.on("@resume", () => {
          if (this._pendingPauseConsumers.has(consumer.id)) {
            this._pendingPauseConsumers.delete(consumer.id);
          }
          this._pendingResumeConsumers.set(consumer.id, consumer);
          queueMicrotask(() => {
            if (this._closed) {
              return;
            }
            if (this._consumerResumeInProgress === false) {
              this.resumePendingConsumers();
            }
          });
        });
        consumer.on("@getstats", (callback, errback) => {
          if (this._closed) {
            return errback(new errors_1.InvalidStateError("closed"));
          }
          this._handler.getReceiverStats(consumer.localId).then(callback).catch(errback);
        });
      }
      handleDataProducer(dataProducer) {
        dataProducer.on("@close", () => {
          this._dataProducers.delete(dataProducer.id);
        });
      }
      handleDataConsumer(dataConsumer) {
        dataConsumer.on("@close", () => {
          this._dataConsumers.delete(dataConsumer.id);
        });
      }
    };
    exports.Transport = Transport;
  }
});

// node_modules/sdp-transform/lib/grammar.js
var require_grammar = __commonJS({
  "node_modules/sdp-transform/lib/grammar.js"(exports, module) {
    var grammar = module.exports = {
      v: [{
        name: "version",
        reg: /^(\d*)$/
      }],
      o: [{
        // o=- 20518 0 IN IP4 203.0.113.1
        // NB: sessionId will be a String in most cases because it is huge
        name: "origin",
        reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
        names: ["username", "sessionId", "sessionVersion", "netType", "ipVer", "address"],
        format: "%s %s %d %s IP%d %s"
      }],
      // default parsing of these only (though some of these feel outdated)
      s: [{ name: "name" }],
      i: [{ name: "description" }],
      u: [{ name: "uri" }],
      e: [{ name: "email" }],
      p: [{ name: "phone" }],
      z: [{ name: "timezones" }],
      // TODO: this one can actually be parsed properly...
      r: [{ name: "repeats" }],
      // TODO: this one can also be parsed properly
      // k: [{}], // outdated thing ignored
      t: [{
        // t=0 0
        name: "timing",
        reg: /^(\d*) (\d*)/,
        names: ["start", "stop"],
        format: "%d %d"
      }],
      c: [{
        // c=IN IP4 10.47.197.26
        name: "connection",
        reg: /^IN IP(\d) (\S*)/,
        names: ["version", "ip"],
        format: "IN IP%d %s"
      }],
      b: [{
        // b=AS:4000
        push: "bandwidth",
        reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
        names: ["type", "limit"],
        format: "%s:%s"
      }],
      m: [{
        // m=video 51744 RTP/AVP 126 97 98 34 31
        // NB: special - pushes to session
        // TODO: rtp/fmtp should be filtered by the payloads found here?
        reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
        names: ["type", "port", "protocol", "payloads"],
        format: "%s %d %s %s"
      }],
      a: [
        {
          // a=rtpmap:110 opus/48000/2
          push: "rtp",
          reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
          names: ["payload", "codec", "rate", "encoding"],
          format: function(o2) {
            return o2.encoding ? "rtpmap:%d %s/%s/%s" : o2.rate ? "rtpmap:%d %s/%s" : "rtpmap:%d %s";
          }
        },
        {
          // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
          // a=fmtp:111 minptime=10; useinbandfec=1
          push: "fmtp",
          reg: /^fmtp:(\d*) ([\S| ]*)/,
          names: ["payload", "config"],
          format: "fmtp:%d %s"
        },
        {
          // a=control:streamid=0
          name: "control",
          reg: /^control:(.*)/,
          format: "control:%s"
        },
        {
          // a=rtcp:65179 IN IP4 193.84.77.194
          name: "rtcp",
          reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
          names: ["port", "netType", "ipVer", "address"],
          format: function(o2) {
            return o2.address != null ? "rtcp:%d %s IP%d %s" : "rtcp:%d";
          }
        },
        {
          // a=rtcp-fb:98 trr-int 100
          push: "rtcpFbTrrInt",
          reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
          names: ["payload", "value"],
          format: "rtcp-fb:%s trr-int %d"
        },
        {
          // a=rtcp-fb:98 nack rpsi
          push: "rtcpFb",
          reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
          names: ["payload", "type", "subtype"],
          format: function(o2) {
            return o2.subtype != null ? "rtcp-fb:%s %s %s" : "rtcp-fb:%s %s";
          }
        },
        {
          // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
          // a=extmap:1/recvonly URI-gps-string
          // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
          push: "ext",
          reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
          names: ["value", "direction", "encrypt-uri", "uri", "config"],
          format: function(o2) {
            return "extmap:%d" + (o2.direction ? "/%s" : "%v") + (o2["encrypt-uri"] ? " %s" : "%v") + " %s" + (o2.config ? " %s" : "");
          }
        },
        {
          // a=extmap-allow-mixed
          name: "extmapAllowMixed",
          reg: /^(extmap-allow-mixed)/
        },
        {
          // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
          push: "crypto",
          reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
          names: ["id", "suite", "config", "sessionConfig"],
          format: function(o2) {
            return o2.sessionConfig != null ? "crypto:%d %s %s %s" : "crypto:%d %s %s";
          }
        },
        {
          // a=setup:actpass
          name: "setup",
          reg: /^setup:(\w*)/,
          format: "setup:%s"
        },
        {
          // a=connection:new
          name: "connectionType",
          reg: /^connection:(new|existing)/,
          format: "connection:%s"
        },
        {
          // a=mid:1
          name: "mid",
          reg: /^mid:([^\s]*)/,
          format: "mid:%s"
        },
        {
          // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
          push: "msid",
          reg: /^msid:([\w-]+)(?: ([\w-]+))?/,
          names: ["id", "appdata"],
          format: "msid:%s %s"
        },
        {
          // a=ptime:20
          name: "ptime",
          reg: /^ptime:(\d*(?:\.\d*)*)/,
          format: "ptime:%d"
        },
        {
          // a=maxptime:60
          name: "maxptime",
          reg: /^maxptime:(\d*(?:\.\d*)*)/,
          format: "maxptime:%d"
        },
        {
          // a=sendrecv
          name: "direction",
          reg: /^(sendrecv|recvonly|sendonly|inactive)/
        },
        {
          // a=ice-lite
          name: "icelite",
          reg: /^(ice-lite)/
        },
        {
          // a=ice-ufrag:F7gI
          name: "iceUfrag",
          reg: /^ice-ufrag:(\S*)/,
          format: "ice-ufrag:%s"
        },
        {
          // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
          name: "icePwd",
          reg: /^ice-pwd:(\S*)/,
          format: "ice-pwd:%s"
        },
        {
          // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
          name: "fingerprint",
          reg: /^fingerprint:(\S*) (\S*)/,
          names: ["type", "hash"],
          format: "fingerprint:%s %s"
        },
        {
          // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
          // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
          // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
          // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
          push: "candidates",
          reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
          names: ["foundation", "component", "transport", "priority", "ip", "port", "type", "raddr", "rport", "tcptype", "generation", "network-id", "network-cost"],
          format: function(o2) {
            var str = "candidate:%s %d %s %d %s %d typ %s";
            str += o2.raddr != null ? " raddr %s rport %d" : "%v%v";
            str += o2.tcptype != null ? " tcptype %s" : "%v";
            if (o2.generation != null) {
              str += " generation %d";
            }
            str += o2["network-id"] != null ? " network-id %d" : "%v";
            str += o2["network-cost"] != null ? " network-cost %d" : "%v";
            return str;
          }
        },
        {
          // a=end-of-candidates (keep after the candidates line for readability)
          name: "endOfCandidates",
          reg: /^(end-of-candidates)/
        },
        {
          // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
          name: "remoteCandidates",
          reg: /^remote-candidates:(.*)/,
          format: "remote-candidates:%s"
        },
        {
          // a=ice-options:google-ice
          name: "iceOptions",
          reg: /^ice-options:(\S*)/,
          format: "ice-options:%s"
        },
        {
          // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
          push: "ssrcs",
          reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
          names: ["id", "attribute", "value"],
          format: function(o2) {
            var str = "ssrc:%d";
            if (o2.attribute != null) {
              str += " %s";
              if (o2.value != null) {
                str += ":%s";
              }
            }
            return str;
          }
        },
        {
          // a=ssrc-group:FEC 1 2
          // a=ssrc-group:FEC-FR 3004364195 1080772241
          push: "ssrcGroups",
          // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
          reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
          names: ["semantics", "ssrcs"],
          format: "ssrc-group:%s %s"
        },
        {
          // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
          name: "msidSemantic",
          reg: /^msid-semantic:\s?(\w*) (\S*)/,
          names: ["semantic", "token"],
          format: "msid-semantic: %s %s"
          // space after ':' is not accidental
        },
        {
          // a=group:BUNDLE audio video
          push: "groups",
          reg: /^group:(\w*) (.*)/,
          names: ["type", "mids"],
          format: "group:%s %s"
        },
        {
          // a=rtcp-mux
          name: "rtcpMux",
          reg: /^(rtcp-mux)/
        },
        {
          // a=rtcp-rsize
          name: "rtcpRsize",
          reg: /^(rtcp-rsize)/
        },
        {
          // a=sctpmap:5000 webrtc-datachannel 1024
          name: "sctpmap",
          reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
          names: ["sctpmapNumber", "app", "maxMessageSize"],
          format: function(o2) {
            return o2.maxMessageSize != null ? "sctpmap:%s %s %s" : "sctpmap:%s %s";
          }
        },
        {
          // a=x-google-flag:conference
          name: "xGoogleFlag",
          reg: /^x-google-flag:([^\s]*)/,
          format: "x-google-flag:%s"
        },
        {
          // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
          push: "rids",
          reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
          names: ["id", "direction", "params"],
          format: function(o2) {
            return o2.params ? "rid:%s %s %s" : "rid:%s %s";
          }
        },
        {
          // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
          // a=imageattr:* send [x=800,y=640] recv *
          // a=imageattr:100 recv [x=320,y=240]
          push: "imageattrs",
          reg: new RegExp(
            // a=imageattr:97
            "^imageattr:(\\d+|\\*)[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?"
          ),
          names: ["pt", "dir1", "attrs1", "dir2", "attrs2"],
          format: function(o2) {
            return "imageattr:%s %s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
          // a=simulcast:recv 1;4,5 send 6;7
          name: "simulcast",
          reg: new RegExp(
            // a=simulcast:
            "^simulcast:(send|recv) ([a-zA-Z0-9\\-_~;,]+)(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?$"
          ),
          names: ["dir1", "list1", "dir2", "list2"],
          format: function(o2) {
            return "simulcast:%s %s" + (o2.dir2 ? " %s %s" : "");
          }
        },
        {
          // old simulcast draft 03 (implemented by Firefox)
          //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
          // a=simulcast: recv pt=97;98 send pt=97
          // a=simulcast: send rid=5;6;7 paused=6,7
          name: "simulcast_03",
          reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
          names: ["value"],
          format: "simulcast: %s"
        },
        {
          // a=framerate:25
          // a=framerate:29.97
          name: "framerate",
          reg: /^framerate:(\d+(?:$|\.\d+))/,
          format: "framerate:%s"
        },
        {
          // RFC4570
          // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
          name: "sourceFilter",
          reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
          names: ["filterMode", "netType", "addressTypes", "destAddress", "srcList"],
          format: "source-filter: %s %s %s %s %s"
        },
        {
          // a=bundle-only
          name: "bundleOnly",
          reg: /^(bundle-only)/
        },
        {
          // a=label:1
          name: "label",
          reg: /^label:(.+)/,
          format: "label:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
          name: "sctpPort",
          reg: /^sctp-port:(\d+)$/,
          format: "sctp-port:%s"
        },
        {
          // RFC version 26 for SCTP over DTLS
          // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
          name: "maxMessageSize",
          reg: /^max-message-size:(\d+)$/,
          format: "max-message-size:%s"
        },
        {
          // RFC7273
          // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
          push: "tsRefClocks",
          reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
          names: ["clksrc", "clksrcExt"],
          format: function(o2) {
            return "ts-refclk:%s" + (o2.clksrcExt != null ? "=%s" : "");
          }
        },
        {
          // RFC7273
          // a=mediaclk:direct=963214424
          name: "mediaClk",
          reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
          names: ["id", "mediaClockName", "mediaClockValue", "rateNumerator", "rateDenominator"],
          format: function(o2) {
            var str = "mediaclk:";
            str += o2.id != null ? "id=%s %s" : "%v%s";
            str += o2.mediaClockValue != null ? "=%s" : "";
            str += o2.rateNumerator != null ? " rate=%s" : "";
            str += o2.rateDenominator != null ? "/%s" : "";
            return str;
          }
        },
        {
          // a=keywds:keywords
          name: "keywords",
          reg: /^keywds:(.+)$/,
          format: "keywds:%s"
        },
        {
          // a=content:main
          name: "content",
          reg: /^content:(.+)/,
          format: "content:%s"
        },
        // BFCP https://tools.ietf.org/html/rfc4583
        {
          // a=floorctrl:c-s
          name: "bfcpFloorCtrl",
          reg: /^floorctrl:(c-only|s-only|c-s)/,
          format: "floorctrl:%s"
        },
        {
          // a=confid:1
          name: "bfcpConfId",
          reg: /^confid:(\d+)/,
          format: "confid:%s"
        },
        {
          // a=userid:1
          name: "bfcpUserId",
          reg: /^userid:(\d+)/,
          format: "userid:%s"
        },
        {
          // a=floorid:1
          name: "bfcpFloorId",
          reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
          names: ["id", "mStream"],
          format: "floorid:%s mstrm:%s"
        },
        {
          // any a= that we don't understand is kept verbatim on media.invalid
          push: "invalid",
          names: ["value"]
        }
      ]
    };
    Object.keys(grammar).forEach(function(key) {
      var objs = grammar[key];
      objs.forEach(function(obj) {
        if (!obj.reg) {
          obj.reg = /(.*)/;
        }
        if (!obj.format) {
          obj.format = "%s";
        }
      });
    });
  }
});

// node_modules/sdp-transform/lib/parser.js
var require_parser = __commonJS({
  "node_modules/sdp-transform/lib/parser.js"(exports) {
    var toIntIfInt = function(v2) {
      return String(Number(v2)) === v2 ? Number(v2) : v2;
    };
    var attachProperties = function(match, location, names, rawName) {
      if (rawName && !names) {
        location[rawName] = toIntIfInt(match[1]);
      } else {
        for (var i2 = 0; i2 < names.length; i2 += 1) {
          if (match[i2 + 1] != null) {
            location[names[i2]] = toIntIfInt(match[i2 + 1]);
          }
        }
      }
    };
    var parseReg = function(obj, location, content) {
      var needsBlank = obj.name && obj.names;
      if (obj.push && !location[obj.push]) {
        location[obj.push] = [];
      } else if (needsBlank && !location[obj.name]) {
        location[obj.name] = {};
      }
      var keyLocation = obj.push ? {} : (
        // blank object that will be pushed
        needsBlank ? location[obj.name] : location
      );
      attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
      if (obj.push) {
        location[obj.push].push(keyLocation);
      }
    };
    var grammar = require_grammar();
    var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
    exports.parse = function(sdp) {
      var session = {}, media = [], location = session;
      sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function(l2) {
        var type = l2[0];
        var content = l2.slice(2);
        if (type === "m") {
          media.push({ rtp: [], fmtp: [] });
          location = media[media.length - 1];
        }
        for (var j2 = 0; j2 < (grammar[type] || []).length; j2 += 1) {
          var obj = grammar[type][j2];
          if (obj.reg.test(content)) {
            return parseReg(obj, location, content);
          }
        }
      });
      session.media = media;
      return session;
    };
    var paramReducer = function(acc, expr) {
      var s2 = expr.split(/=(.+)/, 2);
      if (s2.length === 2) {
        acc[s2[0]] = toIntIfInt(s2[1]);
      } else if (s2.length === 1 && expr.length > 1) {
        acc[s2[0]] = void 0;
      }
      return acc;
    };
    exports.parseParams = function(str) {
      return str.split(/;\s?/).reduce(paramReducer, {});
    };
    exports.parseFmtpConfig = exports.parseParams;
    exports.parsePayloads = function(str) {
      return str.toString().split(" ").map(Number);
    };
    exports.parseRemoteCandidates = function(str) {
      var candidates = [];
      var parts = str.split(" ").map(toIntIfInt);
      for (var i2 = 0; i2 < parts.length; i2 += 3) {
        candidates.push({
          component: parts[i2],
          ip: parts[i2 + 1],
          port: parts[i2 + 2]
        });
      }
      return candidates;
    };
    exports.parseImageAttributes = function(str) {
      return str.split(" ").map(function(item) {
        return item.substring(1, item.length - 1).split(",").reduce(paramReducer, {});
      });
    };
    exports.parseSimulcastStreamList = function(str) {
      return str.split(";").map(function(stream) {
        return stream.split(",").map(function(format) {
          var scid, paused = false;
          if (format[0] !== "~") {
            scid = toIntIfInt(format);
          } else {
            scid = toIntIfInt(format.substring(1, format.length));
            paused = true;
          }
          return {
            scid,
            paused
          };
        });
      });
    };
  }
});

// node_modules/sdp-transform/lib/writer.js
var require_writer = __commonJS({
  "node_modules/sdp-transform/lib/writer.js"(exports, module) {
    var grammar = require_grammar();
    var formatRegExp = /%[sdv%]/g;
    var format = function(formatStr) {
      var i2 = 1;
      var args = arguments;
      var len = args.length;
      return formatStr.replace(formatRegExp, function(x2) {
        if (i2 >= len) {
          return x2;
        }
        var arg = args[i2];
        i2 += 1;
        switch (x2) {
          case "%%":
            return "%";
          case "%s":
            return String(arg);
          case "%d":
            return Number(arg);
          case "%v":
            return "";
        }
      });
    };
    var makeLine = function(type, obj, location) {
      var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;
      var args = [type + "=" + str];
      if (obj.names) {
        for (var i2 = 0; i2 < obj.names.length; i2 += 1) {
          var n2 = obj.names[i2];
          if (obj.name) {
            args.push(location[obj.name][n2]);
          } else {
            args.push(location[obj.names[i2]]);
          }
        }
      } else {
        args.push(location[obj.name]);
      }
      return format.apply(null, args);
    };
    var defaultOuterOrder = [
      "v",
      "o",
      "s",
      "i",
      "u",
      "e",
      "p",
      "c",
      "b",
      "t",
      "r",
      "z",
      "a"
    ];
    var defaultInnerOrder = ["i", "c", "b", "a"];
    module.exports = function(session, opts) {
      opts = opts || {};
      if (session.version == null) {
        session.version = 0;
      }
      if (session.name == null) {
        session.name = " ";
      }
      session.media.forEach(function(mLine) {
        if (mLine.payloads == null) {
          mLine.payloads = "";
        }
      });
      var outerOrder = opts.outerOrder || defaultOuterOrder;
      var innerOrder = opts.innerOrder || defaultInnerOrder;
      var sdp = [];
      outerOrder.forEach(function(type) {
        grammar[type].forEach(function(obj) {
          if (obj.name in session && session[obj.name] != null) {
            sdp.push(makeLine(type, obj, session));
          } else if (obj.push in session && session[obj.push] != null) {
            session[obj.push].forEach(function(el) {
              sdp.push(makeLine(type, obj, el));
            });
          }
        });
      });
      session.media.forEach(function(mLine) {
        sdp.push(makeLine("m", grammar.m[0], mLine));
        innerOrder.forEach(function(type) {
          grammar[type].forEach(function(obj) {
            if (obj.name in mLine && mLine[obj.name] != null) {
              sdp.push(makeLine(type, obj, mLine));
            } else if (obj.push in mLine && mLine[obj.push] != null) {
              mLine[obj.push].forEach(function(el) {
                sdp.push(makeLine(type, obj, el));
              });
            }
          });
        });
      });
      return sdp.join("\r\n") + "\r\n";
    };
  }
});

// node_modules/sdp-transform/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/sdp-transform/lib/index.js"(exports) {
    var parser = require_parser();
    var writer = require_writer();
    var grammar = require_grammar();
    exports.grammar = grammar;
    exports.write = writer;
    exports.parse = parser.parse;
    exports.parseParams = parser.parseParams;
    exports.parseFmtpConfig = parser.parseFmtpConfig;
    exports.parsePayloads = parser.parsePayloads;
    exports.parseRemoteCandidates = parser.parseRemoteCandidates;
    exports.parseImageAttributes = parser.parseImageAttributes;
    exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  }
});

// node_modules/mediasoup-client/lib/scalabilityModes.js
var require_scalabilityModes = __commonJS({
  "node_modules/mediasoup-client/lib/scalabilityModes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parse = parse;
    var ScalabilityModeRegex = new RegExp("^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})");
    function parse(scalabilityMode) {
      const match = ScalabilityModeRegex.exec(scalabilityMode ?? "");
      if (match) {
        return {
          spatialLayers: Number(match[1]),
          temporalLayers: Number(match[2])
        };
      } else {
        return {
          spatialLayers: 1,
          temporalLayers: 1
        };
      }
    }
  }
});

// node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js
var require_MediaSection = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
    var sdpTransform = require_lib3();
    var utils = require_utils();
    var MediaSection = class {
      // SDP media object.
      _mediaObject;
      constructor({ iceParameters, iceCandidates, dtlsParameters }) {
        this._mediaObject = {
          type: "",
          port: 0,
          protocol: "",
          payloads: "",
          rtp: [],
          fmtp: []
        };
        if (iceParameters) {
          this.setIceParameters(iceParameters);
        }
        if (iceCandidates) {
          this._mediaObject.candidates = [];
          for (const candidate of iceCandidates) {
            const candidateObject = {
              foundation: candidate.foundation,
              // mediasoup does mandates rtcp-mux so candidates component is always
              // RTP (1).
              component: 1,
              // Be ready for new candidate.address field in mediasoup server side
              // field and keep backward compatibility with deprecated candidate.ip.
              ip: candidate.address ?? candidate.ip,
              port: candidate.port,
              priority: candidate.priority,
              transport: candidate.protocol,
              type: candidate.type
            };
            if (candidate.tcpType) {
              candidateObject.tcptype = candidate.tcpType;
            }
            this._mediaObject.candidates.push(candidateObject);
          }
          this._mediaObject.endOfCandidates = "end-of-candidates";
          this._mediaObject.iceOptions = "renomination";
        }
        if (dtlsParameters) {
          this.setDtlsRole(dtlsParameters.role);
        }
      }
      get mid() {
        return String(this._mediaObject.mid);
      }
      get closed() {
        return this._mediaObject.port === 0;
      }
      getObject() {
        return this._mediaObject;
      }
      setIceParameters(iceParameters) {
        this._mediaObject.iceUfrag = iceParameters.usernameFragment;
        this._mediaObject.icePwd = iceParameters.password;
      }
      pause() {
        this._mediaObject.direction = "inactive";
      }
      disable() {
        this.pause();
      }
      close() {
        this.disable();
        this._mediaObject.port = 0;
        delete this._mediaObject.candidates;
        delete this._mediaObject.endOfCandidates;
        delete this._mediaObject.iceUfrag;
        delete this._mediaObject.icePwd;
        delete this._mediaObject.iceOptions;
        this._mediaObject.rtp = [];
        this._mediaObject.fmtp = [];
        delete this._mediaObject.rtcp;
        delete this._mediaObject.rtcpFb;
        delete this._mediaObject.ssrcs;
        delete this._mediaObject.ssrcGroups;
        delete this._mediaObject.simulcast;
        delete this._mediaObject.simulcast_03;
        delete this._mediaObject.rids;
        delete this._mediaObject.extmapAllowMixed;
      }
    };
    exports.MediaSection = MediaSection;
    var AnswerMediaSection = class extends MediaSection {
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions }) {
        super({ iceParameters, iceCandidates, dtlsParameters });
        this._mediaObject.mid = String(offerMediaObject.mid);
        this._mediaObject.type = offerMediaObject.type;
        this._mediaObject.protocol = offerMediaObject.protocol;
        if (!plainRtpParameters) {
          this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
          this._mediaObject.port = 7;
        } else {
          this._mediaObject.connection = {
            ip: plainRtpParameters.ip,
            version: plainRtpParameters.ipVersion
          };
          this._mediaObject.port = plainRtpParameters.port;
        }
        switch (offerMediaObject.type) {
          case "audio":
          case "video": {
            this._mediaObject.direction = "recvonly";
            this._mediaObject.rtp = [];
            this._mediaObject.rtcpFb = [];
            this._mediaObject.fmtp = [];
            for (const codec of answerRtpParameters.codecs) {
              const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              this._mediaObject.rtp.push(rtp);
              const codecParameters = utils.clone(codec.parameters) ?? {};
              let codecRtcpFeedback = utils.clone(codec.rtcpFeedback) ?? [];
              if (codecOptions) {
                const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, opusNack, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                const offerCodec = offerRtpParameters.codecs.find((c2) => c2.payloadType === codec.payloadType);
                switch (codec.mimeType.toLowerCase()) {
                  case "audio/opus":
                  case "audio/multiopus": {
                    if (opusStereo !== void 0) {
                      offerCodec.parameters["sprop-stereo"] = opusStereo ? 1 : 0;
                      codecParameters["stereo"] = opusStereo ? 1 : 0;
                    }
                    if (opusFec !== void 0) {
                      offerCodec.parameters["useinbandfec"] = opusFec ? 1 : 0;
                      codecParameters["useinbandfec"] = opusFec ? 1 : 0;
                    }
                    if (opusDtx !== void 0) {
                      offerCodec.parameters["usedtx"] = opusDtx ? 1 : 0;
                      codecParameters["usedtx"] = opusDtx ? 1 : 0;
                    }
                    if (opusMaxPlaybackRate !== void 0) {
                      codecParameters["maxplaybackrate"] = opusMaxPlaybackRate;
                    }
                    if (opusMaxAverageBitrate !== void 0) {
                      codecParameters["maxaveragebitrate"] = opusMaxAverageBitrate;
                    }
                    if (opusPtime !== void 0) {
                      offerCodec.parameters["ptime"] = opusPtime;
                      codecParameters["ptime"] = opusPtime;
                    }
                    if (!opusNack) {
                      offerCodec.rtcpFeedback = offerCodec.rtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                      codecRtcpFeedback = codecRtcpFeedback.filter((fb) => fb.type !== "nack" || fb.parameter);
                    }
                    break;
                  }
                  case "video/vp8":
                  case "video/vp9":
                  case "video/h264":
                  case "video/h265":
                  case "video/av1": {
                    if (videoGoogleStartBitrate !== void 0) {
                      codecParameters["x-google-start-bitrate"] = videoGoogleStartBitrate;
                    }
                    if (videoGoogleMaxBitrate !== void 0) {
                      codecParameters["x-google-max-bitrate"] = videoGoogleMaxBitrate;
                    }
                    if (videoGoogleMinBitrate !== void 0) {
                      codecParameters["x-google-min-bitrate"] = videoGoogleMinBitrate;
                    }
                    break;
                  }
                }
              }
              const fmtp = {
                payload: codec.payloadType,
                config: ""
              };
              for (const key of Object.keys(codecParameters)) {
                if (fmtp.config) {
                  fmtp.config += ";";
                }
                fmtp.config += `${key}=${codecParameters[key]}`;
              }
              if (fmtp.config) {
                this._mediaObject.fmtp.push(fmtp);
              }
              for (const fb of codecRtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                  payload: codec.payloadType,
                  type: fb.type,
                  subtype: fb.parameter
                });
              }
            }
            this._mediaObject.payloads = answerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
            this._mediaObject.ext = [];
            for (const ext of answerRtpParameters.headerExtensions) {
              const found = (offerMediaObject.ext ?? []).some((localExt) => localExt.uri === ext.uri);
              if (!found) {
                continue;
              }
              this._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            }
            if (offerMediaObject.extmapAllowMixed === "extmap-allow-mixed") {
              this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
            }
            if (offerMediaObject.simulcast) {
              this._mediaObject.simulcast = {
                dir1: "recv",
                list1: offerMediaObject.simulcast.list1
              };
              this._mediaObject.rids = [];
              for (const rid of offerMediaObject.rids ?? []) {
                if (rid.direction !== "send") {
                  continue;
                }
                this._mediaObject.rids.push({
                  id: rid.id,
                  direction: "recv"
                });
              }
            } else if (offerMediaObject.simulcast_03) {
              this._mediaObject.simulcast_03 = {
                value: offerMediaObject.simulcast_03.value.replace(/send/g, "recv")
              };
              this._mediaObject.rids = [];
              for (const rid of offerMediaObject.rids ?? []) {
                if (rid.direction !== "send") {
                  continue;
                }
                this._mediaObject.rids.push({
                  id: rid.id,
                  direction: "recv"
                });
              }
            }
            this._mediaObject.rtcpMux = "rtcp-mux";
            this._mediaObject.rtcpRsize = "rtcp-rsize";
            break;
          }
          case "application": {
            if (typeof offerMediaObject.sctpPort === "number") {
              this._mediaObject.payloads = "webrtc-datachannel";
              this._mediaObject.sctpPort = sctpParameters.port;
              this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
            } else if (offerMediaObject.sctpmap) {
              this._mediaObject.payloads = String(sctpParameters.port);
              this._mediaObject.sctpmap = {
                app: "webrtc-datachannel",
                sctpmapNumber: sctpParameters.port,
                maxMessageSize: sctpParameters.maxMessageSize
              };
            }
            break;
          }
        }
      }
      setDtlsRole(role) {
        switch (role) {
          case "client": {
            this._mediaObject.setup = "active";
            break;
          }
          case "server": {
            this._mediaObject.setup = "passive";
            break;
          }
          case "auto": {
            this._mediaObject.setup = "actpass";
            break;
          }
        }
      }
      resume() {
        this._mediaObject.direction = "recvonly";
      }
      muxSimulcastStreams(encodings) {
        if (!this._mediaObject.simulcast?.list1) {
          return;
        }
        const layers = {};
        for (const encoding of encodings) {
          if (encoding.rid) {
            layers[encoding.rid] = encoding;
          }
        }
        const raw = this._mediaObject.simulcast.list1;
        const simulcastStreams = sdpTransform.parseSimulcastStreamList(raw);
        for (const simulcastStream of simulcastStreams) {
          for (const simulcastFormat of simulcastStream) {
            simulcastFormat.paused = !layers[simulcastFormat.scid]?.active;
          }
        }
        this._mediaObject.simulcast.list1 = simulcastStreams.map((simulcastFormats) => simulcastFormats.map((f2) => `${f2.paused ? "~" : ""}${f2.scid}`).join(",")).join(";");
      }
    };
    exports.AnswerMediaSection = AnswerMediaSection;
    var OfferMediaSection = class extends MediaSection {
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, mid, kind, offerRtpParameters, streamId, trackId }) {
        super({ iceParameters, iceCandidates, dtlsParameters });
        this._mediaObject.mid = String(mid);
        this._mediaObject.type = kind;
        if (!plainRtpParameters) {
          this._mediaObject.connection = { ip: "127.0.0.1", version: 4 };
          if (!sctpParameters) {
            this._mediaObject.protocol = "UDP/TLS/RTP/SAVPF";
          } else {
            this._mediaObject.protocol = "UDP/DTLS/SCTP";
          }
          this._mediaObject.port = 7;
        } else {
          this._mediaObject.connection = {
            ip: plainRtpParameters.ip,
            version: plainRtpParameters.ipVersion
          };
          this._mediaObject.protocol = "RTP/AVP";
          this._mediaObject.port = plainRtpParameters.port;
        }
        this._mediaObject.extmapAllowMixed = "extmap-allow-mixed";
        switch (kind) {
          case "audio":
          case "video": {
            this._mediaObject.direction = "sendonly";
            this._mediaObject.rtp = [];
            this._mediaObject.rtcpFb = [];
            this._mediaObject.fmtp = [];
            this._mediaObject.msid = [{ id: streamId, appdata: trackId }];
            for (const codec of offerRtpParameters.codecs) {
              const rtp = {
                payload: codec.payloadType,
                codec: getCodecName(codec),
                rate: codec.clockRate
              };
              if (codec.channels > 1) {
                rtp.encoding = codec.channels;
              }
              this._mediaObject.rtp.push(rtp);
              const fmtp = {
                payload: codec.payloadType,
                config: ""
              };
              for (const key of Object.keys(codec.parameters ?? {})) {
                if (fmtp.config) {
                  fmtp.config += ";";
                }
                fmtp.config += `${key}=${codec.parameters[key]}`;
              }
              if (fmtp.config) {
                this._mediaObject.fmtp.push(fmtp);
              }
              for (const fb of codec.rtcpFeedback) {
                this._mediaObject.rtcpFb.push({
                  payload: codec.payloadType,
                  type: fb.type,
                  subtype: fb.parameter
                });
              }
            }
            this._mediaObject.payloads = offerRtpParameters.codecs.map((codec) => codec.payloadType).join(" ");
            this._mediaObject.ext = [];
            for (const ext of offerRtpParameters.headerExtensions) {
              this._mediaObject.ext.push({
                uri: ext.uri,
                value: ext.id
              });
            }
            this._mediaObject.rtcpMux = "rtcp-mux";
            this._mediaObject.rtcpRsize = "rtcp-rsize";
            const encoding = offerRtpParameters.encodings[0];
            const ssrc = encoding.ssrc;
            const rtxSsrc = encoding.rtx?.ssrc;
            this._mediaObject.ssrcs = [];
            this._mediaObject.ssrcGroups = [];
            if (ssrc && offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                id: ssrc,
                attribute: "cname",
                value: offerRtpParameters.rtcp.cname
              });
            }
            if (rtxSsrc) {
              if (offerRtpParameters.rtcp.cname) {
                this._mediaObject.ssrcs.push({
                  id: rtxSsrc,
                  attribute: "cname",
                  value: offerRtpParameters.rtcp.cname
                });
              }
              if (ssrc) {
                this._mediaObject.ssrcGroups.push({
                  semantics: "FID",
                  ssrcs: `${ssrc} ${rtxSsrc}`
                });
              }
            }
            break;
          }
          case "application": {
            this._mediaObject.payloads = "webrtc-datachannel";
            this._mediaObject.sctpPort = sctpParameters.port;
            this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
            break;
          }
        }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setDtlsRole(role) {
        this._mediaObject.setup = "actpass";
      }
      resume() {
        this._mediaObject.direction = "sendonly";
      }
    };
    exports.OfferMediaSection = OfferMediaSection;
    function getCodecName(codec) {
      const MimeTypeRegex = new RegExp("^(audio|video)/(.+)", "i");
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch) {
        throw new TypeError("invalid codec.mimeType");
      }
      return mimeTypeMatch[2];
    }
  }
});

// node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js
var require_RemoteSdp = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RemoteSdp = void 0;
    var sdpTransform = require_lib3();
    var Logger_1 = require_Logger();
    var MediaSection_1 = require_MediaSection();
    var __1 = require_lib5();
    var DependencyDescriptorCodecs = ["av1", "h264"];
    var logger = new Logger_1.Logger("RemoteSdp");
    var RemoteSdp = class {
      // Remote ICE parameters.
      _iceParameters;
      // Remote ICE candidates.
      _iceCandidates;
      // Remote DTLS parameters.
      _dtlsParameters;
      // Remote SCTP parameters.
      _sctpParameters;
      // Parameters for plain RTP (no SRTP nor DTLS no BUNDLE).
      _plainRtpParameters;
      // MediaSection instances with same order as in the SDP.
      _mediaSections = [];
      // MediaSection indices indexed by MID.
      _midToIndex = /* @__PURE__ */ new Map();
      // First MID.
      _firstMid;
      // SDP object.
      _sdpObject;
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters }) {
        this._iceParameters = iceParameters;
        this._iceCandidates = iceCandidates;
        this._dtlsParameters = dtlsParameters;
        this._sctpParameters = sctpParameters;
        this._plainRtpParameters = plainRtpParameters;
        this._sdpObject = {
          version: 0,
          origin: {
            address: "0.0.0.0",
            ipVer: 4,
            netType: "IN",
            sessionId: "10000",
            sessionVersion: 0,
            username: `mediasoup-client-v${__1.version}`
          },
          name: "-",
          timing: { start: 0, stop: 0 },
          media: []
        };
        this._sdpObject.iceOptions = "ice2";
        if (iceParameters?.iceLite) {
          this._sdpObject.icelite = "ice-lite";
        }
        if (dtlsParameters) {
          this._sdpObject.msidSemantic = { semantic: "WMS", token: "*" };
          const numFingerprints = this._dtlsParameters.fingerprints.length;
          this._sdpObject.fingerprint = {
            type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
            hash: dtlsParameters.fingerprints[numFingerprints - 1].value
          };
          this._sdpObject.groups = [{ type: "BUNDLE", mids: "" }];
        }
        if (plainRtpParameters) {
          this._sdpObject.origin.address = plainRtpParameters.ip;
          this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
        }
      }
      updateIceParameters(iceParameters) {
        logger.debug("updateIceParameters() [iceParameters:%o]", iceParameters);
        this._iceParameters = iceParameters;
        this._sdpObject.icelite = iceParameters.iceLite ? "ice-lite" : void 0;
        for (const mediaSection of this._mediaSections) {
          mediaSection.setIceParameters(iceParameters);
        }
      }
      updateDtlsRole(role) {
        logger.debug("updateDtlsRole() [role:%s]", role);
        this._dtlsParameters.role = role;
        for (const mediaSection of this._mediaSections) {
          mediaSection.setDtlsRole(role);
        }
      }
      /**
       * Set session level a=extmap-allow-mixed attibute.
       */
      setSessionExtmapAllowMixed() {
        logger.debug("setSessionExtmapAllowMixed()");
        this._sdpObject.extmapAllowMixed = "extmap-allow-mixed";
      }
      getNextMediaSectionIdx() {
        for (let idx = 0; idx < this._mediaSections.length; ++idx) {
          const mediaSection = this._mediaSections[idx];
          if (mediaSection.closed) {
            return { idx, reuseMid: mediaSection.mid };
          }
        }
        return { idx: this._mediaSections.length };
      }
      send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          plainRtpParameters: this._plainRtpParameters,
          offerMediaObject,
          offerRtpParameters,
          answerRtpParameters,
          codecOptions
        });
        const mediaObject = mediaSection.getObject();
        const ddCodec = mediaObject.rtp.find((rtp) => DependencyDescriptorCodecs.includes(rtp.codec.toLowerCase()));
        if (!ddCodec) {
          mediaObject.ext = mediaObject.ext?.filter((extmap) => extmap.uri !== "https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension");
        }
        if (reuseMid) {
          this.replaceMediaSection(mediaSection, reuseMid);
        } else if (!this._midToIndex.has(mediaSection.mid)) {
          this.addMediaSection(mediaSection);
        } else {
          this.replaceMediaSection(mediaSection);
        }
      }
      receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
        this.setSessionExtmapAllowMixed();
        const mediaSection = new MediaSection_1.OfferMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          plainRtpParameters: this._plainRtpParameters,
          mid,
          kind,
          offerRtpParameters,
          streamId,
          trackId
        });
        const oldMediaSection = this._mediaSections.find((m2) => m2.closed);
        if (oldMediaSection) {
          this.replaceMediaSection(mediaSection, oldMediaSection.mid);
        } else {
          this.addMediaSection(mediaSection);
        }
      }
      pauseMediaSection(mid) {
        const mediaSection = this.findMediaSection(mid);
        mediaSection.pause();
      }
      resumeSendingMediaSection(mid) {
        const mediaSection = this.findMediaSection(mid);
        mediaSection.resume();
      }
      resumeReceivingMediaSection(mid) {
        const mediaSection = this.findMediaSection(mid);
        mediaSection.resume();
      }
      disableMediaSection(mid) {
        const mediaSection = this.findMediaSection(mid);
        mediaSection.disable();
      }
      /**
       * Closes media section. Returns true if the given MID corresponds to a m
       * section that has been indeed closed. False otherwise.
       *
       * NOTE: Closing the first m section is a pain since it invalidates the bundled
       * transport, so instead closing it we just disable it.
       */
      closeMediaSection(mid) {
        const mediaSection = this.findMediaSection(mid);
        if (mid === this._firstMid) {
          logger.debug("closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]", mid);
          this.disableMediaSection(mid);
          return false;
        }
        mediaSection.close();
        this.regenerateBundleMids();
        return true;
      }
      muxMediaSectionSimulcast(mid, encodings) {
        const mediaSection = this.findMediaSection(mid);
        mediaSection.muxSimulcastStreams(encodings);
        this.replaceMediaSection(mediaSection);
      }
      sendSctpAssociation({ offerMediaObject }) {
        const mediaSection = new MediaSection_1.AnswerMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          sctpParameters: this._sctpParameters,
          plainRtpParameters: this._plainRtpParameters,
          offerMediaObject
        });
        this.addMediaSection(mediaSection);
      }
      receiveSctpAssociation() {
        const mediaSection = new MediaSection_1.OfferMediaSection({
          iceParameters: this._iceParameters,
          iceCandidates: this._iceCandidates,
          dtlsParameters: this._dtlsParameters,
          sctpParameters: this._sctpParameters,
          plainRtpParameters: this._plainRtpParameters,
          mid: "datachannel",
          kind: "application"
        });
        this.addMediaSection(mediaSection);
      }
      getSdp() {
        this._sdpObject.origin.sessionVersion++;
        return sdpTransform.write(this._sdpObject);
      }
      addMediaSection(newMediaSection) {
        if (!this._firstMid) {
          this._firstMid = newMediaSection.mid;
        }
        this._mediaSections.push(newMediaSection);
        this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
        this._sdpObject.media.push(newMediaSection.getObject());
        this.regenerateBundleMids();
      }
      replaceMediaSection(newMediaSection, reuseMid) {
        if (typeof reuseMid === "string") {
          const idx = this._midToIndex.get(reuseMid);
          if (idx === void 0) {
            throw new Error(`no media section found for reuseMid '${reuseMid}'`);
          }
          const oldMediaSection = this._mediaSections[idx];
          this._mediaSections[idx] = newMediaSection;
          this._midToIndex.delete(oldMediaSection.mid);
          this._midToIndex.set(newMediaSection.mid, idx);
          this._sdpObject.media[idx] = newMediaSection.getObject();
          this.regenerateBundleMids();
        } else {
          const idx = this._midToIndex.get(newMediaSection.mid);
          if (idx === void 0) {
            throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
          }
          this._mediaSections[idx] = newMediaSection;
          this._sdpObject.media[idx] = newMediaSection.getObject();
        }
      }
      findMediaSection(mid) {
        const idx = this._midToIndex.get(mid);
        if (idx === void 0) {
          throw new Error(`no media section found with mid '${mid}'`);
        }
        return this._mediaSections[idx];
      }
      regenerateBundleMids() {
        if (!this._dtlsParameters) {
          return;
        }
        this._sdpObject.groups[0].mids = this._mediaSections.filter((mediaSection) => !mediaSection.closed).map((mediaSection) => mediaSection.mid).join(" ");
      }
    };
    exports.RemoteSdp = RemoteSdp;
  }
});

// node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js
var require_commonUtils = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extractRtpCapabilities = extractRtpCapabilities;
    exports.extractDtlsParameters = extractDtlsParameters;
    exports.getCname = getCname;
    exports.applyCodecParameters = applyCodecParameters;
    exports.addHeaderExtension = addHeaderExtension;
    var sdpTransform = require_lib3();
    function extractRtpCapabilities({ sdpObject }) {
      const codecsMap = /* @__PURE__ */ new Map();
      const headerExtensionMap = /* @__PURE__ */ new Map();
      for (const m2 of sdpObject.media) {
        const kind = m2.type;
        switch (kind) {
          case "audio":
          case "video": {
            break;
          }
          default: {
            continue;
          }
        }
        for (const rtp of m2.rtp) {
          const codec = {
            kind,
            mimeType: `${kind}/${rtp.codec}`,
            preferredPayloadType: rtp.payload,
            clockRate: rtp.rate,
            channels: rtp.encoding,
            parameters: {},
            rtcpFeedback: []
          };
          codecsMap.set(codec.preferredPayloadType, codec);
        }
        for (const fmtp of m2.fmtp ?? []) {
          const parameters = sdpTransform.parseParams(fmtp.config);
          const codec = codecsMap.get(fmtp.payload);
          if (!codec) {
            continue;
          }
          if (parameters?.hasOwnProperty("profile-level-id")) {
            parameters["profile-level-id"] = String(parameters["profile-level-id"]);
          }
          codec.parameters = parameters;
        }
        for (const fb of m2.rtcpFb ?? []) {
          const feedback = {
            type: fb.type,
            parameter: fb.subtype
          };
          if (!feedback.parameter) {
            delete feedback.parameter;
          }
          if (fb.payload !== "*") {
            const codec = codecsMap.get(Number(fb.payload));
            if (!codec) {
              continue;
            }
            codec.rtcpFeedback.push(feedback);
          } else {
            for (const codec of codecsMap.values()) {
              if (codec.kind === kind && !/.+\/rtx$/i.test(codec.mimeType)) {
                codec.rtcpFeedback.push(feedback);
              }
            }
          }
        }
        for (const ext of m2.ext ?? []) {
          if (ext["encrypt-uri"]) {
            continue;
          }
          const headerExtension = {
            kind,
            uri: ext.uri,
            preferredId: ext.value
          };
          headerExtensionMap.set(headerExtension.preferredId, headerExtension);
        }
      }
      const rtpCapabilities = {
        codecs: Array.from(codecsMap.values()),
        headerExtensions: Array.from(headerExtensionMap.values())
      };
      return rtpCapabilities;
    }
    function extractDtlsParameters({ sdpObject }) {
      let setup = sdpObject.setup;
      let fingerprint = sdpObject.fingerprint;
      if (!setup || !fingerprint) {
        const mediaObject = (sdpObject.media ?? []).find((m2) => m2.port !== 0);
        if (mediaObject) {
          setup = setup ?? mediaObject.setup;
          fingerprint = fingerprint ?? mediaObject.fingerprint;
        }
      }
      if (!setup) {
        throw new Error("no a=setup found at SDP session or media level");
      } else if (!fingerprint) {
        throw new Error("no a=fingerprint found at SDP session or media level");
      }
      let role;
      switch (setup) {
        case "active": {
          role = "client";
          break;
        }
        case "passive": {
          role = "server";
          break;
        }
        case "actpass": {
          role = "auto";
          break;
        }
      }
      const dtlsParameters = {
        role,
        fingerprints: [
          {
            algorithm: fingerprint.type,
            value: fingerprint.hash
          }
        ]
      };
      return dtlsParameters;
    }
    function getCname({ offerMediaObject }) {
      const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
      if (!ssrcCnameLine) {
        return "";
      }
      return ssrcCnameLine.value;
    }
    function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
      for (const codec of offerRtpParameters.codecs) {
        const mimeType = codec.mimeType.toLowerCase();
        if (mimeType !== "audio/opus") {
          continue;
        }
        const rtp = (answerMediaObject.rtp ?? []).find((r2) => r2.payload === codec.payloadType);
        if (!rtp) {
          continue;
        }
        answerMediaObject.fmtp = answerMediaObject.fmtp ?? [];
        let fmtp = answerMediaObject.fmtp.find((f2) => f2.payload === codec.payloadType);
        if (!fmtp) {
          fmtp = { payload: codec.payloadType, config: "" };
          answerMediaObject.fmtp.push(fmtp);
        }
        const parameters = sdpTransform.parseParams(fmtp.config);
        switch (mimeType) {
          case "audio/opus": {
            const spropStereo = codec.parameters?.["sprop-stereo"];
            if (spropStereo !== void 0) {
              parameters["stereo"] = Number(spropStereo) ? 1 : 0;
            }
            break;
          }
        }
        fmtp.config = "";
        for (const key of Object.keys(parameters)) {
          if (fmtp.config) {
            fmtp.config += ";";
          }
          fmtp.config += `${key}=${parameters[key]}`;
        }
      }
    }
    function addHeaderExtension({ offerMediaObject, headerExtensionUri, headerExtensionId }) {
      if (!offerMediaObject.ext) {
        offerMediaObject.ext = [];
      }
      offerMediaObject.ext.push({
        uri: headerExtensionUri,
        value: headerExtensionId
      });
    }
  }
});

// node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js
var require_unifiedPlanUtils = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRtpEncodings = getRtpEncodings;
    exports.addLegacySimulcast = addLegacySimulcast;
    function getRtpEncodings({ offerMediaObject, codecs }) {
      const ssrcs = /* @__PURE__ */ new Set();
      for (const line of offerMediaObject.ssrcs ?? []) {
        const ssrc = line.id;
        if (ssrc) {
          ssrcs.add(ssrc);
        }
      }
      if (ssrcs.size === 0) {
        throw new Error("no a=ssrc lines found");
      }
      const ssrcToRtxSsrc = /* @__PURE__ */ new Map();
      for (const line of offerMediaObject.ssrcGroups ?? []) {
        if (line.semantics !== "FID") {
          continue;
        }
        const ssrcsStr = line.ssrcs.split(/\s+/);
        const ssrc = Number(ssrcsStr[0]);
        const rtxSsrc = Number(ssrcsStr[1]);
        if (ssrcs.has(ssrc)) {
          ssrcs.delete(ssrc);
          ssrcs.delete(rtxSsrc);
          ssrcToRtxSsrc.set(ssrc, rtxSsrc);
        }
      }
      for (const ssrc of ssrcs) {
        ssrcToRtxSsrc.set(ssrc, void 0);
      }
      const encodings = [];
      for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
        const encoding = { ssrc };
        if (rtxSsrc && codecs.length > 1) {
          encoding.rtx = { ssrc: rtxSsrc };
        }
        encodings.push(encoding);
      }
      return encodings;
    }
    function addLegacySimulcast({ offerMediaObject, numStreams }) {
      if (numStreams <= 1) {
        throw new TypeError("numStreams must be greater than 1");
      }
      const ssrcMsidLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "msid");
      if (!ssrcMsidLine) {
        throw new Error("a=ssrc line with msid information not found");
      }
      const [streamId, trackId] = ssrcMsidLine.value.split(" ");
      const firstSsrc = Number(ssrcMsidLine.id);
      let firstRtxSsrc;
      (offerMediaObject.ssrcGroups ?? []).some((line) => {
        if (line.semantics !== "FID") {
          return false;
        }
        const ssrcs2 = line.ssrcs.split(/\s+/);
        if (Number(ssrcs2[0]) === firstSsrc) {
          firstRtxSsrc = Number(ssrcs2[1]);
          return true;
        } else {
          return false;
        }
      });
      const ssrcCnameLine = (offerMediaObject.ssrcs ?? []).find((line) => line.attribute === "cname");
      if (!ssrcCnameLine) {
        throw new Error("a=ssrc line with cname information not found");
      }
      const cname = ssrcCnameLine.value;
      const ssrcs = [];
      const rtxSsrcs = [];
      for (let i2 = 0; i2 < numStreams; ++i2) {
        ssrcs.push(firstSsrc + i2);
        if (firstRtxSsrc) {
          rtxSsrcs.push(firstRtxSsrc + i2);
        }
      }
      offerMediaObject.ssrcGroups = [];
      offerMediaObject.ssrcs = [];
      offerMediaObject.ssrcGroups.push({
        semantics: "SIM",
        ssrcs: ssrcs.join(" ")
      });
      for (const ssrc of ssrcs) {
        offerMediaObject.ssrcs.push({
          id: ssrc,
          attribute: "cname",
          value: cname
        });
        offerMediaObject.ssrcs.push({
          id: ssrc,
          attribute: "msid",
          value: `${streamId} ${trackId}`
        });
      }
      for (let i2 = 0; i2 < rtxSsrcs.length; ++i2) {
        const ssrc = ssrcs[i2];
        const rtxSsrc = rtxSsrcs[i2];
        offerMediaObject.ssrcs.push({
          id: rtxSsrc,
          attribute: "cname",
          value: cname
        });
        offerMediaObject.ssrcs.push({
          id: rtxSsrc,
          attribute: "msid",
          value: `${streamId} ${trackId}`
        });
        offerMediaObject.ssrcGroups.push({
          semantics: "FID",
          ssrcs: `${ssrc} ${rtxSsrc}`
        });
      }
    }
  }
});

// node_modules/mediasoup-client/lib/handlers/ortc/utils.js
var require_utils2 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/ortc/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.addNackSupportForOpus = addNackSupportForOpus;
    exports.addHeaderExtensionSupport = addHeaderExtensionSupport;
    exports.getMsidStreamIdAndTrackId = getMsidStreamIdAndTrackId;
    function addNackSupportForOpus(rtpCapabilities) {
      for (const codec of rtpCapabilities.codecs ?? []) {
        if ((codec.mimeType.toLowerCase() === "audio/opus" || codec.mimeType.toLowerCase() === "audio/multiopus") && !codec.rtcpFeedback?.some((fb) => fb.type === "nack" && !fb.parameter)) {
          if (!codec.rtcpFeedback) {
            codec.rtcpFeedback = [];
          }
          codec.rtcpFeedback.push({ type: "nack" });
        }
      }
    }
    function addHeaderExtensionSupport(rtpCapabilities, headerExtension) {
      let preferredId;
      const existingHeaderExtension = rtpCapabilities.headerExtensions?.find((exten) => exten.uri === headerExtension.uri);
      if (existingHeaderExtension) {
        if (existingHeaderExtension.kind === headerExtension.kind) {
          return;
        } else {
          preferredId = existingHeaderExtension.preferredId;
        }
      }
      if (!rtpCapabilities.headerExtensions) {
        rtpCapabilities.headerExtensions = [];
      }
      if (preferredId === void 0) {
        preferredId = 1;
        const setPreferredIds = new Set(rtpCapabilities.headerExtensions.map((exten) => exten.preferredId));
        while (setPreferredIds.has(preferredId)) {
          ++preferredId;
        }
      }
      const newHeaderExtension = {
        kind: headerExtension.kind,
        uri: headerExtension.uri,
        preferredId,
        preferredEncrypt: false,
        direction: headerExtension.direction
      };
      rtpCapabilities.headerExtensions.push(newHeaderExtension);
    }
    function getMsidStreamIdAndTrackId(msid) {
      if (!msid || typeof msid !== "string") {
        return { msidStreamId: void 0, msidTrackId: void 0 };
      }
      const [msidStreamId, msidTrackId] = msid.trim().split(/\s+/);
      if (!msidStreamId) {
        return { msidStreamId: void 0, msidTrackId: void 0 };
      }
      return { msidStreamId, msidTrackId };
    }
  }
});

// node_modules/mediasoup-client/lib/handlers/Chrome111.js
var require_Chrome111 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/Chrome111.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chrome111 = void 0;
    var sdpTransform = require_lib3();
    var enhancedEvents_1 = require_enhancedEvents();
    var Logger_1 = require_Logger();
    var ortc = require_ortc();
    var errors_1 = require_errors();
    var scalabilityModes_1 = require_scalabilityModes();
    var RemoteSdp_1 = require_RemoteSdp();
    var sdpCommonUtils = require_commonUtils();
    var sdpUnifiedPlanUtils = require_unifiedPlanUtils();
    var ortcUtils = require_utils2();
    var logger = new Logger_1.Logger("Chrome111");
    var NAME = "Chrome111";
    var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
    var Chrome111 = class _Chrome111 extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Handler direction.
      _direction;
      // Remote SDP handler.
      _remoteSdp;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      _forcedLocalDtlsRole;
      // RTCPeerConnection instance.
      _pc;
      // Map of RTCTransceivers indexed by MID.
      _mapMidTransceiver = /* @__PURE__ */ new Map();
      // Default local stream for sending if no `streamId` is given in send().
      _sendStream = new MediaStream();
      // Whether a DataChannel m=application section has been created.
      _hasDataChannelMediaSection = false;
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      _nextSendSctpStreamId = 0;
      // Got transport local and remote parameters.
      _transportReady = false;
      /**
       * Creates a factory function.
       */
      static createFactory() {
        return {
          name: NAME,
          factory: (options) => new _Chrome111(options),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            let pc2 = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require"
            });
            try {
              pc2.addTransceiver("audio");
              pc2.addTransceiver("video", {
                sendEncodings: [{ scalabilityMode: "L3T3" }]
              });
              const offer = await pc2.createOffer();
              try {
                pc2.close();
              } catch (error2) {
              }
              pc2 = void 0;
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = _Chrome111.getLocalRtpCapabilities(sdpObject);
              return nativeRtpCapabilities;
            } catch (error2) {
              try {
                pc2?.close();
              } catch (error22) {
              }
              pc2 = void 0;
              throw error2;
            }
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS
            };
          }
        };
      }
      static getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions = []) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
          sdpObject: localSdpObject
        });
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        for (const headerExtension of extraHeaderExtensions) {
          ortcUtils.addHeaderExtensionSupport(nativeRtpCapabilities, headerExtension);
        }
        return nativeRtpCapabilities;
      }
      constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
        super();
        logger.debug("constructor()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== "auto") {
          this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        }
        this._pc = new RTCPeerConnection({
          iceServers: iceServers ?? [],
          iceTransportPolicy: iceTransportPolicy ?? "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          ...additionalSettings
        });
        this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
        if (this._pc.connectionState) {
          this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
        } else {
          logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
          this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        }
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        try {
          this._pc.close();
        } catch (error2) {
        }
        this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
        this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
        this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        this.emit("@close");
        super.close();
      }
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
          return;
        }
        if (this._direction === "send") {
          const offer = await this._pc.createOffer({ iceRestart: true });
          logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        } else {
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
      }
      async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
      }
      async send({ track, streamId, encodings, codecOptions, headerExtensionOptions, codec, onRtpSender }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s, streamId:%s]", track.kind, track.id, streamId);
        if (encodings && encodings.length > 1) {
          let maxTemporalLayers = 1;
          for (const encoding of encodings) {
            const temporalLayers = encoding.scalabilityMode ? (0, scalabilityModes_1.parse)(encoding.scalabilityMode).temporalLayers : 3;
            if (temporalLayers > maxTemporalLayers) {
              maxTemporalLayers = temporalLayers;
            }
          }
          encodings.forEach((encoding, idx) => {
            encoding.rid = `r${idx}`;
            encoding.scalabilityMode = `L1T${maxTemporalLayers}`;
          });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
          direction: "sendonly",
          streams: [this._sendStream],
          sendEncodings: encodings
        });
        if (onRtpSender) {
          onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
          this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const extraHeaderExtensions = [];
        extraHeaderExtensions.push({
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
          kind: track.kind,
          direction: "sendonly"
        });
        const nativeRtpCapabilities = _Chrome111.getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        if (headerExtensionOptions?.absCaptureTime) {
          const offerMediaObject2 = localSdpObject.media[mediaSectionIdx.idx];
          sdpCommonUtils.addHeaderExtension({
            offerMediaObject: offerMediaObject2,
            headerExtensionUri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
            headerExtensionId: sendingRemoteRtpParameters.headerExtensions.find((headerExtension) => headerExtension.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time").id
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const localId = transceiver.mid;
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
          offerMediaObject
        });
        sendingRtpParameters.msid = `${streamId ?? this._sendStream.id} ${track.id}`;
        if (!encodings) {
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
        } else if (encodings.length === 1) {
          const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
          Object.assign(newEncodings[0], encodings[0]);
          sendingRtpParameters.encodings = newEncodings;
        } else {
          sendingRtpParameters.encodings = encodings;
        }
        this._remoteSdp.send({
          offerMediaObject,
          reuseMid: mediaSectionIdx.reuseMid,
          offerRtpParameters: sendingRtpParameters,
          answerRtpParameters: sendingRemoteRtpParameters,
          codecOptions
        });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.set(localId, transceiver);
        return {
          localId,
          rtpParameters: sendingRtpParameters,
          rtpSender: transceiver.sender
        };
      }
      async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        if (this._closed) {
          return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
          try {
            transceiver.stop();
          } catch (error2) {
          }
        }
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
      }
      async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          if (idx <= spatialLayer) {
            encoding.active = true;
          } else {
            encoding.active = false;
          }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
          negotiated: true,
          id: this._nextSendSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        if (!this._hasDataChannelMediaSection) {
          const offer = await this._pc.createOffer();
          const localSdpObject = sdpTransform.parse(offer.sdp);
          const offerMediaObject = localSdpObject.media.find((m2) => m2.type === "application");
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          this._remoteSdp.sendSctpAssociation({ offerMediaObject });
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
          streamId: options.id,
          ordered: options.ordered,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = /* @__PURE__ */ new Map();
        for (const options of optionsList) {
          const { trackId, kind, rtpParameters, streamId } = options;
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
          mapLocalId.set(trackId, localId);
          const { msidStreamId } = ortcUtils.getMsidStreamIdAndTrackId(rtpParameters.msid);
          this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: streamId ?? msidStreamId ?? rtpParameters.rtcp?.cname ?? "-",
            trackId
          });
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
          const { trackId, onRtpReceiver } = options;
          if (onRtpReceiver) {
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
            if (!transceiver) {
              throw new Error("transceiver not found");
            }
            onRtpReceiver(transceiver.receiver);
          }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
          const { trackId, rtpParameters } = options;
          const localId = mapLocalId.get(trackId);
          const answerMediaObject = localSdpObject.media.find((m2) => String(m2.mid) === localId);
          sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
          });
        }
        answer = {
          type: "answer",
          sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
          const { trackId } = options;
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
          if (!transceiver) {
            throw new Error("new RTCRtpTransceiver not found");
          } else {
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
        }
        return results;
      }
      async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
          this._mapMidTransceiver.delete(localId);
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("pauseReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("resumeReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "recvonly";
          this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
          negotiated: true,
          id: streamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        if (!this._hasDataChannelMediaSection) {
          this._remoteSdp.receiveSctpAssociation();
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          if (!this._transportReady) {
            const localSdpObject = sdpTransform.parse(answer.sdp);
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
      }
      async setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject) {
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
          sdpObject: localSdpObject
        });
        dtlsParameters.role = localDtlsRole;
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        await new Promise((resolve, reject) => {
          this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
      }
      onIceGatheringStateChange = () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      };
      onIceCandidateError = (event) => {
        this.emit("@icecandidateerror", event);
      };
      onConnectionStateChange = () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      };
      onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      };
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
      assertSendDirection() {
        if (this._direction !== "send") {
          throw new Error('method can just be called for handlers with "send" direction');
        }
      }
      assertRecvDirection() {
        if (this._direction !== "recv") {
          throw new Error('method can just be called for handlers with "recv" direction');
        }
      }
    };
    exports.Chrome111 = Chrome111;
  }
});

// node_modules/mediasoup-client/lib/handlers/Chrome74.js
var require_Chrome74 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/Chrome74.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Chrome74 = void 0;
    var sdpTransform = require_lib3();
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var ortc = require_ortc();
    var errors_1 = require_errors();
    var scalabilityModes_1 = require_scalabilityModes();
    var RemoteSdp_1 = require_RemoteSdp();
    var sdpCommonUtils = require_commonUtils();
    var sdpUnifiedPlanUtils = require_unifiedPlanUtils();
    var ortcUtils = require_utils2();
    var logger = new Logger_1.Logger("Chrome74");
    var NAME = "Chrome74";
    var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
    var Chrome74 = class _Chrome74 extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Handler direction.
      _direction;
      // Remote SDP handler.
      _remoteSdp;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      _forcedLocalDtlsRole;
      // RTCPeerConnection instance.
      _pc;
      // Map of RTCTransceivers indexed by MID.
      _mapMidTransceiver = /* @__PURE__ */ new Map();
      // Default local stream for sending if no `streamId` is given in send().
      _sendStream = new MediaStream();
      // Whether a DataChannel m=application section has been created.
      _hasDataChannelMediaSection = false;
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      _nextSendSctpStreamId = 0;
      // Got transport local and remote parameters.
      _transportReady = false;
      /**
       * Creates a factory function.
       */
      static createFactory() {
        return {
          name: NAME,
          factory: (options) => new _Chrome74(options),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            let pc2 = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require"
            });
            try {
              pc2.addTransceiver("audio");
              pc2.addTransceiver("video");
              const offer = await pc2.createOffer();
              try {
                pc2.close();
              } catch (error2) {
              }
              pc2 = void 0;
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = _Chrome74.getLocalRtpCapabilities(sdpObject);
              return nativeRtpCapabilities;
            } catch (error2) {
              try {
                pc2?.close();
              } catch (error22) {
              }
              pc2 = void 0;
              throw error2;
            }
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS
            };
          }
        };
      }
      static getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions = []) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
          sdpObject: localSdpObject
        });
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        for (const headerExtension of extraHeaderExtensions) {
          ortcUtils.addHeaderExtensionSupport(nativeRtpCapabilities, headerExtension);
        }
        return nativeRtpCapabilities;
      }
      constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
        super();
        logger.debug("constructor()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== "auto") {
          this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        }
        this._pc = new RTCPeerConnection({
          iceServers: iceServers ?? [],
          iceTransportPolicy: iceTransportPolicy ?? "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          ...additionalSettings
        });
        this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
        if (this._pc.connectionState) {
          this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
        } else {
          logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
          this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        }
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        try {
          this._pc.close();
        } catch (error2) {
        }
        this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
        this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
        this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        this.emit("@close");
        super.close();
      }
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
          return;
        }
        if (this._direction === "send") {
          const offer = await this._pc.createOffer({ iceRestart: true });
          logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        } else {
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
      }
      async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
      }
      async send({ track, streamId, encodings, codecOptions, headerExtensionOptions, codec }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s, streamId:%s]", track.kind, track.id, streamId);
        if (encodings && encodings.length > 1) {
          encodings.forEach((encoding, idx) => {
            encoding.rid = `r${idx}`;
          });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
          direction: "sendonly",
          streams: [this._sendStream],
          sendEncodings: encodings
        });
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
          this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const extraHeaderExtensions = [];
        extraHeaderExtensions.push({
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
          kind: track.kind,
          direction: "sendonly"
        });
        const nativeRtpCapabilities = _Chrome74.getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        let offerMediaObject;
        if (encodings?.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
          logger.debug("send() | enabling legacy simulcast for VP9 SVC");
          hackVp9Svc = true;
          localSdpObject = sdpTransform.parse(offer.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpUnifiedPlanUtils.addLegacySimulcast({
            offerMediaObject,
            numStreams: layers.spatialLayers
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        if (headerExtensionOptions?.absCaptureTime) {
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpCommonUtils.addHeaderExtension({
            offerMediaObject,
            headerExtensionUri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
            headerExtensionId: sendingRemoteRtpParameters.headerExtensions.find((headerExtension) => headerExtension.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time").id
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        await this._pc.setLocalDescription(offer);
        const localId = transceiver.mid;
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
          offerMediaObject
        });
        sendingRtpParameters.msid = `${streamId ?? this._sendStream.id} ${track.id}`;
        if (!encodings) {
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
        } else if (encodings.length === 1) {
          let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
          Object.assign(newEncodings[0], encodings[0]);
          if (hackVp9Svc) {
            newEncodings = [newEncodings[0]];
          }
          sendingRtpParameters.encodings = newEncodings;
        } else {
          sendingRtpParameters.encodings = encodings;
        }
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
          for (const encoding of sendingRtpParameters.encodings) {
            if (encoding.scalabilityMode) {
              encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            } else {
              encoding.scalabilityMode = "L1T3";
            }
          }
        }
        this._remoteSdp.send({
          offerMediaObject,
          reuseMid: mediaSectionIdx.reuseMid,
          offerRtpParameters: sendingRtpParameters,
          answerRtpParameters: sendingRemoteRtpParameters,
          codecOptions
        });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.set(localId, transceiver);
        return {
          localId,
          rtpParameters: sendingRtpParameters,
          rtpSender: transceiver.sender
        };
      }
      async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        if (this._closed) {
          return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
          try {
            transceiver.stop();
          } catch (error2) {
          }
        }
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
      }
      async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          if (idx <= spatialLayer) {
            encoding.active = true;
          } else {
            encoding.active = false;
          }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
          negotiated: true,
          id: this._nextSendSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        if (!this._hasDataChannelMediaSection) {
          const offer = await this._pc.createOffer();
          const localSdpObject = sdpTransform.parse(offer.sdp);
          const offerMediaObject = localSdpObject.media.find((m2) => m2.type === "application");
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          this._remoteSdp.sendSctpAssociation({ offerMediaObject });
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
          streamId: options.id,
          ordered: options.ordered,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = /* @__PURE__ */ new Map();
        for (const options of optionsList) {
          const { trackId, kind, rtpParameters, streamId } = options;
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
          mapLocalId.set(trackId, localId);
          const { msidStreamId } = ortcUtils.getMsidStreamIdAndTrackId(rtpParameters.msid);
          this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: streamId ?? msidStreamId ?? rtpParameters.rtcp?.cname ?? "-",
            trackId
          });
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
          const { trackId, rtpParameters } = options;
          const localId = mapLocalId.get(trackId);
          const answerMediaObject = localSdpObject.media.find((m2) => String(m2.mid) === localId);
          sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
          });
        }
        answer = {
          type: "answer",
          sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
          const { trackId } = options;
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
          if (!transceiver) {
            throw new Error("new RTCRtpTransceiver not found");
          } else {
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
        }
        return results;
      }
      async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
          this._mapMidTransceiver.delete(localId);
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("pauseReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("resumeReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "recvonly";
          this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
          negotiated: true,
          id: streamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        if (!this._hasDataChannelMediaSection) {
          this._remoteSdp.receiveSctpAssociation();
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          if (!this._transportReady) {
            const localSdpObject = sdpTransform.parse(answer.sdp);
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
      }
      async setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject) {
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
          sdpObject: localSdpObject
        });
        dtlsParameters.role = localDtlsRole;
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        await new Promise((resolve, reject) => {
          this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
      }
      onIceGatheringStateChange = () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      };
      onIceCandidateError = (event) => {
        this.emit("@icecandidateerror", event);
      };
      onConnectionStateChange = () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      };
      onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      };
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
      assertSendDirection() {
        if (this._direction !== "send") {
          throw new Error('method can just be called for handlers with "send" direction');
        }
      }
      assertRecvDirection() {
        if (this._direction !== "recv") {
          throw new Error('method can just be called for handlers with "recv" direction');
        }
      }
    };
    exports.Chrome74 = Chrome74;
  }
});

// node_modules/mediasoup-client/lib/handlers/Firefox120.js
var require_Firefox120 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/Firefox120.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Firefox120 = void 0;
    var sdpTransform = require_lib3();
    var enhancedEvents_1 = require_enhancedEvents();
    var Logger_1 = require_Logger();
    var errors_1 = require_errors();
    var ortc = require_ortc();
    var scalabilityModes_1 = require_scalabilityModes();
    var RemoteSdp_1 = require_RemoteSdp();
    var sdpCommonUtils = require_commonUtils();
    var sdpUnifiedPlanUtils = require_unifiedPlanUtils();
    var ortcUtils = require_utils2();
    var logger = new Logger_1.Logger("Firefox120");
    var NAME = "Firefox120";
    var SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
    var Firefox120 = class _Firefox120 extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Handler direction.
      _direction;
      // Remote SDP handler.
      _remoteSdp;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // RTCPeerConnection instance.
      _pc;
      // Map of RTCTransceivers indexed by MID.
      _mapMidTransceiver = /* @__PURE__ */ new Map();
      // Default local stream for sending if no `streamId` is given in send().
      _sendStream = new MediaStream();
      // Whether a DataChannel m=application section has been created.
      _hasDataChannelMediaSection = false;
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      _nextSendSctpStreamId = 0;
      // Got transport local and remote parameters.
      _transportReady = false;
      /**
       * Creates a factory function.
       */
      static createFactory() {
        return {
          name: NAME,
          factory: (options) => new _Firefox120(options),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            let pc2 = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require"
            });
            const canvas = document.createElement("canvas");
            canvas.getContext("2d");
            const fakeStream = canvas.captureStream();
            const fakeVideoTrack = fakeStream.getVideoTracks()[0];
            try {
              pc2.addTransceiver("audio", { direction: "sendrecv" });
              pc2.addTransceiver(fakeVideoTrack, {
                direction: "sendrecv",
                sendEncodings: [
                  { rid: "r0", maxBitrate: 1e5 },
                  { rid: "r1", maxBitrate: 5e5 }
                ]
              });
              const offer = await pc2.createOffer();
              try {
                canvas.remove();
              } catch (error2) {
              }
              try {
                fakeVideoTrack.stop();
              } catch (error2) {
              }
              try {
                pc2.close();
              } catch (error2) {
              }
              pc2 = void 0;
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = _Firefox120.getLocalRtpCapabilities(sdpObject);
              return nativeRtpCapabilities;
            } catch (error2) {
              try {
                canvas.remove();
              } catch (error22) {
              }
              try {
                fakeVideoTrack.stop();
              } catch (error22) {
              }
              try {
                pc2?.close();
              } catch (error22) {
              }
              pc2 = void 0;
              throw error2;
            }
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS
            };
          }
        };
      }
      static getLocalRtpCapabilities(localSdpObject) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
          sdpObject: localSdpObject
        });
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        return nativeRtpCapabilities;
      }
      constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
        super();
        logger.debug("constructor()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._pc = new RTCPeerConnection({
          iceServers: iceServers ?? [],
          iceTransportPolicy: iceTransportPolicy ?? "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          ...additionalSettings
        });
        this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
        if (this._pc.connectionState) {
          this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
        } else {
          logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
          this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        }
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        try {
          this._pc.close();
        } catch (error2) {
        }
        this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
        this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
        this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        this.emit("@close");
        super.close();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        throw new errors_1.UnsupportedError("not supported");
      }
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
          return;
        }
        if (this._direction === "send") {
          const offer = await this._pc.createOffer({ iceRestart: true });
          logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        } else {
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
      }
      async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
      }
      async send({ track, streamId, encodings, codecOptions, codec, onRtpSender }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s, streamId:%s]", track.kind, track.id, streamId);
        if (encodings && encodings.length > 1) {
          encodings.forEach((encoding, idx) => {
            encoding.rid = `r${idx}`;
          });
        }
        const transceiver = this._pc.addTransceiver(track, {
          direction: "sendonly",
          streams: [this._sendStream],
          sendEncodings: encodings
        });
        if (onRtpSender) {
          onRtpSender(transceiver.sender);
        }
        const offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
          this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const nativeRtpCapabilities = _Firefox120.getLocalRtpCapabilities(localSdpObject);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "client", localSdpObject });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const localId = transceiver.mid;
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
          offerMediaObject
        });
        sendingRtpParameters.msid = `${streamId ?? this._sendStream.id} ${track.id}`;
        if (!encodings) {
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
        } else if (encodings.length === 1) {
          const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
          Object.assign(newEncodings[0], encodings[0]);
          sendingRtpParameters.encodings = newEncodings;
        } else {
          sendingRtpParameters.encodings = encodings;
        }
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
          for (const encoding of sendingRtpParameters.encodings) {
            if (encoding.scalabilityMode) {
              encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            } else {
              encoding.scalabilityMode = "L1T3";
            }
          }
        }
        this._remoteSdp.send({
          offerMediaObject,
          offerRtpParameters: sendingRtpParameters,
          answerRtpParameters: sendingRemoteRtpParameters,
          codecOptions
        });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.set(localId, transceiver);
        return {
          localId,
          rtpParameters: sendingRtpParameters,
          rtpSender: transceiver.sender
        };
      }
      async stopSending(localId) {
        this.assertSendDirection();
        logger.debug("stopSending() [localId:%s]", localId);
        if (this._closed) {
          return;
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated transceiver not found");
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        this._remoteSdp.disableMediaSection(transceiver.mid);
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
      }
      async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "sendonly";
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated transceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          if (idx <= spatialLayer) {
            encoding.active = true;
          } else {
            encoding.active = false;
          }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
          negotiated: true,
          id: this._nextSendSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        if (!this._hasDataChannelMediaSection) {
          const offer = await this._pc.createOffer();
          const localSdpObject = sdpTransform.parse(offer.sdp);
          const offerMediaObject = localSdpObject.media.find((m2) => m2.type === "application");
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          this._remoteSdp.sendSctpAssociation({ offerMediaObject });
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
          streamId: options.id,
          ordered: options.ordered,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = /* @__PURE__ */ new Map();
        for (const options of optionsList) {
          const { trackId, kind, rtpParameters, streamId } = options;
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
          mapLocalId.set(trackId, localId);
          const { msidStreamId } = ortcUtils.getMsidStreamIdAndTrackId(rtpParameters.msid);
          this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: streamId ?? msidStreamId ?? rtpParameters.rtcp?.cname ?? "-",
            trackId
          });
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
          const { trackId, onRtpReceiver } = options;
          if (onRtpReceiver) {
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
            if (!transceiver) {
              throw new Error("transceiver not found");
            }
            onRtpReceiver(transceiver.receiver);
          }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
          const { trackId, rtpParameters } = options;
          const localId = mapLocalId.get(trackId);
          const answerMediaObject = localSdpObject.media.find((m2) => String(m2.mid) === localId);
          sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
          });
          answer = {
            type: "answer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "client", localSdpObject });
        }
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
          const { trackId } = options;
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
          if (!transceiver) {
            throw new Error("new RTCRtpTransceiver not found");
          }
          this._mapMidTransceiver.set(localId, transceiver);
          results.push({
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
          });
        }
        return results;
      }
      async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
          this._mapMidTransceiver.delete(localId);
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("pauseReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("resumeReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "recvonly";
          this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
          negotiated: true,
          id: streamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        if (!this._hasDataChannelMediaSection) {
          this._remoteSdp.receiveSctpAssociation();
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          if (!this._transportReady) {
            const localSdpObject = sdpTransform.parse(answer.sdp);
            await this.setupTransport({ localDtlsRole: "client", localSdpObject });
          }
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
      }
      async setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject) {
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
          sdpObject: localSdpObject
        });
        dtlsParameters.role = localDtlsRole;
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        await new Promise((resolve, reject) => {
          this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
      }
      onIceGatheringStateChange = () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      };
      onIceCandidateError = (event) => {
        this.emit("@icecandidateerror", event);
      };
      onConnectionStateChange = () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      };
      onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      };
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
      assertSendDirection() {
        if (this._direction !== "send") {
          throw new Error('method can just be called for handlers with "send" direction');
        }
      }
      assertRecvDirection() {
        if (this._direction !== "recv") {
          throw new Error('method can just be called for handlers with "recv" direction');
        }
      }
    };
    exports.Firefox120 = Firefox120;
  }
});

// node_modules/mediasoup-client/lib/handlers/Safari12.js
var require_Safari12 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/Safari12.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Safari12 = void 0;
    var sdpTransform = require_lib3();
    var enhancedEvents_1 = require_enhancedEvents();
    var Logger_1 = require_Logger();
    var ortc = require_ortc();
    var errors_1 = require_errors();
    var scalabilityModes_1 = require_scalabilityModes();
    var RemoteSdp_1 = require_RemoteSdp();
    var sdpCommonUtils = require_commonUtils();
    var sdpUnifiedPlanUtils = require_unifiedPlanUtils();
    var ortcUtils = require_utils2();
    var logger = new Logger_1.Logger("Safari12");
    var NAME = "Safari12";
    var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
    var Safari12 = class _Safari12 extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Handler direction.
      _direction;
      // Remote SDP handler.
      _remoteSdp;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      _forcedLocalDtlsRole;
      // RTCPeerConnection instance.
      _pc;
      // Map of RTCTransceivers indexed by MID.
      _mapMidTransceiver = /* @__PURE__ */ new Map();
      // Default local stream for sending if no `streamId` is given in send().
      _sendStream = new MediaStream();
      // Whether a DataChannel m=application section has been created.
      _hasDataChannelMediaSection = false;
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      _nextSendSctpStreamId = 0;
      // Got transport local and remote parameters.
      _transportReady = false;
      /**
       * Creates a factory function.
       */
      static createFactory() {
        return {
          name: NAME,
          factory: (options) => new _Safari12(options),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            let pc2 = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require"
            });
            try {
              pc2.addTransceiver("audio");
              pc2.addTransceiver("video");
              const offer = await pc2.createOffer();
              try {
                pc2.close();
              } catch (error2) {
              }
              pc2 = void 0;
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = _Safari12.getLocalRtpCapabilities(sdpObject);
              return nativeRtpCapabilities;
            } catch (error2) {
              try {
                pc2?.close();
              } catch (error22) {
              }
              pc2 = void 0;
              throw error2;
            }
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS
            };
          }
        };
      }
      static getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions = []) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
          sdpObject: localSdpObject
        });
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        for (const headerExtension of extraHeaderExtensions) {
          ortcUtils.addHeaderExtensionSupport(nativeRtpCapabilities, headerExtension);
        }
        return nativeRtpCapabilities;
      }
      constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
        super();
        logger.debug("constructor()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== "auto") {
          this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        }
        this._pc = new RTCPeerConnection({
          iceServers: iceServers ?? [],
          iceTransportPolicy: iceTransportPolicy ?? "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          ...additionalSettings
        });
        this._pc.addEventListener("icegatheringstatechange", () => {
          this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
        });
        this._pc.addEventListener("icecandidateerror", (event) => {
          this.emit("@icecandidateerror", event);
        });
        this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
        if (this._pc.connectionState) {
          this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
        } else {
          logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
          this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        }
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        try {
          this._pc.close();
        } catch (error2) {
        }
        this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
        this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
        this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        this.emit("@close");
        super.close();
      }
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
          return;
        }
        if (this._direction === "send") {
          const offer = await this._pc.createOffer({ iceRestart: true });
          logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        } else {
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
      }
      async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
      }
      async send({ track, streamId, encodings, codecOptions, headerExtensionOptions, codec, onRtpSender }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s, streamId:%s]", track.kind, track.id, streamId);
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
          direction: "sendonly",
          streams: [this._sendStream]
        });
        if (onRtpSender) {
          onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
          this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const extraHeaderExtensions = [];
        extraHeaderExtensions.push({
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
          kind: track.kind,
          direction: "sendonly"
        });
        const nativeRtpCapabilities = _Safari12.getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        let offerMediaObject;
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        if (encodings && encodings.length > 1) {
          logger.debug("send() | enabling legacy simulcast");
          localSdpObject = sdpTransform.parse(offer.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpUnifiedPlanUtils.addLegacySimulcast({
            offerMediaObject,
            numStreams: encodings.length
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        if (headerExtensionOptions?.absCaptureTime) {
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpCommonUtils.addHeaderExtension({
            offerMediaObject,
            headerExtensionUri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
            headerExtensionId: sendingRemoteRtpParameters.headerExtensions.find((headerExtension) => headerExtension.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time").id
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const localId = transceiver.mid;
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
          offerMediaObject
        });
        sendingRtpParameters.msid = `${streamId ?? this._sendStream.id} ${track.id}`;
        sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
          offerMediaObject,
          codecs: sendingRtpParameters.codecs
        });
        if (encodings) {
          for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
            if (encodings[idx]) {
              Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
            }
          }
        }
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
          for (const encoding of sendingRtpParameters.encodings) {
            if (encoding.scalabilityMode) {
              encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            } else {
              encoding.scalabilityMode = "L1T3";
            }
          }
        }
        this._remoteSdp.send({
          offerMediaObject,
          reuseMid: mediaSectionIdx.reuseMid,
          offerRtpParameters: sendingRtpParameters,
          answerRtpParameters: sendingRemoteRtpParameters,
          codecOptions
        });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.set(localId, transceiver);
        return {
          localId,
          rtpParameters: sendingRtpParameters,
          rtpSender: transceiver.sender
        };
      }
      async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
          return;
        }
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
          try {
            transceiver.stop();
          } catch (error2) {
          }
        }
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
      }
      async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "sendonly";
        this._remoteSdp.resumeSendingMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          if (idx <= spatialLayer) {
            encoding.active = true;
          } else {
            encoding.active = false;
          }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
          negotiated: true,
          id: this._nextSendSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        if (!this._hasDataChannelMediaSection) {
          const offer = await this._pc.createOffer();
          const localSdpObject = sdpTransform.parse(offer.sdp);
          const offerMediaObject = localSdpObject.media.find((m2) => m2.type === "application");
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          this._remoteSdp.sendSctpAssociation({ offerMediaObject });
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
          streamId: options.id,
          ordered: options.ordered,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = /* @__PURE__ */ new Map();
        for (const options of optionsList) {
          const { trackId, kind, rtpParameters, streamId } = options;
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
          mapLocalId.set(trackId, localId);
          const { msidStreamId } = ortcUtils.getMsidStreamIdAndTrackId(rtpParameters.msid);
          this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: streamId ?? msidStreamId ?? rtpParameters.rtcp?.cname ?? "-",
            trackId
          });
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
          const { trackId, onRtpReceiver } = options;
          if (onRtpReceiver) {
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
            if (!transceiver) {
              throw new Error("transceiver not found");
            }
            onRtpReceiver(transceiver.receiver);
          }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
          const { trackId, rtpParameters } = options;
          const localId = mapLocalId.get(trackId);
          const answerMediaObject = localSdpObject.media.find((m2) => String(m2.mid) === localId);
          sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
          });
        }
        answer = {
          type: "answer",
          sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
          const { trackId } = options;
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
          if (!transceiver) {
            throw new Error("new RTCRtpTransceiver not found");
          }
          this._mapMidTransceiver.set(localId, transceiver);
          results.push({
            localId,
            track: transceiver.receiver.track,
            rtpReceiver: transceiver.receiver
          });
        }
        return results;
      }
      async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
          this._mapMidTransceiver.delete(localId);
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("pauseReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("resumeReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "recvonly";
          this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
          negotiated: true,
          id: streamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        if (!this._hasDataChannelMediaSection) {
          this._remoteSdp.receiveSctpAssociation();
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          if (!this._transportReady) {
            const localSdpObject = sdpTransform.parse(answer.sdp);
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
      }
      async setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject) {
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
          sdpObject: localSdpObject
        });
        dtlsParameters.role = localDtlsRole;
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        await new Promise((resolve, reject) => {
          this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
      }
      onIceGatheringStateChange = () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      };
      onIceCandidateError = (event) => {
        this.emit("@icecandidateerror", event);
      };
      onConnectionStateChange = () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      };
      onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      };
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
      assertSendDirection() {
        if (this._direction !== "send") {
          throw new Error('method can just be called for handlers with "send" direction');
        }
      }
      assertRecvDirection() {
        if (this._direction !== "recv") {
          throw new Error('method can just be called for handlers with "recv" direction');
        }
      }
    };
    exports.Safari12 = Safari12;
  }
});

// node_modules/mediasoup-client/lib/handlers/ReactNative106.js
var require_ReactNative106 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/ReactNative106.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReactNative106 = void 0;
    var sdpTransform = require_lib3();
    var enhancedEvents_1 = require_enhancedEvents();
    var Logger_1 = require_Logger();
    var ortc = require_ortc();
    var errors_1 = require_errors();
    var scalabilityModes_1 = require_scalabilityModes();
    var RemoteSdp_1 = require_RemoteSdp();
    var sdpCommonUtils = require_commonUtils();
    var sdpUnifiedPlanUtils = require_unifiedPlanUtils();
    var ortcUtils = require_utils2();
    var logger = new Logger_1.Logger("ReactNative106");
    var NAME = "ReactNative106";
    var SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
    var ReactNative106 = class _ReactNative106 extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Handler direction.
      _direction;
      // Remote SDP handler.
      _remoteSdp;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // Initial server side DTLS role. If not 'auto', it will force the opposite
      // value in client side.
      _forcedLocalDtlsRole;
      // RTCPeerConnection instance.
      _pc;
      // Map of RTCTransceivers indexed by MID.
      _mapMidTransceiver = /* @__PURE__ */ new Map();
      // Default local stream for sending if no `streamId` is given in send().
      _sendStream = new MediaStream();
      // Whether a DataChannel m=application section has been created.
      _hasDataChannelMediaSection = false;
      // Sending DataChannel id value counter. Incremented for each new DataChannel.
      _nextSendSctpStreamId = 0;
      // Got transport local and remote parameters.
      _transportReady = false;
      /**
       * Creates a factory function.
       */
      static createFactory() {
        return {
          name: NAME,
          factory: (options) => new _ReactNative106(options),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            let pc2 = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: "all",
              bundlePolicy: "max-bundle",
              rtcpMuxPolicy: "require"
            });
            try {
              pc2.addTransceiver("audio");
              pc2.addTransceiver("video");
              const offer = await pc2.createOffer();
              try {
                pc2.close();
              } catch (error2) {
              }
              pc2 = void 0;
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = _ReactNative106.getLocalRtpCapabilities(sdpObject);
              return nativeRtpCapabilities;
            } catch (error2) {
              try {
                pc2?.close();
              } catch (error22) {
              }
              pc2 = void 0;
              throw error2;
            }
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return {
              numStreams: SCTP_NUM_STREAMS
            };
          }
        };
      }
      static getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions = []) {
        const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({
          sdpObject: localSdpObject
        });
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        ortcUtils.addNackSupportForOpus(nativeRtpCapabilities);
        for (const headerExtension of extraHeaderExtensions) {
          ortcUtils.addHeaderExtensionSupport(nativeRtpCapabilities, headerExtension);
        }
        return nativeRtpCapabilities;
      }
      constructor({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, getSendExtendedRtpCapabilities }) {
        super();
        logger.debug("constructor()");
        this._direction = direction;
        this._remoteSdp = new RemoteSdp_1.RemoteSdp({
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters
        });
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        if (dtlsParameters.role && dtlsParameters.role !== "auto") {
          this._forcedLocalDtlsRole = dtlsParameters.role === "server" ? "client" : "server";
        }
        this._pc = new RTCPeerConnection({
          iceServers: iceServers ?? [],
          iceTransportPolicy: iceTransportPolicy ?? "all",
          bundlePolicy: "max-bundle",
          rtcpMuxPolicy: "require",
          ...additionalSettings
        });
        this._pc.addEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.addEventListener("icecandidateerror", this.onIceCandidateError);
        if (this._pc.connectionState) {
          this._pc.addEventListener("connectionstatechange", this.onConnectionStateChange);
        } else {
          logger.warn("run() | pc.connectionState not supported, using pc.iceConnectionState");
          this._pc.addEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        }
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        this._sendStream.release(
          /* releaseTracks */
          false
        );
        try {
          this._pc.close();
        } catch (error2) {
        }
        this._pc.removeEventListener("icegatheringstatechange", this.onIceGatheringStateChange);
        this._pc.removeEventListener("icecandidateerror", this.onIceCandidateError);
        this._pc.removeEventListener("connectionstatechange", this.onConnectionStateChange);
        this._pc.removeEventListener("iceconnectionstatechange", this.onIceConnectionStateChange);
        this.emit("@close");
        super.close();
      }
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug("updateIceServers()");
        const configuration = this._pc.getConfiguration();
        configuration.iceServers = iceServers;
        this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
        this._remoteSdp.updateIceParameters(iceParameters);
        if (!this._transportReady) {
          return;
        }
        if (this._direction === "send") {
          const offer = await this._pc.createOffer({ iceRestart: true });
          logger.debug("restartIce() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
        } else {
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("restartIce() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug("restartIce() | calling pc.setLocalDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
        }
      }
      async getTransportStats() {
        this.assertNotClosed();
        return this._pc.getStats();
      }
      async send({ track, streamId, encodings, codecOptions, headerExtensionOptions, codec, onRtpSender }) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("send() [kind:%s, track.id:%s, streamId:%s]", track.kind, track.id, streamId);
        if (encodings && encodings.length > 1) {
          encodings.forEach((encoding, idx) => {
            encoding.rid = `r${idx}`;
          });
        }
        const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
        const transceiver = this._pc.addTransceiver(track, {
          direction: "sendonly",
          streams: [this._sendStream],
          sendEncodings: encodings
        });
        if (onRtpSender) {
          onRtpSender(transceiver.sender);
        }
        let offer = await this._pc.createOffer();
        let localSdpObject = sdpTransform.parse(offer.sdp);
        if (localSdpObject.extmapAllowMixed) {
          this._remoteSdp.setSessionExtmapAllowMixed();
        }
        const extraHeaderExtensions = [];
        extraHeaderExtensions.push({
          uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
          kind: track.kind,
          direction: "sendonly"
        });
        const nativeRtpCapabilities = _ReactNative106.getLocalRtpCapabilities(localSdpObject, extraHeaderExtensions);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const sendingRemoteRtpParameters = ortc.getSendingRemoteRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRemoteRtpParameters.codecs = ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        let hackVp9Svc = false;
        const layers = (0, scalabilityModes_1.parse)((encodings ?? [{}])[0].scalabilityMode);
        let offerMediaObject;
        if (encodings?.length === 1 && layers.spatialLayers > 1 && sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp9") {
          logger.debug("send() | enabling legacy simulcast for VP9 SVC");
          hackVp9Svc = true;
          localSdpObject = sdpTransform.parse(offer.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpUnifiedPlanUtils.addLegacySimulcast({
            offerMediaObject,
            numStreams: layers.spatialLayers
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        if (headerExtensionOptions?.absCaptureTime) {
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          sdpCommonUtils.addHeaderExtension({
            offerMediaObject,
            headerExtensionUri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time",
            headerExtensionId: sendingRemoteRtpParameters.headerExtensions.find((headerExtension) => headerExtension.uri === "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time").id
          });
          offer = {
            type: "offer",
            sdp: sdpTransform.write(localSdpObject)
          };
        }
        logger.debug("send() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        let localId = transceiver.mid ?? void 0;
        if (!localId) {
          logger.warn("send() | missing transceiver.mid (bug in react-native-webrtc, using a workaround");
        }
        sendingRtpParameters.mid = localId;
        localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
        sendingRtpParameters.rtcp.cname = sdpCommonUtils.getCname({
          offerMediaObject
        });
        sendingRtpParameters.msid = `${streamId ?? this._sendStream.id} ${track.id}`;
        if (!encodings) {
          sendingRtpParameters.encodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
        } else if (encodings.length === 1) {
          let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({
            offerMediaObject,
            codecs: sendingRtpParameters.codecs
          });
          Object.assign(newEncodings[0], encodings[0]);
          if (hackVp9Svc) {
            newEncodings = [newEncodings[0]];
          }
          sendingRtpParameters.encodings = newEncodings;
        } else {
          sendingRtpParameters.encodings = encodings;
        }
        if (sendingRtpParameters.encodings.length > 1 && (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/vp8" || sendingRtpParameters.codecs[0].mimeType.toLowerCase() === "video/h264")) {
          for (const encoding of sendingRtpParameters.encodings) {
            if (encoding.scalabilityMode) {
              encoding.scalabilityMode = `L1T${layers.temporalLayers}`;
            } else {
              encoding.scalabilityMode = "L1T3";
            }
          }
        }
        this._remoteSdp.send({
          offerMediaObject,
          reuseMid: mediaSectionIdx.reuseMid,
          offerRtpParameters: sendingRtpParameters,
          answerRtpParameters: sendingRemoteRtpParameters,
          codecOptions
        });
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("send() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        if (!localId) {
          localId = transceiver.mid;
          sendingRtpParameters.mid = localId;
        }
        this._mapMidTransceiver.set(localId, transceiver);
        return {
          localId,
          rtpParameters: sendingRtpParameters,
          rtpSender: transceiver.sender
        };
      }
      async stopSending(localId) {
        this.assertSendDirection();
        if (this._closed) {
          return;
        }
        logger.debug("stopSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        void transceiver.sender.replaceTrack(null);
        this._pc.removeTrack(transceiver.sender);
        const mediaSectionClosed = this._remoteSdp.closeMediaSection(transceiver.mid);
        if (mediaSectionClosed) {
          try {
            transceiver.stop();
          } catch (error2) {
          }
        }
        const offer = await this._pc.createOffer();
        logger.debug("stopSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
        this._mapMidTransceiver.delete(localId);
      }
      async pauseSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("pauseSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "inactive";
        this._remoteSdp.pauseMediaSection(localId);
        const offer = await this._pc.createOffer();
        logger.debug("pauseSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async resumeSending(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("resumeSending() [localId:%s]", localId);
        const transceiver = this._mapMidTransceiver.get(localId);
        this._remoteSdp.resumeSendingMediaSection(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        transceiver.direction = "sendonly";
        const offer = await this._pc.createOffer();
        logger.debug("resumeSending() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeSending() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        this.assertSendDirection();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          if (idx <= spatialLayer) {
            encoding.active = true;
          } else {
            encoding.active = false;
          }
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setMaxSpatialLayer() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setMaxSpatialLayer() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        this.assertSendDirection();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        const parameters = transceiver.sender.getParameters();
        parameters.encodings.forEach((encoding, idx) => {
          parameters.encodings[idx] = { ...encoding, ...params };
        });
        await transceiver.sender.setParameters(parameters);
        this._remoteSdp.muxMediaSectionSimulcast(localId, parameters.encodings);
        const offer = await this._pc.createOffer();
        logger.debug("setRtpEncodingParameters() | calling pc.setLocalDescription() [offer:%o]", offer);
        await this._pc.setLocalDescription(offer);
        const answer = {
          type: "answer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("setRtpEncodingParameters() | calling pc.setRemoteDescription() [answer:%o]", answer);
        await this._pc.setRemoteDescription(answer);
      }
      async getSenderStats(localId) {
        this.assertNotClosed();
        this.assertSendDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        this.assertSendDirection();
        const options = {
          negotiated: true,
          id: this._nextSendSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("sendDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        this._nextSendSctpStreamId = ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
        if (!this._hasDataChannelMediaSection) {
          const offer = await this._pc.createOffer();
          const localSdpObject = sdpTransform.parse(offer.sdp);
          const offerMediaObject = localSdpObject.media.find((m2) => m2.type === "application");
          if (!this._transportReady) {
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("sendDataChannel() | calling pc.setLocalDescription() [offer:%o]", offer);
          await this._pc.setLocalDescription(offer);
          this._remoteSdp.sendSctpAssociation({ offerMediaObject });
          const answer = {
            type: "answer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setRemoteDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        const sctpStreamParameters = {
          streamId: options.id,
          ordered: options.ordered,
          maxPacketLifeTime: options.maxPacketLifeTime,
          maxRetransmits: options.maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const results = [];
        const mapLocalId = /* @__PURE__ */ new Map();
        for (const options of optionsList) {
          const { trackId, kind, rtpParameters, streamId } = options;
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = rtpParameters.mid ?? String(this._mapMidTransceiver.size);
          mapLocalId.set(trackId, localId);
          const { msidStreamId } = ortcUtils.getMsidStreamIdAndTrackId(rtpParameters.msid);
          this._remoteSdp.receive({
            mid: localId,
            kind,
            offerRtpParameters: rtpParameters,
            streamId: streamId ?? msidStreamId ?? rtpParameters.rtcp?.cname ?? "-",
            trackId
          });
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("receive() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        for (const options of optionsList) {
          const { trackId, onRtpReceiver } = options;
          if (onRtpReceiver) {
            const localId = mapLocalId.get(trackId);
            const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
            if (!transceiver) {
              throw new Error("transceiver not found");
            }
            onRtpReceiver(transceiver.receiver);
          }
        }
        let answer = await this._pc.createAnswer();
        const localSdpObject = sdpTransform.parse(answer.sdp);
        for (const options of optionsList) {
          const { trackId, rtpParameters } = options;
          const localId = mapLocalId.get(trackId);
          const answerMediaObject = localSdpObject.media.find((m2) => String(m2.mid) === localId);
          sdpCommonUtils.applyCodecParameters({
            offerRtpParameters: rtpParameters,
            answerMediaObject
          });
        }
        answer = {
          type: "answer",
          sdp: sdpTransform.write(localSdpObject)
        };
        if (!this._transportReady) {
          await this.setupTransport({
            localDtlsRole: this._forcedLocalDtlsRole ?? "client",
            localSdpObject
          });
        }
        logger.debug("receive() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const options of optionsList) {
          const { trackId } = options;
          const localId = mapLocalId.get(trackId);
          const transceiver = this._pc.getTransceivers().find((t2) => t2.mid === localId);
          if (!transceiver) {
            throw new Error("new RTCRtpTransceiver not found");
          } else {
            this._mapMidTransceiver.set(localId, transceiver);
            results.push({
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
            });
          }
        }
        return results;
      }
      async stopReceiving(localIds) {
        this.assertRecvDirection();
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          this._remoteSdp.closeMediaSection(transceiver.mid);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("stopReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("stopReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
        for (const localId of localIds) {
          this._mapMidTransceiver.delete(localId);
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("pauseReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "inactive";
          this._remoteSdp.pauseMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("pauseReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("pauseReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
        this.assertRecvDirection();
        for (const localId of localIds) {
          logger.debug("resumeReceiving() [localId:%s]", localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver) {
            throw new Error("associated RTCRtpTransceiver not found");
          }
          transceiver.direction = "recvonly";
          this._remoteSdp.resumeReceivingMediaSection(localId);
        }
        const offer = {
          type: "offer",
          sdp: this._remoteSdp.getSdp()
        };
        logger.debug("resumeReceiving() | calling pc.setRemoteDescription() [offer:%o]", offer);
        await this._pc.setRemoteDescription(offer);
        const answer = await this._pc.createAnswer();
        logger.debug("resumeReceiving() | calling pc.setLocalDescription() [answer:%o]", answer);
        await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const transceiver = this._mapMidTransceiver.get(localId);
        if (!transceiver) {
          throw new Error("associated RTCRtpTransceiver not found");
        }
        return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        this.assertRecvDirection();
        const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
        const options = {
          negotiated: true,
          id: streamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          protocol
        };
        logger.debug("receiveDataChannel() [options:%o]", options);
        const dataChannel = this._pc.createDataChannel(label, options);
        if (!this._hasDataChannelMediaSection) {
          this._remoteSdp.receiveSctpAssociation();
          const offer = {
            type: "offer",
            sdp: this._remoteSdp.getSdp()
          };
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]", offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          if (!this._transportReady) {
            const localSdpObject = sdpTransform.parse(answer.sdp);
            await this.setupTransport({
              localDtlsRole: this._forcedLocalDtlsRole ?? "client",
              localSdpObject
            });
          }
          logger.debug("receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]", answer);
          await this._pc.setLocalDescription(answer);
          this._hasDataChannelMediaSection = true;
        }
        return { dataChannel };
      }
      async setupTransport({ localDtlsRole, localSdpObject }) {
        if (!localSdpObject) {
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
        }
        const dtlsParameters = sdpCommonUtils.extractDtlsParameters({
          sdpObject: localSdpObject
        });
        dtlsParameters.role = localDtlsRole;
        this._remoteSdp.updateDtlsRole(localDtlsRole === "client" ? "server" : "client");
        await new Promise((resolve, reject) => {
          this.safeEmit("@connect", { dtlsParameters }, resolve, reject);
        });
        this._transportReady = true;
      }
      onIceGatheringStateChange = () => {
        this.emit("@icegatheringstatechange", this._pc.iceGatheringState);
      };
      onIceCandidateError = (event) => {
        this.emit("@icecandidateerror", event);
      };
      onConnectionStateChange = () => {
        this.emit("@connectionstatechange", this._pc.connectionState);
      };
      onIceConnectionStateChange = () => {
        switch (this._pc.iceConnectionState) {
          case "checking": {
            this.emit("@connectionstatechange", "connecting");
            break;
          }
          case "connected":
          case "completed": {
            this.emit("@connectionstatechange", "connected");
            break;
          }
          case "failed": {
            this.emit("@connectionstatechange", "failed");
            break;
          }
          case "disconnected": {
            this.emit("@connectionstatechange", "disconnected");
            break;
          }
          case "closed": {
            this.emit("@connectionstatechange", "closed");
            break;
          }
        }
      };
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
      assertSendDirection() {
        if (this._direction !== "send") {
          throw new Error('method can just be called for handlers with "send" direction');
        }
      }
      assertRecvDirection() {
        if (this._direction !== "recv") {
          throw new Error('method can just be called for handlers with "recv" direction');
        }
      }
    };
    exports.ReactNative106 = ReactNative106;
  }
});

// node_modules/mediasoup-client/lib/Device.js
var require_Device = __commonJS({
  "node_modules/mediasoup-client/lib/Device.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Device = void 0;
    exports.detectDevice = detectDevice;
    exports.detectDeviceAsync = detectDeviceAsync;
    var Logger_1 = require_Logger();
    var enhancedEvents_1 = require_enhancedEvents();
    var errors_1 = require_errors();
    var utils = require_utils();
    var ortc = require_ortc();
    var Transport_1 = require_Transport();
    var Chrome111_1 = require_Chrome111();
    var Chrome74_1 = require_Chrome74();
    var Firefox120_1 = require_Firefox120();
    var Safari12_1 = require_Safari12();
    var ReactNative106_1 = require_ReactNative106();
    var logger = new Logger_1.Logger("Device");
    function detectDevice(userAgent, userAgentData) {
      logger.debug("detectDevice()");
      if (!userAgent && typeof navigator === "object") {
        userAgent = navigator.userAgent;
      }
      if (!userAgentData && typeof navigator === "object") {
        userAgentData = navigator.userAgentData;
      }
      return detectDeviceImpl(userAgent, userAgentData);
    }
    async function detectDeviceAsync(userAgent, userAgentData) {
      logger.debug("detectDeviceAsync()");
      if (!userAgent && typeof navigator === "object") {
        userAgent = navigator.userAgent;
      }
      if (!userAgentData && typeof navigator === "object") {
        userAgentData = navigator.userAgentData;
      }
      return detectDeviceImpl(userAgent, userAgentData);
    }
    var Device2 = class _Device {
      // RTC handler factory.
      _handlerFactory;
      // Handler name.
      _handlerName;
      // Loaded flag.
      _loaded = false;
      // Callback for sending Transports to request sending extended RTP capabilities
      // on demand.
      _getSendExtendedRtpCapabilities;
      // Local RTP capabilities for receiving media.
      _recvRtpCapabilities;
      // Whether we can produce audio/video based on remote RTP capabilities.
      _canProduceByKind = {
        audio: false,
        video: false
      };
      // Local SCTP capabilities.
      _sctpCapabilities;
      // Observer instance.
      _observer = new enhancedEvents_1.EnhancedEventEmitter();
      /**
       * Create a new Device to connect to mediasoup server. It uses a more advanced
       * device detection.
       *
       * @throws {UnsupportedError} if device is not supported.
       */
      static async factory({ handlerName, handlerFactory } = {}) {
        logger.debug("factory()");
        if (handlerName && handlerFactory) {
          throw new TypeError("just one of handlerName or handlerInterface can be given");
        }
        if (!handlerName && !handlerFactory) {
          handlerName = await detectDeviceAsync();
          if (!handlerName) {
            throw new errors_1.UnsupportedError("device not supported");
          }
        }
        return new _Device({ handlerName, handlerFactory });
      }
      /**
       * Create a new Device to connect to mediasoup server.
       *
       * @throws {UnsupportedError} if device is not supported.
       */
      constructor({ handlerName, handlerFactory } = {}) {
        logger.debug("constructor()");
        if (handlerName && handlerFactory) {
          throw new TypeError("just one of handlerName or handlerInterface can be given");
        }
        if (handlerFactory) {
          this._handlerFactory = handlerFactory;
        } else {
          if (handlerName) {
            logger.debug("constructor() | handler given: %s", handlerName);
          } else {
            handlerName = detectDevice();
            if (handlerName) {
              logger.debug("constructor() | detected handler: %s", handlerName);
            } else {
              throw new errors_1.UnsupportedError("device not supported");
            }
          }
          switch (handlerName) {
            case "Chrome111": {
              this._handlerFactory = Chrome111_1.Chrome111.createFactory();
              break;
            }
            case "Chrome74": {
              this._handlerFactory = Chrome74_1.Chrome74.createFactory();
              break;
            }
            case "Firefox120": {
              this._handlerFactory = Firefox120_1.Firefox120.createFactory();
              break;
            }
            case "Safari12": {
              this._handlerFactory = Safari12_1.Safari12.createFactory();
              break;
            }
            case "ReactNative106": {
              this._handlerFactory = ReactNative106_1.ReactNative106.createFactory();
              break;
            }
            default: {
              throw new TypeError(`unknown handlerName "${handlerName}"`);
            }
          }
        }
        this._handlerName = this._handlerFactory.name;
      }
      /**
       * The RTC handler name.
       */
      get handlerName() {
        return this._handlerName;
      }
      /**
       * Whether the Device is loaded.
       */
      get loaded() {
        return this._loaded;
      }
      /**
       * RTP capabilities of the Device for receiving media.
       *
       * @throws {InvalidStateError} if not loaded.
       */
      get rtpCapabilities() {
        if (!this._loaded) {
          throw new errors_1.InvalidStateError("not loaded");
        }
        return this._recvRtpCapabilities;
      }
      /**
       * SCTP capabilities of the Device.
       *
       * @throws {InvalidStateError} if not loaded.
       */
      get sctpCapabilities() {
        if (!this._loaded) {
          throw new errors_1.InvalidStateError("not loaded");
        }
        return this._sctpCapabilities;
      }
      get observer() {
        return this._observer;
      }
      /**
       * Initialize the Device.
       */
      async load({ routerRtpCapabilities, preferLocalCodecsOrder = false }) {
        logger.debug("load() [routerRtpCapabilities:%o]", routerRtpCapabilities);
        if (this._loaded) {
          throw new errors_1.InvalidStateError("already loaded");
        }
        const clonedRouterRtpCapabilities = utils.clone(routerRtpCapabilities);
        ortc.validateAndNormalizeRtpCapabilities(clonedRouterRtpCapabilities);
        const { getNativeRtpCapabilities, getNativeSctpCapabilities } = this._handlerFactory;
        const clonedNativeRtpCapabilities = utils.clone(await getNativeRtpCapabilities());
        ortc.validateAndNormalizeRtpCapabilities(clonedNativeRtpCapabilities);
        logger.debug("load() | got native RTP capabilities:%o", clonedNativeRtpCapabilities);
        this._getSendExtendedRtpCapabilities = (nativeRtpCapabilities) => {
          return utils.clone(ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, clonedRouterRtpCapabilities, preferLocalCodecsOrder));
        };
        const recvExtendedRtpCapabilities = ortc.getExtendedRtpCapabilities(
          clonedNativeRtpCapabilities,
          clonedRouterRtpCapabilities,
          /* preferLocalCodecsOrder */
          false
        );
        this._recvRtpCapabilities = ortc.getRecvRtpCapabilities(recvExtendedRtpCapabilities);
        ortc.validateAndNormalizeRtpCapabilities(this._recvRtpCapabilities);
        logger.debug("load() | got receiving RTP capabilities:%o", this._recvRtpCapabilities);
        this._canProduceByKind.audio = ortc.canSend("audio", this._recvRtpCapabilities);
        this._canProduceByKind.video = ortc.canSend("video", this._recvRtpCapabilities);
        this._sctpCapabilities = await getNativeSctpCapabilities();
        ortc.validateSctpCapabilities(this._sctpCapabilities);
        logger.debug("load() | got native SCTP capabilities:%o", this._sctpCapabilities);
        logger.debug("load() succeeded");
        this._loaded = true;
      }
      /**
       * Whether we can produce audio/video.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      canProduce(kind) {
        if (!this._loaded) {
          throw new errors_1.InvalidStateError("not loaded");
        } else if (kind !== "audio" && kind !== "video") {
          throw new TypeError(`invalid kind "${kind}"`);
        }
        return this._canProduceByKind[kind];
      }
      /**
       * Creates a Transport for sending media.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
        logger.debug("createSendTransport()");
        return this.createTransport({
          direction: "send",
          id,
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          appData
        });
      }
      /**
       * Creates a Transport for receiving media.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
        logger.debug("createRecvTransport()");
        return this.createTransport({
          direction: "recv",
          id,
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          appData
        });
      }
      createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, appData }) {
        if (!this._loaded) {
          throw new errors_1.InvalidStateError("not loaded");
        } else if (typeof id !== "string") {
          throw new TypeError("missing id");
        } else if (typeof iceParameters !== "object") {
          throw new TypeError("missing iceParameters");
        } else if (!Array.isArray(iceCandidates)) {
          throw new TypeError("missing iceCandidates");
        } else if (typeof dtlsParameters !== "object") {
          throw new TypeError("missing dtlsParameters");
        } else if (sctpParameters && typeof sctpParameters !== "object") {
          throw new TypeError("wrong sctpParameters");
        } else if (appData && typeof appData !== "object") {
          throw new TypeError("if given, appData must be an object");
        }
        const transport = new Transport_1.Transport({
          direction,
          id,
          iceParameters,
          iceCandidates,
          dtlsParameters,
          sctpParameters,
          iceServers,
          iceTransportPolicy,
          additionalSettings,
          appData,
          handlerFactory: this._handlerFactory,
          getSendExtendedRtpCapabilities: this._getSendExtendedRtpCapabilities,
          recvRtpCapabilities: this._recvRtpCapabilities,
          canProduceByKind: this._canProduceByKind
        });
        this._observer.safeEmit("newtransport", transport);
        return transport;
      }
    };
    exports.Device = Device2;
    function detectDeviceImpl(userAgent, userAgentData) {
      logger.debug('detectDeviceImpl() [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
      const chromiumMajorVersion = getChromiumMajorVersion(userAgent, userAgentData);
      if (chromiumMajorVersion) {
        if (chromiumMajorVersion >= 111) {
          logger.debug("detectDeviceImpl() | using Chrome111 handler");
          return "Chrome111";
        } else if (chromiumMajorVersion >= 74) {
          logger.debug("detectDeviceImpl() | using Chrome74 handler");
          return "Chrome74";
        } else {
          logger.warn("detectDeviceImpl() | unsupported Chromium based browser/version");
          return void 0;
        }
      }
      const firefoxMajorVersion = getFirefoxMajorVersion(userAgent);
      if (firefoxMajorVersion) {
        if (firefoxMajorVersion >= 120) {
          logger.debug("detectDeviceImpl() | using Firefox120 handler");
          return "Firefox120";
        } else {
          logger.warn("detectDeviceImpl() | unsupported Firefox browser/version");
          return void 0;
        }
      }
      const macOSWebKitMajorVersion = getMacOSWebKitMajorVersion(userAgent);
      if (macOSWebKitMajorVersion) {
        if (macOSWebKitMajorVersion >= 605) {
          logger.debug("detectDeviceImpl() | using Safari12 handler");
          return "Safari12";
        } else {
          logger.warn("detectDeviceImpl() | unsupported desktop Safari browser/version");
          return void 0;
        }
      }
      const iOSWebKitMajorVersion = getIOSWebKitMajorVersion(userAgent);
      if (iOSWebKitMajorVersion) {
        if (iOSWebKitMajorVersion >= 605) {
          logger.debug("detectDeviceImpl() | using Safari12 handler");
          return "Safari12";
        } else {
          logger.warn("detectDeviceImpl() | unsupported iOS Safari based browser/version");
          return void 0;
        }
      }
      if (isReactNative()) {
        if (typeof RTCPeerConnection !== "undefined" && typeof RTCRtpTransceiver !== "undefined") {
          logger.debug("detectDeviceImpl() | using ReactNative106 handler");
          return "ReactNative106";
        } else {
          logger.warn("detectDeviceImpl() | unsupported react-native-webrtc version without RTCPeerConnection or RTCRtpTransceiver, forgot to call registerGlobals() on it?");
          return void 0;
        }
      }
      logger.warn('detectDeviceImpl() | device not supported [userAgent:"%s", userAgentData:%o]', userAgent, userAgentData);
      return void 0;
    }
    function getChromiumMajorVersion(userAgent, userAgentData) {
      logger.debug("getChromiumMajorVersion()");
      if (isIOS(userAgent, userAgentData)) {
        logger.debug("getChromiumMajorVersion() | this is iOS => undefined");
        return void 0;
      }
      if (isReactNative()) {
        logger.debug("getChromiumMajorVersion() | this is React-Native => undefined");
        return void 0;
      }
      if (userAgentData) {
        const chromiumBrand = (userAgentData.brands ?? []).find((b2) => b2.brand === "Chromium");
        if (chromiumBrand) {
          const majorVersion = Number(chromiumBrand.version);
          logger.debug(`getChromiumMajorVersion() | Chromium major version based on NavigatorUAData => ${majorVersion}`);
          return majorVersion;
        }
      }
      const match = userAgent?.match(/\b(?:Chrome|Chromium)\/(\w+)/i);
      if (match?.[1]) {
        const majorVersion = Number(match[1]);
        logger.debug(`getChromiumMajorVersion() | Chromium major version based on User-Agent => ${majorVersion}`);
        return majorVersion;
      }
      logger.debug("getChromiumMajorVersion() | this is not Chromium => undefined");
      return void 0;
    }
    function getFirefoxMajorVersion(userAgent) {
      logger.debug("getFirefoxMajorVersion()");
      if (isIOS(userAgent)) {
        logger.debug("getFirefoxMajorVersion() | this is iOS => undefined");
        return void 0;
      }
      if (isReactNative()) {
        logger.debug("getFirefoxMajorVersion() | this is React-Native => undefined");
        return void 0;
      }
      const match = userAgent?.match(/\bFirefox\/(\w+)/i);
      if (match?.[1]) {
        const majorVersion = Number(match[1]);
        logger.debug(`getFirefoxMajorVersion() | Firefox major version based on User-Agent => ${majorVersion}`);
        return majorVersion;
      }
      logger.debug("getFirefoxMajorVersion() | this is not Firefox => undefined");
      return void 0;
    }
    function getMacOSWebKitMajorVersion(userAgent) {
      logger.debug("getMacOSWebKitMajorVersion()");
      if (isIOS(userAgent)) {
        logger.debug("getMacOSWebKitMajorVersion() | this is iOS => undefined");
        return void 0;
      }
      if (isReactNative()) {
        logger.debug("getMacOSWebKitMajorVersion() | this is React-Native => undefined");
        return void 0;
      }
      const isSafari = userAgent && /\bSafari\b/i.test(userAgent) && !/\bChrome\b/i.test(userAgent) && !/\bChromium\b/i.test(userAgent) && !/\bFirefox\b/i.test(userAgent);
      if (!isSafari) {
        logger.debug("getMacOSWebKitMajorVersion() | this is not Safari => undefined");
        return void 0;
      }
      const match = userAgent.match(/AppleWebKit\/(\w+)/i);
      if (match?.[1]) {
        const majorVersion = Number(match[1]);
        logger.debug(`getMacOSWebKitMajorVersion() | WebKit major version based on User-Agent => ${majorVersion}`);
        return majorVersion;
      }
      logger.debug("getMacOSWebKitMajorVersion() | this is not WebKit => undefined");
      return void 0;
    }
    function getIOSWebKitMajorVersion(userAgent) {
      logger.debug("getIOSWebKitMajorVersion()");
      if (!isIOS(userAgent)) {
        logger.debug("getIOSWebKitMajorVersion() | this is not iOS => undefined");
        return void 0;
      }
      if (isReactNative()) {
        logger.debug("getIOSWebKitMajorVersion() | this is React-Native => undefined");
        return void 0;
      }
      const match = userAgent?.match(/AppleWebKit\/(\w+)/i);
      if (match?.[1]) {
        const majorVersion = Number(match[1]);
        logger.debug(`getIOSWebKitMajorVersion() | WebKit major version based on User-Agent => ${majorVersion}`);
        return majorVersion;
      }
      logger.debug("getIOSWebKitMajorVersion() | this is not WebKit => undefined");
      return void 0;
    }
    function isIOS(userAgent, userAgentData) {
      logger.debug("isIOS()");
      if (userAgentData?.platform === "iOS") {
        logger.debug("isIOS() | this is iOS based on NavigatorUAData.platform => true");
        return true;
      }
      if (userAgentData?.platform) {
        logger.debug("isIOS() | this is not iOS based on NavigatorUAData.platform => false");
        return false;
      }
      if (userAgent && /iPad|iPhone|iPod/.test(userAgent)) {
        logger.debug("isIOS() | this is iOS based on User-Agent => true");
        return true;
      }
      if (typeof navigator === "object" && navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) {
        logger.debug("isIOS() | this is iPadOS 13+ based on User-Agent => true");
        return true;
      }
      logger.debug("isIOS() | this is not iOS => false");
      return false;
    }
    function isReactNative() {
      logger.debug("isReactNative()");
      if (typeof navigator === "object" && navigator.product === "ReactNative") {
        logger.debug("isReactNative() | this is React-Native based on navigator.product");
        return true;
      }
      logger.debug("isReactNative() | this is not React-Native => false");
      return false;
    }
  }
});

// node_modules/@lukeed/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/@lukeed/uuid/dist/index.js"(exports) {
    var IDX = 256;
    var HEX = [];
    var BUFFER;
    while (IDX--) HEX[IDX] = (IDX + 256).toString(16).substring(1);
    function v4() {
      var i2 = 0, num, out = "";
      if (!BUFFER || IDX + 16 > 256) {
        BUFFER = Array(i2 = 256);
        while (i2--) BUFFER[i2] = 256 * Math.random() | 0;
        i2 = IDX = 0;
      }
      for (; i2 < 16; i2++) {
        num = BUFFER[IDX + i2];
        if (i2 == 6) out += HEX[num & 15 | 64];
        else if (i2 == 8) out += HEX[num & 63 | 128];
        else out += HEX[num];
        if (i2 & 1 && i2 > 1 && i2 < 11) out += "-";
      }
      IDX++;
      return out;
    }
    exports.v4 = v4;
  }
});

// node_modules/fake-mediastreamtrack/lib/fakeEvents/FakeEventTarget.js
var require_FakeEventTarget = __commonJS({
  "node_modules/fake-mediastreamtrack/lib/fakeEvents/FakeEventTarget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FakeEventTarget = void 0;
    var FakeEventTarget = class {
      listeners = {};
      addEventListener(type, callback, options) {
        if (!callback) {
          return;
        }
        this.listeners[type] = this.listeners[type] ?? [];
        this.listeners[type].push({
          callback: (
            // eslint-disable-next-line @typescript-eslint/unbound-method
            typeof callback === "function" ? callback : callback.handleEvent
          ),
          once: typeof options === "object" && options.once === true
        });
      }
      removeEventListener(type, callback, options) {
        if (!this.listeners[type]) {
          return;
        }
        if (!callback) {
          return;
        }
        this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== // eslint-disable-next-line @typescript-eslint/unbound-method
        (typeof callback === "function" ? callback : callback.handleEvent));
      }
      dispatchEvent(event) {
        if (!event || typeof event.type !== "string") {
          throw new Error("invalid event object");
        }
        const entries = this.listeners[event.type];
        if (!entries) {
          return true;
        }
        for (const listener of [...entries]) {
          try {
            listener.callback.call(this, event);
          } catch (error2) {
            setTimeout(() => {
              throw error2;
            }, 0);
          }
          if (listener.once) {
            this.removeEventListener(event.type, listener.callback);
          }
        }
        return !event.defaultPrevented;
      }
    };
    exports.FakeEventTarget = FakeEventTarget;
  }
});

// node_modules/fake-mediastreamtrack/lib/fakeEvents/FakeEvent.js
var require_FakeEvent = __commonJS({
  "node_modules/fake-mediastreamtrack/lib/fakeEvents/FakeEvent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FakeEvent = void 0;
    var FakeEvent = class {
      /**
       * Constants.
       */
      NONE = 0;
      CAPTURING_PHASE = 1;
      AT_TARGET = 2;
      BUBBLING_PHASE = 3;
      /**
       * Members.
       */
      type;
      bubbles;
      cancelable;
      defaultPrevented = false;
      composed = false;
      currentTarget = null;
      // Not implemented.
      eventPhase = this.NONE;
      isTrusted = true;
      target = null;
      timeStamp = 0;
      // Deprecated.
      cancelBubble = false;
      returnValue = true;
      srcElement = null;
      constructor(type, options = {}) {
        this.type = type;
        this.bubbles = options.bubbles ?? false;
        this.cancelable = options.cancelable ?? false;
      }
      preventDefault() {
        if (this.cancelable) {
          this.defaultPrevented = true;
        }
      }
      /**
       * Not implemented.
       */
      stopPropagation() {
      }
      /**
       * Not implemented.
       */
      stopImmediatePropagation() {
      }
      /**
       * Not implemented.
       */
      composedPath() {
        return [];
      }
      /**
       * Not implemented.
       * @deprecated
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      initEvent(type, bubbles, cancelable) {
      }
    };
    exports.FakeEvent = FakeEvent;
  }
});

// node_modules/fake-mediastreamtrack/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/fake-mediastreamtrack/lib/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clone = clone;
    function clone(value) {
      if (value === void 0) {
        return void 0;
      } else if (Number.isNaN(value)) {
        return NaN;
      } else if (typeof structuredClone === "function") {
        return structuredClone(value);
      } else {
        return JSON.parse(JSON.stringify(value));
      }
    }
  }
});

// node_modules/fake-mediastreamtrack/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/fake-mediastreamtrack/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FakeMediaStreamTrack = void 0;
    var uuid_1 = require_dist();
    var FakeEventTarget_1 = require_FakeEventTarget();
    var FakeEvent_1 = require_FakeEvent();
    var utils_1 = require_utils3();
    var FakeMediaStreamTrack = class _FakeMediaStreamTrack extends FakeEventTarget_1.FakeEventTarget {
      #id;
      #kind;
      #label;
      #readyState;
      #enabled;
      #muted;
      #contentHint;
      #capabilities;
      #constraints;
      #settings;
      #data;
      // Events.
      #onmute = null;
      #onunmute = null;
      #onended = null;
      // Custom events.
      #onenabledchange = null;
      #onstopped = null;
      constructor({ kind, id, label, contentHint, enabled, muted, readyState, capabilities, constraints, settings, data: data2 }) {
        super();
        this.#id = id ?? (0, uuid_1.v4)();
        this.#kind = kind;
        this.#label = label ?? "";
        this.#contentHint = contentHint ?? "";
        this.#enabled = enabled ?? true;
        this.#muted = muted ?? false;
        this.#readyState = readyState ?? "live";
        this.#capabilities = capabilities ?? {};
        this.#constraints = constraints ?? {};
        this.#settings = settings ?? {};
        this.#data = data2 ?? {};
      }
      get id() {
        return this.#id;
      }
      get kind() {
        return this.#kind;
      }
      get label() {
        return this.#label;
      }
      get contentHint() {
        return this.#contentHint;
      }
      set contentHint(contentHint) {
        this.#contentHint = contentHint;
      }
      get enabled() {
        return this.#enabled;
      }
      /**
       * Changes `enabled` member value and fires a custom "enabledchange" event.
       */
      set enabled(enabled) {
        const changed = this.#enabled !== enabled;
        this.#enabled = enabled;
        if (changed) {
          this.dispatchEvent(new FakeEvent_1.FakeEvent("enabledchange"));
        }
      }
      get muted() {
        return this.#muted;
      }
      get readyState() {
        return this.#readyState;
      }
      /**
       * Application custom data getter.
       */
      get data() {
        return this.#data;
      }
      /**
       * Application custom data setter.
       */
      set data(data2) {
        this.#data = data2;
      }
      get onmute() {
        return this.#onmute;
      }
      set onmute(handler) {
        if (this.#onmute) {
          this.removeEventListener("mute", this.#onmute);
        }
        this.#onmute = handler;
        if (handler) {
          this.addEventListener("mute", handler);
        }
      }
      get onunmute() {
        return this.#onunmute;
      }
      set onunmute(handler) {
        if (this.#onunmute) {
          this.removeEventListener("unmute", this.#onunmute);
        }
        this.#onunmute = handler;
        if (handler) {
          this.addEventListener("unmute", handler);
        }
      }
      get onended() {
        return this.#onended;
      }
      set onended(handler) {
        if (this.#onended) {
          this.removeEventListener("ended", this.#onended);
        }
        this.#onended = handler;
        if (handler) {
          this.addEventListener("ended", handler);
        }
      }
      get onenabledchange() {
        return this.#onenabledchange;
      }
      set onenabledchange(handler) {
        if (this.#onenabledchange) {
          this.removeEventListener("enabledchange", this.#onenabledchange);
        }
        this.#onenabledchange = handler;
        if (handler) {
          this.addEventListener("enabledchange", handler);
        }
      }
      get onstopped() {
        return this.#onstopped;
      }
      set onstopped(handler) {
        if (this.#onstopped) {
          this.removeEventListener("stopped", this.#onstopped);
        }
        this.#onstopped = handler;
        if (handler) {
          this.addEventListener("stopped", handler);
        }
      }
      addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
      }
      /**
       * Changes `readyState` member to "ended" and fires a custom "stopped" event
       * (if not already stopped).
       */
      stop() {
        if (this.#readyState === "ended") {
          return;
        }
        this.#readyState = "ended";
        this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
      }
      /**
       * Clones current track into another FakeMediaStreamTrack. `id` and `data`
       * can be optionally given.
       */
      clone({ id, data: data2 } = {}) {
        return new _FakeMediaStreamTrack({
          id: id ?? (0, uuid_1.v4)(),
          kind: this.#kind,
          label: this.#label,
          contentHint: this.#contentHint,
          enabled: this.#enabled,
          muted: this.#muted,
          readyState: this.#readyState,
          capabilities: (0, utils_1.clone)(this.#capabilities),
          constraints: (0, utils_1.clone)(this.#constraints),
          settings: (0, utils_1.clone)(this.#settings),
          data: data2 ?? (0, utils_1.clone)(this.#data)
        });
      }
      getCapabilities() {
        return this.#capabilities;
      }
      getConstraints() {
        return this.#constraints;
      }
      async applyConstraints(constraints = {}) {
        this.#constraints = constraints;
        return Promise.resolve();
      }
      getSettings() {
        return this.#settings;
      }
      /**
       * Simulates a remotely triggered stop. It fires a custom "stopped" event and
       * the standard "ended" event (if the track was not already stopped).
       */
      remoteStop() {
        if (this.#readyState === "ended") {
          return;
        }
        this.#readyState = "ended";
        this.dispatchEvent(new FakeEvent_1.FakeEvent("stopped"));
        this.dispatchEvent(new FakeEvent_1.FakeEvent("ended"));
      }
      /**
       * Simulates a remotely triggered mute. It fires a "mute" event (if the track
       * was not already muted).
       */
      remoteMute() {
        if (this.#muted) {
          return;
        }
        this.#muted = true;
        this.dispatchEvent(new FakeEvent_1.FakeEvent("mute"));
      }
      /**
       * Simulates a remotely triggered unmute. It fires an "unmute" event (if the
       * track was muted).
       */
      remoteUnmute() {
        if (!this.#muted) {
          return;
        }
        this.#muted = false;
        this.dispatchEvent(new FakeEvent_1.FakeEvent("unmute"));
      }
    };
    exports.FakeMediaStreamTrack = FakeMediaStreamTrack;
  }
});

// node_modules/mediasoup-client/lib/handlers/fakeEvents/FakeEventTarget.js
var require_FakeEventTarget2 = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/fakeEvents/FakeEventTarget.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FakeEventTarget = void 0;
    var FakeEventTarget = class {
      listeners = {};
      addEventListener(type, callback, options) {
        if (!callback) {
          return;
        }
        this.listeners[type] = this.listeners[type] ?? [];
        this.listeners[type].push({
          callback: typeof callback === "function" ? callback : callback.handleEvent,
          once: typeof options === "object" && options.once === true
        });
      }
      removeEventListener(type, callback, options) {
        if (!this.listeners[type]) {
          return;
        }
        if (!callback) {
          return;
        }
        this.listeners[type] = this.listeners[type].filter((listener) => listener.callback !== (typeof callback === "function" ? callback : callback.handleEvent));
      }
      dispatchEvent(event) {
        if (!event || typeof event.type !== "string") {
          throw new Error("invalid event object");
        }
        const entries = this.listeners[event.type];
        if (!entries) {
          return true;
        }
        for (const listener of [...entries]) {
          try {
            listener.callback.call(this, event);
          } catch (error2) {
            setTimeout(() => {
              throw error2;
            }, 0);
          }
          if (listener.once) {
            this.removeEventListener(event.type, listener.callback);
          }
        }
        return !event.defaultPrevented;
      }
    };
    exports.FakeEventTarget = FakeEventTarget;
  }
});

// node_modules/mediasoup-client/lib/handlers/FakeHandler.js
var require_FakeHandler = __commonJS({
  "node_modules/mediasoup-client/lib/handlers/FakeHandler.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FakeHandler = void 0;
    var fake_mediastreamtrack_1 = require_lib4();
    var enhancedEvents_1 = require_enhancedEvents();
    var Logger_1 = require_Logger();
    var utils = require_utils();
    var ortc = require_ortc();
    var errors_1 = require_errors();
    var FakeEventTarget_1 = require_FakeEventTarget2();
    var logger = new Logger_1.Logger("FakeHandler");
    var NAME = "FakeHandler";
    var FakeHandler = class _FakeHandler extends enhancedEvents_1.EnhancedEventEmitter {
      // Closed flag.
      _closed = false;
      // Fake parameters source of RTP and SCTP parameters and capabilities.
      _fakeParameters;
      // Callback to request sending extended RTP capabilities on demand.
      _getSendExtendedRtpCapabilities;
      // Local RTCP CNAME.
      _cname = `CNAME-${utils.generateRandomNumber()}`;
      // Default sending MediaStream id.
      _defaultSendStreamId = `${utils.generateRandomNumber()}`;
      // Got transport local and remote parameters.
      _transportReady = false;
      // Next localId.
      _nextLocalId = 1;
      // Sending and receiving tracks indexed by localId.
      _tracks = /* @__PURE__ */ new Map();
      // DataChannel id value counter. It must be incremented for each new DataChannel.
      _nextSctpStreamId = 0;
      /**
       * Creates a factory function.
       */
      static createFactory(fakeParameters) {
        return {
          name: NAME,
          factory: (options) => new _FakeHandler(options, fakeParameters),
          getNativeRtpCapabilities: async () => {
            logger.debug("getNativeRtpCapabilities()");
            return _FakeHandler.getLocalRtpCapabilities(fakeParameters);
          },
          getNativeSctpCapabilities: async () => {
            logger.debug("getNativeSctpCapabilities()");
            return fakeParameters.generateNativeSctpCapabilities();
          }
        };
      }
      static getLocalRtpCapabilities(fakeParameters) {
        const nativeRtpCapabilities = fakeParameters.generateNativeRtpCapabilities();
        ortc.validateAndNormalizeRtpCapabilities(nativeRtpCapabilities);
        return nativeRtpCapabilities;
      }
      constructor({
        // direction,
        // iceParameters,
        // iceCandidates,
        // dtlsParameters,
        // sctpParameters,
        // iceServers,
        // iceTransportPolicy,
        // additionalSettings,
        getSendExtendedRtpCapabilities
      }, fakeParameters) {
        super();
        logger.debug("constructor()");
        this._getSendExtendedRtpCapabilities = getSendExtendedRtpCapabilities;
        this._fakeParameters = fakeParameters;
      }
      get name() {
        return NAME;
      }
      close() {
        logger.debug("close()");
        if (this._closed) {
          return;
        }
        this._closed = true;
        super.close();
      }
      // NOTE: Custom method for simulation purposes.
      setIceGatheringState(iceGatheringState) {
        this.emit("@icegatheringstatechange", iceGatheringState);
      }
      // NOTE: Custom method for simulation purposes.
      setConnectionState(connectionState) {
        this.emit("@connectionstatechange", connectionState);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async updateIceServers(iceServers) {
        this.assertNotClosed();
        logger.debug("updateIceServers()");
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async restartIce(iceParameters) {
        this.assertNotClosed();
        logger.debug("restartIce()");
      }
      async getTransportStats() {
        this.assertNotClosed();
        return /* @__PURE__ */ new Map();
      }
      async send({ track, streamId, encodings, codecOptions, codec }) {
        this.assertNotClosed();
        logger.debug("send() [kind:%s, track.id:%s]", track.kind, track.id);
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "server" });
        }
        const nativeRtpCapabilities = _FakeHandler.getLocalRtpCapabilities(this._fakeParameters);
        const sendExtendedRtpCapabilities = this._getSendExtendedRtpCapabilities(nativeRtpCapabilities);
        const sendingRtpParameters = ortc.getSendingRtpParameters(track.kind, sendExtendedRtpCapabilities);
        sendingRtpParameters.codecs = ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
        const useRtx = sendingRtpParameters.codecs.some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
        sendingRtpParameters.mid = `mid-${utils.generateRandomNumber()}`;
        sendingRtpParameters.msid = `${streamId ?? "-"} ${track.id}`;
        if (!encodings) {
          encodings = [{}];
        }
        for (const encoding of encodings) {
          encoding.ssrc = utils.generateRandomNumber();
          if (useRtx) {
            encoding.rtx = { ssrc: utils.generateRandomNumber() };
          }
        }
        sendingRtpParameters.encodings = encodings;
        sendingRtpParameters.rtcp = {
          cname: this._cname,
          reducedSize: true,
          mux: true
        };
        sendingRtpParameters.msid = `${streamId ?? this._defaultSendStreamId} ${track.id}`;
        const localId = this._nextLocalId++;
        this._tracks.set(localId, track);
        return { localId: String(localId), rtpParameters: sendingRtpParameters };
      }
      async stopSending(localId) {
        logger.debug("stopSending() [localId:%s]", localId);
        if (this._closed) {
          return;
        }
        if (!this._tracks.has(Number(localId))) {
          throw new Error("local track not found");
        }
        this._tracks.delete(Number(localId));
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async pauseSending(localId) {
        this.assertNotClosed();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async resumeSending(localId) {
        this.assertNotClosed();
      }
      async replaceTrack(localId, track) {
        this.assertNotClosed();
        if (track) {
          logger.debug("replaceTrack() [localId:%s, track.id:%s]", localId, track.id);
        } else {
          logger.debug("replaceTrack() [localId:%s, no track]", localId);
        }
        this._tracks.delete(Number(localId));
        this._tracks.set(Number(localId), track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
        this.assertNotClosed();
        logger.debug("setMaxSpatialLayer() [localId:%s, spatialLayer:%s]", localId, spatialLayer);
      }
      async setRtpEncodingParameters(localId, params) {
        this.assertNotClosed();
        logger.debug("setRtpEncodingParameters() [localId:%s, params:%o]", localId, params);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getSenderStats(localId) {
        this.assertNotClosed();
        return /* @__PURE__ */ new Map();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
        this.assertNotClosed();
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "server" });
        }
        logger.debug("sendDataChannel()");
        const dataChannel = new FakeRTCDataChannel({
          id: this._nextSctpStreamId++,
          ordered,
          maxPacketLifeTime,
          maxRetransmits,
          label,
          protocol
        });
        const sctpStreamParameters = {
          streamId: this._nextSctpStreamId,
          ordered,
          maxPacketLifeTime,
          maxRetransmits
        };
        return { dataChannel, sctpStreamParameters };
      }
      async receive(optionsList) {
        this.assertNotClosed();
        const results = [];
        for (const options of optionsList) {
          const { trackId, kind } = options;
          if (!this._transportReady) {
            await this.setupTransport({ localDtlsRole: "client" });
          }
          logger.debug("receive() [trackId:%s, kind:%s]", trackId, kind);
          const localId = this._nextLocalId++;
          const track = new fake_mediastreamtrack_1.FakeMediaStreamTrack({ kind });
          this._tracks.set(localId, track);
          results.push({ localId: String(localId), track });
        }
        return results;
      }
      async stopReceiving(localIds) {
        if (this._closed) {
          return;
        }
        for (const localId of localIds) {
          logger.debug("stopReceiving() [localId:%s]", localId);
          this._tracks.delete(Number(localId));
        }
      }
      async pauseReceiving(localIds) {
        this.assertNotClosed();
      }
      async resumeReceiving(localIds) {
        this.assertNotClosed();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getReceiverStats(localId) {
        this.assertNotClosed();
        return /* @__PURE__ */ new Map();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
        this.assertNotClosed();
        if (!this._transportReady) {
          await this.setupTransport({ localDtlsRole: "client" });
        }
        logger.debug("receiveDataChannel()");
        const dataChannel = new FakeRTCDataChannel({
          id: sctpStreamParameters.streamId,
          ordered: sctpStreamParameters.ordered,
          maxPacketLifeTime: sctpStreamParameters.maxPacketLifeTime,
          maxRetransmits: sctpStreamParameters.maxRetransmits,
          label,
          protocol
        });
        return { dataChannel };
      }
      async setupTransport({
        localDtlsRole,
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        localSdpObject
      }) {
        const dtlsParameters = utils.clone(this._fakeParameters.generateLocalDtlsParameters());
        if (localDtlsRole) {
          dtlsParameters.role = localDtlsRole;
        }
        this.emit("@connectionstatechange", "connecting");
        await new Promise((resolve, reject) => this.emit("@connect", { dtlsParameters }, resolve, reject));
        this._transportReady = true;
      }
      assertNotClosed() {
        if (this._closed) {
          throw new errors_1.InvalidStateError("method called in a closed handler");
        }
      }
    };
    exports.FakeHandler = FakeHandler;
    var FakeRTCDataChannel = class extends FakeEventTarget_1.FakeEventTarget {
      // Members for RTCDataChannel standard public getters/setters.
      _id;
      _negotiated = true;
      // mediasoup just uses negotiated DataChannels.
      _ordered;
      _maxPacketLifeTime;
      _maxRetransmits;
      _label;
      _protocol;
      _readyState = "connecting";
      _bufferedAmount = 0;
      _bufferedAmountLowThreshold = 0;
      _binaryType = "arraybuffer";
      // Events.
      _onopen = null;
      _onclosing = null;
      _onclose = null;
      _onmessage = null;
      _onbufferedamountlow = null;
      _onerror = null;
      constructor({ id, ordered = true, maxPacketLifeTime = null, maxRetransmits = null, label = "", protocol = "" }) {
        super();
        logger.debug(`constructor() [id:${id}, ordered:${ordered}, maxPacketLifeTime:${maxPacketLifeTime}, maxRetransmits:${maxRetransmits}, label:${label}, protocol:${protocol}`);
        this._id = id;
        this._ordered = ordered;
        this._maxPacketLifeTime = maxPacketLifeTime;
        this._maxRetransmits = maxRetransmits;
        this._label = label;
        this._protocol = protocol;
      }
      get id() {
        return this._id;
      }
      get negotiated() {
        return this._negotiated;
      }
      get ordered() {
        return this._ordered;
      }
      get maxPacketLifeTime() {
        return this._maxPacketLifeTime;
      }
      get maxRetransmits() {
        return this._maxRetransmits;
      }
      get label() {
        return this._label;
      }
      get protocol() {
        return this._protocol;
      }
      get readyState() {
        return this._readyState;
      }
      get bufferedAmount() {
        return this._bufferedAmount;
      }
      get bufferedAmountLowThreshold() {
        return this._bufferedAmountLowThreshold;
      }
      set bufferedAmountLowThreshold(value) {
        this._bufferedAmountLowThreshold = value;
      }
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(binaryType) {
        this._binaryType = binaryType;
      }
      get onopen() {
        return this._onopen;
      }
      set onopen(handler) {
        if (this._onopen) {
          this.removeEventListener("open", this._onopen);
        }
        this._onopen = handler;
        if (handler) {
          this.addEventListener("open", handler);
        }
      }
      get onclosing() {
        return this._onclosing;
      }
      set onclosing(handler) {
        if (this._onclosing) {
          this.removeEventListener("closing", this._onclosing);
        }
        this._onclosing = handler;
        if (handler) {
          this.addEventListener("closing", handler);
        }
      }
      get onclose() {
        return this._onclose;
      }
      set onclose(handler) {
        if (this._onclose) {
          this.removeEventListener("close", this._onclose);
        }
        this._onclose = handler;
        if (handler) {
          this.addEventListener("close", handler);
        }
      }
      get onmessage() {
        return this._onmessage;
      }
      set onmessage(handler) {
        if (this._onmessage) {
          this.removeEventListener("message", this._onmessage);
        }
        this._onmessage = handler;
        if (handler) {
          this.addEventListener("message", handler);
        }
      }
      get onbufferedamountlow() {
        return this._onbufferedamountlow;
      }
      set onbufferedamountlow(handler) {
        if (this._onbufferedamountlow) {
          this.removeEventListener("bufferedamountlow", this._onbufferedamountlow);
        }
        this._onbufferedamountlow = handler;
        if (handler) {
          this.addEventListener("bufferedamountlow", handler);
        }
      }
      get onerror() {
        return this._onerror;
      }
      set onerror(handler) {
        if (this._onerror) {
          this.removeEventListener("error", this._onerror);
        }
        this._onerror = handler;
        if (handler) {
          this.addEventListener("error", handler);
        }
      }
      addEventListener(type, listener, options) {
        super.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        super.removeEventListener(type, listener, options);
      }
      close() {
        if (["closing", "closed"].includes(this._readyState)) {
          return;
        }
        this._readyState = "closed";
      }
      /**
       * We extend the definition of send() to allow Node Buffer. However
       * ArrayBufferView and Blob do not exist in Node.
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      send(data2) {
        if (this._readyState !== "open") {
          throw new errors_1.InvalidStateError("not open");
        }
      }
    };
  }
});

// node_modules/mediasoup-client/lib/test/fakeParameters.js
var require_fakeParameters = __commonJS({
  "node_modules/mediasoup-client/lib/test/fakeParameters.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.generateRouterRtpCapabilities = generateRouterRtpCapabilities;
    exports.generateNativeRtpCapabilities = generateNativeRtpCapabilities;
    exports.generateNativeSctpCapabilities = generateNativeSctpCapabilities;
    exports.generateLocalDtlsParameters = generateLocalDtlsParameters;
    exports.generateTransportRemoteParameters = generateTransportRemoteParameters;
    exports.generateProducerRemoteParameters = generateProducerRemoteParameters;
    exports.generateConsumerRemoteParameters = generateConsumerRemoteParameters;
    exports.generateDataProducerRemoteParameters = generateDataProducerRemoteParameters;
    exports.generateDataConsumerRemoteParameters = generateDataConsumerRemoteParameters;
    var utils = require_utils();
    function generateFakeUuid() {
      return String(utils.generateRandomNumber());
    }
    function generateRouterRtpCapabilities() {
      return utils.deepFreeze({
        codecs: [
          {
            mimeType: "audio/opus",
            kind: "audio",
            preferredPayloadType: 100,
            clockRate: 48e3,
            channels: 2,
            rtcpFeedback: [{ type: "transport-cc" }],
            parameters: {
              useinbandfec: 1,
              foo: "bar"
            }
          },
          {
            mimeType: "video/VP8",
            kind: "video",
            preferredPayloadType: 101,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "nack" },
              { type: "nack", parameter: "pli" },
              { type: "ccm", parameter: "fir" },
              { type: "goog-remb" },
              { type: "transport-cc" }
            ],
            parameters: {
              "x-google-start-bitrate": 1500
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 102,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 101
            }
          },
          {
            mimeType: "video/H264",
            kind: "video",
            preferredPayloadType: 103,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "nack" },
              { type: "nack", parameter: "pli" },
              { type: "ccm", parameter: "fir" },
              { type: "goog-remb" },
              { type: "transport-cc" }
            ],
            parameters: {
              "level-asymmetry-allowed": 1,
              "packetization-mode": 1,
              "profile-level-id": "42e01f"
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 104,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 103
            }
          },
          {
            mimeType: "video/VP9",
            kind: "video",
            preferredPayloadType: 105,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "nack" },
              { type: "nack", parameter: "pli" },
              { type: "ccm", parameter: "fir" },
              { type: "goog-remb" },
              { type: "transport-cc" }
            ],
            parameters: {
              "profile-id": 0,
              "x-google-start-bitrate": 1500
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 106,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 105
            }
          }
        ],
        headerExtensions: [
          {
            kind: "audio",
            uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
            preferredId: 1,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
            preferredId: 1,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:sdes:rtp-stream-id",
            preferredId: 2,
            preferredEncrypt: false,
            direction: "recvonly"
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:sdes:repaired-rtp-stream-id",
            preferredId: 3,
            preferredEncrypt: false,
            direction: "recvonly"
          },
          {
            kind: "audio",
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
            preferredId: 4,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "video",
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
            preferredId: 4,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "audio",
            uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
            preferredId: 5,
            preferredEncrypt: false,
            direction: "recvonly"
          },
          {
            kind: "video",
            uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
            preferredId: 5,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "audio",
            uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
            preferredId: 10,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "video",
            uri: "urn:3gpp:video-orientation",
            preferredId: 11,
            preferredEncrypt: false,
            direction: "sendrecv"
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:toffset",
            preferredId: 12,
            preferredEncrypt: false,
            direction: "sendrecv"
          }
        ]
      });
    }
    function generateNativeRtpCapabilities() {
      return {
        codecs: [
          {
            mimeType: "audio/opus",
            kind: "audio",
            preferredPayloadType: 111,
            clockRate: 48e3,
            channels: 2,
            rtcpFeedback: [{ type: "transport-cc" }],
            parameters: {
              minptime: 10,
              useinbandfec: 1
            }
          },
          {
            mimeType: "audio/ISAC",
            kind: "audio",
            preferredPayloadType: 103,
            clockRate: 16e3,
            channels: 1,
            rtcpFeedback: [{ type: "transport-cc" }],
            parameters: {}
          },
          {
            mimeType: "audio/CN",
            kind: "audio",
            preferredPayloadType: 106,
            clockRate: 32e3,
            channels: 1,
            rtcpFeedback: [{ type: "transport-cc" }],
            parameters: {}
          },
          {
            mimeType: "audio/foo",
            kind: "audio",
            preferredPayloadType: 107,
            clockRate: 9e4,
            channels: 4,
            rtcpFeedback: [{ type: "foo-qwe-qwe" }],
            parameters: {
              foo: "lalala"
            }
          },
          {
            mimeType: "video/BAZCODEC",
            kind: "video",
            preferredPayloadType: 100,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "foo" },
              { type: "transport-cc" },
              { type: "ccm", parameter: "fir" },
              { type: "nack" },
              { type: "nack", parameter: "pli" }
            ],
            parameters: {
              baz: "1234abcd"
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 101,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 100
            }
          },
          {
            mimeType: "video/VP8",
            kind: "video",
            preferredPayloadType: 96,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "goog-remb" },
              { type: "transport-cc" },
              { type: "ccm", parameter: "fir" },
              { type: "nack" },
              { type: "nack", parameter: "pli" }
            ],
            parameters: {
              baz: "1234abcd"
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 97,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 96
            }
          },
          {
            mimeType: "video/VP9",
            kind: "video",
            preferredPayloadType: 98,
            clockRate: 9e4,
            rtcpFeedback: [
              { type: "goog-remb" },
              { type: "transport-cc" },
              { type: "ccm", parameter: "fir" },
              { type: "nack" },
              { type: "nack", parameter: "pli" }
            ],
            parameters: {
              "profile-id": 0
            }
          },
          {
            mimeType: "video/rtx",
            kind: "video",
            preferredPayloadType: 99,
            clockRate: 9e4,
            rtcpFeedback: [],
            parameters: {
              apt: 98
            }
          }
        ],
        headerExtensions: [
          {
            kind: "audio",
            uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
            preferredId: 1
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
            preferredId: 1
          },
          {
            kind: "video",
            uri: "urn:ietf:params:rtp-hdrext:toffset",
            preferredId: 2
          },
          {
            kind: "video",
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
            preferredId: 3
          },
          {
            kind: "video",
            uri: "urn:3gpp:video-orientation",
            preferredId: 4
          },
          {
            kind: "video",
            uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
            preferredId: 5
          },
          {
            kind: "video",
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/playout-delay",
            preferredId: 6
          },
          {
            kind: "video",
            // @ts-expect-error --- ON purpose.
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-content-type",
            preferredId: 7
          },
          {
            kind: "video",
            // @ts-expect-error --- ON purpose.
            uri: "http://www.webrtc.org/experiments/rtp-hdrext/video-timing",
            preferredId: 8
          },
          {
            kind: "audio",
            uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
            preferredId: 10
          }
        ]
      };
    }
    function generateNativeSctpCapabilities() {
      return utils.deepFreeze({
        numStreams: { OS: 2048, MIS: 2048 }
      });
    }
    function generateLocalDtlsParameters() {
      return utils.deepFreeze({
        fingerprints: [
          {
            algorithm: "sha-256",
            value: "82:5A:68:3D:36:C3:0A:DE:AF:E7:32:43:D2:88:83:57:AC:2D:65:E5:80:C4:B6:FB:AF:1A:A0:21:9F:6D:0C:AD"
          }
        ],
        role: "auto"
      });
    }
    function generateTransportRemoteParameters() {
      return {
        id: generateFakeUuid(),
        iceParameters: utils.deepFreeze({
          iceLite: true,
          password: "yku5ej8nvfaor28lvtrabcx0wkrpkztz",
          usernameFragment: "h3hk1iz6qqlnqlne"
        }),
        iceCandidates: utils.deepFreeze([
          {
            foundation: "udpcandidate",
            address: "9.9.9.9",
            ip: "9.9.9.9",
            port: 40533,
            priority: 1078862079,
            protocol: "udp",
            type: "host",
            tcpType: "passive"
          },
          {
            foundation: "udpcandidate",
            address: "9.9.9.9",
            ip: "9:9:9:9:9:9",
            port: 41333,
            priority: 1078862089,
            protocol: "udp",
            type: "host",
            tcpType: "passive"
          }
        ]),
        dtlsParameters: utils.deepFreeze({
          fingerprints: [
            {
              algorithm: "sha-256",
              value: "A9:F4:E0:D2:74:D3:0F:D9:CA:A5:2F:9F:7F:47:FA:F0:C4:72:DD:73:49:D0:3B:14:90:20:51:30:1B:90:8E:71"
            },
            {
              algorithm: "sha-384",
              value: "03:D9:0B:87:13:98:F6:6D:BC:FC:92:2E:39:D4:E1:97:32:61:30:56:84:70:81:6E:D1:82:97:EA:D9:C1:21:0F:6B:C5:E7:7F:E1:97:0C:17:97:6E:CF:B3:EF:2E:74:B0"
            },
            {
              algorithm: "sha-512",
              value: "84:27:A4:28:A4:73:AF:43:02:2A:44:68:FF:2F:29:5C:3B:11:9A:60:F4:A8:F0:F5:AC:A0:E3:49:3E:B1:34:53:A9:85:CE:51:9B:ED:87:5E:B8:F4:8E:3D:FA:20:51:B8:96:EE:DA:56:DC:2F:5C:62:79:15:23:E0:21:82:2B:2C"
            }
          ],
          role: "auto"
        }),
        sctpParameters: utils.deepFreeze({
          port: 5e3,
          OS: 2048,
          MIS: 2048,
          maxMessageSize: 2e6
        })
      };
    }
    function generateProducerRemoteParameters() {
      return utils.deepFreeze({
        id: generateFakeUuid()
      });
    }
    function generateConsumerRemoteParameters({ id, codecMimeType } = {}) {
      switch (codecMimeType) {
        case "audio/opus": {
          return {
            id: id ?? generateFakeUuid(),
            producerId: generateFakeUuid(),
            kind: "audio",
            rtpParameters: utils.deepFreeze({
              codecs: [
                {
                  mimeType: "audio/opus",
                  payloadType: 100,
                  clockRate: 48e3,
                  channels: 2,
                  rtcpFeedback: [{ type: "transport-cc" }],
                  parameters: {
                    useinbandfec: 1,
                    foo: "bar"
                  }
                }
              ],
              encodings: [
                {
                  ssrc: 46687003
                }
              ],
              headerExtensions: [
                {
                  uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                  id: 1
                },
                {
                  uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                  id: 5
                },
                {
                  uri: "urn:ietf:params:rtp-hdrext:ssrc-audio-level",
                  id: 10
                }
              ],
              rtcp: {
                cname: "wB4Ql4lrsxYLjzuN",
                reducedSize: true,
                mux: true
              }
            })
          };
        }
        case "audio/ISAC": {
          return {
            id: id ?? generateFakeUuid(),
            producerId: generateFakeUuid(),
            kind: "audio",
            rtpParameters: utils.deepFreeze({
              codecs: [
                {
                  mimeType: "audio/ISAC",
                  payloadType: 111,
                  clockRate: 16e3,
                  channels: 1,
                  rtcpFeedback: [{ type: "transport-cc" }],
                  parameters: {}
                }
              ],
              encodings: [
                {
                  ssrc: 46687004
                }
              ],
              headerExtensions: [
                {
                  uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                  id: 1
                },
                {
                  uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                  id: 5
                }
              ],
              rtcp: {
                cname: "wB4Ql4lrsxYLjzuN",
                reducedSize: true,
                mux: true
              }
            })
          };
        }
        case "video/VP8": {
          return {
            id: id ?? generateFakeUuid(),
            producerId: generateFakeUuid(),
            kind: "video",
            rtpParameters: utils.deepFreeze({
              codecs: [
                {
                  mimeType: "video/VP8",
                  payloadType: 101,
                  clockRate: 9e4,
                  rtcpFeedback: [
                    { type: "nack" },
                    { type: "nack", parameter: "pli" },
                    { type: "ccm", parameter: "fir" },
                    { type: "goog-remb" },
                    { type: "transport-cc" }
                  ],
                  parameters: {
                    "x-google-start-bitrate": 1500
                  }
                },
                {
                  mimeType: "video/rtx",
                  payloadType: 102,
                  clockRate: 9e4,
                  rtcpFeedback: [],
                  parameters: {
                    apt: 101
                  }
                }
              ],
              encodings: [
                {
                  ssrc: 99991111,
                  rtx: {
                    ssrc: 99991112
                  }
                }
              ],
              headerExtensions: [
                {
                  uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                  id: 1
                },
                {
                  uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                  id: 4
                },
                {
                  uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                  id: 5
                },
                {
                  uri: "urn:3gpp:video-orientation",
                  id: 11
                },
                {
                  uri: "urn:ietf:params:rtp-hdrext:toffset",
                  id: 12
                }
              ],
              rtcp: {
                cname: "wB4Ql4lrsxYLjzuN",
                reducedSize: true,
                mux: true
              }
            })
          };
        }
        case "video/H264": {
          return {
            id: id ?? generateFakeUuid(),
            producerId: generateFakeUuid(),
            kind: "video",
            rtpParameters: utils.deepFreeze({
              codecs: [
                {
                  mimeType: "video/H264",
                  payloadType: 103,
                  clockRate: 9e4,
                  rtcpFeedback: [
                    { type: "nack" },
                    { type: "nack", parameter: "pli" },
                    { type: "ccm", parameter: "fir" },
                    { type: "goog-remb" },
                    { type: "transport-cc" }
                  ],
                  parameters: {
                    "level-asymmetry-allowed": 1,
                    "packetization-mode": 1,
                    "profile-level-id": "42e01f"
                  }
                },
                {
                  mimeType: "video/rtx",
                  payloadType: 104,
                  clockRate: 9e4,
                  rtcpFeedback: [],
                  parameters: {
                    apt: 103
                  }
                }
              ],
              encodings: [
                {
                  ssrc: 99991113,
                  rtx: {
                    ssrc: 99991114
                  }
                }
              ],
              headerExtensions: [
                {
                  uri: "urn:ietf:params:rtp-hdrext:sdes:mid",
                  id: 1
                },
                {
                  uri: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time",
                  id: 4
                },
                {
                  uri: "http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01",
                  id: 5
                },
                {
                  uri: "urn:3gpp:video-orientation",
                  id: 11
                },
                {
                  uri: "urn:ietf:params:rtp-hdrext:toffset",
                  id: 12
                }
              ],
              rtcp: {
                cname: "wB4Ql4lrsxYLjzuN",
                reducedSize: true,
                mux: true
              }
            })
          };
        }
        default: {
          throw new TypeError(`unknown codecMimeType '${codecMimeType}'`);
        }
      }
    }
    function generateDataProducerRemoteParameters() {
      return utils.deepFreeze({
        id: generateFakeUuid()
      });
    }
    function generateDataConsumerRemoteParameters({ id } = {}) {
      return {
        id: id ?? generateFakeUuid(),
        dataProducerId: generateFakeUuid(),
        sctpStreamParameters: utils.deepFreeze({
          streamId: 666,
          maxPacketLifeTime: 5e3,
          maxRetransmits: void 0
        })
      };
    }
  }
});

// node_modules/mediasoup-client/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/mediasoup-client/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.debug = exports.testFakeParameters = exports.FakeHandler = exports.enhancedEvents = exports.ortc = exports.parseScalabilityMode = exports.detectDeviceAsync = exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
    var debug_1 = require_browser();
    exports.debug = debug_1.default;
    exports.types = require_types();
    exports.version = "3.18.6";
    var Device_1 = require_Device();
    Object.defineProperty(exports, "Device", { enumerable: true, get: function() {
      return Device_1.Device;
    } });
    Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function() {
      return Device_1.detectDevice;
    } });
    Object.defineProperty(exports, "detectDeviceAsync", { enumerable: true, get: function() {
      return Device_1.detectDeviceAsync;
    } });
    var scalabilityModes_1 = require_scalabilityModes();
    Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function() {
      return scalabilityModes_1.parse;
    } });
    exports.ortc = require_ortc();
    exports.enhancedEvents = require_enhancedEvents();
    var FakeHandler_1 = require_FakeHandler();
    Object.defineProperty(exports, "FakeHandler", { enumerable: true, get: function() {
      return FakeHandler_1.FakeHandler;
    } });
    exports.testFakeParameters = require_fakeParameters();
  }
});

// node_modules/@mediapipe/tasks-vision/vision_bundle.mjs
var vision_bundle_exports = {};
__export(vision_bundle_exports, {
  DrawingUtils: () => Ja,
  FaceDetector: () => _c,
  FaceLandmarker: () => Ic,
  FilesetResolver: () => na,
  GestureRecognizer: () => Oc,
  HandLandmarker: () => Uc,
  HolisticLandmarker: () => Vc,
  ImageClassifier: () => Xc,
  ImageEmbedder: () => Hc,
  ImageSegmenter: () => qc,
  ImageSegmenterResult: () => Wc,
  InteractiveSegmenter: () => Jc,
  InteractiveSegmenterResult: () => $c,
  MPImage: () => oc,
  MPMask: () => Ga,
  ObjectDetector: () => Zc,
  PoseLandmarker: () => nh,
  TaskRunner: () => _a,
  VisionTaskRunner: () => yc
});
function e(e2, n2) {
  t: {
    for (var r2 = ["CLOSURE_FLAGS"], i2 = t, s2 = 0; s2 < r2.length; s2++) if (null == (i2 = i2[r2[s2]])) {
      r2 = null;
      break t;
    }
    r2 = i2;
  }
  return null != (e2 = r2 && r2[e2]) ? e2 : n2;
}
function n() {
  throw Error("Invalid UTF8");
}
function r(t2, e2) {
  return e2 = String.fromCharCode.apply(null, e2), null == t2 ? e2 : t2 + e2;
}
function h(t2) {
  if (c) t2 = (a ||= new TextEncoder()).encode(t2);
  else {
    let n2 = 0;
    const r2 = new Uint8Array(3 * t2.length);
    for (let i2 = 0; i2 < t2.length; i2++) {
      var e2 = t2.charCodeAt(i2);
      if (e2 < 128) r2[n2++] = e2;
      else {
        if (e2 < 2048) r2[n2++] = e2 >> 6 | 192;
        else {
          if (e2 >= 55296 && e2 <= 57343) {
            if (e2 <= 56319 && i2 < t2.length) {
              const s2 = t2.charCodeAt(++i2);
              if (s2 >= 56320 && s2 <= 57343) {
                e2 = 1024 * (e2 - 55296) + s2 - 56320 + 65536, r2[n2++] = e2 >> 18 | 240, r2[n2++] = e2 >> 12 & 63 | 128, r2[n2++] = e2 >> 6 & 63 | 128, r2[n2++] = 63 & e2 | 128;
                continue;
              }
              i2--;
            }
            e2 = 65533;
          }
          r2[n2++] = e2 >> 12 | 224, r2[n2++] = e2 >> 6 & 63 | 128;
        }
        r2[n2++] = 63 & e2 | 128;
      }
    }
    t2 = n2 === r2.length ? r2 : r2.subarray(0, n2);
  }
  return t2;
}
function u(e2) {
  t.setTimeout((() => {
    throw e2;
  }), 0);
}
function m() {
  var e2 = t.navigator;
  return e2 && (e2 = e2.userAgent) ? e2 : "";
}
function _(t2) {
  return _[" "](t2), t2;
}
function w(t2) {
  const e2 = t2.length;
  let n2 = 3 * e2 / 4;
  n2 % 3 ? n2 = Math.floor(n2) : -1 != "=.".indexOf(t2[e2 - 1]) && (n2 = -1 != "=.".indexOf(t2[e2 - 2]) ? n2 - 2 : n2 - 1);
  const r2 = new Uint8Array(n2);
  let i2 = 0;
  return (function(t3, e3) {
    function n3(e4) {
      for (; r3 < t3.length; ) {
        const e5 = t3.charAt(r3++), n4 = E[e5];
        if (null != n4) return n4;
        if (!/^[\s\xa0]*$/.test(e5)) throw Error("Unknown base64 encoding at char: " + e5);
      }
      return e4;
    }
    T();
    let r3 = 0;
    for (; ; ) {
      const t4 = n3(-1), r4 = n3(0), i3 = n3(64), s2 = n3(64);
      if (64 === s2 && -1 === t4) break;
      e3(t4 << 2 | r4 >> 4), 64 != i3 && (e3(r4 << 4 & 240 | i3 >> 2), 64 != s2 && e3(i3 << 6 & 192 | s2));
    }
  })(t2, (function(t3) {
    r2[i2++] = t3;
  })), i2 !== n2 ? r2.subarray(0, i2) : r2;
}
function T() {
  if (!E) {
    E = {};
    var t2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), e2 = ["+/=", "+/", "-_=", "-_.", "-_"];
    for (let n2 = 0; n2 < 5; n2++) {
      const r2 = t2.concat(e2[n2].split(""));
      v[n2] = r2;
      for (let t3 = 0; t3 < r2.length; t3++) {
        const e3 = r2[t3];
        void 0 === E[e3] && (E[e3] = t3);
      }
    }
  }
}
function x(t2) {
  return S[t2] || "";
}
function L(t2) {
  if (!b) return w(t2);
  t2 = k.test(t2) ? t2.replace(k, x) : t2, t2 = atob(t2);
  const e2 = new Uint8Array(t2.length);
  for (let n2 = 0; n2 < t2.length; n2++) e2[n2] = t2.charCodeAt(n2);
  return e2;
}
function R(t2) {
  return A && null != t2 && t2 instanceof Uint8Array;
}
function F() {
  return C ||= new P(null, I);
}
function M(t2) {
  N(I);
  var e2 = t2.g;
  return null == (e2 = null == e2 || R(e2) ? e2 : "string" == typeof e2 ? L(e2) : null) ? e2 : t2.g = e2;
}
function N(t2) {
  if (t2 !== I) throw Error("illegal external caller");
}
function U(t2, e2) {
  t2.__closure__error__context__984382 || (t2.__closure__error__context__984382 = {}), t2.__closure__error__context__984382.severity = e2;
}
function D(t2) {
  return U(t2 = Error(t2), "warning"), t2;
}
function B(t2, e2) {
  if (null != t2) {
    var n2 = O ??= {}, r2 = n2[t2] || 0;
    r2 >= e2 || (n2[t2] = r2 + 1, U(t2 = Error(), "incident"), u(t2));
  }
}
function G() {
  return "function" == typeof BigInt;
}
function V(t2, e2, n2 = false) {
  return "function" == typeof Symbol && "symbol" == typeof /* @__PURE__ */ Symbol() ? n2 && Symbol.for && t2 ? Symbol.for(t2) : null != t2 ? Symbol(t2) : /* @__PURE__ */ Symbol() : e2;
}
function it(t2, e2) {
  j || et in t2 || tt(t2, Q), t2[et] |= e2;
}
function st(t2, e2) {
  j || et in t2 || tt(t2, Q), t2[et] = e2;
}
function ot(t2) {
  return it(t2, 34), t2;
}
function at(t2) {
  return it(t2, 8192), t2;
}
function ht(t2, e2) {
  return void 0 === e2 ? t2.h !== ut && !!(2 & (0 | t2.v[et])) : !!(2 & e2) && t2.h !== ut;
}
function lt(t2, e2) {
  if (null != t2) {
    if ("string" == typeof t2) t2 = t2 ? new P(t2, I) : F();
    else if (t2.constructor !== P) if (R(t2)) t2 = t2.length ? new P(new Uint8Array(t2), I) : F();
    else {
      if (!e2) throw Error();
      t2 = void 0;
    }
  }
  return t2;
}
function pt(t2, e2, n2) {
  const r2 = 128 & e2 ? 0 : -1, i2 = t2.length;
  var s2;
  (s2 = !!i2) && (s2 = null != (s2 = t2[i2 - 1]) && "object" == typeof s2 && s2.constructor === Object);
  const o2 = i2 + (s2 ? -1 : 0);
  for (e2 = 128 & e2 ? 1 : 0; e2 < o2; e2++) n2(e2 - r2, t2[e2]);
  if (s2) {
    t2 = t2[i2 - 1];
    for (const e3 in t2) !isNaN(e3) && n2(+e3, t2[e3]);
  }
}
function mt(t2) {
  return 128 & t2 ? gt : void 0;
}
function yt(t2) {
  return t2.Na = true, t2;
}
function Tt(t2) {
  var e2 = t2;
  if (vt(e2)) {
    if (!/^\s*(?:-?[1-9]\d*|0)?\s*$/.test(e2)) throw Error(String(e2));
  } else if (_t(e2) && !Number.isSafeInteger(e2)) throw Error(String(e2));
  return wt ? BigInt(t2) : t2 = Et(t2) ? t2 ? "1" : "0" : vt(t2) ? t2.trim() || "0" : String(t2);
}
function Lt(t2, e2) {
  if (t2.length > e2.length) return false;
  if (t2.length < e2.length || t2 === e2) return true;
  for (let n2 = 0; n2 < t2.length; n2++) {
    const r2 = t2[n2], i2 = e2[n2];
    if (r2 > i2) return false;
    if (r2 < i2) return true;
  }
}
function Pt(t2) {
  const e2 = t2 >>> 0;
  Ft = e2, Mt = (t2 - e2) / 4294967296 >>> 0;
}
function Ct(t2) {
  if (t2 < 0) {
    Pt(-t2);
    const [e2, n2] = Ht(Ft, Mt);
    Ft = e2 >>> 0, Mt = n2 >>> 0;
  } else Pt(t2);
}
function Ot(t2) {
  const e2 = It ||= new DataView(new ArrayBuffer(8));
  e2.setFloat32(0, +t2, true), Mt = 0, Ft = e2.getUint32(0, true);
}
function Nt(t2, e2) {
  const n2 = 4294967296 * e2 + (t2 >>> 0);
  return Number.isSafeInteger(n2) ? n2 : Gt(t2, e2);
}
function Ut(t2, e2) {
  return Tt(G() ? BigInt.asUintN(64, (BigInt(e2 >>> 0) << BigInt(32)) + BigInt(t2 >>> 0)) : Gt(t2, e2));
}
function Dt(t2, e2) {
  const n2 = 2147483648 & e2;
  return n2 && (e2 = ~e2 >>> 0, 0 == (t2 = 1 + ~t2 >>> 0) && (e2 = e2 + 1 >>> 0)), "number" == typeof (t2 = Nt(t2, e2)) ? n2 ? -t2 : t2 : n2 ? "-" + t2 : t2;
}
function Bt(t2, e2) {
  return G() ? Tt(BigInt.asIntN(64, (BigInt.asUintN(32, BigInt(e2)) << BigInt(32)) + BigInt.asUintN(32, BigInt(t2)))) : Tt(Vt(t2, e2));
}
function Gt(t2, e2) {
  if (t2 >>>= 0, (e2 >>>= 0) <= 2097151) var n2 = "" + (4294967296 * e2 + t2);
  else G() ? n2 = "" + (BigInt(e2) << BigInt(32) | BigInt(t2)) : (t2 = (16777215 & t2) + 6777216 * (n2 = 16777215 & (t2 >>> 24 | e2 << 8)) + 6710656 * (e2 = e2 >> 16 & 65535), n2 += 8147497 * e2, e2 *= 2, t2 >= 1e7 && (n2 += t2 / 1e7 >>> 0, t2 %= 1e7), n2 >= 1e7 && (e2 += n2 / 1e7 >>> 0, n2 %= 1e7), n2 = e2 + jt(n2) + jt(t2));
  return n2;
}
function jt(t2) {
  return t2 = String(t2), "0000000".slice(t2.length) + t2;
}
function Vt(t2, e2) {
  if (2147483648 & e2) if (G()) t2 = "" + (BigInt(0 | e2) << BigInt(32) | BigInt(t2 >>> 0));
  else {
    const [n2, r2] = Ht(t2, e2);
    t2 = "-" + Gt(n2, r2);
  }
  else t2 = Gt(t2, e2);
  return t2;
}
function Xt(t2) {
  if (t2.length < 16) Ct(Number(t2));
  else if (G()) t2 = BigInt(t2), Ft = Number(t2 & BigInt(4294967295)) >>> 0, Mt = Number(t2 >> BigInt(32) & BigInt(4294967295));
  else {
    const e2 = +("-" === t2[0]);
    Mt = Ft = 0;
    const n2 = t2.length;
    for (let r2 = e2, i2 = (n2 - e2) % 6 + e2; i2 <= n2; r2 = i2, i2 += 6) {
      const e3 = Number(t2.slice(r2, i2));
      Mt *= 1e6, Ft = 1e6 * Ft + e3, Ft >= 4294967296 && (Mt += Math.trunc(Ft / 4294967296), Mt >>>= 0, Ft >>>= 0);
    }
    if (e2) {
      const [t3, e3] = Ht(Ft, Mt);
      Ft = t3, Mt = e3;
    }
  }
}
function Ht(t2, e2) {
  return e2 = ~e2, t2 ? t2 = 1 + ~t2 : e2 += 1, [t2, e2];
}
function Wt(t2) {
  return Array.prototype.slice.call(t2);
}
function Zt(t2) {
  if (null != t2 && "number" != typeof t2) throw Error(`Value of float/double field must be a number, found ${typeof t2}: ${t2}`);
  return t2;
}
function Qt(t2) {
  return null == t2 || "number" == typeof t2 ? t2 : "NaN" === t2 || "Infinity" === t2 || "-Infinity" === t2 ? Number(t2) : void 0;
}
function te(t2) {
  if (null != t2 && "boolean" != typeof t2) {
    var e2 = typeof t2;
    throw Error(`Expected boolean but got ${"object" != e2 ? e2 : t2 ? Array.isArray(t2) ? "array" : e2 : "null"}: ${t2}`);
  }
  return t2;
}
function ee(t2) {
  return null == t2 || "boolean" == typeof t2 ? t2 : "number" == typeof t2 ? !!t2 : void 0;
}
function re(t2) {
  switch (typeof t2) {
    case "bigint":
      return true;
    case "number":
      return qt(t2);
    case "string":
      return ne.test(t2);
    default:
      return false;
  }
}
function ie(t2) {
  if (null == t2) return t2;
  if ("string" == typeof t2 && t2) t2 = +t2;
  else if ("number" != typeof t2) return;
  return qt(t2) ? 0 | t2 : void 0;
}
function se(t2) {
  if (null == t2) return t2;
  if ("string" == typeof t2 && t2) t2 = +t2;
  else if ("number" != typeof t2) return;
  return qt(t2) ? t2 >>> 0 : void 0;
}
function oe(t2) {
  const e2 = t2.length;
  return ("-" === t2[0] ? e2 < 20 || 20 === e2 && t2 <= "-9223372036854775808" : e2 < 19 || 19 === e2 && t2 <= "9223372036854775807") ? t2 : (Xt(t2), Vt(Ft, Mt));
}
function ae(t2) {
  return t2 = $t(t2), Yt(t2) || (Ct(t2), t2 = Dt(Ft, Mt)), t2;
}
function ce(t2) {
  var e2 = $t(Number(t2));
  return Yt(e2) ? String(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), oe(t2));
}
function he(t2) {
  var e2 = $t(Number(t2));
  return Yt(e2) ? Tt(e2) : (-1 !== (e2 = t2.indexOf(".")) && (t2 = t2.substring(0, e2)), G() ? Tt(zt(64, BigInt(t2))) : Tt(oe(t2)));
}
function ue(t2) {
  return Yt(t2) ? t2 = Tt(ae(t2)) : (t2 = $t(t2), Yt(t2) ? t2 = String(t2) : (Ct(t2), t2 = Vt(Ft, Mt)), t2 = Tt(t2)), t2;
}
function le(t2) {
  return null == t2 ? t2 : "bigint" == typeof t2 ? (At(t2) ? t2 = Number(t2) : (t2 = zt(64, t2), t2 = At(t2) ? Number(t2) : String(t2)), t2) : re(t2) ? "number" == typeof t2 ? ae(t2) : ce(t2) : void 0;
}
function fe(t2) {
  const e2 = typeof t2;
  return null == t2 ? t2 : "bigint" === e2 ? Tt(zt(64, t2)) : re(t2) ? "string" === e2 ? he(t2) : ue(t2) : void 0;
}
function de(t2) {
  if ("string" != typeof t2) throw Error();
  return t2;
}
function pe(t2) {
  if (null != t2 && "string" != typeof t2) throw Error();
  return t2;
}
function ge(t2) {
  return null == t2 || "string" == typeof t2 ? t2 : void 0;
}
function me(t2, e2, n2, r2) {
  return null != t2 && t2[J] === ct ? t2 : Array.isArray(t2) ? ((r2 = (n2 = 0 | t2[et]) | 32 & r2 | 2 & r2) !== n2 && st(t2, r2), new e2(t2)) : (n2 ? 2 & r2 ? ((t2 = e2[H]) || (ot((t2 = new e2()).v), t2 = e2[H] = t2), e2 = t2) : e2 = new e2() : e2 = void 0, e2);
}
function ye(t2, e2, n2) {
  if (e2) t: {
    if (!re(e2 = t2)) throw D("int64");
    switch (typeof e2) {
      case "string":
        e2 = he(e2);
        break t;
      case "bigint":
        e2 = Tt(zt(64, e2));
        break t;
      default:
        e2 = ue(e2);
    }
  }
  else e2 = fe(t2);
  return null == (t2 = e2) ? n2 ? Jt : void 0 : t2;
}
function Te(t2) {
  return t2;
}
function Ae(t2) {
  if (2 & t2.J) throw Error("Cannot mutate an immutable Map");
}
function ke(t2, e2, n2, r2, i2, s2) {
  return t2 = me(t2, r2, n2, s2), i2 && (t2 = Ke(t2)), t2;
}
function Se(t2) {
  return [t2, this.get(t2)];
}
function Le() {
  return xe ||= new be(ot([]), void 0, void 0, void 0, _e);
}
function Re(t2) {
  return z ? t2[z] : void 0;
}
function Ie(t2, e2) {
  for (const n2 in t2) !isNaN(n2) && e2(t2, +n2, t2[n2]);
}
function Pe(t2, e2) {
  e2 < 100 || B(Y, 1);
}
function Ce(t2, e2, n2, r2) {
  const i2 = void 0 !== r2;
  r2 = !!r2;
  var s2, o2 = z;
  !i2 && j && o2 && (s2 = t2[o2]) && Ie(s2, Pe), o2 = [];
  var a2 = t2.length;
  let c2;
  s2 = 4294967295;
  let h2 = false;
  const u2 = !!(64 & e2), l2 = u2 ? 128 & e2 ? 0 : -1 : void 0;
  1 & e2 || (c2 = a2 && t2[a2 - 1], null != c2 && "object" == typeof c2 && c2.constructor === Object ? s2 = --a2 : c2 = void 0, !u2 || 128 & e2 || i2 || (h2 = true, s2 = s2 - l2 + l2)), e2 = void 0;
  for (var f2 = 0; f2 < a2; f2++) {
    let i3 = t2[f2];
    if (null != i3 && null != (i3 = n2(i3, r2))) if (u2 && f2 >= s2) {
      const t3 = f2 - l2;
      (e2 ??= {})[t3] = i3;
    } else o2[f2] = i3;
  }
  if (c2) for (let t3 in c2) {
    if (null == (a2 = c2[t3]) || null == (a2 = n2(a2, r2))) continue;
    let i3;
    f2 = +t3, u2 && !Number.isNaN(f2) && (i3 = f2 + l2) < s2 ? o2[i3] = a2 : (e2 ??= {})[t3] = a2;
  }
  return e2 && (h2 ? o2.push(e2) : o2[s2] = e2), i2 && z && (t2 = Re(t2)) && t2 instanceof Fe && (o2[z] = (function(t3) {
    const e3 = new Fe();
    return Ie(t3, ((t4, n3, r3) => {
      e3[n3] = Wt(r3);
    })), e3.da = t3.da, e3;
  })(t2)), o2;
}
function Oe(t2) {
  return t2[0] = Ne(t2[0]), t2[1] = Ne(t2[1]), t2;
}
function Ne(t2) {
  switch (typeof t2) {
    case "number":
      return Number.isFinite(t2) ? t2 : "" + t2;
    case "bigint":
      return At(t2) ? Number(t2) : "" + t2;
    case "boolean":
      return t2 ? 1 : 0;
    case "object":
      if (Array.isArray(t2)) {
        var e2 = 0 | t2[et];
        return 0 === t2.length && 1 & e2 ? void 0 : Ce(t2, e2, Ne);
      }
      if (null != t2 && t2[J] === ct) return Ue(t2);
      if (t2 instanceof P) {
        if (null == (e2 = t2.g)) t2 = "";
        else if ("string" == typeof e2) t2 = e2;
        else {
          if (b) {
            for (var n2 = "", r2 = 0, i2 = e2.length - 10240; r2 < i2; ) n2 += String.fromCharCode.apply(null, e2.subarray(r2, r2 += 10240));
            n2 += String.fromCharCode.apply(null, r2 ? e2.subarray(r2) : e2), e2 = btoa(n2);
          } else {
            void 0 === n2 && (n2 = 0), T(), n2 = v[n2], r2 = Array(Math.floor(e2.length / 3)), i2 = n2[64] || "";
            let t3 = 0, h2 = 0;
            for (; t3 < e2.length - 2; t3 += 3) {
              var s2 = e2[t3], o2 = e2[t3 + 1], a2 = e2[t3 + 2], c2 = n2[s2 >> 2];
              s2 = n2[(3 & s2) << 4 | o2 >> 4], o2 = n2[(15 & o2) << 2 | a2 >> 6], a2 = n2[63 & a2], r2[h2++] = c2 + s2 + o2 + a2;
            }
            switch (c2 = 0, a2 = i2, e2.length - t3) {
              case 2:
                a2 = n2[(15 & (c2 = e2[t3 + 1])) << 2] || i2;
              case 1:
                e2 = e2[t3], r2[h2] = n2[e2 >> 2] + n2[(3 & e2) << 4 | c2 >> 4] + a2 + i2;
            }
            e2 = r2.join("");
          }
          t2 = t2.g = e2;
        }
        return t2;
      }
      return t2 instanceof be ? t2 = 0 !== t2.size ? t2.V(Oe) : void 0 : void 0;
  }
  return t2;
}
function Ue(t2) {
  return Ce(t2 = t2.v, 0 | t2[et], Ne);
}
function Ge(t2, e2) {
  return je(t2, e2[0], e2[1]);
}
function je(t2, e2, n2, r2 = 0) {
  if (null == t2) {
    var i2 = 32;
    n2 ? (t2 = [n2], i2 |= 128) : t2 = [], e2 && (i2 = -16760833 & i2 | (1023 & e2) << 14);
  } else {
    if (!Array.isArray(t2)) throw Error("narr");
    if (i2 = 0 | t2[et], d && 1 & i2) throw Error("rfarr");
    if (2048 & i2 && !(2 & i2) && (function() {
      if (d) throw Error("carr");
      B($, 5);
    })(), 256 & i2) throw Error("farr");
    if (64 & i2) return (i2 | r2) !== i2 && st(t2, i2 | r2), t2;
    if (n2 && (i2 |= 128, n2 !== t2[0])) throw Error("mid");
    t: {
      i2 |= 64;
      var s2 = (n2 = t2).length;
      if (s2) {
        var o2 = s2 - 1;
        const t3 = n2[o2];
        if (null != t3 && "object" == typeof t3 && t3.constructor === Object) {
          if ((o2 -= e2 = 128 & i2 ? 0 : -1) >= 1024) throw Error("pvtlmt");
          for (var a2 in t3) (s2 = +a2) < o2 && (n2[s2 + e2] = t3[a2], delete t3[a2]);
          i2 = -16760833 & i2 | (1023 & o2) << 14;
          break t;
        }
      }
      if (e2) {
        if ((a2 = Math.max(e2, s2 - (128 & i2 ? 0 : -1))) > 1024) throw Error("spvt");
        i2 = -16760833 & i2 | (1023 & a2) << 14;
      }
    }
  }
  return st(t2, 64 | i2 | r2), t2;
}
function Ve(t2, e2) {
  if ("object" != typeof t2) return t2;
  if (Array.isArray(t2)) {
    var n2 = 0 | t2[et];
    return 0 === t2.length && 1 & n2 ? void 0 : Xe(t2, n2, e2);
  }
  if (null != t2 && t2[J] === ct) return We(t2);
  if (t2 instanceof be) {
    if (2 & (e2 = t2.J)) return t2;
    if (!t2.size) return;
    if (n2 = ot(t2.V()), t2.K) for (t2 = 0; t2 < n2.length; t2++) {
      const r2 = n2[t2];
      let i2 = r2[1];
      i2 = null == i2 || "object" != typeof i2 ? void 0 : null != i2 && i2[J] === ct ? We(i2) : Array.isArray(i2) ? Xe(i2, 0 | i2[et], !!(32 & e2)) : void 0, r2[1] = i2;
    }
    return n2;
  }
  return t2 instanceof P ? t2 : void 0;
}
function Xe(t2, e2, n2) {
  return 2 & e2 || (!n2 || 4096 & e2 || 16 & e2 ? t2 = ze(t2, e2, false, n2 && !(16 & e2)) : (it(t2, 34), 4 & e2 && Object.freeze(t2))), t2;
}
function He(t2, e2, n2) {
  return t2 = new t2.constructor(e2), n2 && (t2.h = ut), t2.m = ut, t2;
}
function We(t2) {
  const e2 = t2.v, n2 = 0 | e2[et];
  return ht(t2, n2) ? t2 : Je(t2, e2, n2) ? He(t2, e2) : ze(e2, n2);
}
function ze(t2, e2, n2, r2) {
  return r2 ??= !!(34 & e2), t2 = Ce(t2, e2, Ve, r2), r2 = 32, n2 && (r2 |= 2), st(t2, e2 = 16769217 & e2 | r2), t2;
}
function Ke(t2) {
  const e2 = t2.v, n2 = 0 | e2[et];
  return ht(t2, n2) ? Je(t2, e2, n2) ? He(t2, e2, true) : new t2.constructor(ze(e2, n2, false)) : t2;
}
function Ye(t2) {
  if (t2.h !== ut) return false;
  var e2 = t2.v;
  return it(e2 = ze(e2, 0 | e2[et]), 2048), t2.v = e2, t2.h = void 0, t2.m = void 0, true;
}
function qe(t2) {
  if (!Ye(t2) && ht(t2, 0 | t2.v[et])) throw Error();
}
function $e(t2, e2) {
  void 0 === e2 && (e2 = 0 | t2[et]), 32 & e2 && !(4096 & e2) && st(t2, 4096 | e2);
}
function Je(t2, e2, n2) {
  return !!(2 & n2) || !(!(32 & n2) || 4096 & n2) && (st(e2, 2 | n2), t2.h = ut, true);
}
function tn(t2, e2, n2, r2, i2) {
  if (null !== (e2 = en(t2.v, e2, n2, i2)) || r2 && t2.m !== ut) return e2;
}
function en(t2, e2, n2, r2) {
  if (-1 === e2) return null;
  const i2 = e2 + (n2 ? 0 : -1), s2 = t2.length - 1;
  let o2, a2;
  if (!(s2 < 1 + (n2 ? 0 : -1))) {
    if (i2 >= s2) if (o2 = t2[s2], null != o2 && "object" == typeof o2 && o2.constructor === Object) n2 = o2[e2], a2 = true;
    else {
      if (i2 !== s2) return;
      n2 = o2;
    }
    else n2 = t2[i2];
    if (r2 && null != n2) {
      if (null == (r2 = r2(n2))) return r2;
      if (!Object.is(r2, n2)) return a2 ? o2[e2] = r2 : t2[i2] = r2, r2;
    }
    return n2;
  }
}
function nn(t2, e2, n2, r2) {
  qe(t2), rn(t2 = t2.v, 0 | t2[et], e2, n2, r2);
}
function rn(t2, e2, n2, r2, i2) {
  const s2 = n2 + (i2 ? 0 : -1);
  var o2 = t2.length - 1;
  if (o2 >= 1 + (i2 ? 0 : -1) && s2 >= o2) {
    const i3 = t2[o2];
    if (null != i3 && "object" == typeof i3 && i3.constructor === Object) return i3[n2] = r2, e2;
  }
  return s2 <= o2 ? (t2[s2] = r2, e2) : (void 0 !== r2 && (n2 >= (o2 = (e2 ??= 0 | t2[et]) >> 14 & 1023 || 536870912) ? null != r2 && (t2[o2 + (i2 ? 0 : -1)] = { [n2]: r2 }) : t2[s2] = r2), e2);
}
function sn() {
  return void 0 === dt ? 2 : 4;
}
function on(t2, e2, n2, r2, i2) {
  let s2 = t2.v, o2 = 0 | s2[et];
  r2 = ht(t2, o2) ? 1 : r2, i2 = !!i2 || 3 === r2, 2 === r2 && Ye(t2) && (s2 = t2.v, o2 = 0 | s2[et]);
  let a2 = (t2 = cn(s2, e2)) === nt ? 7 : 0 | t2[et], c2 = hn(a2, o2);
  var h2 = !(4 & c2);
  if (h2) {
    4 & c2 && (t2 = Wt(t2), a2 = 0, c2 = xn(c2, o2), o2 = rn(s2, o2, e2, t2));
    let r3 = 0, i3 = 0;
    for (; r3 < t2.length; r3++) {
      const e3 = n2(t2[r3]);
      null != e3 && (t2[i3++] = e3);
    }
    i3 < r3 && (t2.length = i3), n2 = -513 & (4 | c2), c2 = n2 &= -1025, c2 &= -4097;
  }
  return c2 !== a2 && (st(t2, c2), 2 & c2 && Object.freeze(t2)), an(t2, c2, s2, o2, e2, r2, h2, i2);
}
function an(t2, e2, n2, r2, i2, s2, o2, a2) {
  let c2 = e2;
  return 1 === s2 || 4 === s2 && (2 & e2 || !(16 & e2) && 32 & r2) ? un(e2) || ((e2 |= !t2.length || o2 && !(4096 & e2) || 32 & r2 && !(4096 & e2 || 16 & e2) ? 2 : 256) !== c2 && st(t2, e2), Object.freeze(t2)) : (2 === s2 && un(e2) && (t2 = Wt(t2), c2 = 0, e2 = xn(e2, r2), r2 = rn(n2, r2, i2, t2)), un(e2) || (a2 || (e2 |= 16), e2 !== c2 && st(t2, e2))), 2 & e2 || !(4096 & e2 || 16 & e2) || $e(n2, r2), t2;
}
function cn(t2, e2, n2) {
  return t2 = en(t2, e2, n2), Array.isArray(t2) ? t2 : nt;
}
function hn(t2, e2) {
  return 2 & e2 && (t2 |= 2), 1 | t2;
}
function un(t2) {
  return !!(2 & t2) && !!(4 & t2) || !!(256 & t2);
}
function ln(t2) {
  return lt(t2, true);
}
function fn(t2) {
  t2 = Wt(t2);
  for (let e2 = 0; e2 < t2.length; e2++) {
    const n2 = t2[e2] = Wt(t2[e2]);
    Array.isArray(n2[1]) && (n2[1] = ot(n2[1]));
  }
  return at(t2);
}
function dn(t2, e2, n2, r2) {
  qe(t2), rn(t2 = t2.v, 0 | t2[et], e2, ("0" === r2 ? 0 === Number(n2) : n2 === r2) ? void 0 : n2);
}
function pn(t2, e2, n2) {
  if (2 & e2) throw Error();
  const r2 = mt(e2);
  let i2 = cn(t2, n2, r2), s2 = i2 === nt ? 7 : 0 | i2[et], o2 = hn(s2, e2);
  return (2 & o2 || un(o2) || 16 & o2) && (o2 === s2 || un(o2) || st(i2, o2), i2 = Wt(i2), s2 = 0, o2 = xn(o2, e2), rn(t2, e2, n2, i2, r2)), o2 &= -13, o2 !== s2 && st(i2, o2), i2;
}
function gn(t2, e2) {
  var n2 = Ds;
  return _n(mn(t2 = t2.v), t2, void 0, n2) === e2 ? e2 : -1;
}
function mn(t2) {
  if (j) return t2[W] ?? (t2[W] = /* @__PURE__ */ new Map());
  if (W in t2) return t2[W];
  const e2 = /* @__PURE__ */ new Map();
  return Object.defineProperty(t2, W, { value: e2 }), e2;
}
function yn(t2, e2, n2, r2, i2) {
  const s2 = mn(t2), o2 = _n(s2, t2, e2, n2, i2);
  return o2 !== r2 && (o2 && (e2 = rn(t2, e2, o2, void 0, i2)), s2.set(n2, r2)), e2;
}
function _n(t2, e2, n2, r2, i2) {
  let s2 = t2.get(r2);
  if (null != s2) return s2;
  s2 = 0;
  for (let t3 = 0; t3 < r2.length; t3++) {
    const o2 = r2[t3];
    null != en(e2, o2, i2) && (0 !== s2 && (n2 = rn(e2, n2, s2, void 0, i2)), s2 = o2);
  }
  return t2.set(r2, s2), s2;
}
function vn(t2, e2, n2) {
  let r2 = 0 | t2[et];
  const i2 = mt(r2), s2 = en(t2, n2, i2);
  let o2;
  if (null != s2 && s2[J] === ct) {
    if (!ht(s2)) return Ye(s2), s2.v;
    o2 = s2.v;
  } else Array.isArray(s2) && (o2 = s2);
  if (o2) {
    const t3 = 0 | o2[et];
    2 & t3 && (o2 = ze(o2, t3));
  }
  return o2 = Ge(o2, e2), o2 !== s2 && rn(t2, r2, n2, o2, i2), o2;
}
function En(t2, e2, n2, r2, i2) {
  let s2 = false;
  if (null != (r2 = en(t2, r2, i2, ((t3) => {
    const r3 = me(t3, n2, false, e2);
    return s2 = r3 !== t3 && null != r3, r3;
  })))) return s2 && !ht(r2) && $e(t2, e2), r2;
}
function wn(t2, e2, n2, r2) {
  let i2 = t2.v, s2 = 0 | i2[et];
  if (null == (e2 = En(i2, s2, e2, n2, r2))) return e2;
  if (s2 = 0 | i2[et], !ht(t2, s2)) {
    const o2 = Ke(e2);
    o2 !== e2 && (Ye(t2) && (i2 = t2.v, s2 = 0 | i2[et]), s2 = rn(i2, s2, n2, e2 = o2, r2), $e(i2, s2));
  }
  return e2;
}
function Tn(t2, e2, n2, r2, i2, s2, o2, a2) {
  var c2 = ht(t2, n2);
  s2 = c2 ? 1 : s2, o2 = !!o2 || 3 === s2, c2 = a2 && !c2, (2 === s2 || c2) && Ye(t2) && (n2 = 0 | (e2 = t2.v)[et]);
  var h2 = (t2 = cn(e2, i2)) === nt ? 7 : 0 | t2[et], u2 = hn(h2, n2);
  if (a2 = !(4 & u2)) {
    var l2 = t2, f2 = n2;
    const e3 = !!(2 & u2);
    e3 && (f2 |= 2);
    let i3 = !e3, s3 = true, o3 = 0, a3 = 0;
    for (; o3 < l2.length; o3++) {
      const t3 = me(l2[o3], r2, false, f2);
      if (t3 instanceof r2) {
        if (!e3) {
          const e4 = ht(t3);
          i3 &&= !e4, s3 &&= e4;
        }
        l2[a3++] = t3;
      }
    }
    a3 < o3 && (l2.length = a3), u2 |= 4, u2 = s3 ? -4097 & u2 : 4096 | u2, u2 = i3 ? 8 | u2 : -9 & u2;
  }
  if (u2 !== h2 && (st(t2, u2), 2 & u2 && Object.freeze(t2)), c2 && !(8 & u2 || !t2.length && (1 === s2 || 4 === s2 && (2 & u2 || !(16 & u2) && 32 & n2)))) {
    for (un(u2) && (t2 = Wt(t2), u2 = xn(u2, n2), n2 = rn(e2, n2, i2, t2)), r2 = t2, c2 = u2, h2 = 0; h2 < r2.length; h2++) (l2 = r2[h2]) !== (u2 = Ke(l2)) && (r2[h2] = u2);
    c2 |= 8, st(t2, u2 = c2 = r2.length ? 4096 | c2 : -4097 & c2);
  }
  return an(t2, u2, e2, n2, i2, s2, a2, o2);
}
function An(t2, e2, n2) {
  const r2 = t2.v;
  return Tn(t2, r2, 0 | r2[et], e2, n2, sn(), false, true);
}
function bn(t2) {
  return null == t2 && (t2 = void 0), t2;
}
function kn(t2, e2, n2, r2, i2) {
  return nn(t2, n2, r2 = bn(r2), i2), r2 && !ht(r2) && $e(t2.v), t2;
}
function Sn(t2, e2, n2, r2) {
  t: {
    var i2 = r2 = bn(r2);
    qe(t2);
    const s2 = t2.v;
    let o2 = 0 | s2[et];
    if (null == i2) {
      const t3 = mn(s2);
      if (_n(t3, s2, o2, n2) !== e2) break t;
      t3.set(n2, 0);
    } else o2 = yn(s2, o2, n2, e2);
    rn(s2, o2, e2, i2);
  }
  r2 && !ht(r2) && $e(t2.v);
}
function xn(t2, e2) {
  return -273 & (2 & e2 ? 2 | t2 : -3 & t2);
}
function Ln(t2, e2, n2, r2) {
  var i2 = r2;
  qe(t2), t2 = Tn(t2, r2 = t2.v, 0 | r2[et], n2, e2, 2, true), i2 = null != i2 ? i2 : new n2(), t2.push(i2), e2 = n2 = t2 === nt ? 7 : 0 | t2[et], (i2 = ht(i2)) ? (n2 &= -9, 1 === t2.length && (n2 &= -4097)) : n2 |= 4096, n2 !== e2 && st(t2, n2), i2 || $e(r2);
}
function Rn(t2, e2, n2) {
  return ie(tn(t2, e2, void 0, n2));
}
function In(t2) {
  return (g ? tn(t2, 2, void 0, void 0, fe) : fe(tn(t2, 2))) ?? Ze;
}
function Fn(t2, e2) {
  return tn(t2, e2, void 0, void 0, Qt) ?? 0;
}
function Mn(t2, e2, n2) {
  if (null != n2) {
    if ("number" != typeof n2) throw D("int32");
    if (!qt(n2)) throw D("int32");
    n2 |= 0;
  }
  nn(t2, e2, n2);
}
function Pn(t2, e2, n2) {
  nn(t2, e2, Zt(n2));
}
function Cn(t2, e2, n2) {
  dn(t2, e2, pe(n2), "");
}
function On(t2, e2, n2) {
  {
    qe(t2);
    const o2 = t2.v;
    let a2 = 0 | o2[et];
    if (null == n2) rn(o2, a2, e2);
    else {
      var r2 = t2 = n2 === nt ? 7 : 0 | n2[et], i2 = un(t2), s2 = i2 || Object.isFrozen(n2);
      for (i2 || (t2 = 0), s2 || (n2 = Wt(n2), r2 = 0, t2 = xn(t2, a2), s2 = false), t2 |= 5, t2 |= (4 & t2 ? 512 & t2 ? 512 : 1024 & t2 ? 1024 : 0 : void 0) ?? (g ? 1024 : 0), i2 = 0; i2 < n2.length; i2++) {
        const e3 = n2[i2], o3 = de(e3);
        Object.is(e3, o3) || (s2 && (n2 = Wt(n2), r2 = 0, t2 = xn(t2, a2), s2 = false), n2[i2] = o3);
      }
      t2 !== r2 && (s2 && (n2 = Wt(n2), t2 = xn(t2, a2)), st(n2, t2)), rn(o2, a2, e2, n2);
    }
  }
}
function Nn(t2, e2, n2) {
  qe(t2), on(t2, e2, ge, 2, true).push(de(n2));
}
function Dn(t2, e2) {
  if ("string" == typeof t2) return new Un(L(t2), e2);
  if (Array.isArray(t2)) return new Un(new Uint8Array(t2), e2);
  if (t2.constructor === Uint8Array) return new Un(t2, false);
  if (t2.constructor === ArrayBuffer) return t2 = new Uint8Array(t2), new Un(t2, false);
  if (t2.constructor === P) return e2 = M(t2) || new Uint8Array(0), new Un(e2, true, t2);
  if (t2 instanceof Uint8Array) return t2 = t2.constructor === Uint8Array ? t2 : new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength), new Un(t2, false);
  throw Error();
}
function Bn(t2, e2) {
  let n2, r2 = 0, i2 = 0, s2 = 0;
  const o2 = t2.h;
  let a2 = t2.g;
  do {
    n2 = o2[a2++], r2 |= (127 & n2) << s2, s2 += 7;
  } while (s2 < 32 && 128 & n2);
  if (s2 > 32) for (i2 |= (127 & n2) >> 4, s2 = 3; s2 < 32 && 128 & n2; s2 += 7) n2 = o2[a2++], i2 |= (127 & n2) << s2;
  if (Wn(t2, a2), !(128 & n2)) return e2(r2 >>> 0, i2 >>> 0);
  throw Error();
}
function Gn(t2) {
  let e2 = 0, n2 = t2.g;
  const r2 = n2 + 10, i2 = t2.h;
  for (; n2 < r2; ) {
    const r3 = i2[n2++];
    if (e2 |= r3, 0 == (128 & r3)) return Wn(t2, n2), !!(127 & e2);
  }
  throw Error();
}
function jn(t2) {
  const e2 = t2.h;
  let n2 = t2.g, r2 = e2[n2++], i2 = 127 & r2;
  if (128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 7, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 14, 128 & r2 && (r2 = e2[n2++], i2 |= (127 & r2) << 21, 128 & r2 && (r2 = e2[n2++], i2 |= r2 << 28, 128 & r2 && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++] && 128 & e2[n2++]))))) throw Error();
  return Wn(t2, n2), i2;
}
function Vn(t2) {
  return jn(t2) >>> 0;
}
function Xn(t2) {
  var e2 = t2.h;
  const n2 = t2.g;
  var r2 = e2[n2], i2 = e2[n2 + 1];
  const s2 = e2[n2 + 2];
  return e2 = e2[n2 + 3], Wn(t2, t2.g + 4), t2 = 2 * ((i2 = (r2 << 0 | i2 << 8 | s2 << 16 | e2 << 24) >>> 0) >> 31) + 1, r2 = i2 >>> 23 & 255, i2 &= 8388607, 255 == r2 ? i2 ? NaN : t2 * (1 / 0) : 0 == r2 ? 1401298464324817e-60 * t2 * i2 : t2 * Math.pow(2, r2 - 150) * (i2 + 8388608);
}
function Hn(t2) {
  return jn(t2);
}
function Wn(t2, e2) {
  if (t2.g = e2, e2 > t2.l) throw Error();
}
function zn(t2, e2) {
  if (e2 < 0) throw Error();
  const n2 = t2.g;
  if ((e2 = n2 + e2) > t2.l) throw Error();
  return t2.g = e2, n2;
}
function Kn(t2, e2) {
  if (0 == e2) return F();
  var n2 = zn(t2, e2);
  return t2.Y && t2.j ? n2 = t2.h.subarray(n2, n2 + e2) : (t2 = t2.h, n2 = n2 === (e2 = n2 + e2) ? new Uint8Array(0) : Rt ? t2.slice(n2, e2) : new Uint8Array(t2.subarray(n2, e2))), 0 == n2.length ? F() : new P(n2, I);
}
function qn(t2, e2, n2, r2) {
  if (ir.length) {
    const i2 = ir.pop();
    return i2.o(r2), i2.g.init(t2, e2, n2, r2), i2;
  }
  return new rr(t2, e2, n2, r2);
}
function $n(t2) {
  t2.g.clear(), t2.l = -1, t2.h = -1, ir.length < 100 && ir.push(t2);
}
function Jn(t2) {
  var e2 = t2.g;
  if (e2.g == e2.l) return false;
  t2.m = t2.g.g;
  var n2 = Vn(t2.g);
  if (e2 = n2 >>> 3, !((n2 &= 7) >= 0 && n2 <= 5)) throw Error();
  if (e2 < 1) throw Error();
  return t2.l = e2, t2.h = n2, true;
}
function Zn(t2) {
  switch (t2.h) {
    case 0:
      0 != t2.h ? Zn(t2) : Gn(t2.g);
      break;
    case 1:
      Wn(t2 = t2.g, t2.g + 8);
      break;
    case 2:
      if (2 != t2.h) Zn(t2);
      else {
        var e2 = Vn(t2.g);
        Wn(t2 = t2.g, t2.g + e2);
      }
      break;
    case 5:
      Wn(t2 = t2.g, t2.g + 4);
      break;
    case 3:
      for (e2 = t2.l; ; ) {
        if (!Jn(t2)) throw Error();
        if (4 == t2.h) {
          if (t2.l != e2) throw Error();
          break;
        }
        Zn(t2);
      }
      break;
    default:
      throw Error();
  }
}
function Qn(t2, e2, n2) {
  const r2 = t2.g.l;
  var i2 = Vn(t2.g);
  let s2 = (i2 = t2.g.g + i2) - r2;
  if (s2 <= 0 && (t2.g.l = i2, n2(e2, t2, void 0, void 0, void 0), s2 = i2 - t2.g.g), s2) throw Error();
  return t2.g.g = i2, t2.g.l = r2, e2;
}
function tr(t2) {
  var e2 = Vn(t2.g), a2 = zn(t2 = t2.g, e2);
  if (t2 = t2.h, o) {
    var c2, h2 = t2;
    (c2 = s) || (c2 = s = new TextDecoder("utf-8", { fatal: true })), e2 = a2 + e2, h2 = 0 === a2 && e2 === h2.length ? h2 : h2.subarray(a2, e2);
    try {
      var u2 = c2.decode(h2);
    } catch (t3) {
      if (void 0 === i) {
        try {
          c2.decode(new Uint8Array([128]));
        } catch (t4) {
        }
        try {
          c2.decode(new Uint8Array([97])), i = true;
        } catch (t4) {
          i = false;
        }
      }
      throw !i && (s = void 0), t3;
    }
  } else {
    e2 = (u2 = a2) + e2, a2 = [];
    let i2, s2 = null;
    for (; u2 < e2; ) {
      var l2 = t2[u2++];
      l2 < 128 ? a2.push(l2) : l2 < 224 ? u2 >= e2 ? n() : (i2 = t2[u2++], l2 < 194 || 128 != (192 & i2) ? (u2--, n()) : a2.push((31 & l2) << 6 | 63 & i2)) : l2 < 240 ? u2 >= e2 - 1 ? n() : (i2 = t2[u2++], 128 != (192 & i2) || 224 === l2 && i2 < 160 || 237 === l2 && i2 >= 160 || 128 != (192 & (c2 = t2[u2++])) ? (u2--, n()) : a2.push((15 & l2) << 12 | (63 & i2) << 6 | 63 & c2)) : l2 <= 244 ? u2 >= e2 - 2 ? n() : (i2 = t2[u2++], 128 != (192 & i2) || i2 - 144 + (l2 << 28) >> 30 != 0 || 128 != (192 & (c2 = t2[u2++])) || 128 != (192 & (h2 = t2[u2++])) ? (u2--, n()) : (l2 = (7 & l2) << 18 | (63 & i2) << 12 | (63 & c2) << 6 | 63 & h2, l2 -= 65536, a2.push(55296 + (l2 >> 10 & 1023), 56320 + (1023 & l2)))) : n(), a2.length >= 8192 && (s2 = r(s2, a2), a2.length = 0);
    }
    u2 = r(s2, a2);
  }
  return u2;
}
function er(t2) {
  const e2 = Vn(t2.g);
  return Kn(t2.g, e2);
}
function nr(t2, e2, n2) {
  var r2 = Vn(t2.g);
  for (r2 = t2.g.g + r2; t2.g.g < r2; ) n2.push(e2(t2.g));
}
function sr(t2) {
  return t2 ? /^\d+$/.test(t2) ? (Xt(t2), new or(Ft, Mt)) : null : ar ||= new or(0, 0);
}
function cr(t2) {
  return t2 ? /^-?\d+$/.test(t2) ? (Xt(t2), new hr(Ft, Mt)) : null : ur ||= new hr(0, 0);
}
function lr(t2, e2, n2) {
  for (; n2 > 0 || e2 > 127; ) t2.g.push(127 & e2 | 128), e2 = (e2 >>> 7 | n2 << 25) >>> 0, n2 >>>= 7;
  t2.g.push(e2);
}
function fr(t2, e2) {
  for (; e2 > 127; ) t2.g.push(127 & e2 | 128), e2 >>>= 7;
  t2.g.push(e2);
}
function dr(t2, e2) {
  if (e2 >= 0) fr(t2, e2);
  else {
    for (let n2 = 0; n2 < 9; n2++) t2.g.push(127 & e2 | 128), e2 >>= 7;
    t2.g.push(1);
  }
}
function pr(t2) {
  var e2 = Ft;
  t2.g.push(e2 >>> 0 & 255), t2.g.push(e2 >>> 8 & 255), t2.g.push(e2 >>> 16 & 255), t2.g.push(e2 >>> 24 & 255);
}
function gr(t2, e2) {
  0 !== e2.length && (t2.l.push(e2), t2.h += e2.length);
}
function mr(t2, e2, n2) {
  fr(t2.g, 8 * e2 + n2);
}
function yr(t2, e2) {
  return mr(t2, e2, 2), e2 = t2.g.end(), gr(t2, e2), e2.push(t2.h), e2;
}
function _r(t2, e2) {
  var n2 = e2.pop();
  for (n2 = t2.h + t2.g.length() - n2; n2 > 127; ) e2.push(127 & n2 | 128), n2 >>>= 7, t2.h++;
  e2.push(n2), t2.h++;
}
function vr(t2, e2, n2) {
  mr(t2, e2, 2), fr(t2.g, n2.length), gr(t2, t2.g.end()), gr(t2, n2);
}
function Er(t2, e2, n2, r2) {
  null != n2 && (e2 = yr(t2, e2), r2(n2, t2), _r(t2, e2));
}
function wr() {
  const t2 = class {
    constructor() {
      throw Error();
    }
  };
  return Object.setPrototypeOf(t2, t2.prototype), t2;
}
function Mr(t2, e2, n2) {
  var r2 = t2.v;
  z && z in r2 && (r2 = r2[z]) && delete r2[e2.g], e2.h ? e2.j(t2, e2.h, e2.g, n2, e2.l) : e2.j(t2, e2.g, n2, e2.l);
}
function Or(t2, e2) {
  return new Cr(t2, e2, Tr);
}
function Nr(t2, e2, n2, r2, i2) {
  Er(t2, n2, Yr(e2, r2), i2);
}
function zr(t2, e2, n2, r2) {
  var i2 = r2[t2];
  if (i2) return i2;
  (i2 = {}).qa = r2, i2.T = (function(t3) {
    switch (typeof t3) {
      case "boolean":
        return De ||= [0, void 0, true];
      case "number":
        return t3 > 0 ? void 0 : 0 === t3 ? Be ||= [0, void 0] : [-t3, void 0];
      case "string":
        return [0, t3];
      case "object":
        return t3;
    }
  })(r2[0]);
  var s2 = r2[1];
  let o2 = 1;
  s2 && s2.constructor === Object && (i2.ba = s2, "function" == typeof (s2 = r2[++o2]) && (i2.ma = true, Hr ??= s2, Wr ??= r2[o2 + 1], s2 = r2[o2 += 2]));
  const a2 = {};
  for (; s2 && Array.isArray(s2) && s2.length && "number" == typeof s2[0] && s2[0] > 0; ) {
    for (var c2 = 0; c2 < s2.length; c2++) a2[s2[c2]] = s2;
    s2 = r2[++o2];
  }
  for (c2 = 1; void 0 !== s2; ) {
    let t3;
    "number" == typeof s2 && (c2 += s2, s2 = r2[++o2]);
    var h2 = void 0;
    if (s2 instanceof Cr ? t3 = s2 : (t3 = Ur, o2--), t3?.l) {
      s2 = r2[++o2], h2 = r2;
      var u2 = o2;
      "function" == typeof s2 && (s2 = s2(), h2[u2] = s2), h2 = s2;
    }
    for (u2 = c2 + 1, "number" == typeof (s2 = r2[++o2]) && s2 < 0 && (u2 -= s2, s2 = r2[++o2]); c2 < u2; c2++) {
      const r3 = a2[c2];
      h2 ? n2(i2, c2, t3, h2, r3) : e2(i2, c2, t3, r3);
    }
  }
  return r2[t2] = i2;
}
function Kr(t2) {
  return Array.isArray(t2) ? t2[0] instanceof Cr ? t2 : [Dr, t2] : [t2, void 0];
}
function Yr(t2, e2) {
  return t2 instanceof Pr ? t2.v : Array.isArray(t2) ? Ge(t2, e2) : void 0;
}
function qr(t2, e2, n2, r2) {
  const i2 = n2.g;
  t2[e2] = r2 ? (t3, e3, n3) => i2(t3, e3, n3, r2) : i2;
}
function $r(t2, e2, n2, r2, i2) {
  const s2 = n2.g;
  let o2, a2;
  t2[e2] = (t3, e3, n3) => s2(t3, e3, n3, a2 ||= zr(Gr, qr, $r, r2).T, o2 ||= Jr(r2), i2);
}
function Jr(t2) {
  let e2 = t2[jr];
  if (null != e2) return e2;
  const n2 = zr(Gr, qr, $r, t2);
  return e2 = n2.ma ? (t3, e3) => Hr(t3, e3, n2) : (t3, e3) => {
    for (; Jn(e3) && 4 != e3.h; ) {
      var r2 = e3.l, i2 = n2[r2];
      if (null == i2) {
        var s2 = n2.ba;
        s2 && (s2 = s2[r2]) && (null != (s2 = Qr(s2)) && (i2 = n2[r2] = s2));
      }
      if (null == i2 || !i2(e3, t3, r2)) {
        if (i2 = (s2 = e3).m, Zn(s2), s2.ha) var o2 = void 0;
        else o2 = s2.g.g - i2, s2.g.g = i2, o2 = Kn(s2.g, o2);
        i2 = void 0, s2 = t3, o2 && ((i2 = s2[z] ?? (s2[z] = new Fe()))[r2] ?? (i2[r2] = [])).push(o2);
      }
    }
    return (t3 = Re(t3)) && (t3.da = n2.qa[Xr]), true;
  }, t2[jr] = e2, t2[Xr] = Zr.bind(t2), e2;
}
function Zr(t2, e2, n2, r2) {
  var i2 = this[Gr];
  const s2 = this[jr], o2 = Ge(void 0, i2.T), a2 = Re(t2);
  if (a2) {
    var c2 = false, h2 = i2.ba;
    if (h2) {
      if (i2 = (e3, n3, i3) => {
        if (0 !== i3.length) if (h2[n3]) for (const t3 of i3) {
          e3 = qn(t3);
          try {
            c2 = true, s2(o2, e3);
          } finally {
            $n(e3);
          }
        }
        else r2?.(t2, n3, i3);
      }, null == e2) Ie(a2, i2);
      else if (null != a2) {
        const t3 = a2[e2];
        t3 && i2(a2, e2, t3);
      }
      if (c2) {
        let r3 = 0 | t2[et];
        if (2 & r3 && 2048 & r3 && !n2?.Ka) throw Error();
        const i3 = mt(r3), s3 = (e3, s4) => {
          if (null != en(t2, e3, i3)) {
            if (1 === n2?.Qa) return;
            throw Error();
          }
          null != s4 && (r3 = rn(t2, r3, e3, s4, i3)), delete a2[e3];
        };
        null == e2 ? pt(o2, 0 | o2[et], ((t3, e3) => {
          s3(t3, e3);
        })) : s3(e2, en(o2, e2, i3));
      }
    }
  }
}
function Qr(t2) {
  const e2 = (t2 = Kr(t2))[0].g;
  if (t2 = t2[1]) {
    const n2 = Jr(t2), r2 = zr(Gr, qr, $r, t2).T;
    return (t3, i2, s2) => e2(t3, i2, s2, r2, n2);
  }
  return e2;
}
function ti(t2, e2, n2) {
  t2[e2] = n2.h;
}
function ei(t2, e2, n2, r2) {
  let i2, s2;
  const o2 = n2.h;
  t2[e2] = (t3, e3, n3) => o2(t3, e3, n3, s2 ||= zr(Br, ti, ei, r2).T, i2 ||= ni(r2));
}
function ni(t2) {
  let e2 = t2[Vr];
  if (!e2) {
    const n2 = zr(Br, ti, ei, t2);
    e2 = (t3, e3) => ri(t3, e3, n2), t2[Vr] = e2;
  }
  return e2;
}
function ri(t2, e2, n2) {
  pt(t2, 0 | t2[et], ((t3, r2) => {
    if (null != r2) {
      var i2 = (function(t4, e3) {
        var n3 = t4[e3];
        if (n3) return n3;
        if ((n3 = t4.ba) && (n3 = n3[e3])) {
          var r3 = (n3 = Kr(n3))[0].h;
          if (n3 = n3[1]) {
            const e4 = ni(n3), i3 = zr(Br, ti, ei, n3).T;
            n3 = t4.ma ? Wr(i3, e4) : (t5, n4, s2) => r3(t5, n4, s2, i3, e4);
          } else n3 = r3;
          return t4[e3] = n3;
        }
      })(n2, t3);
      i2 ? i2(e2, r2, t3) : t3 < 500 || B(q, 3);
    }
  })), (t2 = Re(t2)) && Ie(t2, ((t3, n3, r2) => {
    for (gr(e2, e2.g.end()), t3 = 0; t3 < r2.length; t3++) gr(e2, M(r2[t3]) || new Uint8Array(0));
  }));
}
function si(t2, e2) {
  if (Array.isArray(e2)) {
    var n2 = 0 | e2[et];
    if (4 & n2) return e2;
    for (var r2 = 0, i2 = 0; r2 < e2.length; r2++) {
      const n3 = t2(e2[r2]);
      null != n3 && (e2[i2++] = n3);
    }
    return i2 < r2 && (e2.length = i2), (t2 = -1537 & (5 | n2)) !== n2 && st(e2, t2), 2 & t2 && Object.freeze(e2), e2;
  }
}
function oi(t2, e2, n2) {
  return new Cr(t2, e2, n2);
}
function ai(t2, e2, n2) {
  return new Cr(t2, e2, n2);
}
function ci(t2, e2, n2) {
  rn(t2, 0 | t2[et], e2, n2, mt(0 | t2[et]));
}
function ui(t2, e2, n2) {
  null != (e2 = Qt(e2)) && (mr(t2, n2, 5), t2 = t2.g, Ot(e2), pr(t2));
}
function li(t2, e2, n2) {
  if (e2 = (function(t3) {
    if (null == t3) return t3;
    const e3 = typeof t3;
    if ("bigint" === e3) return String(zt(64, t3));
    if (re(t3)) {
      if ("string" === e3) return ce(t3);
      if ("number" === e3) return ae(t3);
    }
  })(e2), null != e2) {
    if ("string" == typeof e2) cr(e2);
    if (null != e2) switch (mr(t2, n2, 0), typeof e2) {
      case "number":
        t2 = t2.g, Ct(e2), lr(t2, Ft, Mt);
        break;
      case "bigint":
        n2 = BigInt.asUintN(64, e2), n2 = new hr(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), lr(t2.g, n2.h, n2.g);
        break;
      default:
        n2 = cr(e2), lr(t2.g, n2.h, n2.g);
    }
  }
}
function fi(t2, e2, n2) {
  null != (e2 = ie(e2)) && null != e2 && (mr(t2, n2, 0), dr(t2.g, e2));
}
function di(t2, e2, n2) {
  null != (e2 = ee(e2)) && (mr(t2, n2, 0), t2.g.g.push(e2 ? 1 : 0));
}
function pi(t2, e2, n2) {
  null != (e2 = ge(e2)) && vr(t2, n2, h(e2));
}
function gi(t2, e2, n2, r2, i2) {
  Er(t2, n2, Yr(e2, r2), i2);
}
function mi(t2, e2, n2) {
  null != (e2 = null == e2 || "string" == typeof e2 || e2 instanceof P ? e2 : void 0) && vr(t2, n2, Dn(e2, true).buffer);
}
function yi(t2, e2, n2) {
  return (5 === t2.h || 2 === t2.h) && (e2 = pn(e2, 0 | e2[et], n2), 2 == t2.h ? nr(t2, Xn, e2) : e2.push(Xn(t2.g)), true);
}
function Gi(t2, e2) {
  return new Bi(t2, e2);
}
function ji(t2, e2) {
  return (n2, r2) => {
    {
      const s2 = { ea: true };
      r2 && Object.assign(s2, r2), n2 = qn(n2, void 0, void 0, s2);
      try {
        const r3 = new t2(), s3 = r3.v;
        Jr(e2)(s3, n2);
        var i2 = r3;
      } finally {
        $n(n2);
      }
    }
    return i2;
  };
}
function Vi(t2) {
  return function() {
    const e2 = new class {
      constructor() {
        this.l = [], this.h = 0, this.g = new class {
          constructor() {
            this.g = [];
          }
          length() {
            return this.g.length;
          }
          end() {
            const t3 = this.g;
            return this.g = [], t3;
          }
        }();
      }
    }();
    ri(this.v, e2, zr(Br, ti, ei, t2)), gr(e2, e2.g.end());
    const n2 = new Uint8Array(e2.h), r2 = e2.l, i2 = r2.length;
    let s2 = 0;
    for (let t3 = 0; t3 < i2; t3++) {
      const e3 = r2[t3];
      n2.set(e3, s2), s2 += e3.length;
    }
    return e2.l = [n2], n2;
  };
}
function Ki(t2) {
  var e2;
  return void 0 === Wi && (Wi = (function() {
    let t3 = null;
    if (!zi) return t3;
    try {
      const e3 = (t4) => t4;
      t3 = zi.createPolicy("goog#html", { createHTML: e3, createScript: e3, createScriptURL: e3 });
    } catch (t4) {
    }
    return t3;
  })()), t2 = (e2 = Wi) ? e2.createScriptURL(t2) : t2, new class {
    constructor(t3) {
      this.g = t3;
    }
    toString() {
      return this.g + "";
    }
  }(t2);
}
function Yi(t2, ...e2) {
  if (0 === e2.length) return Ki(t2[0]);
  let n2 = t2[0];
  for (let r2 = 0; r2 < e2.length; r2++) n2 += encodeURIComponent(e2[r2]) + t2[r2 + 1];
  return Ki(n2);
}
function os(t2, e2) {
  Nn(t2, 3, e2);
}
function as(t2, e2) {
  Nn(t2, 4, e2);
}
function fs(t2, e2) {
  Ln(t2, 1, cs, e2);
}
function ds(t2, e2) {
  Nn(t2, 10, e2);
}
function ps(t2, e2) {
  Nn(t2, 15, e2);
}
function Xo(t2, e2) {
  return e2 = e2 ? e2.clone() : new Gs(), void 0 !== t2.displayNamesLocale ? nn(e2, 1, pe(t2.displayNamesLocale)) : void 0 === t2.displayNamesLocale && nn(e2, 1), void 0 !== t2.maxResults ? Mn(e2, 2, t2.maxResults) : "maxResults" in t2 && nn(e2, 2), void 0 !== t2.scoreThreshold ? Pn(e2, 3, t2.scoreThreshold) : "scoreThreshold" in t2 && nn(e2, 3), void 0 !== t2.categoryAllowlist ? On(e2, 4, t2.categoryAllowlist) : "categoryAllowlist" in t2 && nn(e2, 4), void 0 !== t2.categoryDenylist ? On(e2, 5, t2.categoryDenylist) : "categoryDenylist" in t2 && nn(e2, 5), e2;
}
function Ho(t2) {
  const e2 = Number(t2);
  return Number.isSafeInteger(e2) ? e2 : String(t2);
}
function Wo(t2, e2 = -1, n2 = "") {
  return { categories: t2.map(((t3) => ({ index: Rn(t3, 1) ?? 0 ?? -1, score: Fn(t3, 2) ?? 0, categoryName: ge(tn(t3, 3)) ?? "" ?? "", displayName: ge(tn(t3, 4)) ?? "" ?? "" }))), headIndex: e2, headName: n2 };
}
function zo(t2) {
  const e2 = { classifications: An(t2, Ps, 1).map(((t3) => Wo(wn(t3, vs, 4)?.g() ?? [], Rn(t3, 2) ?? 0, ge(tn(t3, 3)) ?? ""))) };
  return null != (function(t3) {
    return le(g ? tn(t3, 2, void 0, void 0, fe) : tn(t3, 2));
  })(t2) && (e2.timestampMs = Ho(In(t2))), e2;
}
function Ko(t2) {
  var e2 = on(t2, 3, Qt, sn()), n2 = on(t2, 2, ie, sn()), r2 = on(t2, 1, ge, sn()), i2 = on(t2, 9, ge, sn());
  const s2 = { categories: [], keypoints: [] };
  for (let t3 = 0; t3 < e2.length; t3++) s2.categories.push({ score: e2[t3], index: n2[t3] ?? -1, categoryName: r2[t3] ?? "", displayName: i2[t3] ?? "" });
  if ((e2 = wn(t2, bs, 4)?.l()) && (s2.boundingBox = { originX: Rn(e2, 1, Qe) ?? 0, originY: Rn(e2, 2, Qe) ?? 0, width: Rn(e2, 3, Qe) ?? 0, height: Rn(e2, 4, Qe) ?? 0, angle: 0 }), wn(t2, bs, 4)?.g().length) for (const e3 of wn(t2, bs, 4).g()) s2.keypoints.push({ x: tn(e3, 1, void 0, Qe, Qt) ?? 0, y: tn(e3, 2, void 0, Qe, Qt) ?? 0, score: tn(e3, 4, void 0, Qe, Qt) ?? 0, label: ge(tn(e3, 3, void 0, Qe)) ?? "" });
  return s2;
}
function Yo(t2) {
  const e2 = [];
  for (const n2 of An(t2, Ls, 1)) e2.push({ x: Fn(n2, 1) ?? 0, y: Fn(n2, 2) ?? 0, z: Fn(n2, 3) ?? 0, visibility: Fn(n2, 4) ?? 0 });
  return e2;
}
function qo(t2) {
  const e2 = [];
  for (const n2 of An(t2, Ss, 1)) e2.push({ x: Fn(n2, 1) ?? 0, y: Fn(n2, 2) ?? 0, z: Fn(n2, 3) ?? 0, visibility: Fn(n2, 4) ?? 0 });
  return e2;
}
function $o(t2) {
  return Array.from(t2, ((t3) => t3 > 127 ? t3 - 256 : t3));
}
function Jo(t2, e2) {
  if (t2.length !== e2.length) throw Error(`Cannot compute cosine similarity between embeddings of different sizes (${t2.length} vs. ${e2.length}).`);
  let n2 = 0, r2 = 0, i2 = 0;
  for (let s2 = 0; s2 < t2.length; s2++) n2 += t2[s2] * e2[s2], r2 += t2[s2] * t2[s2], i2 += e2[s2] * e2[s2];
  if (r2 <= 0 || i2 <= 0) throw Error("Cannot compute cosine similarity on embedding with 0 norm.");
  return n2 / Math.sqrt(r2 * i2);
}
async function ta() {
  if (void 0 === Zo) try {
    await WebAssembly.instantiate(Qo), Zo = true;
  } catch {
    Zo = false;
  }
  return Zo;
}
async function ea(t2, e2 = Yi``) {
  const n2 = await ta() ? "wasm_internal" : "wasm_nosimd_internal";
  return { wasmLoaderPath: `${e2}/${t2}_${n2}.js`, wasmBinaryPath: `${e2}/${t2}_${n2}.wasm` };
}
function ra() {
  var t2 = navigator;
  return "undefined" != typeof OffscreenCanvas && (!(function(t3 = navigator) {
    return (t3 = t3.userAgent).includes("Safari") && !t3.includes("Chrome");
  })(t2) || !!((t2 = t2.userAgent.match(/Version\/([\d]+).*Safari/)) && t2.length >= 1 && Number(t2[1]) >= 17));
}
async function ia(t2) {
  if ("function" != typeof importScripts) {
    const e2 = document.createElement("script");
    return e2.src = t2.toString(), e2.crossOrigin = "anonymous", new Promise(((t3, n2) => {
      e2.addEventListener("load", (() => {
        t3();
      }), false), e2.addEventListener("error", ((t4) => {
        n2(t4);
      }), false), document.body.appendChild(e2);
    }));
  }
  try {
    importScripts(t2.toString());
  } catch (e2) {
    if (!(e2 instanceof TypeError)) throw e2;
    await self.import(t2.toString());
  }
}
function sa(t2) {
  return void 0 !== t2.videoWidth ? [t2.videoWidth, t2.videoHeight] : void 0 !== t2.naturalWidth ? [t2.naturalWidth, t2.naturalHeight] : void 0 !== t2.displayWidth ? [t2.displayWidth, t2.displayHeight] : [t2.width, t2.height];
}
function oa(t2, e2, n2) {
  t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target"), n2(e2 = t2.i.stringToNewUTF8(e2)), t2.i._free(e2);
}
function aa(t2, e2, n2) {
  if (!t2.i.canvas) throw Error("No OpenGL canvas configured.");
  if (n2 ? t2.i._bindTextureToStream(n2) : t2.i._bindTextureToCanvas(), !(n2 = t2.i.canvas.getContext("webgl2") || t2.i.canvas.getContext("webgl"))) throw Error("Failed to obtain WebGL context from the provided canvas. `getContext()` should only be invoked with `webgl` or `webgl2`.");
  t2.i.gpuOriginForWebTexturesIsBottomLeft && n2.pixelStorei(n2.UNPACK_FLIP_Y_WEBGL, true), n2.texImage2D(n2.TEXTURE_2D, 0, n2.RGBA, n2.RGBA, n2.UNSIGNED_BYTE, e2), t2.i.gpuOriginForWebTexturesIsBottomLeft && n2.pixelStorei(n2.UNPACK_FLIP_Y_WEBGL, false);
  const [r2, i2] = sa(e2);
  return !t2.l || r2 === t2.i.canvas.width && i2 === t2.i.canvas.height || (t2.i.canvas.width = r2, t2.i.canvas.height = i2), [r2, i2];
}
function ca(t2, e2, n2) {
  t2.m || console.error("No wasm multistream support detected: ensure dependency inclusion of :gl_graph_runner_internal_multi_input target");
  const r2 = new Uint32Array(e2.length);
  for (let n3 = 0; n3 < e2.length; n3++) r2[n3] = t2.i.stringToNewUTF8(e2[n3]);
  e2 = t2.i._malloc(4 * r2.length), t2.i.HEAPU32.set(r2, e2 >> 2), n2(e2);
  for (const e3 of r2) t2.i._free(e3);
  t2.i._free(e2);
}
function ha(t2, e2, n2) {
  t2.i.simpleListeners = t2.i.simpleListeners || {}, t2.i.simpleListeners[e2] = n2;
}
function ua(t2, e2, n2) {
  let r2 = [];
  t2.i.simpleListeners = t2.i.simpleListeners || {}, t2.i.simpleListeners[e2] = (t3, e3, i2) => {
    e3 ? (n2(r2, i2), r2 = []) : r2.push(t3);
  };
}
async function la(t2, e2, n2, r2) {
  return t2 = await (async (t3, e3, n3, r3, i2) => {
    if (e3 && await ia(e3), !self.ModuleFactory) throw Error("ModuleFactory not set.");
    if (n3 && (await ia(n3), !self.ModuleFactory)) throw Error("ModuleFactory not set.");
    return self.Module && i2 && ((e3 = self.Module).locateFile = i2.locateFile, i2.mainScriptUrlOrBlob && (e3.mainScriptUrlOrBlob = i2.mainScriptUrlOrBlob)), i2 = await self.ModuleFactory(self.Module || i2), self.ModuleFactory = self.Module = void 0, new t3(i2, r3);
  })(t2, n2.wasmLoaderPath, n2.assetLoaderPath, e2, { locateFile: (t3) => t3.endsWith(".wasm") ? n2.wasmBinaryPath.toString() : n2.assetBinaryPath && t3.endsWith(".data") ? n2.assetBinaryPath.toString() : t3 }), await t2.o(r2), t2;
}
function fa(t2, e2) {
  const n2 = wn(t2.baseOptions, zs, 1) || new zs();
  "string" == typeof e2 ? (nn(n2, 2, pe(e2)), nn(n2, 1)) : e2 instanceof Uint8Array && (nn(n2, 1, lt(e2, false)), nn(n2, 2)), kn(t2.baseOptions, 0, 1, n2);
}
function da(t2) {
  try {
    const e2 = t2.H.length;
    if (1 === e2) throw Error(t2.H[0].message);
    if (e2 > 1) throw Error("Encountered multiple errors: " + t2.H.map(((t3) => t3.message)).join(", "));
  } finally {
    t2.H = [];
  }
}
function pa(t2, e2) {
  t2.C = Math.max(t2.C, e2);
}
function ga(t2, e2) {
  t2.B = new cs(), Cn(t2.B, 2, "PassThroughCalculator"), os(t2.B, "free_memory"), as(t2.B, "free_memory_unused_out"), ds(e2, "free_memory"), fs(e2, t2.B);
}
function ma(t2, e2) {
  os(t2.B, e2), as(t2.B, e2 + "_unused_out");
}
function ya(t2) {
  t2.g.addBoolToStream(true, "free_memory", t2.C);
}
function va(t2, e2) {
  if (!t2) throw Error(`Unable to obtain required WebGL resource: ${e2}`);
  return t2;
}
function wa(t2, e2, n2) {
  const r2 = t2.g;
  if (n2 = va(r2.createShader(n2), "Failed to create WebGL shader"), r2.shaderSource(n2, e2), r2.compileShader(n2), !r2.getShaderParameter(n2, r2.COMPILE_STATUS)) throw Error(`Could not compile WebGL shader: ${r2.getShaderInfoLog(n2)}`);
  return r2.attachShader(t2.h, n2), n2;
}
function Ta(t2, e2) {
  const n2 = t2.g, r2 = va(n2.createVertexArray(), "Failed to create vertex array");
  n2.bindVertexArray(r2);
  const i2 = va(n2.createBuffer(), "Failed to create buffer");
  n2.bindBuffer(n2.ARRAY_BUFFER, i2), n2.enableVertexAttribArray(t2.O), n2.vertexAttribPointer(t2.O, 2, n2.FLOAT, false, 0, 0), n2.bufferData(n2.ARRAY_BUFFER, new Float32Array([-1, -1, -1, 1, 1, 1, 1, -1]), n2.STATIC_DRAW);
  const s2 = va(n2.createBuffer(), "Failed to create buffer");
  return n2.bindBuffer(n2.ARRAY_BUFFER, s2), n2.enableVertexAttribArray(t2.L), n2.vertexAttribPointer(t2.L, 2, n2.FLOAT, false, 0, 0), n2.bufferData(n2.ARRAY_BUFFER, new Float32Array(e2 ? [0, 1, 0, 0, 1, 0, 1, 1] : [0, 0, 0, 1, 1, 1, 1, 0]), n2.STATIC_DRAW), n2.bindBuffer(n2.ARRAY_BUFFER, null), n2.bindVertexArray(null), new Ea(n2, r2, i2, s2);
}
function Aa(t2, e2) {
  if (t2.g) {
    if (e2 !== t2.g) throw Error("Cannot change GL context once initialized");
  } else t2.g = e2;
}
function ba(t2, e2, n2, r2) {
  return Aa(t2, e2), t2.h || (t2.m(), t2.D()), n2 ? (t2.u || (t2.u = Ta(t2, true)), n2 = t2.u) : (t2.A || (t2.A = Ta(t2, false)), n2 = t2.A), e2.useProgram(t2.h), n2.bind(), t2.l(), t2 = r2(), n2.g.bindVertexArray(null), t2;
}
function ka(t2, e2, n2) {
  return Aa(t2, e2), t2 = va(e2.createTexture(), "Failed to create texture"), e2.bindTexture(e2.TEXTURE_2D, t2), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_S, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_WRAP_T, e2.CLAMP_TO_EDGE), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MIN_FILTER, n2 ?? e2.LINEAR), e2.texParameteri(e2.TEXTURE_2D, e2.TEXTURE_MAG_FILTER, n2 ?? e2.LINEAR), e2.bindTexture(e2.TEXTURE_2D, null), t2;
}
function Sa(t2, e2, n2) {
  Aa(t2, e2), t2.B || (t2.B = va(e2.createFramebuffer(), "Failed to create framebuffe.")), e2.bindFramebuffer(e2.FRAMEBUFFER, t2.B), e2.framebufferTexture2D(e2.FRAMEBUFFER, e2.COLOR_ATTACHMENT0, e2.TEXTURE_2D, n2, 0);
}
function xa(t2) {
  t2.g?.bindFramebuffer(t2.g.FRAMEBUFFER, null);
}
function Fa(t2, e2) {
  switch (e2) {
    case 0:
      return t2.g.find(((t3) => t3 instanceof Uint8Array));
    case 1:
      return t2.g.find(((t3) => t3 instanceof Float32Array));
    case 2:
      return t2.g.find(((t3) => "undefined" != typeof WebGLTexture && t3 instanceof WebGLTexture));
    default:
      throw Error(`Type is not supported: ${e2}`);
  }
}
function Ma(t2) {
  var e2 = Fa(t2, 1);
  if (!e2) {
    if (e2 = Fa(t2, 0)) e2 = new Float32Array(e2).map(((t3) => t3 / 255));
    else {
      e2 = new Float32Array(t2.width * t2.height);
      const r2 = Ca(t2);
      var n2 = Na(t2);
      if (Sa(n2, r2, Pa(t2)), "iPad Simulator;iPhone Simulator;iPod Simulator;iPad;iPhone;iPod".split(";").includes(navigator.platform) || navigator.userAgent.includes("Mac") && "document" in self && "ontouchend" in self.document) {
        n2 = new Float32Array(t2.width * t2.height * 4), r2.readPixels(0, 0, t2.width, t2.height, r2.RGBA, r2.FLOAT, n2);
        for (let t3 = 0, r3 = 0; t3 < e2.length; ++t3, r3 += 4) e2[t3] = n2[r3];
      } else r2.readPixels(0, 0, t2.width, t2.height, r2.RED, r2.FLOAT, e2);
    }
    t2.g.push(e2);
  }
  return e2;
}
function Pa(t2) {
  let e2 = Fa(t2, 2);
  if (!e2) {
    const n2 = Ca(t2);
    e2 = Ua(t2);
    const r2 = Ma(t2), i2 = Oa(t2);
    n2.texImage2D(n2.TEXTURE_2D, 0, i2, t2.width, t2.height, 0, n2.RED, n2.FLOAT, r2), Da(t2);
  }
  return e2;
}
function Ca(t2) {
  if (!t2.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t2.h || (t2.h = va(t2.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t2.h;
}
function Oa(t2) {
  if (t2 = Ca(t2), !Ba) if (t2.getExtension("EXT_color_buffer_float") && t2.getExtension("OES_texture_float_linear") && t2.getExtension("EXT_float_blend")) Ba = t2.R32F;
  else {
    if (!t2.getExtension("EXT_color_buffer_half_float")) throw Error("GPU does not fully support 4-channel float32 or float16 formats");
    Ba = t2.R16F;
  }
  return Ba;
}
function Na(t2) {
  return t2.l || (t2.l = new La()), t2.l;
}
function Ua(t2) {
  const e2 = Ca(t2);
  e2.viewport(0, 0, t2.width, t2.height), e2.activeTexture(e2.TEXTURE0);
  let n2 = Fa(t2, 2);
  return n2 || (n2 = ka(Na(t2), e2, t2.m ? e2.LINEAR : e2.NEAREST), t2.g.push(n2), t2.j = true), e2.bindTexture(e2.TEXTURE_2D, n2), n2;
}
function Da(t2) {
  t2.h.bindTexture(t2.h.TEXTURE_2D, null);
}
function Xa(t2) {
  return { ...Va, fillColor: (t2 = t2 || {}).color, ...t2 };
}
function Ha(t2, e2) {
  return t2 instanceof Function ? t2(e2) : t2;
}
function Wa(t2, e2, n2) {
  return Math.max(Math.min(e2, n2), Math.min(Math.max(e2, n2), t2));
}
function za(t2) {
  if (!t2.l) throw Error("CPU rendering requested but CanvasRenderingContext2D not provided.");
  return t2.l;
}
function Ka(t2) {
  if (!t2.j) throw Error("GPU rendering requested but WebGL2RenderingContext not provided.");
  return t2.j;
}
function Ya(t2, e2, n2) {
  if (e2.R()) n2(e2.N());
  else {
    const r2 = e2.ka() ? e2.ia() : e2.ja();
    t2.m = t2.m ?? new La();
    const i2 = Ka(t2);
    n2((t2 = new Ga([r2], e2.m, false, i2.canvas, t2.m, e2.width, e2.height)).N()), t2.close();
  }
}
function qa(t2, e2, n2, r2) {
  const i2 = (function(t3) {
    return t3.g || (t3.g = new Ra()), t3.g;
  })(t2), s2 = Ka(t2), o2 = Array.isArray(n2) ? new ImageData(new Uint8ClampedArray(n2), 1, 1) : n2;
  ba(i2, s2, true, (() => {
    !(function(t4, e3, n3, r3) {
      const i3 = t4.g;
      if (i3.activeTexture(i3.TEXTURE0), i3.bindTexture(i3.TEXTURE_2D, e3), i3.activeTexture(i3.TEXTURE1), i3.bindTexture(i3.TEXTURE_2D, t4.C), i3.texImage2D(i3.TEXTURE_2D, 0, i3.RGBA, i3.RGBA, i3.UNSIGNED_BYTE, n3), t4.I && (function(t5, e4) {
        if (t5 !== e4) return false;
        t5 = t5.entries(), e4 = e4.entries();
        for (const [r4, i4] of t5) {
          t5 = r4;
          const s3 = i4;
          var n4 = e4.next();
          if (n4.done) return false;
          const [o3, a2] = n4.value;
          if (n4 = a2, t5 !== o3 || s3[0] !== n4[0] || s3[1] !== n4[1] || s3[2] !== n4[2] || s3[3] !== n4[3]) return false;
        }
        return !!e4.next().done;
      })(t4.I, r3)) i3.activeTexture(i3.TEXTURE2), i3.bindTexture(i3.TEXTURE_2D, t4.j);
      else {
        t4.I = r3;
        const e4 = Array(1024).fill(0);
        r3.forEach(((t5, n4) => {
          if (4 !== t5.length) throw Error(`Color at index ${n4} is not a four-channel value.`);
          e4[4 * n4] = t5[0], e4[4 * n4 + 1] = t5[1], e4[4 * n4 + 2] = t5[2], e4[4 * n4 + 3] = t5[3];
        })), i3.activeTexture(i3.TEXTURE2), i3.bindTexture(i3.TEXTURE_2D, t4.j), i3.texImage2D(i3.TEXTURE_2D, 0, i3.RGBA, 256, 1, 0, i3.RGBA, i3.UNSIGNED_BYTE, new Uint8Array(e4));
      }
    })(i2, e2, o2, r2), s2.clearColor(0, 0, 0, 0), s2.clear(s2.COLOR_BUFFER_BIT), s2.drawArrays(s2.TRIANGLE_FAN, 0, 4);
    const t3 = i2.g;
    t3.activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, null);
  }));
}
function $a(t2, e2, n2, r2) {
  const i2 = Ka(t2), s2 = (function(t3) {
    return t3.h || (t3.h = new Ia()), t3.h;
  })(t2), o2 = Array.isArray(n2) ? new ImageData(new Uint8ClampedArray(n2), 1, 1) : n2, a2 = Array.isArray(r2) ? new ImageData(new Uint8ClampedArray(r2), 1, 1) : r2;
  ba(s2, i2, true, (() => {
    var t3 = s2.g;
    t3.activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, e2), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, s2.j), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, o2), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, s2.C), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, t3.RGBA, t3.UNSIGNED_BYTE, a2), i2.clearColor(0, 0, 0, 0), i2.clear(i2.COLOR_BUFFER_BIT), i2.drawArrays(i2.TRIANGLE_FAN, 0, 4), i2.bindTexture(i2.TEXTURE_2D, null), (t3 = s2.g).activeTexture(t3.TEXTURE0), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE1), t3.bindTexture(t3.TEXTURE_2D, null), t3.activeTexture(t3.TEXTURE2), t3.bindTexture(t3.TEXTURE_2D, null);
  }));
}
function Za(t2, e2) {
  switch (e2) {
    case 0:
      return t2.g.find(((t3) => t3 instanceof ImageData));
    case 1:
      return t2.g.find(((t3) => "undefined" != typeof ImageBitmap && t3 instanceof ImageBitmap));
    case 2:
      return t2.g.find(((t3) => "undefined" != typeof WebGLTexture && t3 instanceof WebGLTexture));
    default:
      throw Error(`Type is not supported: ${e2}`);
  }
}
function Qa(t2) {
  var e2 = Za(t2, 0);
  if (!e2) {
    e2 = ec(t2);
    const n2 = nc(t2), r2 = new Uint8Array(t2.width * t2.height * 4);
    Sa(n2, e2, tc(t2)), e2.readPixels(0, 0, t2.width, t2.height, e2.RGBA, e2.UNSIGNED_BYTE, r2), xa(n2), e2 = new ImageData(new Uint8ClampedArray(r2.buffer), t2.width, t2.height), t2.g.push(e2);
  }
  return e2;
}
function tc(t2) {
  let e2 = Za(t2, 2);
  if (!e2) {
    const n2 = ec(t2);
    e2 = rc(t2);
    const r2 = Za(t2, 1) || Qa(t2);
    n2.texImage2D(n2.TEXTURE_2D, 0, n2.RGBA, n2.RGBA, n2.UNSIGNED_BYTE, r2), ic(t2);
  }
  return e2;
}
function ec(t2) {
  if (!t2.canvas) throw Error("Conversion to different image formats require that a canvas is passed when initializing the image.");
  return t2.h || (t2.h = va(t2.canvas.getContext("webgl2"), "You cannot use a canvas that is already bound to a different type of rendering context.")), t2.h;
}
function nc(t2) {
  return t2.l || (t2.l = new La()), t2.l;
}
function rc(t2) {
  const e2 = ec(t2);
  e2.viewport(0, 0, t2.width, t2.height), e2.activeTexture(e2.TEXTURE0);
  let n2 = Za(t2, 2);
  return n2 || (n2 = ka(nc(t2), e2), t2.g.push(n2), t2.m = true), e2.bindTexture(e2.TEXTURE_2D, n2), n2;
}
function ic(t2) {
  t2.h.bindTexture(t2.h.TEXTURE_2D, null);
}
function sc(t2) {
  const e2 = ec(t2);
  return ba(nc(t2), e2, true, (() => (function(t3, e3) {
    const n2 = t3.canvas;
    if (n2.width === t3.width && n2.height === t3.height) return e3();
    const r2 = n2.width, i2 = n2.height;
    return n2.width = t3.width, n2.height = t3.height, t3 = e3(), n2.width = r2, n2.height = i2, t3;
  })(t2, (() => {
    if (e2.bindFramebuffer(e2.FRAMEBUFFER, null), e2.clearColor(0, 0, 0, 0), e2.clear(e2.COLOR_BUFFER_BIT), e2.drawArrays(e2.TRIANGLE_FAN, 0, 4), !(t2.canvas instanceof OffscreenCanvas)) throw Error("Conversion to ImageBitmap requires that the MediaPipe Tasks is initialized with an OffscreenCanvas");
    return t2.canvas.transferToImageBitmap();
  }))));
}
function cc(...t2) {
  return t2.map((([t3, e2]) => ({ start: t3, end: e2 })));
}
async function fc(t2, e2, n2) {
  return (async function(t3, e3, n3, r2) {
    return la(t3, e3, n3, r2);
  })(t2, n2.canvas ?? (ra() ? void 0 : document.createElement("canvas")), e2, n2);
}
function dc(t2, e2, n2, r2) {
  if (t2.U) {
    const s2 = new Ms();
    if (n2?.regionOfInterest) {
      if (!t2.oa) throw Error("This task doesn't support region-of-interest.");
      var i2 = n2.regionOfInterest;
      if (i2.left >= i2.right || i2.top >= i2.bottom) throw Error("Expected RectF with left < right and top < bottom.");
      if (i2.left < 0 || i2.top < 0 || i2.right > 1 || i2.bottom > 1) throw Error("Expected RectF values to be in [0,1].");
      Pn(s2, 1, (i2.left + i2.right) / 2), Pn(s2, 2, (i2.top + i2.bottom) / 2), Pn(s2, 4, i2.right - i2.left), Pn(s2, 3, i2.bottom - i2.top);
    } else Pn(s2, 1, 0.5), Pn(s2, 2, 0.5), Pn(s2, 4, 1), Pn(s2, 3, 1);
    if (n2?.rotationDegrees) {
      if (n2?.rotationDegrees % 90 != 0) throw Error("Expected rotation to be a multiple of 90\xB0.");
      if (Pn(s2, 5, -Math.PI * n2.rotationDegrees / 180), n2?.rotationDegrees % 180 != 0) {
        const [t3, r3] = sa(e2);
        n2 = Fn(s2, 3) * r3 / t3, i2 = Fn(s2, 4) * t3 / r3, Pn(s2, 4, n2), Pn(s2, 3, i2);
      }
    }
    t2.g.addProtoToStream(s2.g(), "mediapipe.NormalizedRect", t2.U, r2);
  }
  t2.g.pa(e2, t2.X, r2 ?? performance.now()), t2.finishProcessing();
}
function pc(t2, e2, n2) {
  if (t2.baseOptions?.g()) throw Error("Task is not initialized with image mode. 'runningMode' must be set to 'IMAGE'.");
  dc(t2, e2, n2, t2.C + 1);
}
function gc(t2, e2, n2, r2) {
  if (!t2.baseOptions?.g()) throw Error("Task is not initialized with video mode. 'runningMode' must be set to 'VIDEO'.");
  dc(t2, e2, n2, r2);
}
function mc(t2, e2, n2, r2) {
  var i2 = e2.data;
  const s2 = e2.width, o2 = s2 * (e2 = e2.height);
  if ((i2 instanceof Uint8Array || i2 instanceof Float32Array) && i2.length !== o2) throw Error("Unsupported channel count: " + i2.length / o2);
  return t2 = new Ga([i2], n2, false, t2.g.i.canvas, t2.P, s2, e2), r2 ? t2.clone() : t2;
}
function Rc(t2) {
  t2.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] };
}
function Mc(t2) {
  t2.gestures = [], t2.landmarks = [], t2.worldLandmarks = [], t2.handedness = [];
}
function Pc(t2) {
  return 0 === t2.gestures.length ? { gestures: [], landmarks: [], worldLandmarks: [], handedness: [], handednesses: [] } : { gestures: t2.gestures, landmarks: t2.landmarks, worldLandmarks: t2.worldLandmarks, handedness: t2.handedness, handednesses: t2.handedness };
}
function Cc(t2, e2 = true) {
  const n2 = [];
  for (const i2 of t2) {
    var r2 = ws(i2);
    t2 = [];
    for (const n3 of r2.g()) r2 = e2 && null != Rn(n3, 1) ? Rn(n3, 1) ?? 0 : -1, t2.push({ score: Fn(n3, 2) ?? 0, index: r2, categoryName: ge(tn(n3, 3)) ?? "" ?? "", displayName: ge(tn(n3, 4)) ?? "" ?? "" });
    n2.push(t2);
  }
  return n2;
}
function Nc(t2) {
  return { landmarks: t2.landmarks, worldLandmarks: t2.worldLandmarks, handednesses: t2.handedness, handedness: t2.handedness };
}
function Bc(t2) {
  t2.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] };
}
function Gc(t2) {
  try {
    if (!t2.D) return t2.h;
    t2.D(t2.h);
  } finally {
    ya(t2);
  }
}
function jc(t2, e2) {
  t2 = Rs(t2), e2.push(Yo(t2));
}
function zc(t2) {
  const e2 = (function(t3) {
    return An(t3, cs, 1);
  })(t2.ca()).filter(((t3) => (ge(tn(t3, 1)) ?? "").includes("mediapipe.tasks.TensorsToSegmentationCalculator")));
  if (t2.u = [], e2.length > 1) throw Error("The graph has more than one mediapipe.tasks.TensorsToSegmentationCalculator.");
  1 === e2.length && (wn(e2[0], rs, 7)?.j()?.g() ?? /* @__PURE__ */ new Map()).forEach(((e3, n2) => {
    t2.u[Number(n2)] = ge(tn(e3, 1)) ?? "";
  }));
}
function Kc(t2) {
  t2.categoryMask = void 0, t2.confidenceMasks = void 0, t2.qualityScores = void 0;
}
function Yc(t2) {
  try {
    const e2 = new Wc(t2.confidenceMasks, t2.categoryMask, t2.qualityScores);
    if (!t2.j) return e2;
    t2.j(e2);
  } finally {
    ya(t2);
  }
}
function th(t2) {
  t2.landmarks = [], t2.worldLandmarks = [], t2.segmentationMasks = void 0;
}
function eh(t2) {
  try {
    const e2 = new Qc(t2.landmarks, t2.worldLandmarks, t2.segmentationMasks);
    if (!t2.u) return e2;
    t2.u(e2);
  } finally {
    ya(t2);
  }
}
var t, i, s, o, a, c, l, f, d, p, g, y, v, E, A, b, k, S, I, P, C, O, j, X2, H, W, z, K, Y, q, $, J, Z, Q, tt, et, nt, rt, ct, ut, ft, dt, gt, _t, vt, Et, wt, At, bt, kt, St, xt, Rt, It, Ft, Mt, zt, Kt, Yt, qt, $t, Jt, ne, _e, ve, Ee, we, be, xe, Fe, Me, De, Be, Ze, Qe, Un, Yn, rr, ir, or, ar, hr, ur, Tr, Ar, br, kr, Sr, xr, Lr, Rr, Ir, Fr, Pr, Cr, Ur, Dr, Br, Gr, jr, Vr, Xr, Hr, Wr, ii, hi, _i, vi, Ei, wi, Ti, Ai, bi, ki, Si, xi, Li, Ri, Ii, Fi, Mi, Pi, Ci, Oi, Ni, Ui, Di, Bi, Xi, Hi, Wi, zi, qi, $i, Ji, Zi, Qi, ts, es, ns, rs, is, ss, cs, hs, us, ls, gs, ms, ys, _s, vs, Es, ws, Ts, As, bs, ks, Ss, xs, Ls, Rs, Is, Fs, Ms, Ps, Cs, Os, Ns, Us, Ds, Bs, Gs, js, Vs, Xs, Hs, Ws, zs, Ks, Ys, qs, $s, Js, Zs, Qs, to, eo, no, ro, io, so, oo, ao, co, ho, uo, lo, fo, po, go, mo, yo, _o, vo, Eo, wo, To, Ao, bo, ko, So, xo, Lo, Ro, Io, Fo, Mo, Po, Co, Oo, No, Uo, Do, Bo, Go, jo, Vo, Zo, Qo, na, _a, Ea, La, Ra, Ia, Ba, Ga, ja, Va, Ja, oc, ac, hc, uc, lc, yc, _c, vc, Ec, wc, Tc, Ac, bc, kc, Sc, xc, Lc, Ic, Fc, Oc, Uc, Dc, Vc, Xc, Hc, Wc, qc, $c, Jc, Zc, Qc, nh;
var init_vision_bundle = __esm({
  "node_modules/@mediapipe/tasks-vision/vision_bundle.mjs"() {
    t = "undefined" != typeof self ? self : {};
    o = "undefined" != typeof TextDecoder;
    c = "undefined" != typeof TextEncoder;
    f = e(610401301, false);
    d = e(748402147, true);
    p = e(824648567, true);
    g = e(824656860, e(1, true));
    y = t.navigator;
    l = y && y.userAgentData || null, _[" "] = function() {
    };
    v = {};
    E = null;
    A = "undefined" != typeof Uint8Array;
    b = !(!(f && l && l.brands.length > 0) && (-1 != m().indexOf("Trident") || -1 != m().indexOf("MSIE"))) && "function" == typeof btoa;
    k = /[-_.]/g;
    S = { "-": "+", _: "/", ".": "=" };
    I = {};
    P = class {
      h() {
        return new Uint8Array(M(this) || 0);
      }
      constructor(t2, e2) {
        if (N(e2), this.g = t2, null != t2 && 0 === t2.length) throw Error("ByteString should be constructed with non-empty values");
      }
    };
    j = "function" == typeof Symbol && "symbol" == typeof /* @__PURE__ */ Symbol();
    X2 = V("jas", void 0, true);
    H = V(void 0, "0di");
    W = V(void 0, "1oa");
    z = V(void 0, /* @__PURE__ */ Symbol());
    K = V(void 0, "0ub");
    Y = V(void 0, "0ubs");
    q = V(void 0, "0ubsb");
    $ = V(void 0, "0actk");
    J = V("m_m", "Pa", true);
    Z = V();
    Q = { Ga: { value: 0, configurable: true, writable: true, enumerable: false } };
    tt = Object.defineProperties;
    et = j ? X2 : "Ga";
    rt = [];
    st(rt, 7), nt = Object.freeze(rt);
    ct = {};
    ut = {};
    ft = class {
      constructor(t2, e2, n2) {
        this.g = t2, this.h = e2, this.l = n2;
      }
      next() {
        const t2 = this.g.next();
        return t2.done || (t2.value = this.h.call(this.l, t2.value)), t2;
      }
      [Symbol.iterator]() {
        return this;
      }
    };
    dt = Object.freeze({});
    gt = {};
    _t = yt(((t2) => "number" == typeof t2));
    vt = yt(((t2) => "string" == typeof t2));
    Et = yt(((t2) => "boolean" == typeof t2));
    wt = "function" == typeof t.BigInt && "bigint" == typeof t.BigInt(0);
    At = yt(((t2) => wt ? t2 >= kt && t2 <= xt : "-" === t2[0] ? Lt(t2, bt) : Lt(t2, St)));
    bt = Number.MIN_SAFE_INTEGER.toString();
    kt = wt ? BigInt(Number.MIN_SAFE_INTEGER) : void 0;
    St = Number.MAX_SAFE_INTEGER.toString();
    xt = wt ? BigInt(Number.MAX_SAFE_INTEGER) : void 0;
    Rt = "function" == typeof Uint8Array.prototype.slice;
    Ft = 0;
    Mt = 0;
    zt = "function" == typeof BigInt ? BigInt.asIntN : void 0;
    Kt = "function" == typeof BigInt ? BigInt.asUintN : void 0;
    Yt = Number.isSafeInteger;
    qt = Number.isFinite;
    $t = Math.trunc;
    Jt = Tt(0);
    ne = /^-?([1-9][0-9]*|0)(\.[0-9]+)?$/;
    _e = {};
    ve = (function() {
      try {
        return _(new class extends Map {
          constructor() {
            super();
          }
        }()), false;
      } catch {
        return true;
      }
    })();
    Ee = class {
      constructor() {
        this.g = /* @__PURE__ */ new Map();
      }
      get(t2) {
        return this.g.get(t2);
      }
      set(t2, e2) {
        return this.g.set(t2, e2), this.size = this.g.size, this;
      }
      delete(t2) {
        return t2 = this.g.delete(t2), this.size = this.g.size, t2;
      }
      clear() {
        this.g.clear(), this.size = this.g.size;
      }
      has(t2) {
        return this.g.has(t2);
      }
      entries() {
        return this.g.entries();
      }
      keys() {
        return this.g.keys();
      }
      values() {
        return this.g.values();
      }
      forEach(t2, e2) {
        return this.g.forEach(t2, e2);
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
    we = ve ? (Object.setPrototypeOf(Ee.prototype, Map.prototype), Object.defineProperties(Ee.prototype, { size: { value: 0, configurable: true, enumerable: true, writable: true } }), Ee) : class extends Map {
      constructor() {
        super();
      }
    };
    be = class extends we {
      constructor(t2, e2, n2 = Te, r2 = Te) {
        super(), this.J = 0 | t2[et], this.K = e2, this.S = n2, this.fa = this.K ? ke : r2;
        for (let i2 = 0; i2 < t2.length; i2++) {
          const s2 = t2[i2], o2 = n2(s2[0], false, true);
          let a2 = s2[1];
          e2 ? void 0 === a2 && (a2 = null) : a2 = r2(s2[1], false, true, void 0, void 0, this.J), super.set(o2, a2);
        }
      }
      V(t2) {
        return at(Array.from(super.entries(), t2));
      }
      clear() {
        Ae(this), super.clear();
      }
      delete(t2) {
        return Ae(this), super.delete(this.S(t2, true, false));
      }
      entries() {
        if (this.K) {
          var t2 = super.keys();
          t2 = new ft(t2, Se, this);
        } else t2 = super.entries();
        return t2;
      }
      values() {
        if (this.K) {
          var t2 = super.keys();
          t2 = new ft(t2, be.prototype.get, this);
        } else t2 = super.values();
        return t2;
      }
      forEach(t2, e2) {
        this.K ? super.forEach(((n2, r2, i2) => {
          t2.call(e2, i2.get(r2), r2, i2);
        })) : super.forEach(t2, e2);
      }
      set(t2, e2) {
        return Ae(this), null == (t2 = this.S(t2, true, false)) ? this : null == e2 ? (super.delete(t2), this) : super.set(t2, this.fa(e2, true, true, this.K, false, this.J));
      }
      Ma(t2) {
        const e2 = this.S(t2[0], false, true);
        t2 = t2[1], t2 = this.K ? void 0 === t2 ? null : t2 : this.fa(t2, false, true, void 0, false, this.J), super.set(e2, t2);
      }
      has(t2) {
        return super.has(this.S(t2, false, false));
      }
      get(t2) {
        t2 = this.S(t2, false, false);
        const e2 = super.get(t2);
        if (void 0 !== e2) {
          var n2 = this.K;
          return n2 ? ((n2 = this.fa(e2, false, true, n2, this.ra, this.J)) !== e2 && super.set(t2, n2), n2) : e2;
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
    be.prototype.toJSON = void 0;
    Fe = class {
    };
    Me = { Ka: true };
    Ze = Tt(0);
    Qe = {};
    Un = class {
      constructor(t2, e2, n2) {
        if (this.buffer = t2, n2 && !e2) throw Error();
        this.g = e2;
      }
    };
    Yn = [];
    rr = class {
      constructor(t2, e2, n2, r2) {
        if (Yn.length) {
          const i2 = Yn.pop();
          i2.init(t2, e2, n2, r2), t2 = i2;
        } else t2 = new class {
          constructor(t3, e3, n3, r3) {
            this.h = null, this.j = false, this.g = this.l = this.m = 0, this.init(t3, e3, n3, r3);
          }
          init(t3, e3, n3, { Y: r3 = false, ea: i2 = false } = {}) {
            this.Y = r3, this.ea = i2, t3 && (t3 = Dn(t3, this.ea), this.h = t3.buffer, this.j = t3.g, this.m = e3 || 0, this.l = void 0 !== n3 ? this.m + n3 : this.h.length, this.g = this.m);
          }
          clear() {
            this.h = null, this.j = false, this.g = this.l = this.m = 0, this.Y = false;
          }
        }(t2, e2, n2, r2);
        this.g = t2, this.m = this.g.g, this.h = this.l = -1, this.o(r2);
      }
      o({ ha: t2 = false } = {}) {
        this.ha = t2;
      }
    };
    ir = [];
    or = class {
      constructor(t2, e2) {
        this.h = t2 >>> 0, this.g = e2 >>> 0;
      }
    };
    hr = class {
      constructor(t2, e2) {
        this.h = t2 >>> 0, this.g = e2 >>> 0;
      }
    };
    Tr = wr();
    Ar = wr();
    br = wr();
    kr = wr();
    Sr = wr();
    xr = wr();
    Lr = wr();
    Rr = wr();
    Ir = wr();
    Fr = wr();
    Pr = class {
      constructor(t2, e2) {
        this.v = je(t2, e2, void 0, 2048);
      }
      toJSON() {
        return Ue(this);
      }
      j() {
        var t2 = Fo, e2 = this.v, n2 = t2.g, r2 = z;
        if (j && r2 && null != e2[r2]?.[n2] && B(K, 3), e2 = t2.g, Z && z && void 0 === Z && (r2 = (n2 = this.v)[z]) && (r2 = r2.da)) try {
          r2(n2, e2, Me);
        } catch (t3) {
          u(t3);
        }
        return t2.h ? t2.m(this, t2.h, t2.g, t2.l) : t2.m(this, t2.g, t2.defaultValue, t2.l);
      }
      clone() {
        const t2 = this.v, e2 = 0 | t2[et];
        return Je(this, t2, e2) ? He(this, t2, true) : new this.constructor(ze(t2, e2, false));
      }
    };
    Pr.prototype[J] = ct, Pr.prototype.toString = function() {
      return this.v.toString();
    };
    Cr = class {
      constructor(t2, e2, n2) {
        this.g = t2, this.h = e2, t2 = Tr, this.l = !!t2 && n2 === t2 || false;
      }
    };
    Ur = Or((function(t2, e2, n2, r2, i2) {
      return 2 === t2.h && (Qn(t2, vn(e2, r2, n2), i2), true);
    }), Nr);
    Dr = Or((function(t2, e2, n2, r2, i2) {
      return 2 === t2.h && (Qn(t2, vn(e2, r2, n2), i2), true);
    }), Nr);
    Br = /* @__PURE__ */ Symbol();
    Gr = /* @__PURE__ */ Symbol();
    jr = /* @__PURE__ */ Symbol();
    Vr = /* @__PURE__ */ Symbol();
    Xr = /* @__PURE__ */ Symbol();
    ii = Tt(0);
    hi = Or((function(t2, e2, n2, r2, i2) {
      if (2 !== t2.h) return false;
      if (t2 = Wt(t2 = Qn(t2, Ge([void 0, void 0], r2), i2)), i2 = mt(r2 = 0 | e2[et]), 2 & r2) throw Error();
      let s2 = en(e2, n2, i2);
      if (s2 instanceof be) 0 != (2 & s2.J) ? (s2 = s2.V(), s2.push(t2), rn(e2, r2, n2, s2, i2)) : s2.Ma(t2);
      else if (Array.isArray(s2)) {
        var o2 = 0 | s2[et];
        8192 & o2 || st(s2, o2 |= 8192), 2 & o2 && (s2 = fn(s2), rn(e2, r2, n2, s2, i2)), s2.push(t2);
      } else rn(e2, r2, n2, at([t2]), i2);
      return true;
    }), (function(t2, e2, n2, r2, i2) {
      if (e2 instanceof be) e2.forEach(((e3, s2) => {
        Er(t2, n2, Ge([s2, e3], r2), i2);
      }));
      else if (Array.isArray(e2)) {
        for (let s2 = 0; s2 < e2.length; s2++) {
          const o2 = e2[s2];
          Array.isArray(o2) && Er(t2, n2, Ge(o2, r2), i2);
        }
        at(e2);
      }
    }));
    _i = oi((function(t2, e2, n2) {
      return 5 === t2.h && (ci(e2, n2, Xn(t2.g)), true);
    }), ui, Rr);
    vi = ai(yi, (function(t2, e2, n2) {
      if (null != (e2 = si(Qt, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
        var r2 = t2, i2 = n2, s2 = e2[o2];
        null != s2 && (mr(r2, i2, 5), r2 = r2.g, Ot(s2), pr(r2));
      }
    }), Rr);
    Ei = ai(yi, (function(t2, e2, n2) {
      if (null != (e2 = si(Qt, e2)) && e2.length) {
        mr(t2, n2, 2), fr(t2.g, 4 * e2.length);
        for (let r2 = 0; r2 < e2.length; r2++) n2 = t2.g, Ot(e2[r2]), pr(n2);
      }
    }), Rr);
    wi = oi((function(t2, e2, n2) {
      return 5 === t2.h && (ci(e2, n2, 0 === (t2 = Xn(t2.g)) ? void 0 : t2), true);
    }), ui, Rr);
    Ti = oi((function(t2, e2, n2) {
      return p ? (0 !== t2.h ? t2 = false : (ci(e2, n2, Bn(t2.g, Bt)), t2 = true), t2) : 0 === t2.h && (ci(e2, n2, Bn(t2.g, Dt)), true);
    }), li, xr);
    Ai = oi((function(t2, e2, n2) {
      return p ? (0 !== t2.h ? e2 = false : (ci(e2, n2, (t2 = Bn(t2.g, Bt)) === ii ? void 0 : t2), e2 = true), e2) : 0 === t2.h && (ci(e2, n2, 0 === (t2 = Bn(t2.g, Dt)) ? void 0 : t2), true);
    }), li, xr);
    bi = oi((function(t2, e2, n2) {
      return p ? (0 !== t2.h ? t2 = false : (ci(e2, n2, Bn(t2.g, Ut)), t2 = true), t2) : 0 === t2.h && (ci(e2, n2, Bn(t2.g, Nt)), true);
    }), (function(t2, e2, n2) {
      if (e2 = (function(t3) {
        if (null == t3) return t3;
        var e3 = typeof t3;
        if ("bigint" === e3) return String(Kt(64, t3));
        if (re(t3)) {
          if ("string" === e3) return e3 = $t(Number(t3)), Yt(e3) && e3 >= 0 ? t3 = String(e3) : (-1 !== (e3 = t3.indexOf(".")) && (t3 = t3.substring(0, e3)), (e3 = "-" !== t3[0] && ((e3 = t3.length) < 20 || 20 === e3 && t3 <= "18446744073709551615")) || (Xt(t3), t3 = Gt(Ft, Mt))), t3;
          if ("number" === e3) return (t3 = $t(t3)) >= 0 && Yt(t3) || (Ct(t3), t3 = Nt(Ft, Mt)), t3;
        }
      })(e2), null != e2) {
        if ("string" == typeof e2) sr(e2);
        if (null != e2) switch (mr(t2, n2, 0), typeof e2) {
          case "number":
            t2 = t2.g, Ct(e2), lr(t2, Ft, Mt);
            break;
          case "bigint":
            n2 = BigInt.asUintN(64, e2), n2 = new or(Number(n2 & BigInt(4294967295)), Number(n2 >> BigInt(32))), lr(t2.g, n2.h, n2.g);
            break;
          default:
            n2 = sr(e2), lr(t2.g, n2.h, n2.g);
        }
      }
    }), Lr);
    ki = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, jn(t2.g)), true);
    }), fi, kr);
    Si = ai((function(t2, e2, n2) {
      return (0 === t2.h || 2 === t2.h) && (e2 = pn(e2, 0 | e2[et], n2), 2 == t2.h ? nr(t2, jn, e2) : e2.push(jn(t2.g)), true);
    }), (function(t2, e2, n2) {
      if (null != (e2 = si(ie, e2)) && e2.length) {
        n2 = yr(t2, n2);
        for (let n3 = 0; n3 < e2.length; n3++) dr(t2.g, e2[n3]);
        _r(t2, n2);
      }
    }), kr);
    xi = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, 0 === (t2 = jn(t2.g)) ? void 0 : t2), true);
    }), fi, kr);
    Li = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, Gn(t2.g)), true);
    }), di, Ar);
    Ri = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, false === (t2 = Gn(t2.g)) ? void 0 : t2), true);
    }), di, Ar);
    Ii = ai((function(t2, e2, n2) {
      return 2 === t2.h && (t2 = tr(t2), pn(e2, 0 | e2[et], n2).push(t2), true);
    }), (function(t2, e2, n2) {
      if (null != (e2 = si(ge, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
        var r2 = t2, i2 = n2, s2 = e2[o2];
        null != s2 && vr(r2, i2, h(s2));
      }
    }), br);
    Fi = oi((function(t2, e2, n2) {
      return 2 === t2.h && (ci(e2, n2, "" === (t2 = tr(t2)) ? void 0 : t2), true);
    }), pi, br);
    Mi = oi((function(t2, e2, n2) {
      return 2 === t2.h && (ci(e2, n2, tr(t2)), true);
    }), pi, br);
    Pi = (function(t2, e2, n2 = Tr) {
      return new Cr(t2, e2, n2);
    })((function(t2, e2, n2, r2, i2) {
      return 2 === t2.h && (r2 = Ge(void 0, r2), pn(e2, 0 | e2[et], n2).push(r2), Qn(t2, r2, i2), true);
    }), (function(t2, e2, n2, r2, i2) {
      if (Array.isArray(e2)) {
        for (let s2 = 0; s2 < e2.length; s2++) gi(t2, e2[s2], n2, r2, i2);
        1 & (t2 = 0 | e2[et]) || st(e2, 1 | t2);
      }
    }));
    Ci = Or((function(t2, e2, n2, r2, i2, s2) {
      if (2 !== t2.h) return false;
      let o2 = 0 | e2[et];
      return yn(e2, o2, s2, n2, mt(o2)), Qn(t2, e2 = vn(e2, r2, n2), i2), true;
    }), gi);
    Oi = oi((function(t2, e2, n2) {
      return 2 === t2.h && (ci(e2, n2, er(t2)), true);
    }), mi, Ir);
    Ni = ai((function(t2, e2, n2) {
      return (0 === t2.h || 2 === t2.h) && (e2 = pn(e2, 0 | e2[et], n2), 2 == t2.h ? nr(t2, Vn, e2) : e2.push(Vn(t2.g)), true);
    }), (function(t2, e2, n2) {
      if (null != (e2 = si(se, e2))) for (let o2 = 0; o2 < e2.length; o2++) {
        var r2 = t2, i2 = n2, s2 = e2[o2];
        null != s2 && (mr(r2, i2, 0), fr(r2.g, s2));
      }
    }), Sr);
    Ui = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, 0 === (t2 = Vn(t2.g)) ? void 0 : t2), true);
    }), (function(t2, e2, n2) {
      null != (e2 = se(e2)) && null != e2 && (mr(t2, n2, 0), fr(t2.g, e2));
    }), Sr);
    Di = oi((function(t2, e2, n2) {
      return 0 === t2.h && (ci(e2, n2, jn(t2.g)), true);
    }), (function(t2, e2, n2) {
      null != (e2 = ie(e2)) && (e2 = parseInt(e2, 10), mr(t2, n2, 0), dr(t2.g, e2));
    }), Fr);
    Bi = class {
      constructor(t2, e2) {
        var n2 = rs;
        this.g = t2, this.h = e2, this.m = wn, this.j = kn, this.defaultValue = void 0, this.l = null != n2.Oa ? gt : void 0;
      }
      register() {
        _(this);
      }
    };
    Xi = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Hi = [0, Fi, oi((function(t2, e2, n2) {
      return 2 === t2.h && (ci(e2, n2, (t2 = er(t2)) === F() ? void 0 : t2), true);
    }), (function(t2, e2, n2) {
      if (null != e2) {
        if (e2 instanceof Pr) {
          const r2 = e2.Ra;
          return void (r2 ? (e2 = r2(e2), null != e2 && vr(t2, n2, Dn(e2, true).buffer)) : B(q, 3));
        }
        if (Array.isArray(e2)) return void B(q, 3);
      }
      mi(t2, e2, n2);
    }), Ir)];
    zi = globalThis.trustedTypes;
    qi = [0, ki, Di, Li, -1, Si, Di, -1, Li];
    $i = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ji = [0, Li, Mi, Li, Di, -1, ai((function(t2, e2, n2) {
      return (0 === t2.h || 2 === t2.h) && (e2 = pn(e2, 0 | e2[et], n2), 2 == t2.h ? nr(t2, Hn, e2) : e2.push(jn(t2.g)), true);
    }), (function(t2, e2, n2) {
      if (null != (e2 = si(ie, e2)) && e2.length) {
        n2 = yr(t2, n2);
        for (let n3 = 0; n3 < e2.length; n3++) dr(t2.g, e2[n3]);
        _r(t2, n2);
      }
    }), Fr), Mi, -1, [0, Li, -1], Di, Li, -1];
    Zi = [0, 3, Li, -1, 2, [0, ki], [0, Di, Li], [0, Mi, -1], [0]];
    Qi = [0, Mi, -2];
    ts = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    es = [0];
    ns = [0, ki, Li, 1, Li, -4];
    rs = class extends Pr {
      constructor(t2) {
        super(t2, 2);
      }
    };
    is = {};
    is[336783863] = [0, Mi, Li, -1, ki, [0, [1, 2, 3, 4, 5, 6, 7, 8, 9], Ci, es, Ci, Ji, Ci, Qi, Ci, ns, Ci, qi, Ci, [0, Mi, -2], Ci, [0, Mi, Di], Ci, Zi, Ci, [0, Di, -1, Li]], [0, Mi], Li, [0, [1, 3], [2, 4], Ci, [0, Si], -1, Ci, [0, Ii], -1, Pi, [0, Mi, -1]], Mi];
    ss = [0, Ai, -1, Ri, -3, Ai, Si, Fi, xi, Ai, -1, Ri, xi, Ri, -2, Fi];
    cs = class extends Pr {
      constructor(t2) {
        super(t2, 500);
      }
      o(t2) {
        return kn(this, 0, 7, t2);
      }
    };
    hs = [-1, {}];
    us = [0, Mi, 1, hs];
    ls = [0, Mi, Ii, hs];
    gs = class extends Pr {
      constructor(t2) {
        super(t2, 500);
      }
      o(t2) {
        return kn(this, 0, 1001, t2);
      }
    };
    ms = [-500, Pi, [-500, Fi, -1, Ii, -3, [-2, is, Li], Pi, Hi, xi, -1, us, ls, Pi, [0, Fi, Ri], Fi, ss, xi, Ii, 987, Ii], 4, Pi, [-500, Mi, -1, [-1, {}], 998, Mi], Pi, [-500, Mi, Ii, -1, [-2, {}, Li], 997, Ii, -1], xi, Pi, [-500, Mi, Ii, hs, 998, Ii], Ii, xi, us, ls, Pi, [0, Fi, -1, hs], Ii, -2, ss, Fi, -1, Ri, [0, Ri, Ui], 978, hs, Pi, Hi];
    gs.prototype.g = Vi(ms);
    ys = ji(gs, ms);
    _s = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    vs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      g() {
        return An(this, _s, 1);
      }
    };
    Es = [0, Pi, [0, ki, _i, Mi, -1]];
    ws = ji(vs, Es);
    Ts = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    As = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    bs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      l() {
        return wn(this, Ts, 2);
      }
      g() {
        return An(this, As, 5);
      }
    };
    ks = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, Ii, Si, Ei, [0, Di, [0, ki, -3], [0, _i, -3], [0, ki, -1, [0, Pi, [0, ki, -2]]], Pi, [0, _i, -1, Mi, _i]], Mi, -1, Ti, Pi, [0, ki, _i], Ii, Ti]);
    Ss = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    xs = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, Pi, [0, _i, -4]]);
    Ls = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Rs = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, Pi, [0, _i, -4]]);
    Is = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Fs = [0, ki, -1, Ei, Di];
    Ms = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ms.prototype.g = Vi([0, _i, -4, Ti]);
    Ps = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Cs = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, Pi, [0, 1, ki, Mi, Es], Ti]);
    Os = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ns = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      na() {
        const t2 = tn(this, 1, void 0, void 0, ln);
        return null == t2 ? F() : t2;
      }
    };
    Us = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ds = [1, 2];
    Bs = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, Pi, [0, Ds, Ci, [0, Ei], Ci, [0, Oi], ki, Mi], Ti]);
    Gs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    js = [0, Mi, ki, _i, Ii, -1];
    Vs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Xs = [0, Li, -1];
    Hs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ws = [1, 2, 3, 4, 5, 6];
    zs = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      g() {
        return null != tn(this, 1, void 0, void 0, ln);
      }
      l() {
        return null != ge(tn(this, 2));
      }
    };
    Ks = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      g() {
        return ee(tn(this, 2)) ?? false;
      }
    };
    Ys = [0, Oi, Mi, [0, ki, Ti, -1], [0, bi, Ti]];
    qs = [0, Ys, Li, [0, Ws, Ci, ns, Ci, Ji, Ci, qi, Ci, es, Ci, Qi, Ci, Zi], Di];
    $s = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Js = [0, qs, _i, -1, ki];
    Zs = Gi(502141897, $s);
    is[502141897] = Js;
    Qs = ji(class extends Pr {
      constructor(t2) {
        super(t2);
      }
    }, [0, [0, Di, -1, vi, Ni], Fs]);
    to = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    eo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    no = [0, qs, _i, [0, qs], Li];
    ro = Gi(508968150, eo);
    is[508968150] = [0, qs, Js, no, _i, [0, [0, Ys]]], is[508968149] = no;
    io = class extends Pr {
      constructor(t2) {
        super(t2);
      }
      l() {
        return wn(this, Gs, 2);
      }
      g() {
        nn(this, 2);
      }
    };
    so = [0, qs, js];
    is[478825465] = so;
    oo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    ao = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    co = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    ho = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    uo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    lo = [0, qs, [0, qs], so, -1];
    fo = [0, qs, _i, ki];
    po = [0, qs, _i];
    go = [0, qs, fo, po, _i];
    mo = Gi(479097054, uo);
    is[479097054] = [0, qs, go, lo], is[463370452] = lo, is[464864288] = fo;
    yo = Gi(462713202, ho);
    is[462713202] = go, is[474472470] = po;
    _o = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    vo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Eo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    wo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    To = [0, qs, _i, -1, ki];
    Ao = [0, qs, _i, Li];
    wo.prototype.g = Vi([0, qs, po, [0, qs], Js, no, To, Ao]);
    bo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    ko = Gi(456383383, bo);
    is[456383383] = [0, qs, js];
    So = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    xo = Gi(476348187, So);
    is[476348187] = [0, qs, Xs];
    Lo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Ro = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Io = [0, Di, -1];
    Fo = Gi(458105876, class extends Pr {
      constructor(t2) {
        super(t2);
      }
      g() {
        let t2;
        var e2 = this.v;
        const n2 = 0 | e2[et];
        return t2 = ht(this, n2), e2 = (function(t3, e3, n3, r2) {
          var i2 = Ro;
          !r2 && Ye(t3) && (n3 = 0 | (e3 = t3.v)[et]);
          var s2 = en(e3, 2);
          if (t3 = false, null == s2) {
            if (r2) return Le();
            s2 = [];
          } else if (s2.constructor === be) {
            if (!(2 & s2.J) || r2) return s2;
            s2 = s2.V();
          } else Array.isArray(s2) ? t3 = !!(2 & (0 | s2[et])) : s2 = [];
          if (r2) {
            if (!s2.length) return Le();
            t3 || (t3 = true, ot(s2));
          } else t3 && (t3 = false, at(s2), s2 = fn(s2));
          return !t3 && 32 & n3 && it(s2, 32), n3 = rn(e3, n3, 2, r2 = new be(s2, i2, ye, void 0)), t3 || $e(e3, n3), r2;
        })(this, e2, n2, t2), !t2 && Ro && (e2.ra = true), e2;
      }
    });
    is[458105876] = [0, Io, hi, [true, Ti, [0, Mi, -1, Ii]], [0, Si, Li, Di]];
    Mo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Po = Gi(458105758, Mo);
    is[458105758] = [0, qs, Mi, Io];
    Co = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Oo = [0, wi, -1, Ri];
    No = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Uo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Do = [1, 2];
    Uo.prototype.g = Vi([0, Do, Ci, Oo, Ci, [0, Pi, Oo]]);
    Bo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Go = Gi(443442058, Bo);
    is[443442058] = [0, qs, Mi, ki, _i, Ii, -1, Li, _i], is[514774813] = To;
    jo = class extends Pr {
      constructor(t2) {
        super(t2);
      }
    };
    Vo = Gi(516587230, jo);
    is[516587230] = [0, qs, To, Ao, _i], is[518928384] = Ao;
    Qo = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 5, 1, 96, 0, 1, 123, 3, 2, 1, 0, 10, 10, 1, 8, 0, 65, 0, 253, 15, 253, 98, 11]);
    na = class {
    };
    na.forVisionTasks = function(t2) {
      return ea("vision", t2);
    }, na.forTextTasks = function(t2) {
      return ea("text", t2);
    }, na.forGenAiExperimentalTasks = function(t2) {
      return ea("genai_experimental", t2);
    }, na.forGenAiTasks = function(t2) {
      return ea("genai", t2);
    }, na.forAudioTasks = function(t2) {
      return ea("audio", t2);
    }, na.isSimdSupported = function() {
      return ta();
    };
    _a = class {
      constructor(t2) {
        this.g = t2, this.H = [], this.C = 0, this.g.setAutoRenderToScreen(false);
      }
      l(t2, e2 = true) {
        if (e2) {
          const e3 = t2.baseOptions || {};
          if (t2.baseOptions?.modelAssetBuffer && t2.baseOptions?.modelAssetPath) throw Error("Cannot set both baseOptions.modelAssetPath and baseOptions.modelAssetBuffer");
          if (!(wn(this.baseOptions, zs, 1)?.g() || wn(this.baseOptions, zs, 1)?.l() || t2.baseOptions?.modelAssetBuffer || t2.baseOptions?.modelAssetPath)) throw Error("Either baseOptions.modelAssetPath or baseOptions.modelAssetBuffer must be set");
          if ((function(t3, e4) {
            let n2 = wn(t3.baseOptions, Hs, 3);
            if (!n2) {
              var r2 = n2 = new Hs(), i2 = new ts();
              Sn(r2, 4, Ws, i2);
            }
            "delegate" in e4 && ("GPU" === e4.delegate ? (e4 = n2, r2 = new $i(), Sn(e4, 2, Ws, r2)) : (e4 = n2, r2 = new ts(), Sn(e4, 4, Ws, r2))), kn(t3.baseOptions, 0, 3, n2);
          })(this, e3), e3.modelAssetPath) return fetch(e3.modelAssetPath.toString()).then(((t3) => {
            if (t3.ok) return t3.arrayBuffer();
            throw Error(`Failed to fetch model: ${e3.modelAssetPath} (${t3.status})`);
          })).then(((t3) => {
            try {
              this.g.i.FS_unlink("/model.dat");
            } catch {
            }
            this.g.i.FS_createDataFile("/", "model.dat", new Uint8Array(t3), true, false, false), fa(this, "/model.dat"), this.m(), this.L();
          }));
          if (e3.modelAssetBuffer instanceof Uint8Array) fa(this, e3.modelAssetBuffer);
          else if (e3.modelAssetBuffer) return (async function(t3) {
            const e4 = [];
            for (var n2 = 0; ; ) {
              const { done: r2, value: i2 } = await t3.read();
              if (r2) break;
              e4.push(i2), n2 += i2.length;
            }
            if (0 === e4.length) return new Uint8Array(0);
            if (1 === e4.length) return e4[0];
            t3 = new Uint8Array(n2), n2 = 0;
            for (const r2 of e4) t3.set(r2, n2), n2 += r2.length;
            return t3;
          })(e3.modelAssetBuffer).then(((t3) => {
            fa(this, t3), this.m(), this.L();
          }));
        }
        return this.m(), this.L(), Promise.resolve();
      }
      L() {
      }
      ca() {
        let t2;
        if (this.g.ca(((e2) => {
          t2 = ys(e2);
        })), !t2) throw Error("Failed to retrieve CalculatorGraphConfig");
        return t2;
      }
      setGraph(t2, e2) {
        this.g.attachErrorListener(((t3, e3) => {
          this.H.push(Error(e3));
        })), this.g.Ja(), this.g.setGraph(t2, e2), this.B = void 0, da(this);
      }
      finishProcessing() {
        this.g.finishProcessing(), da(this);
      }
      close() {
        this.B = void 0, this.g.closeGraph();
      }
    };
    _a.prototype.close = _a.prototype.close;
    Ea = class {
      constructor(t2, e2, n2, r2) {
        this.g = t2, this.h = e2, this.m = n2, this.l = r2;
      }
      bind() {
        this.g.bindVertexArray(this.h);
      }
      close() {
        this.g.deleteVertexArray(this.h), this.g.deleteBuffer(this.m), this.g.deleteBuffer(this.l);
      }
    };
    La = class {
      H() {
        return "\n  precision mediump float;\n  varying vec2 vTex;\n  uniform sampler2D inputTexture;\n  void main() {\n    gl_FragColor = texture2D(inputTexture, vTex);\n  }\n ";
      }
      m() {
        const t2 = this.g;
        if (this.h = va(t2.createProgram(), "Failed to create WebGL program"), this.X = wa(this, "\n  attribute vec2 aVertex;\n  attribute vec2 aTex;\n  varying vec2 vTex;\n  void main(void) {\n    gl_Position = vec4(aVertex, 0.0, 1.0);\n    vTex = aTex;\n  }", t2.VERTEX_SHADER), this.W = wa(this, this.H(), t2.FRAGMENT_SHADER), t2.linkProgram(this.h), !t2.getProgramParameter(this.h, t2.LINK_STATUS)) throw Error(`Error during program linking: ${t2.getProgramInfoLog(this.h)}`);
        this.O = t2.getAttribLocation(this.h, "aVertex"), this.L = t2.getAttribLocation(this.h, "aTex");
      }
      D() {
      }
      l() {
      }
      close() {
        if (this.h) {
          const t2 = this.g;
          t2.deleteProgram(this.h), t2.deleteShader(this.X), t2.deleteShader(this.W);
        }
        this.B && this.g.deleteFramebuffer(this.B), this.A && this.A.close(), this.u && this.u.close();
      }
    };
    Ra = class extends La {
      H() {
        return "\n  precision mediump float;\n  uniform sampler2D backgroundTexture;\n  uniform sampler2D maskTexture;\n  uniform sampler2D colorMappingTexture;\n  varying vec2 vTex;\n  void main() {\n    vec4 backgroundColor = texture2D(backgroundTexture, vTex);\n    float category = texture2D(maskTexture, vTex).r;\n    vec4 categoryColor = texture2D(colorMappingTexture, vec2(category, 0.0));\n    gl_FragColor = mix(backgroundColor, categoryColor, categoryColor.a);\n  }\n ";
      }
      D() {
        const t2 = this.g;
        t2.activeTexture(t2.TEXTURE1), this.C = ka(this, t2, t2.LINEAR), t2.activeTexture(t2.TEXTURE2), this.j = ka(this, t2, t2.NEAREST);
      }
      m() {
        super.m();
        const t2 = this.g;
        this.P = va(t2.getUniformLocation(this.h, "backgroundTexture"), "Uniform location"), this.U = va(t2.getUniformLocation(this.h, "colorMappingTexture"), "Uniform location"), this.M = va(t2.getUniformLocation(this.h, "maskTexture"), "Uniform location");
      }
      l() {
        super.l();
        const t2 = this.g;
        t2.uniform1i(this.M, 0), t2.uniform1i(this.P, 1), t2.uniform1i(this.U, 2);
      }
      close() {
        this.C && this.g.deleteTexture(this.C), this.j && this.g.deleteTexture(this.j), super.close();
      }
    };
    Ia = class extends La {
      H() {
        return "\n  precision mediump float;\n  uniform sampler2D maskTexture;\n  uniform sampler2D defaultTexture;\n  uniform sampler2D overlayTexture;\n  varying vec2 vTex;\n  void main() {\n    float confidence = texture2D(maskTexture, vTex).r;\n    vec4 defaultColor = texture2D(defaultTexture, vTex);\n    vec4 overlayColor = texture2D(overlayTexture, vTex);\n    // Apply the alpha from the overlay and merge in the default color\n    overlayColor = mix(defaultColor, overlayColor, overlayColor.a);\n    gl_FragColor = mix(defaultColor, overlayColor, confidence);\n  }\n ";
      }
      D() {
        const t2 = this.g;
        t2.activeTexture(t2.TEXTURE1), this.j = ka(this, t2), t2.activeTexture(t2.TEXTURE2), this.C = ka(this, t2);
      }
      m() {
        super.m();
        const t2 = this.g;
        this.M = va(t2.getUniformLocation(this.h, "defaultTexture"), "Uniform location"), this.P = va(t2.getUniformLocation(this.h, "overlayTexture"), "Uniform location"), this.I = va(t2.getUniformLocation(this.h, "maskTexture"), "Uniform location");
      }
      l() {
        super.l();
        const t2 = this.g;
        t2.uniform1i(this.I, 0), t2.uniform1i(this.M, 1), t2.uniform1i(this.P, 2);
      }
      close() {
        this.j && this.g.deleteTexture(this.j), this.C && this.g.deleteTexture(this.C), super.close();
      }
    };
    Ga = class {
      constructor(t2, e2, n2, r2, i2, s2, o2) {
        this.g = t2, this.m = e2, this.j = n2, this.canvas = r2, this.l = i2, this.width = s2, this.height = o2, this.j && (0 === --ja && console.error("You seem to be creating MPMask instances without invoking .close(). This leaks resources."));
      }
      Fa() {
        return !!Fa(this, 0);
      }
      ka() {
        return !!Fa(this, 1);
      }
      R() {
        return !!Fa(this, 2);
      }
      ja() {
        return (e2 = Fa(t2 = this, 0)) || (e2 = Ma(t2), e2 = new Uint8Array(e2.map(((t3) => Math.round(255 * t3)))), t2.g.push(e2)), e2;
        var t2, e2;
      }
      ia() {
        return Ma(this);
      }
      N() {
        return Pa(this);
      }
      clone() {
        const t2 = [];
        for (const e2 of this.g) {
          let n2;
          if (e2 instanceof Uint8Array) n2 = new Uint8Array(e2);
          else if (e2 instanceof Float32Array) n2 = new Float32Array(e2);
          else {
            if (!(e2 instanceof WebGLTexture)) throw Error(`Type is not supported: ${e2}`);
            {
              const t3 = Ca(this), e3 = Na(this);
              t3.activeTexture(t3.TEXTURE1), n2 = ka(e3, t3, this.m ? t3.LINEAR : t3.NEAREST), t3.bindTexture(t3.TEXTURE_2D, n2);
              const r2 = Oa(this);
              t3.texImage2D(t3.TEXTURE_2D, 0, r2, this.width, this.height, 0, t3.RED, t3.FLOAT, null), t3.bindTexture(t3.TEXTURE_2D, null), Sa(e3, t3, n2), ba(e3, t3, false, (() => {
                Ua(this), t3.clearColor(0, 0, 0, 0), t3.clear(t3.COLOR_BUFFER_BIT), t3.drawArrays(t3.TRIANGLE_FAN, 0, 4), Da(this);
              })), xa(e3), Da(this);
            }
          }
          t2.push(n2);
        }
        return new Ga(t2, this.m, this.R(), this.canvas, this.l, this.width, this.height);
      }
      close() {
        this.j && Ca(this).deleteTexture(Fa(this, 2)), ja = -1;
      }
    };
    Ga.prototype.close = Ga.prototype.close, Ga.prototype.clone = Ga.prototype.clone, Ga.prototype.getAsWebGLTexture = Ga.prototype.N, Ga.prototype.getAsFloat32Array = Ga.prototype.ia, Ga.prototype.getAsUint8Array = Ga.prototype.ja, Ga.prototype.hasWebGLTexture = Ga.prototype.R, Ga.prototype.hasFloat32Array = Ga.prototype.ka, Ga.prototype.hasUint8Array = Ga.prototype.Fa;
    ja = 250;
    Va = { color: "white", lineWidth: 4, radius: 6 };
    Ja = class {
      constructor(t2, e2) {
        "undefined" != typeof CanvasRenderingContext2D && t2 instanceof CanvasRenderingContext2D || t2 instanceof OffscreenCanvasRenderingContext2D ? (this.l = t2, this.j = e2) : this.j = t2;
      }
      ya(t2, e2) {
        if (t2) {
          var n2 = za(this);
          e2 = Xa(e2), n2.save();
          var r2 = n2.canvas, i2 = 0;
          for (const s2 of t2) n2.fillStyle = Ha(e2.fillColor, { index: i2, from: s2 }), n2.strokeStyle = Ha(e2.color, { index: i2, from: s2 }), n2.lineWidth = Ha(e2.lineWidth, { index: i2, from: s2 }), (t2 = new Path2D()).arc(s2.x * r2.width, s2.y * r2.height, Ha(e2.radius, { index: i2, from: s2 }), 0, 2 * Math.PI), n2.fill(t2), n2.stroke(t2), ++i2;
          n2.restore();
        }
      }
      xa(t2, e2, n2) {
        if (t2 && e2) {
          var r2 = za(this);
          n2 = Xa(n2), r2.save();
          var i2 = r2.canvas, s2 = 0;
          for (const o2 of e2) {
            r2.beginPath(), e2 = t2[o2.start];
            const a2 = t2[o2.end];
            e2 && a2 && (r2.strokeStyle = Ha(n2.color, { index: s2, from: e2, to: a2 }), r2.lineWidth = Ha(n2.lineWidth, { index: s2, from: e2, to: a2 }), r2.moveTo(e2.x * i2.width, e2.y * i2.height), r2.lineTo(a2.x * i2.width, a2.y * i2.height)), ++s2, r2.stroke();
          }
          r2.restore();
        }
      }
      ua(t2, e2) {
        const n2 = za(this);
        e2 = Xa(e2), n2.save(), n2.beginPath(), n2.lineWidth = Ha(e2.lineWidth, {}), n2.strokeStyle = Ha(e2.color, {}), n2.fillStyle = Ha(e2.fillColor, {}), n2.moveTo(t2.originX, t2.originY), n2.lineTo(t2.originX + t2.width, t2.originY), n2.lineTo(t2.originX + t2.width, t2.originY + t2.height), n2.lineTo(t2.originX, t2.originY + t2.height), n2.lineTo(t2.originX, t2.originY), n2.stroke(), n2.fill(), n2.restore();
      }
      va(t2, e2, n2 = [0, 0, 0, 255]) {
        this.l ? (function(t3, e3, n3, r2) {
          const i2 = Ka(t3);
          Ya(t3, e3, ((e4) => {
            qa(t3, e4, n3, r2), (e4 = za(t3)).drawImage(i2.canvas, 0, 0, e4.canvas.width, e4.canvas.height);
          }));
        })(this, t2, n2, e2) : qa(this, t2.N(), n2, e2);
      }
      wa(t2, e2, n2) {
        this.l ? (function(t3, e3, n3, r2) {
          const i2 = Ka(t3);
          Ya(t3, e3, ((e4) => {
            $a(t3, e4, n3, r2), (e4 = za(t3)).drawImage(i2.canvas, 0, 0, e4.canvas.width, e4.canvas.height);
          }));
        })(this, t2, e2, n2) : $a(this, t2.N(), e2, n2);
      }
      close() {
        this.g?.close(), this.g = void 0, this.h?.close(), this.h = void 0, this.m?.close(), this.m = void 0;
      }
    };
    Ja.prototype.close = Ja.prototype.close, Ja.prototype.drawConfidenceMask = Ja.prototype.wa, Ja.prototype.drawCategoryMask = Ja.prototype.va, Ja.prototype.drawBoundingBox = Ja.prototype.ua, Ja.prototype.drawConnectors = Ja.prototype.xa, Ja.prototype.drawLandmarks = Ja.prototype.ya, Ja.lerp = function(t2, e2, n2, r2, i2) {
      return Wa(r2 * (1 - (t2 - e2) / (n2 - e2)) + i2 * (1 - (n2 - t2) / (n2 - e2)), r2, i2);
    }, Ja.clamp = Wa;
    oc = class {
      constructor(t2, e2, n2, r2, i2, s2, o2) {
        this.g = t2, this.j = e2, this.m = n2, this.canvas = r2, this.l = i2, this.width = s2, this.height = o2, (this.j || this.m) && (0 === --ac && console.error("You seem to be creating MPImage instances without invoking .close(). This leaks resources."));
      }
      Ea() {
        return !!Za(this, 0);
      }
      la() {
        return !!Za(this, 1);
      }
      R() {
        return !!Za(this, 2);
      }
      Ca() {
        return Qa(this);
      }
      Ba() {
        var t2 = Za(this, 1);
        return t2 || (tc(this), rc(this), t2 = sc(this), ic(this), this.g.push(t2), this.j = true), t2;
      }
      N() {
        return tc(this);
      }
      clone() {
        const t2 = [];
        for (const e2 of this.g) {
          let n2;
          if (e2 instanceof ImageData) n2 = new ImageData(e2.data, this.width, this.height);
          else if (e2 instanceof WebGLTexture) {
            const t3 = ec(this), e3 = nc(this);
            t3.activeTexture(t3.TEXTURE1), n2 = ka(e3, t3), t3.bindTexture(t3.TEXTURE_2D, n2), t3.texImage2D(t3.TEXTURE_2D, 0, t3.RGBA, this.width, this.height, 0, t3.RGBA, t3.UNSIGNED_BYTE, null), t3.bindTexture(t3.TEXTURE_2D, null), Sa(e3, t3, n2), ba(e3, t3, false, (() => {
              rc(this), t3.clearColor(0, 0, 0, 0), t3.clear(t3.COLOR_BUFFER_BIT), t3.drawArrays(t3.TRIANGLE_FAN, 0, 4), ic(this);
            })), xa(e3), ic(this);
          } else {
            if (!(e2 instanceof ImageBitmap)) throw Error(`Type is not supported: ${e2}`);
            tc(this), rc(this), n2 = sc(this), ic(this);
          }
          t2.push(n2);
        }
        return new oc(t2, this.la(), this.R(), this.canvas, this.l, this.width, this.height);
      }
      close() {
        this.j && Za(this, 1).close(), this.m && ec(this).deleteTexture(Za(this, 2)), ac = -1;
      }
    };
    oc.prototype.close = oc.prototype.close, oc.prototype.clone = oc.prototype.clone, oc.prototype.getAsWebGLTexture = oc.prototype.N, oc.prototype.getAsImageBitmap = oc.prototype.Ba, oc.prototype.getAsImageData = oc.prototype.Ca, oc.prototype.hasWebGLTexture = oc.prototype.R, oc.prototype.hasImageBitmap = oc.prototype.la, oc.prototype.hasImageData = oc.prototype.Ea;
    ac = 250;
    hc = /* @__PURE__ */ (function(t2) {
      return class extends t2 {
        Ja() {
          this.i._registerModelResourcesGraphService();
        }
      };
    })((uc = class {
      constructor(t2, e2) {
        this.l = true, this.i = t2, this.g = null, this.h = 0, this.m = "function" == typeof this.i._addIntToInputStream, void 0 !== e2 ? this.i.canvas = e2 : ra() ? this.i.canvas = new OffscreenCanvas(1, 1) : (console.warn("OffscreenCanvas not supported and GraphRunner constructor glCanvas parameter is undefined. Creating backup canvas."), this.i.canvas = document.createElement("canvas"));
      }
      async initializeGraph(t2) {
        const e2 = await (await fetch(t2)).arrayBuffer();
        t2 = !(t2.endsWith(".pbtxt") || t2.endsWith(".textproto")), this.setGraph(new Uint8Array(e2), t2);
      }
      setGraphFromString(t2) {
        this.setGraph(new TextEncoder().encode(t2), false);
      }
      setGraph(t2, e2) {
        const n2 = t2.length, r2 = this.i._malloc(n2);
        this.i.HEAPU8.set(t2, r2), e2 ? this.i._changeBinaryGraph(n2, r2) : this.i._changeTextGraph(n2, r2), this.i._free(r2);
      }
      configureAudio(t2, e2, n2, r2, i2) {
        this.i._configureAudio || console.warn('Attempting to use configureAudio without support for input audio. Is build dep ":gl_graph_runner_audio" missing?'), oa(this, r2 || "input_audio", ((r3) => {
          oa(this, i2 = i2 || "audio_header", ((i3) => {
            this.i._configureAudio(r3, i3, t2, e2 ?? 0, n2);
          }));
        }));
      }
      setAutoResizeCanvas(t2) {
        this.l = t2;
      }
      setAutoRenderToScreen(t2) {
        this.i._setAutoRenderToScreen(t2);
      }
      setGpuBufferVerticalFlip(t2) {
        this.i.gpuOriginForWebTexturesIsBottomLeft = t2;
      }
      ca(t2) {
        ha(this, "__graph_config__", ((e2) => {
          t2(e2);
        })), oa(this, "__graph_config__", ((t3) => {
          this.i._getGraphConfig(t3, void 0);
        })), delete this.i.simpleListeners.__graph_config__;
      }
      attachErrorListener(t2) {
        this.i.errorListener = t2;
      }
      attachEmptyPacketListener(t2, e2) {
        this.i.emptyPacketListeners = this.i.emptyPacketListeners || {}, this.i.emptyPacketListeners[t2] = e2;
      }
      addAudioToStream(t2, e2, n2) {
        this.addAudioToStreamWithShape(t2, 0, 0, e2, n2);
      }
      addAudioToStreamWithShape(t2, e2, n2, r2, i2) {
        const s2 = 4 * t2.length;
        this.h !== s2 && (this.g && this.i._free(this.g), this.g = this.i._malloc(s2), this.h = s2), this.i.HEAPF32.set(t2, this.g / 4), oa(this, r2, ((t3) => {
          this.i._addAudioToInputStream(this.g, e2, n2, t3, i2);
        }));
      }
      addGpuBufferToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const [r2, i2] = aa(this, t2, e3);
          this.i._addBoundTextureToStream(e3, r2, i2, n2);
        }));
      }
      addBoolToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          this.i._addBoolToInputStream(t2, e3, n2);
        }));
      }
      addDoubleToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          this.i._addDoubleToInputStream(t2, e3, n2);
        }));
      }
      addFloatToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          this.i._addFloatToInputStream(t2, e3, n2);
        }));
      }
      addIntToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          this.i._addIntToInputStream(t2, e3, n2);
        }));
      }
      addUintToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          this.i._addUintToInputStream(t2, e3, n2);
        }));
      }
      addStringToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          oa(this, t2, ((t3) => {
            this.i._addStringToInputStream(t3, e3, n2);
          }));
        }));
      }
      addStringRecordToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          ca(this, Object.keys(t2), ((r2) => {
            ca(this, Object.values(t2), ((i2) => {
              this.i._addFlatHashMapToInputStream(r2, i2, Object.keys(t2).length, e3, n2);
            }));
          }));
        }));
      }
      addProtoToStream(t2, e2, n2, r2) {
        oa(this, n2, ((n3) => {
          oa(this, e2, ((e3) => {
            const i2 = this.i._malloc(t2.length);
            this.i.HEAPU8.set(t2, i2), this.i._addProtoToInputStream(i2, t2.length, e3, n3, r2), this.i._free(i2);
          }));
        }));
      }
      addEmptyPacketToStream(t2, e2) {
        oa(this, t2, ((t3) => {
          this.i._addEmptyPacketToInputStream(t3, e2);
        }));
      }
      addBoolVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateBoolVector(t2.length);
          if (!r2) throw Error("Unable to allocate new bool vector on heap.");
          for (const e4 of t2) this.i._addBoolVectorEntry(r2, e4);
          this.i._addBoolVectorToInputStream(r2, e3, n2);
        }));
      }
      addDoubleVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateDoubleVector(t2.length);
          if (!r2) throw Error("Unable to allocate new double vector on heap.");
          for (const e4 of t2) this.i._addDoubleVectorEntry(r2, e4);
          this.i._addDoubleVectorToInputStream(r2, e3, n2);
        }));
      }
      addFloatVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateFloatVector(t2.length);
          if (!r2) throw Error("Unable to allocate new float vector on heap.");
          for (const e4 of t2) this.i._addFloatVectorEntry(r2, e4);
          this.i._addFloatVectorToInputStream(r2, e3, n2);
        }));
      }
      addIntVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateIntVector(t2.length);
          if (!r2) throw Error("Unable to allocate new int vector on heap.");
          for (const e4 of t2) this.i._addIntVectorEntry(r2, e4);
          this.i._addIntVectorToInputStream(r2, e3, n2);
        }));
      }
      addUintVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateUintVector(t2.length);
          if (!r2) throw Error("Unable to allocate new unsigned int vector on heap.");
          for (const e4 of t2) this.i._addUintVectorEntry(r2, e4);
          this.i._addUintVectorToInputStream(r2, e3, n2);
        }));
      }
      addStringVectorToStream(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const r2 = this.i._allocateStringVector(t2.length);
          if (!r2) throw Error("Unable to allocate new string vector on heap.");
          for (const e4 of t2) oa(this, e4, ((t3) => {
            this.i._addStringVectorEntry(r2, t3);
          }));
          this.i._addStringVectorToInputStream(r2, e3, n2);
        }));
      }
      addBoolToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          this.i._addBoolToInputSidePacket(t2, e3);
        }));
      }
      addDoubleToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          this.i._addDoubleToInputSidePacket(t2, e3);
        }));
      }
      addFloatToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          this.i._addFloatToInputSidePacket(t2, e3);
        }));
      }
      addIntToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          this.i._addIntToInputSidePacket(t2, e3);
        }));
      }
      addUintToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          this.i._addUintToInputSidePacket(t2, e3);
        }));
      }
      addStringToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          oa(this, t2, ((t3) => {
            this.i._addStringToInputSidePacket(t3, e3);
          }));
        }));
      }
      addProtoToInputSidePacket(t2, e2, n2) {
        oa(this, n2, ((n3) => {
          oa(this, e2, ((e3) => {
            const r2 = this.i._malloc(t2.length);
            this.i.HEAPU8.set(t2, r2), this.i._addProtoToInputSidePacket(r2, t2.length, e3, n3), this.i._free(r2);
          }));
        }));
      }
      addBoolVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateBoolVector(t2.length);
          if (!n2) throw Error("Unable to allocate new bool vector on heap.");
          for (const e4 of t2) this.i._addBoolVectorEntry(n2, e4);
          this.i._addBoolVectorToInputSidePacket(n2, e3);
        }));
      }
      addDoubleVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateDoubleVector(t2.length);
          if (!n2) throw Error("Unable to allocate new double vector on heap.");
          for (const e4 of t2) this.i._addDoubleVectorEntry(n2, e4);
          this.i._addDoubleVectorToInputSidePacket(n2, e3);
        }));
      }
      addFloatVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateFloatVector(t2.length);
          if (!n2) throw Error("Unable to allocate new float vector on heap.");
          for (const e4 of t2) this.i._addFloatVectorEntry(n2, e4);
          this.i._addFloatVectorToInputSidePacket(n2, e3);
        }));
      }
      addIntVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateIntVector(t2.length);
          if (!n2) throw Error("Unable to allocate new int vector on heap.");
          for (const e4 of t2) this.i._addIntVectorEntry(n2, e4);
          this.i._addIntVectorToInputSidePacket(n2, e3);
        }));
      }
      addUintVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateUintVector(t2.length);
          if (!n2) throw Error("Unable to allocate new unsigned int vector on heap.");
          for (const e4 of t2) this.i._addUintVectorEntry(n2, e4);
          this.i._addUintVectorToInputSidePacket(n2, e3);
        }));
      }
      addStringVectorToInputSidePacket(t2, e2) {
        oa(this, e2, ((e3) => {
          const n2 = this.i._allocateStringVector(t2.length);
          if (!n2) throw Error("Unable to allocate new string vector on heap.");
          for (const e4 of t2) oa(this, e4, ((t3) => {
            this.i._addStringVectorEntry(n2, t3);
          }));
          this.i._addStringVectorToInputSidePacket(n2, e3);
        }));
      }
      attachBoolListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachBoolListener(t3);
        }));
      }
      attachBoolVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachBoolVectorListener(t3);
        }));
      }
      attachIntListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachIntListener(t3);
        }));
      }
      attachIntVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachIntVectorListener(t3);
        }));
      }
      attachUintListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachUintListener(t3);
        }));
      }
      attachUintVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachUintVectorListener(t3);
        }));
      }
      attachDoubleListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachDoubleListener(t3);
        }));
      }
      attachDoubleVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachDoubleVectorListener(t3);
        }));
      }
      attachFloatListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachFloatListener(t3);
        }));
      }
      attachFloatVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachFloatVectorListener(t3);
        }));
      }
      attachStringListener(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachStringListener(t3);
        }));
      }
      attachStringVectorListener(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachStringVectorListener(t3);
        }));
      }
      attachProtoListener(t2, e2, n2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachProtoListener(t3, n2 || false);
        }));
      }
      attachProtoVectorListener(t2, e2, n2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.i._attachProtoVectorListener(t3, n2 || false);
        }));
      }
      attachAudioListener(t2, e2, n2) {
        this.i._attachAudioListener || console.warn('Attempting to use attachAudioListener without support for output audio. Is build dep ":gl_graph_runner_audio_out" missing?'), ha(this, t2, ((t3, n3) => {
          t3 = new Float32Array(t3.buffer, t3.byteOffset, t3.length / 4), e2(t3, n3);
        })), oa(this, t2, ((t3) => {
          this.i._attachAudioListener(t3, n2 || false);
        }));
      }
      finishProcessing() {
        this.i._waitUntilIdle();
      }
      closeGraph() {
        this.i._closeGraph(), this.i.simpleListeners = void 0, this.i.emptyPacketListeners = void 0;
      }
    }, class extends uc {
      get ga() {
        return this.i;
      }
      pa(t2, e2, n2) {
        oa(this, e2, ((e3) => {
          const [r2, i2] = aa(this, t2, e3);
          this.ga._addBoundTextureAsImageToStream(e3, r2, i2, n2);
        }));
      }
      Z(t2, e2) {
        ha(this, t2, e2), oa(this, t2, ((t3) => {
          this.ga._attachImageListener(t3);
        }));
      }
      aa(t2, e2) {
        ua(this, t2, e2), oa(this, t2, ((t3) => {
          this.ga._attachImageVectorListener(t3);
        }));
      }
    }));
    lc = class extends hc {
    };
    yc = class extends _a {
      constructor(t2, e2, n2, r2) {
        super(t2), this.g = t2, this.X = e2, this.U = n2, this.oa = r2, this.P = new La();
      }
      l(t2, e2 = true) {
        if ("runningMode" in t2 && nn(this.baseOptions, 2, te(!!t2.runningMode && "IMAGE" !== t2.runningMode)), void 0 !== t2.canvas && this.g.i.canvas !== t2.canvas) throw Error("You must create a new task to reset the canvas.");
        return super.l(t2, e2);
      }
      close() {
        this.P.close(), super.close();
      }
    };
    yc.prototype.close = yc.prototype.close;
    _c = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect_in", false), this.j = { detections: [] }, kn(t2 = this.h = new $s(), 0, 1, e2 = new Ks()), Pn(this.h, 2, 0.5), Pn(this.h, 3, 0.3);
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return "minDetectionConfidence" in t2 && Pn(this.h, 2, t2.minDetectionConfidence ?? 0.5), "minSuppressionThreshold" in t2 && Pn(this.h, 3, t2.minSuppressionThreshold ?? 0.3), this.l(t2);
      }
      F(t2, e2) {
        return this.j = { detections: [] }, pc(this, t2, e2), this.j;
      }
      G(t2, e2, n2) {
        return this.j = { detections: [] }, gc(this, t2, n2, e2), this.j;
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect_in"), ps(t2, "detections");
        const e2 = new rs();
        Mr(e2, Zs, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.face_detector.FaceDetectorGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect_in"), as(n2, "DETECTIONS:detections"), n2.o(e2), fs(t2, n2), this.g.attachProtoVectorListener("detections", ((t3, e3) => {
          for (const e4 of t3) t3 = ks(e4), this.j.detections.push(Ko(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("detections", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    _c.prototype.detectForVideo = _c.prototype.G, _c.prototype.detect = _c.prototype.F, _c.prototype.setOptions = _c.prototype.o, _c.createFromModelPath = async function(t2, e2) {
      return fc(_c, t2, { baseOptions: { modelAssetPath: e2 } });
    }, _c.createFromModelBuffer = function(t2, e2) {
      return fc(_c, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, _c.createFromOptions = function(t2, e2) {
      return fc(_c, t2, e2);
    };
    vc = cc([61, 146], [146, 91], [91, 181], [181, 84], [84, 17], [17, 314], [314, 405], [405, 321], [321, 375], [375, 291], [61, 185], [185, 40], [40, 39], [39, 37], [37, 0], [0, 267], [267, 269], [269, 270], [270, 409], [409, 291], [78, 95], [95, 88], [88, 178], [178, 87], [87, 14], [14, 317], [317, 402], [402, 318], [318, 324], [324, 308], [78, 191], [191, 80], [80, 81], [81, 82], [82, 13], [13, 312], [312, 311], [311, 310], [310, 415], [415, 308]);
    Ec = cc([263, 249], [249, 390], [390, 373], [373, 374], [374, 380], [380, 381], [381, 382], [382, 362], [263, 466], [466, 388], [388, 387], [387, 386], [386, 385], [385, 384], [384, 398], [398, 362]);
    wc = cc([276, 283], [283, 282], [282, 295], [295, 285], [300, 293], [293, 334], [334, 296], [296, 336]);
    Tc = cc([474, 475], [475, 476], [476, 477], [477, 474]);
    Ac = cc([33, 7], [7, 163], [163, 144], [144, 145], [145, 153], [153, 154], [154, 155], [155, 133], [33, 246], [246, 161], [161, 160], [160, 159], [159, 158], [158, 157], [157, 173], [173, 133]);
    bc = cc([46, 53], [53, 52], [52, 65], [65, 55], [70, 63], [63, 105], [105, 66], [66, 107]);
    kc = cc([469, 470], [470, 471], [471, 472], [472, 469]);
    Sc = cc([10, 338], [338, 297], [297, 332], [332, 284], [284, 251], [251, 389], [389, 356], [356, 454], [454, 323], [323, 361], [361, 288], [288, 397], [397, 365], [365, 379], [379, 378], [378, 400], [400, 377], [377, 152], [152, 148], [148, 176], [176, 149], [149, 150], [150, 136], [136, 172], [172, 58], [58, 132], [132, 93], [93, 234], [234, 127], [127, 162], [162, 21], [21, 54], [54, 103], [103, 67], [67, 109], [109, 10]);
    xc = [...vc, ...Ec, ...wc, ...Ac, ...bc, ...Sc];
    Lc = cc([127, 34], [34, 139], [139, 127], [11, 0], [0, 37], [37, 11], [232, 231], [231, 120], [120, 232], [72, 37], [37, 39], [39, 72], [128, 121], [121, 47], [47, 128], [232, 121], [121, 128], [128, 232], [104, 69], [69, 67], [67, 104], [175, 171], [171, 148], [148, 175], [118, 50], [50, 101], [101, 118], [73, 39], [39, 40], [40, 73], [9, 151], [151, 108], [108, 9], [48, 115], [115, 131], [131, 48], [194, 204], [204, 211], [211, 194], [74, 40], [40, 185], [185, 74], [80, 42], [42, 183], [183, 80], [40, 92], [92, 186], [186, 40], [230, 229], [229, 118], [118, 230], [202, 212], [212, 214], [214, 202], [83, 18], [18, 17], [17, 83], [76, 61], [61, 146], [146, 76], [160, 29], [29, 30], [30, 160], [56, 157], [157, 173], [173, 56], [106, 204], [204, 194], [194, 106], [135, 214], [214, 192], [192, 135], [203, 165], [165, 98], [98, 203], [21, 71], [71, 68], [68, 21], [51, 45], [45, 4], [4, 51], [144, 24], [24, 23], [23, 144], [77, 146], [146, 91], [91, 77], [205, 50], [50, 187], [187, 205], [201, 200], [200, 18], [18, 201], [91, 106], [106, 182], [182, 91], [90, 91], [91, 181], [181, 90], [85, 84], [84, 17], [17, 85], [206, 203], [203, 36], [36, 206], [148, 171], [171, 140], [140, 148], [92, 40], [40, 39], [39, 92], [193, 189], [189, 244], [244, 193], [159, 158], [158, 28], [28, 159], [247, 246], [246, 161], [161, 247], [236, 3], [3, 196], [196, 236], [54, 68], [68, 104], [104, 54], [193, 168], [168, 8], [8, 193], [117, 228], [228, 31], [31, 117], [189, 193], [193, 55], [55, 189], [98, 97], [97, 99], [99, 98], [126, 47], [47, 100], [100, 126], [166, 79], [79, 218], [218, 166], [155, 154], [154, 26], [26, 155], [209, 49], [49, 131], [131, 209], [135, 136], [136, 150], [150, 135], [47, 126], [126, 217], [217, 47], [223, 52], [52, 53], [53, 223], [45, 51], [51, 134], [134, 45], [211, 170], [170, 140], [140, 211], [67, 69], [69, 108], [108, 67], [43, 106], [106, 91], [91, 43], [230, 119], [119, 120], [120, 230], [226, 130], [130, 247], [247, 226], [63, 53], [53, 52], [52, 63], [238, 20], [20, 242], [242, 238], [46, 70], [70, 156], [156, 46], [78, 62], [62, 96], [96, 78], [46, 53], [53, 63], [63, 46], [143, 34], [34, 227], [227, 143], [123, 117], [117, 111], [111, 123], [44, 125], [125, 19], [19, 44], [236, 134], [134, 51], [51, 236], [216, 206], [206, 205], [205, 216], [154, 153], [153, 22], [22, 154], [39, 37], [37, 167], [167, 39], [200, 201], [201, 208], [208, 200], [36, 142], [142, 100], [100, 36], [57, 212], [212, 202], [202, 57], [20, 60], [60, 99], [99, 20], [28, 158], [158, 157], [157, 28], [35, 226], [226, 113], [113, 35], [160, 159], [159, 27], [27, 160], [204, 202], [202, 210], [210, 204], [113, 225], [225, 46], [46, 113], [43, 202], [202, 204], [204, 43], [62, 76], [76, 77], [77, 62], [137, 123], [123, 116], [116, 137], [41, 38], [38, 72], [72, 41], [203, 129], [129, 142], [142, 203], [64, 98], [98, 240], [240, 64], [49, 102], [102, 64], [64, 49], [41, 73], [73, 74], [74, 41], [212, 216], [216, 207], [207, 212], [42, 74], [74, 184], [184, 42], [169, 170], [170, 211], [211, 169], [170, 149], [149, 176], [176, 170], [105, 66], [66, 69], [69, 105], [122, 6], [6, 168], [168, 122], [123, 147], [147, 187], [187, 123], [96, 77], [77, 90], [90, 96], [65, 55], [55, 107], [107, 65], [89, 90], [90, 180], [180, 89], [101, 100], [100, 120], [120, 101], [63, 105], [105, 104], [104, 63], [93, 137], [137, 227], [227, 93], [15, 86], [86, 85], [85, 15], [129, 102], [102, 49], [49, 129], [14, 87], [87, 86], [86, 14], [55, 8], [8, 9], [9, 55], [100, 47], [47, 121], [121, 100], [145, 23], [23, 22], [22, 145], [88, 89], [89, 179], [179, 88], [6, 122], [122, 196], [196, 6], [88, 95], [95, 96], [96, 88], [138, 172], [172, 136], [136, 138], [215, 58], [58, 172], [172, 215], [115, 48], [48, 219], [219, 115], [42, 80], [80, 81], [81, 42], [195, 3], [3, 51], [51, 195], [43, 146], [146, 61], [61, 43], [171, 175], [175, 199], [199, 171], [81, 82], [82, 38], [38, 81], [53, 46], [46, 225], [225, 53], [144, 163], [163, 110], [110, 144], [52, 65], [65, 66], [66, 52], [229, 228], [228, 117], [117, 229], [34, 127], [127, 234], [234, 34], [107, 108], [108, 69], [69, 107], [109, 108], [108, 151], [151, 109], [48, 64], [64, 235], [235, 48], [62, 78], [78, 191], [191, 62], [129, 209], [209, 126], [126, 129], [111, 35], [35, 143], [143, 111], [117, 123], [123, 50], [50, 117], [222, 65], [65, 52], [52, 222], [19, 125], [125, 141], [141, 19], [221, 55], [55, 65], [65, 221], [3, 195], [195, 197], [197, 3], [25, 7], [7, 33], [33, 25], [220, 237], [237, 44], [44, 220], [70, 71], [71, 139], [139, 70], [122, 193], [193, 245], [245, 122], [247, 130], [130, 33], [33, 247], [71, 21], [21, 162], [162, 71], [170, 169], [169, 150], [150, 170], [188, 174], [174, 196], [196, 188], [216, 186], [186, 92], [92, 216], [2, 97], [97, 167], [167, 2], [141, 125], [125, 241], [241, 141], [164, 167], [167, 37], [37, 164], [72, 38], [38, 12], [12, 72], [38, 82], [82, 13], [13, 38], [63, 68], [68, 71], [71, 63], [226, 35], [35, 111], [111, 226], [101, 50], [50, 205], [205, 101], [206, 92], [92, 165], [165, 206], [209, 198], [198, 217], [217, 209], [165, 167], [167, 97], [97, 165], [220, 115], [115, 218], [218, 220], [133, 112], [112, 243], [243, 133], [239, 238], [238, 241], [241, 239], [214, 135], [135, 169], [169, 214], [190, 173], [173, 133], [133, 190], [171, 208], [208, 32], [32, 171], [125, 44], [44, 237], [237, 125], [86, 87], [87, 178], [178, 86], [85, 86], [86, 179], [179, 85], [84, 85], [85, 180], [180, 84], [83, 84], [84, 181], [181, 83], [201, 83], [83, 182], [182, 201], [137, 93], [93, 132], [132, 137], [76, 62], [62, 183], [183, 76], [61, 76], [76, 184], [184, 61], [57, 61], [61, 185], [185, 57], [212, 57], [57, 186], [186, 212], [214, 207], [207, 187], [187, 214], [34, 143], [143, 156], [156, 34], [79, 239], [239, 237], [237, 79], [123, 137], [137, 177], [177, 123], [44, 1], [1, 4], [4, 44], [201, 194], [194, 32], [32, 201], [64, 102], [102, 129], [129, 64], [213, 215], [215, 138], [138, 213], [59, 166], [166, 219], [219, 59], [242, 99], [99, 97], [97, 242], [2, 94], [94, 141], [141, 2], [75, 59], [59, 235], [235, 75], [24, 110], [110, 228], [228, 24], [25, 130], [130, 226], [226, 25], [23, 24], [24, 229], [229, 23], [22, 23], [23, 230], [230, 22], [26, 22], [22, 231], [231, 26], [112, 26], [26, 232], [232, 112], [189, 190], [190, 243], [243, 189], [221, 56], [56, 190], [190, 221], [28, 56], [56, 221], [221, 28], [27, 28], [28, 222], [222, 27], [29, 27], [27, 223], [223, 29], [30, 29], [29, 224], [224, 30], [247, 30], [30, 225], [225, 247], [238, 79], [79, 20], [20, 238], [166, 59], [59, 75], [75, 166], [60, 75], [75, 240], [240, 60], [147, 177], [177, 215], [215, 147], [20, 79], [79, 166], [166, 20], [187, 147], [147, 213], [213, 187], [112, 233], [233, 244], [244, 112], [233, 128], [128, 245], [245, 233], [128, 114], [114, 188], [188, 128], [114, 217], [217, 174], [174, 114], [131, 115], [115, 220], [220, 131], [217, 198], [198, 236], [236, 217], [198, 131], [131, 134], [134, 198], [177, 132], [132, 58], [58, 177], [143, 35], [35, 124], [124, 143], [110, 163], [163, 7], [7, 110], [228, 110], [110, 25], [25, 228], [356, 389], [389, 368], [368, 356], [11, 302], [302, 267], [267, 11], [452, 350], [350, 349], [349, 452], [302, 303], [303, 269], [269, 302], [357, 343], [343, 277], [277, 357], [452, 453], [453, 357], [357, 452], [333, 332], [332, 297], [297, 333], [175, 152], [152, 377], [377, 175], [347, 348], [348, 330], [330, 347], [303, 304], [304, 270], [270, 303], [9, 336], [336, 337], [337, 9], [278, 279], [279, 360], [360, 278], [418, 262], [262, 431], [431, 418], [304, 408], [408, 409], [409, 304], [310, 415], [415, 407], [407, 310], [270, 409], [409, 410], [410, 270], [450, 348], [348, 347], [347, 450], [422, 430], [430, 434], [434, 422], [313, 314], [314, 17], [17, 313], [306, 307], [307, 375], [375, 306], [387, 388], [388, 260], [260, 387], [286, 414], [414, 398], [398, 286], [335, 406], [406, 418], [418, 335], [364, 367], [367, 416], [416, 364], [423, 358], [358, 327], [327, 423], [251, 284], [284, 298], [298, 251], [281, 5], [5, 4], [4, 281], [373, 374], [374, 253], [253, 373], [307, 320], [320, 321], [321, 307], [425, 427], [427, 411], [411, 425], [421, 313], [313, 18], [18, 421], [321, 405], [405, 406], [406, 321], [320, 404], [404, 405], [405, 320], [315, 16], [16, 17], [17, 315], [426, 425], [425, 266], [266, 426], [377, 400], [400, 369], [369, 377], [322, 391], [391, 269], [269, 322], [417, 465], [465, 464], [464, 417], [386, 257], [257, 258], [258, 386], [466, 260], [260, 388], [388, 466], [456, 399], [399, 419], [419, 456], [284, 332], [332, 333], [333, 284], [417, 285], [285, 8], [8, 417], [346, 340], [340, 261], [261, 346], [413, 441], [441, 285], [285, 413], [327, 460], [460, 328], [328, 327], [355, 371], [371, 329], [329, 355], [392, 439], [439, 438], [438, 392], [382, 341], [341, 256], [256, 382], [429, 420], [420, 360], [360, 429], [364, 394], [394, 379], [379, 364], [277, 343], [343, 437], [437, 277], [443, 444], [444, 283], [283, 443], [275, 440], [440, 363], [363, 275], [431, 262], [262, 369], [369, 431], [297, 338], [338, 337], [337, 297], [273, 375], [375, 321], [321, 273], [450, 451], [451, 349], [349, 450], [446, 342], [342, 467], [467, 446], [293, 334], [334, 282], [282, 293], [458, 461], [461, 462], [462, 458], [276, 353], [353, 383], [383, 276], [308, 324], [324, 325], [325, 308], [276, 300], [300, 293], [293, 276], [372, 345], [345, 447], [447, 372], [352, 345], [345, 340], [340, 352], [274, 1], [1, 19], [19, 274], [456, 248], [248, 281], [281, 456], [436, 427], [427, 425], [425, 436], [381, 256], [256, 252], [252, 381], [269, 391], [391, 393], [393, 269], [200, 199], [199, 428], [428, 200], [266, 330], [330, 329], [329, 266], [287, 273], [273, 422], [422, 287], [250, 462], [462, 328], [328, 250], [258, 286], [286, 384], [384, 258], [265, 353], [353, 342], [342, 265], [387, 259], [259, 257], [257, 387], [424, 431], [431, 430], [430, 424], [342, 353], [353, 276], [276, 342], [273, 335], [335, 424], [424, 273], [292, 325], [325, 307], [307, 292], [366, 447], [447, 345], [345, 366], [271, 303], [303, 302], [302, 271], [423, 266], [266, 371], [371, 423], [294, 455], [455, 460], [460, 294], [279, 278], [278, 294], [294, 279], [271, 272], [272, 304], [304, 271], [432, 434], [434, 427], [427, 432], [272, 407], [407, 408], [408, 272], [394, 430], [430, 431], [431, 394], [395, 369], [369, 400], [400, 395], [334, 333], [333, 299], [299, 334], [351, 417], [417, 168], [168, 351], [352, 280], [280, 411], [411, 352], [325, 319], [319, 320], [320, 325], [295, 296], [296, 336], [336, 295], [319, 403], [403, 404], [404, 319], [330, 348], [348, 349], [349, 330], [293, 298], [298, 333], [333, 293], [323, 454], [454, 447], [447, 323], [15, 16], [16, 315], [315, 15], [358, 429], [429, 279], [279, 358], [14, 15], [15, 316], [316, 14], [285, 336], [336, 9], [9, 285], [329, 349], [349, 350], [350, 329], [374, 380], [380, 252], [252, 374], [318, 402], [402, 403], [403, 318], [6, 197], [197, 419], [419, 6], [318, 319], [319, 325], [325, 318], [367, 364], [364, 365], [365, 367], [435, 367], [367, 397], [397, 435], [344, 438], [438, 439], [439, 344], [272, 271], [271, 311], [311, 272], [195, 5], [5, 281], [281, 195], [273, 287], [287, 291], [291, 273], [396, 428], [428, 199], [199, 396], [311, 271], [271, 268], [268, 311], [283, 444], [444, 445], [445, 283], [373, 254], [254, 339], [339, 373], [282, 334], [334, 296], [296, 282], [449, 347], [347, 346], [346, 449], [264, 447], [447, 454], [454, 264], [336, 296], [296, 299], [299, 336], [338, 10], [10, 151], [151, 338], [278, 439], [439, 455], [455, 278], [292, 407], [407, 415], [415, 292], [358, 371], [371, 355], [355, 358], [340, 345], [345, 372], [372, 340], [346, 347], [347, 280], [280, 346], [442, 443], [443, 282], [282, 442], [19, 94], [94, 370], [370, 19], [441, 442], [442, 295], [295, 441], [248, 419], [419, 197], [197, 248], [263, 255], [255, 359], [359, 263], [440, 275], [275, 274], [274, 440], [300, 383], [383, 368], [368, 300], [351, 412], [412, 465], [465, 351], [263, 467], [467, 466], [466, 263], [301, 368], [368, 389], [389, 301], [395, 378], [378, 379], [379, 395], [412, 351], [351, 419], [419, 412], [436, 426], [426, 322], [322, 436], [2, 164], [164, 393], [393, 2], [370, 462], [462, 461], [461, 370], [164, 0], [0, 267], [267, 164], [302, 11], [11, 12], [12, 302], [268, 12], [12, 13], [13, 268], [293, 300], [300, 301], [301, 293], [446, 261], [261, 340], [340, 446], [330, 266], [266, 425], [425, 330], [426, 423], [423, 391], [391, 426], [429, 355], [355, 437], [437, 429], [391, 327], [327, 326], [326, 391], [440, 457], [457, 438], [438, 440], [341, 382], [382, 362], [362, 341], [459, 457], [457, 461], [461, 459], [434, 430], [430, 394], [394, 434], [414, 463], [463, 362], [362, 414], [396, 369], [369, 262], [262, 396], [354, 461], [461, 457], [457, 354], [316, 403], [403, 402], [402, 316], [315, 404], [404, 403], [403, 315], [314, 405], [405, 404], [404, 314], [313, 406], [406, 405], [405, 313], [421, 418], [418, 406], [406, 421], [366, 401], [401, 361], [361, 366], [306, 408], [408, 407], [407, 306], [291, 409], [409, 408], [408, 291], [287, 410], [410, 409], [409, 287], [432, 436], [436, 410], [410, 432], [434, 416], [416, 411], [411, 434], [264, 368], [368, 383], [383, 264], [309, 438], [438, 457], [457, 309], [352, 376], [376, 401], [401, 352], [274, 275], [275, 4], [4, 274], [421, 428], [428, 262], [262, 421], [294, 327], [327, 358], [358, 294], [433, 416], [416, 367], [367, 433], [289, 455], [455, 439], [439, 289], [462, 370], [370, 326], [326, 462], [2, 326], [326, 370], [370, 2], [305, 460], [460, 455], [455, 305], [254, 449], [449, 448], [448, 254], [255, 261], [261, 446], [446, 255], [253, 450], [450, 449], [449, 253], [252, 451], [451, 450], [450, 252], [256, 452], [452, 451], [451, 256], [341, 453], [453, 452], [452, 341], [413, 464], [464, 463], [463, 413], [441, 413], [413, 414], [414, 441], [258, 442], [442, 441], [441, 258], [257, 443], [443, 442], [442, 257], [259, 444], [444, 443], [443, 259], [260, 445], [445, 444], [444, 260], [467, 342], [342, 445], [445, 467], [459, 458], [458, 250], [250, 459], [289, 392], [392, 290], [290, 289], [290, 328], [328, 460], [460, 290], [376, 433], [433, 435], [435, 376], [250, 290], [290, 392], [392, 250], [411, 416], [416, 433], [433, 411], [341, 463], [463, 464], [464, 341], [453, 464], [464, 465], [465, 453], [357, 465], [465, 412], [412, 357], [343, 412], [412, 399], [399, 343], [360, 363], [363, 440], [440, 360], [437, 399], [399, 456], [456, 437], [420, 456], [456, 363], [363, 420], [401, 435], [435, 288], [288, 401], [372, 383], [383, 353], [353, 372], [339, 255], [255, 249], [249, 339], [448, 261], [261, 255], [255, 448], [133, 243], [243, 190], [190, 133], [133, 155], [155, 112], [112, 133], [33, 246], [246, 247], [247, 33], [33, 130], [130, 25], [25, 33], [398, 384], [384, 286], [286, 398], [362, 398], [398, 414], [414, 362], [362, 463], [463, 341], [341, 362], [263, 359], [359, 467], [467, 263], [263, 249], [249, 255], [255, 263], [466, 467], [467, 260], [260, 466], [75, 60], [60, 166], [166, 75], [238, 239], [239, 79], [79, 238], [162, 127], [127, 139], [139, 162], [72, 11], [11, 37], [37, 72], [121, 232], [232, 120], [120, 121], [73, 72], [72, 39], [39, 73], [114, 128], [128, 47], [47, 114], [233, 232], [232, 128], [128, 233], [103, 104], [104, 67], [67, 103], [152, 175], [175, 148], [148, 152], [119, 118], [118, 101], [101, 119], [74, 73], [73, 40], [40, 74], [107, 9], [9, 108], [108, 107], [49, 48], [48, 131], [131, 49], [32, 194], [194, 211], [211, 32], [184, 74], [74, 185], [185, 184], [191, 80], [80, 183], [183, 191], [185, 40], [40, 186], [186, 185], [119, 230], [230, 118], [118, 119], [210, 202], [202, 214], [214, 210], [84, 83], [83, 17], [17, 84], [77, 76], [76, 146], [146, 77], [161, 160], [160, 30], [30, 161], [190, 56], [56, 173], [173, 190], [182, 106], [106, 194], [194, 182], [138, 135], [135, 192], [192, 138], [129, 203], [203, 98], [98, 129], [54, 21], [21, 68], [68, 54], [5, 51], [51, 4], [4, 5], [145, 144], [144, 23], [23, 145], [90, 77], [77, 91], [91, 90], [207, 205], [205, 187], [187, 207], [83, 201], [201, 18], [18, 83], [181, 91], [91, 182], [182, 181], [180, 90], [90, 181], [181, 180], [16, 85], [85, 17], [17, 16], [205, 206], [206, 36], [36, 205], [176, 148], [148, 140], [140, 176], [165, 92], [92, 39], [39, 165], [245, 193], [193, 244], [244, 245], [27, 159], [159, 28], [28, 27], [30, 247], [247, 161], [161, 30], [174, 236], [236, 196], [196, 174], [103, 54], [54, 104], [104, 103], [55, 193], [193, 8], [8, 55], [111, 117], [117, 31], [31, 111], [221, 189], [189, 55], [55, 221], [240, 98], [98, 99], [99, 240], [142, 126], [126, 100], [100, 142], [219, 166], [166, 218], [218, 219], [112, 155], [155, 26], [26, 112], [198, 209], [209, 131], [131, 198], [169, 135], [135, 150], [150, 169], [114, 47], [47, 217], [217, 114], [224, 223], [223, 53], [53, 224], [220, 45], [45, 134], [134, 220], [32, 211], [211, 140], [140, 32], [109, 67], [67, 108], [108, 109], [146, 43], [43, 91], [91, 146], [231, 230], [230, 120], [120, 231], [113, 226], [226, 247], [247, 113], [105, 63], [63, 52], [52, 105], [241, 238], [238, 242], [242, 241], [124, 46], [46, 156], [156, 124], [95, 78], [78, 96], [96, 95], [70, 46], [46, 63], [63, 70], [116, 143], [143, 227], [227, 116], [116, 123], [123, 111], [111, 116], [1, 44], [44, 19], [19, 1], [3, 236], [236, 51], [51, 3], [207, 216], [216, 205], [205, 207], [26, 154], [154, 22], [22, 26], [165, 39], [39, 167], [167, 165], [199, 200], [200, 208], [208, 199], [101, 36], [36, 100], [100, 101], [43, 57], [57, 202], [202, 43], [242, 20], [20, 99], [99, 242], [56, 28], [28, 157], [157, 56], [124, 35], [35, 113], [113, 124], [29, 160], [160, 27], [27, 29], [211, 204], [204, 210], [210, 211], [124, 113], [113, 46], [46, 124], [106, 43], [43, 204], [204, 106], [96, 62], [62, 77], [77, 96], [227, 137], [137, 116], [116, 227], [73, 41], [41, 72], [72, 73], [36, 203], [203, 142], [142, 36], [235, 64], [64, 240], [240, 235], [48, 49], [49, 64], [64, 48], [42, 41], [41, 74], [74, 42], [214, 212], [212, 207], [207, 214], [183, 42], [42, 184], [184, 183], [210, 169], [169, 211], [211, 210], [140, 170], [170, 176], [176, 140], [104, 105], [105, 69], [69, 104], [193, 122], [122, 168], [168, 193], [50, 123], [123, 187], [187, 50], [89, 96], [96, 90], [90, 89], [66, 65], [65, 107], [107, 66], [179, 89], [89, 180], [180, 179], [119, 101], [101, 120], [120, 119], [68, 63], [63, 104], [104, 68], [234, 93], [93, 227], [227, 234], [16, 15], [15, 85], [85, 16], [209, 129], [129, 49], [49, 209], [15, 14], [14, 86], [86, 15], [107, 55], [55, 9], [9, 107], [120, 100], [100, 121], [121, 120], [153, 145], [145, 22], [22, 153], [178, 88], [88, 179], [179, 178], [197, 6], [6, 196], [196, 197], [89, 88], [88, 96], [96, 89], [135, 138], [138, 136], [136, 135], [138, 215], [215, 172], [172, 138], [218, 115], [115, 219], [219, 218], [41, 42], [42, 81], [81, 41], [5, 195], [195, 51], [51, 5], [57, 43], [43, 61], [61, 57], [208, 171], [171, 199], [199, 208], [41, 81], [81, 38], [38, 41], [224, 53], [53, 225], [225, 224], [24, 144], [144, 110], [110, 24], [105, 52], [52, 66], [66, 105], [118, 229], [229, 117], [117, 118], [227, 34], [34, 234], [234, 227], [66, 107], [107, 69], [69, 66], [10, 109], [109, 151], [151, 10], [219, 48], [48, 235], [235, 219], [183, 62], [62, 191], [191, 183], [142, 129], [129, 126], [126, 142], [116, 111], [111, 143], [143, 116], [118, 117], [117, 50], [50, 118], [223, 222], [222, 52], [52, 223], [94, 19], [19, 141], [141, 94], [222, 221], [221, 65], [65, 222], [196, 3], [3, 197], [197, 196], [45, 220], [220, 44], [44, 45], [156, 70], [70, 139], [139, 156], [188, 122], [122, 245], [245, 188], [139, 71], [71, 162], [162, 139], [149, 170], [170, 150], [150, 149], [122, 188], [188, 196], [196, 122], [206, 216], [216, 92], [92, 206], [164, 2], [2, 167], [167, 164], [242, 141], [141, 241], [241, 242], [0, 164], [164, 37], [37, 0], [11, 72], [72, 12], [12, 11], [12, 38], [38, 13], [13, 12], [70, 63], [63, 71], [71, 70], [31, 226], [226, 111], [111, 31], [36, 101], [101, 205], [205, 36], [203, 206], [206, 165], [165, 203], [126, 209], [209, 217], [217, 126], [98, 165], [165, 97], [97, 98], [237, 220], [220, 218], [218, 237], [237, 239], [239, 241], [241, 237], [210, 214], [214, 169], [169, 210], [140, 171], [171, 32], [32, 140], [241, 125], [125, 237], [237, 241], [179, 86], [86, 178], [178, 179], [180, 85], [85, 179], [179, 180], [181, 84], [84, 180], [180, 181], [182, 83], [83, 181], [181, 182], [194, 201], [201, 182], [182, 194], [177, 137], [137, 132], [132, 177], [184, 76], [76, 183], [183, 184], [185, 61], [61, 184], [184, 185], [186, 57], [57, 185], [185, 186], [216, 212], [212, 186], [186, 216], [192, 214], [214, 187], [187, 192], [139, 34], [34, 156], [156, 139], [218, 79], [79, 237], [237, 218], [147, 123], [123, 177], [177, 147], [45, 44], [44, 4], [4, 45], [208, 201], [201, 32], [32, 208], [98, 64], [64, 129], [129, 98], [192, 213], [213, 138], [138, 192], [235, 59], [59, 219], [219, 235], [141, 242], [242, 97], [97, 141], [97, 2], [2, 141], [141, 97], [240, 75], [75, 235], [235, 240], [229, 24], [24, 228], [228, 229], [31, 25], [25, 226], [226, 31], [230, 23], [23, 229], [229, 230], [231, 22], [22, 230], [230, 231], [232, 26], [26, 231], [231, 232], [233, 112], [112, 232], [232, 233], [244, 189], [189, 243], [243, 244], [189, 221], [221, 190], [190, 189], [222, 28], [28, 221], [221, 222], [223, 27], [27, 222], [222, 223], [224, 29], [29, 223], [223, 224], [225, 30], [30, 224], [224, 225], [113, 247], [247, 225], [225, 113], [99, 60], [60, 240], [240, 99], [213, 147], [147, 215], [215, 213], [60, 20], [20, 166], [166, 60], [192, 187], [187, 213], [213, 192], [243, 112], [112, 244], [244, 243], [244, 233], [233, 245], [245, 244], [245, 128], [128, 188], [188, 245], [188, 114], [114, 174], [174, 188], [134, 131], [131, 220], [220, 134], [174, 217], [217, 236], [236, 174], [236, 198], [198, 134], [134, 236], [215, 177], [177, 58], [58, 215], [156, 143], [143, 124], [124, 156], [25, 110], [110, 7], [7, 25], [31, 228], [228, 25], [25, 31], [264, 356], [356, 368], [368, 264], [0, 11], [11, 267], [267, 0], [451, 452], [452, 349], [349, 451], [267, 302], [302, 269], [269, 267], [350, 357], [357, 277], [277, 350], [350, 452], [452, 357], [357, 350], [299, 333], [333, 297], [297, 299], [396, 175], [175, 377], [377, 396], [280, 347], [347, 330], [330, 280], [269, 303], [303, 270], [270, 269], [151, 9], [9, 337], [337, 151], [344, 278], [278, 360], [360, 344], [424, 418], [418, 431], [431, 424], [270, 304], [304, 409], [409, 270], [272, 310], [310, 407], [407, 272], [322, 270], [270, 410], [410, 322], [449, 450], [450, 347], [347, 449], [432, 422], [422, 434], [434, 432], [18, 313], [313, 17], [17, 18], [291, 306], [306, 375], [375, 291], [259, 387], [387, 260], [260, 259], [424, 335], [335, 418], [418, 424], [434, 364], [364, 416], [416, 434], [391, 423], [423, 327], [327, 391], [301, 251], [251, 298], [298, 301], [275, 281], [281, 4], [4, 275], [254, 373], [373, 253], [253, 254], [375, 307], [307, 321], [321, 375], [280, 425], [425, 411], [411, 280], [200, 421], [421, 18], [18, 200], [335, 321], [321, 406], [406, 335], [321, 320], [320, 405], [405, 321], [314, 315], [315, 17], [17, 314], [423, 426], [426, 266], [266, 423], [396, 377], [377, 369], [369, 396], [270, 322], [322, 269], [269, 270], [413, 417], [417, 464], [464, 413], [385, 386], [386, 258], [258, 385], [248, 456], [456, 419], [419, 248], [298, 284], [284, 333], [333, 298], [168, 417], [417, 8], [8, 168], [448, 346], [346, 261], [261, 448], [417, 413], [413, 285], [285, 417], [326, 327], [327, 328], [328, 326], [277, 355], [355, 329], [329, 277], [309, 392], [392, 438], [438, 309], [381, 382], [382, 256], [256, 381], [279, 429], [429, 360], [360, 279], [365, 364], [364, 379], [379, 365], [355, 277], [277, 437], [437, 355], [282, 443], [443, 283], [283, 282], [281, 275], [275, 363], [363, 281], [395, 431], [431, 369], [369, 395], [299, 297], [297, 337], [337, 299], [335, 273], [273, 321], [321, 335], [348, 450], [450, 349], [349, 348], [359, 446], [446, 467], [467, 359], [283, 293], [293, 282], [282, 283], [250, 458], [458, 462], [462, 250], [300, 276], [276, 383], [383, 300], [292, 308], [308, 325], [325, 292], [283, 276], [276, 293], [293, 283], [264, 372], [372, 447], [447, 264], [346, 352], [352, 340], [340, 346], [354, 274], [274, 19], [19, 354], [363, 456], [456, 281], [281, 363], [426, 436], [436, 425], [425, 426], [380, 381], [381, 252], [252, 380], [267, 269], [269, 393], [393, 267], [421, 200], [200, 428], [428, 421], [371, 266], [266, 329], [329, 371], [432, 287], [287, 422], [422, 432], [290, 250], [250, 328], [328, 290], [385, 258], [258, 384], [384, 385], [446, 265], [265, 342], [342, 446], [386, 387], [387, 257], [257, 386], [422, 424], [424, 430], [430, 422], [445, 342], [342, 276], [276, 445], [422, 273], [273, 424], [424, 422], [306, 292], [292, 307], [307, 306], [352, 366], [366, 345], [345, 352], [268, 271], [271, 302], [302, 268], [358, 423], [423, 371], [371, 358], [327, 294], [294, 460], [460, 327], [331, 279], [279, 294], [294, 331], [303, 271], [271, 304], [304, 303], [436, 432], [432, 427], [427, 436], [304, 272], [272, 408], [408, 304], [395, 394], [394, 431], [431, 395], [378, 395], [395, 400], [400, 378], [296, 334], [334, 299], [299, 296], [6, 351], [351, 168], [168, 6], [376, 352], [352, 411], [411, 376], [307, 325], [325, 320], [320, 307], [285, 295], [295, 336], [336, 285], [320, 319], [319, 404], [404, 320], [329, 330], [330, 349], [349, 329], [334, 293], [293, 333], [333, 334], [366, 323], [323, 447], [447, 366], [316, 15], [15, 315], [315, 316], [331, 358], [358, 279], [279, 331], [317, 14], [14, 316], [316, 317], [8, 285], [285, 9], [9, 8], [277, 329], [329, 350], [350, 277], [253, 374], [374, 252], [252, 253], [319, 318], [318, 403], [403, 319], [351, 6], [6, 419], [419, 351], [324, 318], [318, 325], [325, 324], [397, 367], [367, 365], [365, 397], [288, 435], [435, 397], [397, 288], [278, 344], [344, 439], [439, 278], [310, 272], [272, 311], [311, 310], [248, 195], [195, 281], [281, 248], [375, 273], [273, 291], [291, 375], [175, 396], [396, 199], [199, 175], [312, 311], [311, 268], [268, 312], [276, 283], [283, 445], [445, 276], [390, 373], [373, 339], [339, 390], [295, 282], [282, 296], [296, 295], [448, 449], [449, 346], [346, 448], [356, 264], [264, 454], [454, 356], [337, 336], [336, 299], [299, 337], [337, 338], [338, 151], [151, 337], [294, 278], [278, 455], [455, 294], [308, 292], [292, 415], [415, 308], [429, 358], [358, 355], [355, 429], [265, 340], [340, 372], [372, 265], [352, 346], [346, 280], [280, 352], [295, 442], [442, 282], [282, 295], [354, 19], [19, 370], [370, 354], [285, 441], [441, 295], [295, 285], [195, 248], [248, 197], [197, 195], [457, 440], [440, 274], [274, 457], [301, 300], [300, 368], [368, 301], [417, 351], [351, 465], [465, 417], [251, 301], [301, 389], [389, 251], [394, 395], [395, 379], [379, 394], [399, 412], [412, 419], [419, 399], [410, 436], [436, 322], [322, 410], [326, 2], [2, 393], [393, 326], [354, 370], [370, 461], [461, 354], [393, 164], [164, 267], [267, 393], [268, 302], [302, 12], [12, 268], [312, 268], [268, 13], [13, 312], [298, 293], [293, 301], [301, 298], [265, 446], [446, 340], [340, 265], [280, 330], [330, 425], [425, 280], [322, 426], [426, 391], [391, 322], [420, 429], [429, 437], [437, 420], [393, 391], [391, 326], [326, 393], [344, 440], [440, 438], [438, 344], [458, 459], [459, 461], [461, 458], [364, 434], [434, 394], [394, 364], [428, 396], [396, 262], [262, 428], [274, 354], [354, 457], [457, 274], [317, 316], [316, 402], [402, 317], [316, 315], [315, 403], [403, 316], [315, 314], [314, 404], [404, 315], [314, 313], [313, 405], [405, 314], [313, 421], [421, 406], [406, 313], [323, 366], [366, 361], [361, 323], [292, 306], [306, 407], [407, 292], [306, 291], [291, 408], [408, 306], [291, 287], [287, 409], [409, 291], [287, 432], [432, 410], [410, 287], [427, 434], [434, 411], [411, 427], [372, 264], [264, 383], [383, 372], [459, 309], [309, 457], [457, 459], [366, 352], [352, 401], [401, 366], [1, 274], [274, 4], [4, 1], [418, 421], [421, 262], [262, 418], [331, 294], [294, 358], [358, 331], [435, 433], [433, 367], [367, 435], [392, 289], [289, 439], [439, 392], [328, 462], [462, 326], [326, 328], [94, 2], [2, 370], [370, 94], [289, 305], [305, 455], [455, 289], [339, 254], [254, 448], [448, 339], [359, 255], [255, 446], [446, 359], [254, 253], [253, 449], [449, 254], [253, 252], [252, 450], [450, 253], [252, 256], [256, 451], [451, 252], [256, 341], [341, 452], [452, 256], [414, 413], [413, 463], [463, 414], [286, 441], [441, 414], [414, 286], [286, 258], [258, 441], [441, 286], [258, 257], [257, 442], [442, 258], [257, 259], [259, 443], [443, 257], [259, 260], [260, 444], [444, 259], [260, 467], [467, 445], [445, 260], [309, 459], [459, 250], [250, 309], [305, 289], [289, 290], [290, 305], [305, 290], [290, 460], [460, 305], [401, 376], [376, 435], [435, 401], [309, 250], [250, 392], [392, 309], [376, 411], [411, 433], [433, 376], [453, 341], [341, 464], [464, 453], [357, 453], [453, 465], [465, 357], [343, 357], [357, 412], [412, 343], [437, 343], [343, 399], [399, 437], [344, 360], [360, 440], [440, 344], [420, 437], [437, 456], [456, 420], [360, 420], [420, 363], [363, 360], [361, 401], [401, 288], [288, 361], [265, 372], [372, 353], [353, 265], [390, 339], [339, 249], [249, 390], [339, 448], [448, 255], [255, 339]);
    Ic = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", false), this.j = { faceLandmarks: [], faceBlendshapes: [], facialTransformationMatrixes: [] }, this.outputFacialTransformationMatrixes = this.outputFaceBlendshapes = false, kn(t2 = this.h = new eo(), 0, 1, e2 = new Ks()), this.A = new to(), kn(this.h, 0, 3, this.A), this.u = new $s(), kn(this.h, 0, 2, this.u), Mn(this.u, 4, 1), Pn(this.u, 2, 0.5), Pn(this.A, 2, 0.5), Pn(this.h, 4, 0.5);
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return "numFaces" in t2 && Mn(this.u, 4, t2.numFaces ?? 1), "minFaceDetectionConfidence" in t2 && Pn(this.u, 2, t2.minFaceDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && Pn(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minFacePresenceConfidence" in t2 && Pn(this.A, 2, t2.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t2 && (this.outputFaceBlendshapes = !!t2.outputFaceBlendshapes), "outputFacialTransformationMatrixes" in t2 && (this.outputFacialTransformationMatrixes = !!t2.outputFacialTransformationMatrixes), this.l(t2);
      }
      F(t2, e2) {
        return Rc(this), pc(this, t2, e2), this.j;
      }
      G(t2, e2, n2) {
        return Rc(this), gc(this, t2, n2, e2), this.j;
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect"), ps(t2, "face_landmarks");
        const e2 = new rs();
        Mr(e2, ro, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.face_landmarker.FaceLandmarkerGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), as(n2, "NORM_LANDMARKS:face_landmarks"), n2.o(e2), fs(t2, n2), this.g.attachProtoVectorListener("face_landmarks", ((t3, e3) => {
          for (const e4 of t3) t3 = Rs(e4), this.j.faceLandmarks.push(Yo(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("face_landmarks", ((t3) => {
          pa(this, t3);
        })), this.outputFaceBlendshapes && (ps(t2, "blendshapes"), as(n2, "BLENDSHAPES:blendshapes"), this.g.attachProtoVectorListener("blendshapes", ((t3, e3) => {
          if (this.outputFaceBlendshapes) for (const e4 of t3) t3 = ws(e4), this.j.faceBlendshapes.push(Wo(t3.g() ?? []));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("blendshapes", ((t3) => {
          pa(this, t3);
        }))), this.outputFacialTransformationMatrixes && (ps(t2, "face_geometry"), as(n2, "FACE_GEOMETRY:face_geometry"), this.g.attachProtoVectorListener("face_geometry", ((t3, e3) => {
          if (this.outputFacialTransformationMatrixes) for (const e4 of t3) (t3 = wn(t3 = Qs(e4), Is, 2)) && this.j.facialTransformationMatrixes.push({ rows: Rn(t3, 1) ?? 0 ?? 0, columns: Rn(t3, 2) ?? 0 ?? 0, data: on(t3, 3, Qt, sn()).slice() ?? [] });
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("face_geometry", ((t3) => {
          pa(this, t3);
        }))), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Ic.prototype.detectForVideo = Ic.prototype.G, Ic.prototype.detect = Ic.prototype.F, Ic.prototype.setOptions = Ic.prototype.o, Ic.createFromModelPath = function(t2, e2) {
      return fc(Ic, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Ic.createFromModelBuffer = function(t2, e2) {
      return fc(Ic, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Ic.createFromOptions = function(t2, e2) {
      return fc(Ic, t2, e2);
    }, Ic.FACE_LANDMARKS_LIPS = vc, Ic.FACE_LANDMARKS_LEFT_EYE = Ec, Ic.FACE_LANDMARKS_LEFT_EYEBROW = wc, Ic.FACE_LANDMARKS_LEFT_IRIS = Tc, Ic.FACE_LANDMARKS_RIGHT_EYE = Ac, Ic.FACE_LANDMARKS_RIGHT_EYEBROW = bc, Ic.FACE_LANDMARKS_RIGHT_IRIS = kc, Ic.FACE_LANDMARKS_FACE_OVAL = Sc, Ic.FACE_LANDMARKS_CONTOURS = xc, Ic.FACE_LANDMARKS_TESSELATION = Lc;
    Fc = cc([0, 1], [1, 2], [2, 3], [3, 4], [0, 5], [5, 6], [6, 7], [7, 8], [5, 9], [9, 10], [10, 11], [11, 12], [9, 13], [13, 14], [14, 15], [15, 16], [13, 17], [0, 17], [17, 18], [18, 19], [19, 20]);
    Oc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", false), this.gestures = [], this.landmarks = [], this.worldLandmarks = [], this.handedness = [], kn(t2 = this.j = new uo(), 0, 1, e2 = new Ks()), this.u = new ho(), kn(this.j, 0, 2, this.u), this.D = new co(), kn(this.u, 0, 3, this.D), this.A = new ao(), kn(this.u, 0, 2, this.A), this.h = new oo(), kn(this.j, 0, 3, this.h), Pn(this.A, 2, 0.5), Pn(this.u, 4, 0.5), Pn(this.D, 2, 0.5);
      }
      get baseOptions() {
        return wn(this.j, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.j, 0, 1, t2);
      }
      o(t2) {
        if (Mn(this.A, 3, t2.numHands ?? 1), "minHandDetectionConfidence" in t2 && Pn(this.A, 2, t2.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && Pn(this.u, 4, t2.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t2 && Pn(this.D, 2, t2.minHandPresenceConfidence ?? 0.5), t2.cannedGesturesClassifierOptions) {
          var e2 = new io(), n2 = e2, r2 = Xo(t2.cannedGesturesClassifierOptions, wn(this.h, io, 3)?.l());
          kn(n2, 0, 2, r2), kn(this.h, 0, 3, e2);
        } else void 0 === t2.cannedGesturesClassifierOptions && wn(this.h, io, 3)?.g();
        return t2.customGesturesClassifierOptions ? (kn(n2 = e2 = new io(), 0, 2, r2 = Xo(t2.customGesturesClassifierOptions, wn(this.h, io, 4)?.l())), kn(this.h, 0, 4, e2)) : void 0 === t2.customGesturesClassifierOptions && wn(this.h, io, 4)?.g(), this.l(t2);
      }
      Ha(t2, e2) {
        return Mc(this), pc(this, t2, e2), Pc(this);
      }
      Ia(t2, e2, n2) {
        return Mc(this), gc(this, t2, n2, e2), Pc(this);
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect"), ps(t2, "hand_gestures"), ps(t2, "hand_landmarks"), ps(t2, "world_hand_landmarks"), ps(t2, "handedness");
        const e2 = new rs();
        Mr(e2, mo, this.j);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.gesture_recognizer.GestureRecognizerGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), as(n2, "HAND_GESTURES:hand_gestures"), as(n2, "LANDMARKS:hand_landmarks"), as(n2, "WORLD_LANDMARKS:world_hand_landmarks"), as(n2, "HANDEDNESS:handedness"), n2.o(e2), fs(t2, n2), this.g.attachProtoVectorListener("hand_landmarks", ((t3, e3) => {
          for (const e4 of t3) {
            t3 = Rs(e4);
            const n3 = [];
            for (const e5 of An(t3, Ls, 1)) n3.push({ x: Fn(e5, 1) ?? 0, y: Fn(e5, 2) ?? 0, z: Fn(e5, 3) ?? 0, visibility: Fn(e5, 4) ?? 0 });
            this.landmarks.push(n3);
          }
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoVectorListener("world_hand_landmarks", ((t3, e3) => {
          for (const e4 of t3) {
            t3 = xs(e4);
            const n3 = [];
            for (const e5 of An(t3, Ss, 1)) n3.push({ x: Fn(e5, 1) ?? 0, y: Fn(e5, 2) ?? 0, z: Fn(e5, 3) ?? 0, visibility: Fn(e5, 4) ?? 0 });
            this.worldLandmarks.push(n3);
          }
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("world_hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoVectorListener("hand_gestures", ((t3, e3) => {
          this.gestures.push(...Cc(t3, false)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("hand_gestures", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoVectorListener("handedness", ((t3, e3) => {
          this.handedness.push(...Cc(t3)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("handedness", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Oc.prototype.recognizeForVideo = Oc.prototype.Ia, Oc.prototype.recognize = Oc.prototype.Ha, Oc.prototype.setOptions = Oc.prototype.o, Oc.createFromModelPath = function(t2, e2) {
      return fc(Oc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Oc.createFromModelBuffer = function(t2, e2) {
      return fc(Oc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Oc.createFromOptions = function(t2, e2) {
      return fc(Oc, t2, e2);
    }, Oc.HAND_CONNECTIONS = Fc;
    Uc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.handedness = [], kn(t2 = this.h = new ho(), 0, 1, e2 = new Ks()), this.u = new co(), kn(this.h, 0, 3, this.u), this.j = new ao(), kn(this.h, 0, 2, this.j), Mn(this.j, 3, 1), Pn(this.j, 2, 0.5), Pn(this.u, 2, 0.5), Pn(this.h, 4, 0.5);
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return "numHands" in t2 && Mn(this.j, 3, t2.numHands ?? 1), "minHandDetectionConfidence" in t2 && Pn(this.j, 2, t2.minHandDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && Pn(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minHandPresenceConfidence" in t2 && Pn(this.u, 2, t2.minHandPresenceConfidence ?? 0.5), this.l(t2);
      }
      F(t2, e2) {
        return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], pc(this, t2, e2), Nc(this);
      }
      G(t2, e2, n2) {
        return this.landmarks = [], this.worldLandmarks = [], this.handedness = [], gc(this, t2, n2, e2), Nc(this);
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect"), ps(t2, "hand_landmarks"), ps(t2, "world_hand_landmarks"), ps(t2, "handedness");
        const e2 = new rs();
        Mr(e2, yo, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.hand_landmarker.HandLandmarkerGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), as(n2, "LANDMARKS:hand_landmarks"), as(n2, "WORLD_LANDMARKS:world_hand_landmarks"), as(n2, "HANDEDNESS:handedness"), n2.o(e2), fs(t2, n2), this.g.attachProtoVectorListener("hand_landmarks", ((t3, e3) => {
          for (const e4 of t3) t3 = Rs(e4), this.landmarks.push(Yo(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoVectorListener("world_hand_landmarks", ((t3, e3) => {
          for (const e4 of t3) t3 = xs(e4), this.worldLandmarks.push(qo(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("world_hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoVectorListener("handedness", ((t3, e3) => {
          var n3 = this.handedness, r2 = n3.push;
          const i2 = [];
          for (const e4 of t3) {
            t3 = ws(e4);
            const n4 = [];
            for (const e5 of t3.g()) n4.push({ score: Fn(e5, 2) ?? 0, index: Rn(e5, 1) ?? 0 ?? -1, categoryName: ge(tn(e5, 3)) ?? "" ?? "", displayName: ge(tn(e5, 4)) ?? "" ?? "" });
            i2.push(n4);
          }
          r2.call(n3, ...i2), pa(this, e3);
        })), this.g.attachEmptyPacketListener("handedness", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Uc.prototype.detectForVideo = Uc.prototype.G, Uc.prototype.detect = Uc.prototype.F, Uc.prototype.setOptions = Uc.prototype.o, Uc.createFromModelPath = function(t2, e2) {
      return fc(Uc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Uc.createFromModelBuffer = function(t2, e2) {
      return fc(Uc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Uc.createFromOptions = function(t2, e2) {
      return fc(Uc, t2, e2);
    }, Uc.HAND_CONNECTIONS = Fc;
    Dc = cc([0, 1], [1, 2], [2, 3], [3, 7], [0, 4], [4, 5], [5, 6], [6, 8], [9, 10], [11, 12], [11, 13], [13, 15], [15, 17], [15, 19], [15, 21], [17, 19], [12, 14], [14, 16], [16, 18], [16, 20], [16, 22], [18, 20], [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28], [27, 29], [28, 30], [29, 31], [30, 32], [27, 31], [28, 32]);
    Vc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "input_frames_image", null, false), this.h = { faceLandmarks: [], faceBlendshapes: [], poseLandmarks: [], poseWorldLandmarks: [], poseSegmentationMasks: [], leftHandLandmarks: [], leftHandWorldLandmarks: [], rightHandLandmarks: [], rightHandWorldLandmarks: [] }, this.outputPoseSegmentationMasks = this.outputFaceBlendshapes = false, kn(t2 = this.j = new wo(), 0, 1, e2 = new Ks()), this.I = new co(), kn(this.j, 0, 2, this.I), this.W = new _o(), kn(this.j, 0, 3, this.W), this.u = new $s(), kn(this.j, 0, 4, this.u), this.O = new to(), kn(this.j, 0, 5, this.O), this.A = new vo(), kn(this.j, 0, 6, this.A), this.M = new Eo(), kn(this.j, 0, 7, this.M), Pn(this.u, 2, 0.5), Pn(this.u, 3, 0.3), Pn(this.O, 2, 0.5), Pn(this.A, 2, 0.5), Pn(this.A, 3, 0.3), Pn(this.M, 2, 0.5), Pn(this.I, 2, 0.5);
      }
      get baseOptions() {
        return wn(this.j, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.j, 0, 1, t2);
      }
      o(t2) {
        return "minFaceDetectionConfidence" in t2 && Pn(this.u, 2, t2.minFaceDetectionConfidence ?? 0.5), "minFaceSuppressionThreshold" in t2 && Pn(this.u, 3, t2.minFaceSuppressionThreshold ?? 0.3), "minFacePresenceConfidence" in t2 && Pn(this.O, 2, t2.minFacePresenceConfidence ?? 0.5), "outputFaceBlendshapes" in t2 && (this.outputFaceBlendshapes = !!t2.outputFaceBlendshapes), "minPoseDetectionConfidence" in t2 && Pn(this.A, 2, t2.minPoseDetectionConfidence ?? 0.5), "minPoseSuppressionThreshold" in t2 && Pn(this.A, 3, t2.minPoseSuppressionThreshold ?? 0.3), "minPosePresenceConfidence" in t2 && Pn(this.M, 2, t2.minPosePresenceConfidence ?? 0.5), "outputPoseSegmentationMasks" in t2 && (this.outputPoseSegmentationMasks = !!t2.outputPoseSegmentationMasks), "minHandLandmarksConfidence" in t2 && Pn(this.I, 2, t2.minHandLandmarksConfidence ?? 0.5), this.l(t2);
      }
      F(t2, e2, n2) {
        const r2 = "function" != typeof e2 ? e2 : {};
        return this.D = "function" == typeof e2 ? e2 : n2, Bc(this), pc(this, t2, r2), Gc(this);
      }
      G(t2, e2, n2, r2) {
        const i2 = "function" != typeof n2 ? n2 : {};
        return this.D = "function" == typeof n2 ? n2 : r2, Bc(this), gc(this, t2, i2, e2), Gc(this);
      }
      m() {
        var t2 = new gs();
        ds(t2, "input_frames_image"), ps(t2, "pose_landmarks"), ps(t2, "pose_world_landmarks"), ps(t2, "face_landmarks"), ps(t2, "left_hand_landmarks"), ps(t2, "left_hand_world_landmarks"), ps(t2, "right_hand_landmarks"), ps(t2, "right_hand_world_landmarks");
        const e2 = new rs(), n2 = new Xi();
        Cn(n2, 1, "type.googleapis.com/mediapipe.tasks.vision.holistic_landmarker.proto.HolisticLandmarkerGraphOptions"), (function(t3, e3) {
          if (null != e3) if (Array.isArray(e3)) nn(t3, 2, Ce(e3, 0, Ne));
          else {
            if (!("string" == typeof e3 || e3 instanceof P || R(e3))) throw Error("invalid value in Any.value field: " + e3 + " expected a ByteString, a base64 encoded string, a Uint8Array or a jspb array");
            dn(t3, 2, lt(e3, false), F());
          }
        })(n2, this.j.g());
        const r2 = new cs();
        Cn(r2, 2, "mediapipe.tasks.vision.holistic_landmarker.HolisticLandmarkerGraph"), Ln(r2, 8, Xi, n2), os(r2, "IMAGE:input_frames_image"), as(r2, "POSE_LANDMARKS:pose_landmarks"), as(r2, "POSE_WORLD_LANDMARKS:pose_world_landmarks"), as(r2, "FACE_LANDMARKS:face_landmarks"), as(r2, "LEFT_HAND_LANDMARKS:left_hand_landmarks"), as(r2, "LEFT_HAND_WORLD_LANDMARKS:left_hand_world_landmarks"), as(r2, "RIGHT_HAND_LANDMARKS:right_hand_landmarks"), as(r2, "RIGHT_HAND_WORLD_LANDMARKS:right_hand_world_landmarks"), r2.o(e2), fs(t2, r2), ga(this, t2), this.g.attachProtoListener("pose_landmarks", ((t3, e3) => {
          jc(t3, this.h.poseLandmarks), pa(this, e3);
        })), this.g.attachEmptyPacketListener("pose_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoListener("pose_world_landmarks", ((t3, e3) => {
          var n3 = this.h.poseWorldLandmarks;
          t3 = xs(t3), n3.push(qo(t3)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("pose_world_landmarks", ((t3) => {
          pa(this, t3);
        })), this.outputPoseSegmentationMasks && (as(r2, "POSE_SEGMENTATION_MASK:pose_segmentation_mask"), ma(this, "pose_segmentation_mask"), this.g.Z("pose_segmentation_mask", ((t3, e3) => {
          this.h.poseSegmentationMasks = [mc(this, t3, true, !this.D)], pa(this, e3);
        })), this.g.attachEmptyPacketListener("pose_segmentation_mask", ((t3) => {
          this.h.poseSegmentationMasks = [], pa(this, t3);
        }))), this.g.attachProtoListener("face_landmarks", ((t3, e3) => {
          jc(t3, this.h.faceLandmarks), pa(this, e3);
        })), this.g.attachEmptyPacketListener("face_landmarks", ((t3) => {
          pa(this, t3);
        })), this.outputFaceBlendshapes && (ps(t2, "extra_blendshapes"), as(r2, "FACE_BLENDSHAPES:extra_blendshapes"), this.g.attachProtoListener("extra_blendshapes", ((t3, e3) => {
          var n3 = this.h.faceBlendshapes;
          this.outputFaceBlendshapes && (t3 = ws(t3), n3.push(Wo(t3.g() ?? []))), pa(this, e3);
        })), this.g.attachEmptyPacketListener("extra_blendshapes", ((t3) => {
          pa(this, t3);
        }))), this.g.attachProtoListener("left_hand_landmarks", ((t3, e3) => {
          jc(t3, this.h.leftHandLandmarks), pa(this, e3);
        })), this.g.attachEmptyPacketListener("left_hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoListener("left_hand_world_landmarks", ((t3, e3) => {
          var n3 = this.h.leftHandWorldLandmarks;
          t3 = xs(t3), n3.push(qo(t3)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("left_hand_world_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoListener("right_hand_landmarks", ((t3, e3) => {
          jc(t3, this.h.rightHandLandmarks), pa(this, e3);
        })), this.g.attachEmptyPacketListener("right_hand_landmarks", ((t3) => {
          pa(this, t3);
        })), this.g.attachProtoListener("right_hand_world_landmarks", ((t3, e3) => {
          var n3 = this.h.rightHandWorldLandmarks;
          t3 = xs(t3), n3.push(qo(t3)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("right_hand_world_landmarks", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Vc.prototype.detectForVideo = Vc.prototype.G, Vc.prototype.detect = Vc.prototype.F, Vc.prototype.setOptions = Vc.prototype.o, Vc.createFromModelPath = function(t2, e2) {
      return fc(Vc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Vc.createFromModelBuffer = function(t2, e2) {
      return fc(Vc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Vc.createFromOptions = function(t2, e2) {
      return fc(Vc, t2, e2);
    }, Vc.HAND_CONNECTIONS = Fc, Vc.POSE_CONNECTIONS = Dc, Vc.FACE_LANDMARKS_LIPS = vc, Vc.FACE_LANDMARKS_LEFT_EYE = Ec, Vc.FACE_LANDMARKS_LEFT_EYEBROW = wc, Vc.FACE_LANDMARKS_LEFT_IRIS = Tc, Vc.FACE_LANDMARKS_RIGHT_EYE = Ac, Vc.FACE_LANDMARKS_RIGHT_EYEBROW = bc, Vc.FACE_LANDMARKS_RIGHT_IRIS = kc, Vc.FACE_LANDMARKS_FACE_OVAL = Sc, Vc.FACE_LANDMARKS_CONTOURS = xc, Vc.FACE_LANDMARKS_TESSELATION = Lc;
    Xc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "input_image", "norm_rect", true), this.j = { classifications: [] }, kn(t2 = this.h = new bo(), 0, 1, e2 = new Ks());
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return kn(this.h, 0, 2, Xo(t2, wn(this.h, Gs, 2))), this.l(t2);
      }
      sa(t2, e2) {
        return this.j = { classifications: [] }, pc(this, t2, e2), this.j;
      }
      ta(t2, e2, n2) {
        return this.j = { classifications: [] }, gc(this, t2, n2, e2), this.j;
      }
      m() {
        var t2 = new gs();
        ds(t2, "input_image"), ds(t2, "norm_rect"), ps(t2, "classifications");
        const e2 = new rs();
        Mr(e2, ko, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.image_classifier.ImageClassifierGraph"), os(n2, "IMAGE:input_image"), os(n2, "NORM_RECT:norm_rect"), as(n2, "CLASSIFICATIONS:classifications"), n2.o(e2), fs(t2, n2), this.g.attachProtoListener("classifications", ((t3, e3) => {
          this.j = zo(Cs(t3)), pa(this, e3);
        })), this.g.attachEmptyPacketListener("classifications", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Xc.prototype.classifyForVideo = Xc.prototype.ta, Xc.prototype.classify = Xc.prototype.sa, Xc.prototype.setOptions = Xc.prototype.o, Xc.createFromModelPath = function(t2, e2) {
      return fc(Xc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Xc.createFromModelBuffer = function(t2, e2) {
      return fc(Xc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Xc.createFromOptions = function(t2, e2) {
      return fc(Xc, t2, e2);
    };
    Hc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", true), this.h = new So(), this.embeddings = { embeddings: [] }, kn(t2 = this.h, 0, 1, e2 = new Ks());
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        var e2 = this.h, n2 = wn(this.h, Vs, 2);
        return n2 = n2 ? n2.clone() : new Vs(), void 0 !== t2.l2Normalize ? nn(n2, 1, te(t2.l2Normalize)) : "l2Normalize" in t2 && nn(n2, 1), void 0 !== t2.quantize ? nn(n2, 2, te(t2.quantize)) : "quantize" in t2 && nn(n2, 2), kn(e2, 0, 2, n2), this.l(t2);
      }
      za(t2, e2) {
        return pc(this, t2, e2), this.embeddings;
      }
      Aa(t2, e2, n2) {
        return gc(this, t2, n2, e2), this.embeddings;
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect"), ps(t2, "embeddings_out");
        const e2 = new rs();
        Mr(e2, xo, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.image_embedder.ImageEmbedderGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), as(n2, "EMBEDDINGS:embeddings_out"), n2.o(e2), fs(t2, n2), this.g.attachProtoListener("embeddings_out", ((t3, e3) => {
          t3 = Bs(t3), this.embeddings = (function(t4) {
            return { embeddings: An(t4, Us, 1).map(((t5) => {
              const e4 = { headIndex: Rn(t5, 3) ?? 0 ?? -1, headName: ge(tn(t5, 4)) ?? "" ?? "" };
              var n3 = t5.v;
              return void 0 !== En(n3, 0 | n3[et], Os, gn(t5, 1)) ? (t5 = on(t5 = wn(t5, Os, gn(t5, 1), void 0), 1, Qt, sn()), e4.floatEmbedding = t5.slice()) : (n3 = new Uint8Array(0), e4.quantizedEmbedding = wn(t5, Ns, gn(t5, 2), void 0)?.na()?.h() ?? n3), e4;
            })), timestampMs: Ho(In(t4)) };
          })(t3), pa(this, e3);
        })), this.g.attachEmptyPacketListener("embeddings_out", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Hc.cosineSimilarity = function(t2, e2) {
      if (t2.floatEmbedding && e2.floatEmbedding) t2 = Jo(t2.floatEmbedding, e2.floatEmbedding);
      else {
        if (!t2.quantizedEmbedding || !e2.quantizedEmbedding) throw Error("Cannot compute cosine similarity between quantized and float embeddings.");
        t2 = Jo($o(t2.quantizedEmbedding), $o(e2.quantizedEmbedding));
      }
      return t2;
    }, Hc.prototype.embedForVideo = Hc.prototype.Aa, Hc.prototype.embed = Hc.prototype.za, Hc.prototype.setOptions = Hc.prototype.o, Hc.createFromModelPath = function(t2, e2) {
      return fc(Hc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Hc.createFromModelBuffer = function(t2, e2) {
      return fc(Hc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Hc.createFromOptions = function(t2, e2) {
      return fc(Hc, t2, e2);
    };
    Wc = class {
      constructor(t2, e2, n2) {
        this.confidenceMasks = t2, this.categoryMask = e2, this.qualityScores = n2;
      }
      close() {
        this.confidenceMasks?.forEach(((t2) => {
          t2.close();
        })), this.categoryMask?.close();
      }
    };
    Wc.prototype.close = Wc.prototype.close;
    qc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", false), this.u = [], this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new Mo(), this.A = new Lo(), kn(this.h, 0, 3, this.A), kn(t2 = this.h, 0, 1, e2 = new Ks());
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return void 0 !== t2.displayNamesLocale ? nn(this.h, 2, pe(t2.displayNamesLocale)) : "displayNamesLocale" in t2 && nn(this.h, 2), "outputCategoryMask" in t2 && (this.outputCategoryMask = t2.outputCategoryMask ?? false), "outputConfidenceMasks" in t2 && (this.outputConfidenceMasks = t2.outputConfidenceMasks ?? true), super.l(t2);
      }
      L() {
        zc(this);
      }
      segment(t2, e2, n2) {
        const r2 = "function" != typeof e2 ? e2 : {};
        return this.j = "function" == typeof e2 ? e2 : n2, Kc(this), pc(this, t2, r2), Yc(this);
      }
      La(t2, e2, n2, r2) {
        const i2 = "function" != typeof n2 ? n2 : {};
        return this.j = "function" == typeof n2 ? n2 : r2, Kc(this), gc(this, t2, i2, e2), Yc(this);
      }
      Da() {
        return this.u;
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect");
        const e2 = new rs();
        Mr(e2, Po, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.image_segmenter.ImageSegmenterGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), n2.o(e2), fs(t2, n2), ga(this, t2), this.outputConfidenceMasks && (ps(t2, "confidence_masks"), as(n2, "CONFIDENCE_MASKS:confidence_masks"), ma(this, "confidence_masks"), this.g.aa("confidence_masks", ((t3, e3) => {
          this.confidenceMasks = t3.map(((t4) => mc(this, t4, true, !this.j))), pa(this, e3);
        })), this.g.attachEmptyPacketListener("confidence_masks", ((t3) => {
          this.confidenceMasks = [], pa(this, t3);
        }))), this.outputCategoryMask && (ps(t2, "category_mask"), as(n2, "CATEGORY_MASK:category_mask"), ma(this, "category_mask"), this.g.Z("category_mask", ((t3, e3) => {
          this.categoryMask = mc(this, t3, false, !this.j), pa(this, e3);
        })), this.g.attachEmptyPacketListener("category_mask", ((t3) => {
          this.categoryMask = void 0, pa(this, t3);
        }))), ps(t2, "quality_scores"), as(n2, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", ((t3, e3) => {
          this.qualityScores = t3, pa(this, e3);
        })), this.g.attachEmptyPacketListener("quality_scores", ((t3) => {
          this.categoryMask = void 0, pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    qc.prototype.getLabels = qc.prototype.Da, qc.prototype.segmentForVideo = qc.prototype.La, qc.prototype.segment = qc.prototype.segment, qc.prototype.setOptions = qc.prototype.o, qc.createFromModelPath = function(t2, e2) {
      return fc(qc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, qc.createFromModelBuffer = function(t2, e2) {
      return fc(qc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, qc.createFromOptions = function(t2, e2) {
      return fc(qc, t2, e2);
    };
    $c = class {
      constructor(t2, e2, n2) {
        this.confidenceMasks = t2, this.categoryMask = e2, this.qualityScores = n2;
      }
      close() {
        this.confidenceMasks?.forEach(((t2) => {
          t2.close();
        })), this.categoryMask?.close();
      }
    };
    $c.prototype.close = $c.prototype.close;
    Jc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect_in", false), this.outputCategoryMask = false, this.outputConfidenceMasks = true, this.h = new Mo(), this.u = new Lo(), kn(this.h, 0, 3, this.u), kn(t2 = this.h, 0, 1, e2 = new Ks());
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return "outputCategoryMask" in t2 && (this.outputCategoryMask = t2.outputCategoryMask ?? false), "outputConfidenceMasks" in t2 && (this.outputConfidenceMasks = t2.outputConfidenceMasks ?? true), super.l(t2);
      }
      segment(t2, e2, n2, r2) {
        const i2 = "function" != typeof n2 ? n2 : {};
        if (this.j = "function" == typeof n2 ? n2 : r2, this.qualityScores = this.categoryMask = this.confidenceMasks = void 0, n2 = this.C + 1, r2 = new Uo(), e2.keypoint && e2.scribble) throw Error("Cannot provide both keypoint and scribble.");
        if (e2.keypoint) {
          var s2 = new Co();
          dn(s2, 3, te(true), false), dn(s2, 1, Zt(e2.keypoint.x), 0), dn(s2, 2, Zt(e2.keypoint.y), 0), Sn(r2, 1, Do, s2);
        } else {
          if (!e2.scribble) throw Error("Must provide either a keypoint or a scribble.");
          {
            const t3 = new No();
            for (s2 of e2.scribble) dn(e2 = new Co(), 3, te(true), false), dn(e2, 1, Zt(s2.x), 0), dn(e2, 2, Zt(s2.y), 0), Ln(t3, 1, Co, e2);
            Sn(r2, 2, Do, t3);
          }
        }
        this.g.addProtoToStream(r2.g(), "mediapipe.tasks.vision.interactive_segmenter.proto.RegionOfInterest", "roi_in", n2), pc(this, t2, i2);
        t: {
          try {
            const t3 = new $c(this.confidenceMasks, this.categoryMask, this.qualityScores);
            if (!this.j) {
              var o2 = t3;
              break t;
            }
            this.j(t3);
          } finally {
            ya(this);
          }
          o2 = void 0;
        }
        return o2;
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "roi_in"), ds(t2, "norm_rect_in");
        const e2 = new rs();
        Mr(e2, Po, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.interactive_segmenter.InteractiveSegmenterGraphV2"), os(n2, "IMAGE:image_in"), os(n2, "ROI:roi_in"), os(n2, "NORM_RECT:norm_rect_in"), n2.o(e2), fs(t2, n2), ga(this, t2), this.outputConfidenceMasks && (ps(t2, "confidence_masks"), as(n2, "CONFIDENCE_MASKS:confidence_masks"), ma(this, "confidence_masks"), this.g.aa("confidence_masks", ((t3, e3) => {
          this.confidenceMasks = t3.map(((t4) => mc(this, t4, true, !this.j))), pa(this, e3);
        })), this.g.attachEmptyPacketListener("confidence_masks", ((t3) => {
          this.confidenceMasks = [], pa(this, t3);
        }))), this.outputCategoryMask && (ps(t2, "category_mask"), as(n2, "CATEGORY_MASK:category_mask"), ma(this, "category_mask"), this.g.Z("category_mask", ((t3, e3) => {
          this.categoryMask = mc(this, t3, false, !this.j), pa(this, e3);
        })), this.g.attachEmptyPacketListener("category_mask", ((t3) => {
          this.categoryMask = void 0, pa(this, t3);
        }))), ps(t2, "quality_scores"), as(n2, "QUALITY_SCORES:quality_scores"), this.g.attachFloatVectorListener("quality_scores", ((t3, e3) => {
          this.qualityScores = t3, pa(this, e3);
        })), this.g.attachEmptyPacketListener("quality_scores", ((t3) => {
          this.categoryMask = void 0, pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Jc.prototype.segment = Jc.prototype.segment, Jc.prototype.setOptions = Jc.prototype.o, Jc.createFromModelPath = function(t2, e2) {
      return fc(Jc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Jc.createFromModelBuffer = function(t2, e2) {
      return fc(Jc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Jc.createFromOptions = function(t2, e2) {
      return fc(Jc, t2, e2);
    };
    Zc = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "input_frame_gpu", "norm_rect", false), this.j = { detections: [] }, kn(t2 = this.h = new Bo(), 0, 1, e2 = new Ks());
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return void 0 !== t2.displayNamesLocale ? nn(this.h, 2, pe(t2.displayNamesLocale)) : "displayNamesLocale" in t2 && nn(this.h, 2), void 0 !== t2.maxResults ? Mn(this.h, 3, t2.maxResults) : "maxResults" in t2 && nn(this.h, 3), void 0 !== t2.scoreThreshold ? Pn(this.h, 4, t2.scoreThreshold) : "scoreThreshold" in t2 && nn(this.h, 4), void 0 !== t2.categoryAllowlist ? On(this.h, 5, t2.categoryAllowlist) : "categoryAllowlist" in t2 && nn(this.h, 5), void 0 !== t2.categoryDenylist ? On(this.h, 6, t2.categoryDenylist) : "categoryDenylist" in t2 && nn(this.h, 6), this.l(t2);
      }
      F(t2, e2) {
        return this.j = { detections: [] }, pc(this, t2, e2), this.j;
      }
      G(t2, e2, n2) {
        return this.j = { detections: [] }, gc(this, t2, n2, e2), this.j;
      }
      m() {
        var t2 = new gs();
        ds(t2, "input_frame_gpu"), ds(t2, "norm_rect"), ps(t2, "detections");
        const e2 = new rs();
        Mr(e2, Go, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.ObjectDetectorGraph"), os(n2, "IMAGE:input_frame_gpu"), os(n2, "NORM_RECT:norm_rect"), as(n2, "DETECTIONS:detections"), n2.o(e2), fs(t2, n2), this.g.attachProtoVectorListener("detections", ((t3, e3) => {
          for (const e4 of t3) t3 = ks(e4), this.j.detections.push(Ko(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("detections", ((t3) => {
          pa(this, t3);
        })), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    Zc.prototype.detectForVideo = Zc.prototype.G, Zc.prototype.detect = Zc.prototype.F, Zc.prototype.setOptions = Zc.prototype.o, Zc.createFromModelPath = async function(t2, e2) {
      return fc(Zc, t2, { baseOptions: { modelAssetPath: e2 } });
    }, Zc.createFromModelBuffer = function(t2, e2) {
      return fc(Zc, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, Zc.createFromOptions = function(t2, e2) {
      return fc(Zc, t2, e2);
    };
    Qc = class {
      constructor(t2, e2, n2) {
        this.landmarks = t2, this.worldLandmarks = e2, this.segmentationMasks = n2;
      }
      close() {
        this.segmentationMasks?.forEach(((t2) => {
          t2.close();
        }));
      }
    };
    Qc.prototype.close = Qc.prototype.close;
    nh = class extends yc {
      constructor(t2, e2) {
        super(new lc(t2, e2), "image_in", "norm_rect", false), this.landmarks = [], this.worldLandmarks = [], this.outputSegmentationMasks = false, kn(t2 = this.h = new jo(), 0, 1, e2 = new Ks()), this.A = new Eo(), kn(this.h, 0, 3, this.A), this.j = new vo(), kn(this.h, 0, 2, this.j), Mn(this.j, 4, 1), Pn(this.j, 2, 0.5), Pn(this.A, 2, 0.5), Pn(this.h, 4, 0.5);
      }
      get baseOptions() {
        return wn(this.h, Ks, 1);
      }
      set baseOptions(t2) {
        kn(this.h, 0, 1, t2);
      }
      o(t2) {
        return "numPoses" in t2 && Mn(this.j, 4, t2.numPoses ?? 1), "minPoseDetectionConfidence" in t2 && Pn(this.j, 2, t2.minPoseDetectionConfidence ?? 0.5), "minTrackingConfidence" in t2 && Pn(this.h, 4, t2.minTrackingConfidence ?? 0.5), "minPosePresenceConfidence" in t2 && Pn(this.A, 2, t2.minPosePresenceConfidence ?? 0.5), "outputSegmentationMasks" in t2 && (this.outputSegmentationMasks = t2.outputSegmentationMasks ?? false), this.l(t2);
      }
      F(t2, e2, n2) {
        const r2 = "function" != typeof e2 ? e2 : {};
        return this.u = "function" == typeof e2 ? e2 : n2, th(this), pc(this, t2, r2), eh(this);
      }
      G(t2, e2, n2, r2) {
        const i2 = "function" != typeof n2 ? n2 : {};
        return this.u = "function" == typeof n2 ? n2 : r2, th(this), gc(this, t2, i2, e2), eh(this);
      }
      m() {
        var t2 = new gs();
        ds(t2, "image_in"), ds(t2, "norm_rect"), ps(t2, "normalized_landmarks"), ps(t2, "world_landmarks"), ps(t2, "segmentation_masks");
        const e2 = new rs();
        Mr(e2, Vo, this.h);
        const n2 = new cs();
        Cn(n2, 2, "mediapipe.tasks.vision.pose_landmarker.PoseLandmarkerGraph"), os(n2, "IMAGE:image_in"), os(n2, "NORM_RECT:norm_rect"), as(n2, "NORM_LANDMARKS:normalized_landmarks"), as(n2, "WORLD_LANDMARKS:world_landmarks"), n2.o(e2), fs(t2, n2), ga(this, t2), this.g.attachProtoVectorListener("normalized_landmarks", ((t3, e3) => {
          this.landmarks = [];
          for (const e4 of t3) t3 = Rs(e4), this.landmarks.push(Yo(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("normalized_landmarks", ((t3) => {
          this.landmarks = [], pa(this, t3);
        })), this.g.attachProtoVectorListener("world_landmarks", ((t3, e3) => {
          this.worldLandmarks = [];
          for (const e4 of t3) t3 = xs(e4), this.worldLandmarks.push(qo(t3));
          pa(this, e3);
        })), this.g.attachEmptyPacketListener("world_landmarks", ((t3) => {
          this.worldLandmarks = [], pa(this, t3);
        })), this.outputSegmentationMasks && (as(n2, "SEGMENTATION_MASK:segmentation_masks"), ma(this, "segmentation_masks"), this.g.aa("segmentation_masks", ((t3, e3) => {
          this.segmentationMasks = t3.map(((t4) => mc(this, t4, true, !this.u))), pa(this, e3);
        })), this.g.attachEmptyPacketListener("segmentation_masks", ((t3) => {
          this.segmentationMasks = [], pa(this, t3);
        }))), t2 = t2.g(), this.setGraph(new Uint8Array(t2), true);
      }
    };
    nh.prototype.detectForVideo = nh.prototype.G, nh.prototype.detect = nh.prototype.F, nh.prototype.setOptions = nh.prototype.o, nh.createFromModelPath = function(t2, e2) {
      return fc(nh, t2, { baseOptions: { modelAssetPath: e2 } });
    }, nh.createFromModelBuffer = function(t2, e2) {
      return fc(nh, t2, { baseOptions: { modelAssetBuffer: e2 } });
    }, nh.createFromOptions = function(t2, e2) {
      return fc(nh, t2, e2);
    }, nh.POSE_CONNECTIONS = Dc;
  }
});

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var import_react2 = __toESM(require_react());

// node_modules/lucide-react/dist/esm/shared/src/utils.js
var toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
var toCamelCase = (string) => string.replace(
  /^([A-Z])|[\s-_]+(\w)/g,
  (match, p1, p2) => p2 ? p2.toUpperCase() : p1.toLowerCase()
);
var toPascalCase = (string) => {
  const camelCase = toCamelCase(string);
  return camelCase.charAt(0).toUpperCase() + camelCase.slice(1);
};
var mergeClasses = (...classes) => classes.filter((className, index, array) => {
  return Boolean(className) && className.trim() !== "" && array.indexOf(className) === index;
}).join(" ").trim();
var hasA11yProp = (props) => {
  for (const prop in props) {
    if (prop.startsWith("aria-") || prop === "role" || prop === "title") {
      return true;
    }
  }
};

// node_modules/lucide-react/dist/esm/Icon.js
var import_react = __toESM(require_react());

// node_modules/lucide-react/dist/esm/defaultAttributes.js
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};

// node_modules/lucide-react/dist/esm/Icon.js
var Icon = (0, import_react.forwardRef)(
  ({
    color = "currentColor",
    size = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => (0, import_react.createElement)(
    "svg",
    {
      ref,
      ...defaultAttributes,
      width: size,
      height: size,
      stroke: color,
      strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size) : strokeWidth,
      className: mergeClasses("lucide", className),
      ...!children && !hasA11yProp(rest) && { "aria-hidden": "true" },
      ...rest
    },
    [
      ...iconNode.map(([tag, attrs]) => (0, import_react.createElement)(tag, attrs)),
      ...Array.isArray(children) ? children : [children]
    ]
  )
);

// node_modules/lucide-react/dist/esm/createLucideIcon.js
var createLucideIcon = (iconName, iconNode) => {
  const Component4 = (0, import_react2.forwardRef)(
    ({ className, ...props }, ref) => (0, import_react2.createElement)(Icon, {
      ref,
      iconNode,
      className: mergeClasses(
        `lucide-${toKebabCase(toPascalCase(iconName))}`,
        `lucide-${iconName}`,
        className
      ),
      ...props
    })
  );
  Component4.displayName = toPascalCase(iconName);
  return Component4;
};

// node_modules/lucide-react/dist/esm/icons/chevron-down.js
var __iconNode = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]];
var ChevronDown = createLucideIcon("chevron-down", __iconNode);

// node_modules/lucide-react/dist/esm/icons/chevron-up.js
var __iconNode2 = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]];
var ChevronUp = createLucideIcon("chevron-up", __iconNode2);

// node_modules/lucide-react/dist/esm/icons/ellipsis.js
var __iconNode3 = [
  ["circle", { cx: "12", cy: "12", r: "1", key: "41hilf" }],
  ["circle", { cx: "19", cy: "12", r: "1", key: "1wjl8i" }],
  ["circle", { cx: "5", cy: "12", r: "1", key: "1pcz8c" }]
];
var Ellipsis = createLucideIcon("ellipsis", __iconNode3);

// node_modules/lucide-react/dist/esm/icons/layout-grid.js
var __iconNode4 = [
  ["rect", { width: "7", height: "7", x: "3", y: "3", rx: "1", key: "1g98yp" }],
  ["rect", { width: "7", height: "7", x: "14", y: "3", rx: "1", key: "6d4xhi" }],
  ["rect", { width: "7", height: "7", x: "14", y: "14", rx: "1", key: "nxv5o0" }],
  ["rect", { width: "7", height: "7", x: "3", y: "14", rx: "1", key: "1bb6yr" }]
];
var LayoutGrid = createLucideIcon("layout-grid", __iconNode4);

// node_modules/lucide-react/dist/esm/icons/loader-circle.js
var __iconNode5 = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]];
var LoaderCircle = createLucideIcon("loader-circle", __iconNode5);

// node_modules/lucide-react/dist/esm/icons/maximize.js
var __iconNode6 = [
  ["path", { d: "M8 3H5a2 2 0 0 0-2 2v3", key: "1dcmit" }],
  ["path", { d: "M21 8V5a2 2 0 0 0-2-2h-3", key: "1e4gt3" }],
  ["path", { d: "M3 16v3a2 2 0 0 0 2 2h3", key: "wsl5sc" }],
  ["path", { d: "M16 21h3a2 2 0 0 0 2-2v-3", key: "18trek" }]
];
var Maximize = createLucideIcon("maximize", __iconNode6);

// node_modules/lucide-react/dist/esm/icons/mic-off.js
var __iconNode7 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M15 9.34V5a3 3 0 0 0-5.68-1.33", key: "1gzdoj" }],
  ["path", { d: "M16.95 16.95A7 7 0 0 1 5 12v-2", key: "cqa7eg" }],
  ["path", { d: "M18.89 13.23A7 7 0 0 0 19 12v-2", key: "16hl24" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }],
  ["path", { d: "M9 9v3a3 3 0 0 0 5.12 2.12", key: "r2i35w" }]
];
var MicOff = createLucideIcon("mic-off", __iconNode7);

// node_modules/lucide-react/dist/esm/icons/mic.js
var __iconNode8 = [
  ["path", { d: "M12 19v3", key: "npa21l" }],
  ["path", { d: "M19 10v2a7 7 0 0 1-14 0v-2", key: "1vc78b" }],
  ["rect", { x: "9", y: "2", width: "6", height: "13", rx: "3", key: "s6n7sd" }]
];
var Mic = createLucideIcon("mic", __iconNode8);

// node_modules/lucide-react/dist/esm/icons/minimize.js
var __iconNode9 = [
  ["path", { d: "M8 3v3a2 2 0 0 1-2 2H3", key: "hohbtr" }],
  ["path", { d: "M21 8h-3a2 2 0 0 1-2-2V3", key: "5jw1f3" }],
  ["path", { d: "M3 16h3a2 2 0 0 1 2 2v3", key: "198tvr" }],
  ["path", { d: "M16 21v-3a2 2 0 0 1 2-2h3", key: "ph8mxp" }]
];
var Minimize = createLucideIcon("minimize", __iconNode9);

// node_modules/lucide-react/dist/esm/icons/monitor.js
var __iconNode10 = [
  ["rect", { width: "20", height: "14", x: "2", y: "3", rx: "2", key: "48i651" }],
  ["line", { x1: "8", x2: "16", y1: "21", y2: "21", key: "1svkeh" }],
  ["line", { x1: "12", x2: "12", y1: "17", y2: "21", key: "vw1qmm" }]
];
var Monitor = createLucideIcon("monitor", __iconNode10);

// node_modules/lucide-react/dist/esm/icons/panel-right-close.js
var __iconNode11 = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
  ["path", { d: "m8 9 3 3-3 3", key: "12hl5m" }]
];
var PanelRightClose = createLucideIcon("panel-right-close", __iconNode11);

// node_modules/lucide-react/dist/esm/icons/panel-right-open.js
var __iconNode12 = [
  ["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }],
  ["path", { d: "M15 3v18", key: "14nvp0" }],
  ["path", { d: "m10 15-3-3 3-3", key: "1pgupc" }]
];
var PanelRightOpen = createLucideIcon("panel-right-open", __iconNode12);

// node_modules/lucide-react/dist/esm/icons/phone.js
var __iconNode13 = [
  [
    "path",
    {
      d: "M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384",
      key: "9njp5v"
    }
  ]
];
var Phone = createLucideIcon("phone", __iconNode13);

// node_modules/lucide-react/dist/esm/icons/picture-in-picture-2.js
var __iconNode14 = [
  ["path", { d: "M21 9V6a2 2 0 0 0-2-2H4a2 2 0 0 0-2 2v10c0 1.1.9 2 2 2h4", key: "daa4of" }],
  ["rect", { width: "10", height: "7", x: "12", y: "13", rx: "2", key: "1nb8gs" }]
];
var PictureInPicture2 = createLucideIcon("picture-in-picture-2", __iconNode14);

// node_modules/lucide-react/dist/esm/icons/send.js
var __iconNode15 = [
  [
    "path",
    {
      d: "M14.536 21.686a.5.5 0 0 0 .937-.024l6.5-19a.496.496 0 0 0-.635-.635l-19 6.5a.5.5 0 0 0-.024.937l7.93 3.18a2 2 0 0 1 1.112 1.11z",
      key: "1ffxy3"
    }
  ],
  ["path", { d: "m21.854 2.147-10.94 10.939", key: "12cjpa" }]
];
var Send = createLucideIcon("send", __iconNode15);

// node_modules/lucide-react/dist/esm/icons/share.js
var __iconNode16 = [
  ["path", { d: "M12 2v13", key: "1km8f5" }],
  ["path", { d: "m16 6-4-4-4 4", key: "13yo43" }],
  ["path", { d: "M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8", key: "1b2hhj" }]
];
var Share = createLucideIcon("share", __iconNode16);

// node_modules/lucide-react/dist/esm/icons/smile.js
var __iconNode17 = [
  ["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }],
  ["path", { d: "M8 14s1.5 2 4 2 4-2 4-2", key: "1y1vjs" }],
  ["line", { x1: "9", x2: "9.01", y1: "9", y2: "9", key: "yxxnd0" }],
  ["line", { x1: "15", x2: "15.01", y1: "9", y2: "9", key: "1p4y9e" }]
];
var Smile = createLucideIcon("smile", __iconNode17);

// node_modules/lucide-react/dist/esm/icons/users.js
var __iconNode18 = [
  ["path", { d: "M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2", key: "1yyitq" }],
  ["path", { d: "M16 3.128a4 4 0 0 1 0 7.744", key: "16gr8j" }],
  ["path", { d: "M22 21v-2a4 4 0 0 0-3-3.87", key: "kshegd" }],
  ["circle", { cx: "9", cy: "7", r: "4", key: "nufk8" }]
];
var Users = createLucideIcon("users", __iconNode18);

// node_modules/lucide-react/dist/esm/icons/video-off.js
var __iconNode19 = [
  [
    "path",
    { d: "M10.66 6H14a2 2 0 0 1 2 2v2.5l5.248-3.062A.5.5 0 0 1 22 7.87v8.196", key: "w8jjjt" }
  ],
  ["path", { d: "M16 16a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h2", key: "1xawa7" }],
  ["path", { d: "m2 2 20 20", key: "1ooewy" }]
];
var VideoOff = createLucideIcon("video-off", __iconNode19);

// node_modules/lucide-react/dist/esm/icons/video.js
var __iconNode20 = [
  [
    "path",
    {
      d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5",
      key: "ftymec"
    }
  ],
  ["rect", { x: "2", y: "6", width: "14", height: "12", rx: "2", key: "158x01" }]
];
var Video = createLucideIcon("video", __iconNode20);

// node_modules/lucide-react/dist/esm/icons/x.js
var __iconNode21 = [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
];
var X = createLucideIcon("x", __iconNode21);

// src/webrtc/MeetingPage.js
var import_react6 = __toESM(require_react());

// node_modules/react-router/dist/development/chunk-JZWAC4HX.mjs
var React2 = __toESM(require_react(), 1);
var React22 = __toESM(require_react(), 1);
var React3 = __toESM(require_react(), 1);
var React4 = __toESM(require_react(), 1);
var React9 = __toESM(require_react(), 1);
var React8 = __toESM(require_react(), 1);
var React7 = __toESM(require_react(), 1);
var React6 = __toESM(require_react(), 1);
var React5 = __toESM(require_react(), 1);
var React10 = __toESM(require_react(), 1);
var React11 = __toESM(require_react(), 1);
function invariant(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined") console.warn(message);
    try {
      throw new Error(message);
    } catch (e2) {
    }
  }
}
function createPath({
  pathname = "/",
  search = "",
  hash = ""
}) {
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash && hash !== "#")
    pathname += hash.charAt(0) === "#" ? hash : "#" + hash;
  return pathname;
}
function parsePath(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substring(hashIndex);
      path = path.substring(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substring(searchIndex);
      path = path.substring(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
var _map;
_map = /* @__PURE__ */ new WeakMap();
function matchRoutes(routes, locationArg, basename = "/") {
  return matchRoutesImpl(routes, locationArg, basename, false);
}
function matchRoutesImpl(routes, locationArg, basename, allowPartial) {
  let location = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i2 = 0; matches == null && i2 < branches.length; ++i2) {
    let decoded = decodePath(pathname);
    matches = matchRouteBranch(
      branches[i2],
      decoded,
      allowPartial
    );
  }
  return matches;
}
function convertRouteMatchToUiMatch(match, loaderData) {
  let { route, pathname, params } = match;
  return {
    id: route.id,
    pathname,
    params,
    data: loaderData[route.id],
    loaderData: loaderData[route.id],
    handle: route.handle
  };
}
function flattenRoutes(routes, branches = [], parentsMeta = [], parentPath = "", _hasParentOptionalSegments = false) {
  let flattenRoute = (route, index, hasParentOptionalSegments = _hasParentOptionalSegments, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      if (!meta.relativePath.startsWith(parentPath) && hasParentOptionalSegments) {
        return;
      }
      invariant(
        meta.relativePath.startsWith(parentPath),
        `Absolute route path "${meta.relativePath}" nested under path "${parentPath}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`
      );
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        `Index routes must not have child routes. Please remove all child routes from route path "${path}".`
      );
      flattenRoutes(
        route.children,
        branches,
        routesMeta,
        path,
        hasParentOptionalSegments
      );
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index) => {
    if (route.path === "" || !route.path?.includes("?")) {
      flattenRoute(route, index);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index, true, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0) return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required, ""] : [required];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(
    ...restExploded.map(
      (subpath) => subpath === "" ? required : [required, subpath].join("/")
    )
  );
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map(
    (exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded
  );
}
function rankRouteBranches(branches) {
  branches.sort(
    (a2, b2) => a2.score !== b2.score ? b2.score - a2.score : compareIndexes(
      a2.routesMeta.map((meta) => meta.childrenIndex),
      b2.routesMeta.map((meta) => meta.childrenIndex)
    )
  );
}
var paramRe = /^:[\w-]+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s2) => s2 === "*";
function computeScore(path, index) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s2) => !isSplat(s2)).reduce(
    (score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue),
    initialScore
  );
}
function compareIndexes(a2, b2) {
  let siblings = a2.length === b2.length && a2.slice(0, -1).every((n2, i2) => n2 === b2[i2]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a2[a2.length - 1] - b2[b2.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname, allowPartial = false) {
  let { routesMeta } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i2 = 0; i2 < routesMeta.length; ++i2) {
    let meta = routesMeta[i2];
    let end = i2 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match = matchPath(
      { path: meta.relativePath, caseSensitive: meta.caseSensitive, end },
      remainingPathname
    );
    let route = meta.route;
    if (!match && end && allowPartial && !routesMeta[routesMeta.length - 1].route.index) {
      match = matchPath(
        {
          path: meta.relativePath,
          caseSensitive: meta.caseSensitive,
          end: false
        },
        remainingPathname
      );
    }
    if (!match) {
      return null;
    }
    Object.assign(matchedParams, match.params);
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match.pathname]),
      pathnameBase: normalizePathname(
        joinPaths([matchedPathname, match.pathnameBase])
      ),
      route
    });
    if (match.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);
    }
  }
  return matches;
}
function matchPath(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = { path: pattern, caseSensitive: false, end: true };
  }
  let [matcher, compiledParams] = compilePath(
    pattern.path,
    pattern.caseSensitive,
    pattern.end
  );
  let match = pathname.match(matcher);
  if (!match) return null;
  let matchedPathname = match[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match.slice(1);
  let params = compiledParams.reduce(
    (memo2, { paramName, isOptional }, index) => {
      if (paramName === "*") {
        let splatValue = captureGroups[index] || "";
        pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
      }
      const value = captureGroups[index];
      if (isOptional && !value) {
        memo2[paramName] = void 0;
      } else {
        memo2[paramName] = (value || "").replace(/%2F/g, "/");
      }
      return memo2;
    },
    {}
  );
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive = false, end = true) {
  warning(
    path === "*" || !path.endsWith("*") || path.endsWith("/*"),
    `Route path "${path}" will be treated as if it were "${path.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${path.replace(/\*$/, "/*")}".`
  );
  let params = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(
    /\/:([\w-]+)(\?)?/g,
    (_2, paramName, isOptional) => {
      params.push({ paramName, isOptional: isOptional != null });
      return isOptional ? "/?([^\\/]+)?" : "/([^\\/]+)";
    }
  ).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2");
  if (path.endsWith("*")) {
    params.push({ paramName: "*" });
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else {
  }
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, params];
}
function decodePath(value) {
  try {
    return value.split("/").map((v2) => decodeURIComponent(v2).replace(/\//g, "%2F")).join("/");
  } catch (error2) {
    warning(
      false,
      `The URL path "${value}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${error2}).`
    );
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/") return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
function resolvePath(to2, fromPathname = "/") {
  let {
    pathname: toPathname,
    search = "",
    hash = ""
  } = typeof to2 === "string" ? parsePath(to2) : to2;
  let pathname;
  if (toPathname) {
    toPathname = toPathname.replace(/\/\/+/g, "/");
    if (toPathname.startsWith("/")) {
      pathname = resolvePathname(toPathname.substring(1), "/");
    } else {
      pathname = resolvePathname(toPathname, fromPathname);
    }
  } else {
    pathname = fromPathname;
  }
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1) segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return `Cannot include a '${char}' character in a manually specified \`to.${field}\` field [${JSON.stringify(
    path
  )}].  Please separate it out to the \`to.${dest}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`;
}
function getPathContributingMatches(matches) {
  return matches.filter(
    (match, index) => index === 0 || match.route.path && match.route.path.length > 0
  );
}
function getResolveToMatches(matches) {
  let pathMatches = getPathContributingMatches(matches);
  return pathMatches.map(
    (match, idx) => idx === pathMatches.length - 1 ? match.pathname : match.pathnameBase
  );
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative = false) {
  let to2;
  if (typeof toArg === "string") {
    to2 = parsePath(toArg);
  } else {
    to2 = { ...toArg };
    invariant(
      !to2.pathname || !to2.pathname.includes("?"),
      getInvalidPathError("?", "pathname", "search", to2)
    );
    invariant(
      !to2.pathname || !to2.pathname.includes("#"),
      getInvalidPathError("#", "pathname", "hash", to2)
    );
    invariant(
      !to2.search || !to2.search.includes("#"),
      getInvalidPathError("#", "search", "hash", to2)
    );
  }
  let isEmptyPath = toArg === "" || to2.pathname === "";
  let toPathname = isEmptyPath ? "/" : to2.pathname;
  let from;
  if (toPathname == null) {
    from = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (!isPathRelative && toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to2.pathname = toSegments.join("/");
    }
    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to2, from);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash) => !hash || hash === "#" ? "" : hash.startsWith("#") ? hash : "#" + hash;
var ErrorResponseImpl = class {
  constructor(status, statusText, data2, internal = false) {
    this.status = status;
    this.statusText = statusText || "";
    this.internal = internal;
    if (data2 instanceof Error) {
      this.data = data2.toString();
      this.error = data2;
    } else {
      this.data = data2;
    }
  }
};
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
function getRoutePattern(matches) {
  return matches.map((m2) => m2.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/";
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function parseToInfo(_to, basename) {
  let to2 = _to;
  if (typeof to2 !== "string" || !ABSOLUTE_URL_REGEX.test(to2)) {
    return {
      absoluteURL: void 0,
      isExternal: false,
      to: to2
    };
  }
  let absoluteURL = to2;
  let isExternal = false;
  if (isBrowser) {
    try {
      let currentUrl = new URL(window.location.href);
      let targetUrl = to2.startsWith("//") ? new URL(currentUrl.protocol + to2) : new URL(to2);
      let path = stripBasename(targetUrl.pathname, basename);
      if (targetUrl.origin === currentUrl.origin && path != null) {
        to2 = path + targetUrl.search + targetUrl.hash;
      } else {
        isExternal = true;
      }
    } catch (e2) {
      warning(
        false,
        `<Link to="${to2}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`
      );
    }
  }
  return {
    absoluteURL,
    isExternal,
    to: to2
  };
}
var objectProtoNames = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var validMutationMethodsArr = [
  "POST",
  "PUT",
  "PATCH",
  "DELETE"
];
var validMutationMethods = new Set(
  validMutationMethodsArr
);
var validRequestMethodsArr = [
  "GET",
  ...validMutationMethodsArr
];
var validRequestMethods = new Set(validRequestMethodsArr);
var DataRouterContext = React2.createContext(null);
DataRouterContext.displayName = "DataRouter";
var DataRouterStateContext = React2.createContext(null);
DataRouterStateContext.displayName = "DataRouterState";
var RSCRouterContext = React2.createContext(false);
var ViewTransitionContext = React2.createContext({
  isTransitioning: false
});
ViewTransitionContext.displayName = "ViewTransition";
var FetchersContext = React2.createContext(
  /* @__PURE__ */ new Map()
);
FetchersContext.displayName = "Fetchers";
var AwaitContext = React2.createContext(null);
AwaitContext.displayName = "Await";
var NavigationContext = React2.createContext(
  null
);
NavigationContext.displayName = "Navigation";
var LocationContext = React2.createContext(
  null
);
LocationContext.displayName = "Location";
var RouteContext = React2.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
RouteContext.displayName = "Route";
var RouteErrorContext = React2.createContext(null);
RouteErrorContext.displayName = "RouteError";
var ENABLE_DEV_WARNINGS = true;
var ERROR_DIGEST_BASE = "REACT_ROUTER_ERROR";
var ERROR_DIGEST_REDIRECT = "REDIRECT";
var ERROR_DIGEST_ROUTE_ERROR_RESPONSE = "ROUTE_ERROR_RESPONSE";
function decodeRedirectErrorDigest(digest) {
  if (digest.startsWith(`${ERROR_DIGEST_BASE}:${ERROR_DIGEST_REDIRECT}:{`)) {
    try {
      let parsed = JSON.parse(digest.slice(28));
      if (typeof parsed === "object" && parsed && typeof parsed.status === "number" && typeof parsed.statusText === "string" && typeof parsed.location === "string" && typeof parsed.reloadDocument === "boolean" && typeof parsed.replace === "boolean") {
        return parsed;
      }
    } catch {
    }
  }
}
function decodeRouteErrorResponseDigest(digest) {
  if (digest.startsWith(
    `${ERROR_DIGEST_BASE}:${ERROR_DIGEST_ROUTE_ERROR_RESPONSE}:{`
  )) {
    try {
      let parsed = JSON.parse(digest.slice(40));
      if (typeof parsed === "object" && parsed && typeof parsed.status === "number" && typeof parsed.statusText === "string") {
        return new ErrorResponseImpl(
          parsed.status,
          parsed.statusText,
          parsed.data
        );
      }
    } catch {
    }
  }
}
function useHref(to2, { relative } = {}) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useHref() may be used only in the context of a <Router> component.`
  );
  let { basename, navigator: navigator2 } = React22.useContext(NavigationContext);
  let { hash, pathname, search } = useResolvedPath(to2, { relative });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({ pathname: joinedPathname, search, hash });
}
function useInRouterContext() {
  return React22.useContext(LocationContext) != null;
}
function useLocation() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useLocation() may be used only in the context of a <Router> component.`
  );
  return React22.useContext(LocationContext).location;
}
var navigateEffectWarning = `You should call navigate() in a React.useEffect(), not when your component is first rendered.`;
function useIsomorphicLayoutEffect(cb) {
  let isStatic = React22.useContext(NavigationContext).static;
  if (!isStatic) {
    React22.useLayoutEffect(cb);
  }
}
function useNavigate() {
  let { isDataRoute } = React22.useContext(RouteContext);
  return isDataRoute ? useNavigateStable() : useNavigateUnstable();
}
function useNavigateUnstable() {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useNavigate() may be used only in the context of a <Router> component.`
  );
  let dataRouterContext = React22.useContext(DataRouterContext);
  let { basename, navigator: navigator2 } = React22.useContext(NavigationContext);
  let { matches } = React22.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  let activeRef = React22.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React22.useCallback(
    (to2, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to2 === "number") {
        navigator2.go(to2);
        return;
      }
      let path = resolveTo(
        to2,
        JSON.parse(routePathnamesJson),
        locationPathname,
        options.relative === "path"
      );
      if (dataRouterContext == null && basename !== "/") {
        path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
      }
      (!!options.replace ? navigator2.replace : navigator2.push)(
        path,
        options.state,
        options
      );
    },
    [
      basename,
      navigator2,
      routePathnamesJson,
      locationPathname,
      dataRouterContext
    ]
  );
  return navigate;
}
var OutletContext = React22.createContext(null);
function useParams() {
  let { matches } = React22.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to2, { relative } = {}) {
  let { matches } = React22.useContext(RouteContext);
  let { pathname: locationPathname } = useLocation();
  let routePathnamesJson = JSON.stringify(getResolveToMatches(matches));
  return React22.useMemo(
    () => resolveTo(
      to2,
      JSON.parse(routePathnamesJson),
      locationPathname,
      relative === "path"
    ),
    [to2, routePathnamesJson, locationPathname, relative]
  );
}
function useRoutesImpl(routes, locationArg, dataRouterState, onError, future) {
  invariant(
    useInRouterContext(),
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    `useRoutes() may be used only in the context of a <Router> component.`
  );
  let { navigator: navigator2 } = React22.useContext(NavigationContext);
  let { matches: parentMatches } = React22.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (ENABLE_DEV_WARNINGS) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(
      parentPathname,
      !parentRoute || parentPath.endsWith("*") || parentPath.endsWith("*?"),
      `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${parentPathname}" (under <Route path="${parentPath}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${parentPath}"> to <Route path="${parentPath === "/" ? "*" : `${parentPath}/*`}">.`
    );
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    let parsedLocationArg = typeof locationArg === "string" ? parsePath(locationArg) : locationArg;
    invariant(
      parentPathnameBase === "/" || parsedLocationArg.pathname?.startsWith(parentPathnameBase),
      `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${parentPathnameBase}" but pathname "${parsedLocationArg.pathname}" was given in the \`location\` prop.`
    );
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = pathname;
  if (parentPathnameBase !== "/") {
    let parentSegments = parentPathnameBase.replace(/^\//, "").split("/");
    let segments = pathname.replace(/^\//, "").split("/");
    remainingPathname = "/" + segments.slice(parentSegments.length).join("/");
  }
  let matches = matchRoutes(routes, { pathname: remainingPathname });
  if (ENABLE_DEV_WARNINGS) {
    warning(
      parentRoute || matches != null,
      `No routes matched location "${location.pathname}${location.search}${location.hash}" `
    );
    warning(
      matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0 || matches[matches.length - 1].route.lazy !== void 0,
      `Matched leaf route at location "${location.pathname}${location.search}${location.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`
    );
  }
  let renderedMatches = _renderMatches(
    matches && matches.map(
      (match) => Object.assign({}, match, {
        params: Object.assign({}, parentParams, match.params),
        pathname: joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes.
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match.pathname
        ]),
        pathnameBase: match.pathnameBase === "/" ? parentPathnameBase : joinPaths([
          parentPathnameBase,
          // Re-encode pathnames that were decoded inside matchRoutes
          // Pre-encode `?` and `#` ahead of `encodeLocation` because it uses
          // `new URL()` internally and we need to prevent it from treating
          // them as separators
          navigator2.encodeLocation ? navigator2.encodeLocation(
            match.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")
          ).pathname : match.pathnameBase
        ])
      })
    ),
    parentMatches,
    dataRouterState,
    onError,
    future
  );
  if (locationArg && renderedMatches) {
    return /* @__PURE__ */ React22.createElement(
      LocationContext.Provider,
      {
        value: {
          location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...location
          },
          navigationType: "POP"
          /* Pop */
        }
      },
      renderedMatches
    );
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message = isRouteErrorResponse(error2) ? `${error2.status} ${error2.statusText}` : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = { padding: "0.5rem", backgroundColor: lightgrey };
  let codeStyles = { padding: "2px 4px", backgroundColor: lightgrey };
  let devInfo = null;
  if (ENABLE_DEV_WARNINGS) {
    console.error(
      "Error handled by React Router default ErrorBoundary:",
      error2
    );
    devInfo = /* @__PURE__ */ React22.createElement(React22.Fragment, null, /* @__PURE__ */ React22.createElement("p", null, "\u{1F4BF} Hey developer \u{1F44B}"), /* @__PURE__ */ React22.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ React22.createElement("code", { style: codeStyles }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ React22.createElement("code", { style: codeStyles }, "errorElement"), " prop on your route."));
  }
  return /* @__PURE__ */ React22.createElement(React22.Fragment, null, /* @__PURE__ */ React22.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ React22.createElement("h3", { style: { fontStyle: "italic" } }, message), stack ? /* @__PURE__ */ React22.createElement("pre", { style: preStyles }, stack) : null, devInfo);
}
var defaultErrorElement = /* @__PURE__ */ React22.createElement(DefaultErrorComponent, null);
var RenderErrorBoundary = class extends React22.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      revalidation: props.revalidation,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return { error: error2 };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location || state.revalidation !== "idle" && props.revalidation === "idle") {
      return {
        error: props.error,
        location: props.location,
        revalidation: props.revalidation
      };
    }
    return {
      error: props.error !== void 0 ? props.error : state.error,
      location: state.location,
      revalidation: props.revalidation || state.revalidation
    };
  }
  componentDidCatch(error2, errorInfo) {
    if (this.props.onError) {
      this.props.onError(error2, errorInfo);
    } else {
      console.error(
        "React Router caught the following error during render",
        error2
      );
    }
  }
  render() {
    let error2 = this.state.error;
    if (this.context && typeof error2 === "object" && error2 && "digest" in error2 && typeof error2.digest === "string") {
      const decoded = decodeRouteErrorResponseDigest(error2.digest);
      if (decoded) error2 = decoded;
    }
    let result = error2 !== void 0 ? /* @__PURE__ */ React22.createElement(RouteContext.Provider, { value: this.props.routeContext }, /* @__PURE__ */ React22.createElement(
      RouteErrorContext.Provider,
      {
        value: error2,
        children: this.props.component
      }
    )) : this.props.children;
    if (this.context) {
      return /* @__PURE__ */ React22.createElement(RSCErrorHandler, { error: error2 }, result);
    }
    return result;
  }
};
RenderErrorBoundary.contextType = RSCRouterContext;
var errorRedirectHandledMap = /* @__PURE__ */ new WeakMap();
function RSCErrorHandler({
  children,
  error: error2
}) {
  let { basename } = React22.useContext(NavigationContext);
  if (typeof error2 === "object" && error2 && "digest" in error2 && typeof error2.digest === "string") {
    let redirect2 = decodeRedirectErrorDigest(error2.digest);
    if (redirect2) {
      let existingRedirect = errorRedirectHandledMap.get(error2);
      if (existingRedirect) throw existingRedirect;
      let parsed = parseToInfo(redirect2.location, basename);
      if (isBrowser && !errorRedirectHandledMap.get(error2)) {
        if (parsed.isExternal || redirect2.reloadDocument) {
          window.location.href = parsed.absoluteURL || parsed.to;
        } else {
          const redirectPromise = Promise.resolve().then(
            () => window.__reactRouterDataRouter.navigate(parsed.to, {
              replace: redirect2.replace
            })
          );
          errorRedirectHandledMap.set(error2, redirectPromise);
          throw redirectPromise;
        }
      }
      return /* @__PURE__ */ React22.createElement(
        "meta",
        {
          httpEquiv: "refresh",
          content: `0;url=${parsed.absoluteURL || parsed.to}`
        }
      );
    }
  }
  return children;
}
function RenderedRoute({ routeContext, match, children }) {
  let dataRouterContext = React22.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;
  }
  return /* @__PURE__ */ React22.createElement(RouteContext.Provider, { value: routeContext }, children);
}
function _renderMatches(matches, parentMatches = [], dataRouterState = null, onErrorHandler = null, future = null) {
  if (matches == null) {
    if (!dataRouterState) {
      return null;
    }
    if (dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else if (parentMatches.length === 0 && !dataRouterState.initialized && dataRouterState.matches.length > 0) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState?.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex(
      (m2) => m2.route.id && errors?.[m2.route.id] !== void 0
    );
    invariant(
      errorIndex >= 0,
      `Could not find a matching route for errors on route IDs: ${Object.keys(
        errors
      ).join(",")}`
    );
    renderedMatches = renderedMatches.slice(
      0,
      Math.min(renderedMatches.length, errorIndex + 1)
    );
  }
  let renderFallback = false;
  let fallbackIndex = -1;
  if (dataRouterState) {
    for (let i2 = 0; i2 < renderedMatches.length; i2++) {
      let match = renderedMatches[i2];
      if (match.route.HydrateFallback || match.route.hydrateFallbackElement) {
        fallbackIndex = i2;
      }
      if (match.route.id) {
        let { loaderData, errors: errors2 } = dataRouterState;
        let needsToRunLoader = match.route.loader && !loaderData.hasOwnProperty(match.route.id) && (!errors2 || errors2[match.route.id] === void 0);
        if (match.route.lazy || needsToRunLoader) {
          renderFallback = true;
          if (fallbackIndex >= 0) {
            renderedMatches = renderedMatches.slice(0, fallbackIndex + 1);
          } else {
            renderedMatches = [renderedMatches[0]];
          }
          break;
        }
      }
    }
  }
  let onError = dataRouterState && onErrorHandler ? (error2, errorInfo) => {
    onErrorHandler(error2, {
      location: dataRouterState.location,
      params: dataRouterState.matches?.[0]?.params ?? {},
      unstable_pattern: getRoutePattern(dataRouterState.matches),
      errorInfo
    });
  } : void 0;
  return renderedMatches.reduceRight(
    (outlet, match, index) => {
      let error2;
      let shouldRenderHydrateFallback = false;
      let errorElement = null;
      let hydrateFallbackElement = null;
      if (dataRouterState) {
        error2 = errors && match.route.id ? errors[match.route.id] : void 0;
        errorElement = match.route.errorElement || defaultErrorElement;
        if (renderFallback) {
          if (fallbackIndex < 0 && index === 0) {
            warningOnce(
              "route-fallback",
              false,
              "No `HydrateFallback` element provided to render during initial hydration"
            );
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = null;
          } else if (fallbackIndex === index) {
            shouldRenderHydrateFallback = true;
            hydrateFallbackElement = match.route.hydrateFallbackElement || null;
          }
        }
      }
      let matches2 = parentMatches.concat(renderedMatches.slice(0, index + 1));
      let getChildren = () => {
        let children;
        if (error2) {
          children = errorElement;
        } else if (shouldRenderHydrateFallback) {
          children = hydrateFallbackElement;
        } else if (match.route.Component) {
          children = /* @__PURE__ */ React22.createElement(match.route.Component, null);
        } else if (match.route.element) {
          children = match.route.element;
        } else {
          children = outlet;
        }
        return /* @__PURE__ */ React22.createElement(
          RenderedRoute,
          {
            match,
            routeContext: {
              outlet,
              matches: matches2,
              isDataRoute: dataRouterState != null
            },
            children
          }
        );
      };
      return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /* @__PURE__ */ React22.createElement(
        RenderErrorBoundary,
        {
          location: dataRouterState.location,
          revalidation: dataRouterState.revalidation,
          component: errorElement,
          error: error2,
          children: getChildren(),
          routeContext: { outlet: null, matches: matches2, isDataRoute: true },
          onError
        }
      ) : getChildren();
    },
    null
  );
}
function getDataRouterConsoleError(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext(hookName) {
  let ctx = React22.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError(hookName));
  return ctx;
}
function useDataRouterState(hookName) {
  let state = React22.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError(hookName));
  return state;
}
function useRouteContext(hookName) {
  let route = React22.useContext(RouteContext);
  invariant(route, getDataRouterConsoleError(hookName));
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  invariant(
    thisRoute.route.id,
    `${hookName} can only be used on routes that contain a unique "id"`
  );
  return thisRoute.route.id;
}
function useRouteId() {
  return useCurrentRouteId(
    "useRouteId"
    /* UseRouteId */
  );
}
function useNavigation() {
  let state = useDataRouterState(
    "useNavigation"
    /* UseNavigation */
  );
  return state.navigation;
}
function useMatches() {
  let { matches, loaderData } = useDataRouterState(
    "useMatches"
    /* UseMatches */
  );
  return React22.useMemo(
    () => matches.map((m2) => convertRouteMatchToUiMatch(m2, loaderData)),
    [matches, loaderData]
  );
}
function useRouteError() {
  let error2 = React22.useContext(RouteErrorContext);
  let state = useDataRouterState(
    "useRouteError"
    /* UseRouteError */
  );
  let routeId = useCurrentRouteId(
    "useRouteError"
    /* UseRouteError */
  );
  if (error2 !== void 0) {
    return error2;
  }
  return state.errors?.[routeId];
}
function useNavigateStable() {
  let { router } = useDataRouterContext(
    "useNavigate"
    /* UseNavigateStable */
  );
  let id = useCurrentRouteId(
    "useNavigate"
    /* UseNavigateStable */
  );
  let activeRef = React22.useRef(false);
  useIsomorphicLayoutEffect(() => {
    activeRef.current = true;
  });
  let navigate = React22.useCallback(
    async (to2, options = {}) => {
      warning(activeRef.current, navigateEffectWarning);
      if (!activeRef.current) return;
      if (typeof to2 === "number") {
        await router.navigate(to2);
      } else {
        await router.navigate(to2, { fromRouteId: id, ...options });
      }
    },
    [router, id]
  );
  return navigate;
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    warning(false, message);
  }
}
var USE_OPTIMISTIC = "useOptimistic";
var useOptimisticImpl = React3[USE_OPTIMISTIC];
var MemoizedDataRoutes = React3.memo(DataRoutes);
function DataRoutes({
  routes,
  future,
  state,
  onError
}) {
  return useRoutesImpl(routes, void 0, state, onError, future);
}
function Router({
  basename: basenameProp = "/",
  children = null,
  location: locationProp,
  navigationType = "POP",
  navigator: navigator2,
  static: staticProp = false,
  unstable_useTransitions
}) {
  invariant(
    !useInRouterContext(),
    `You cannot render a <Router> inside another <Router>. You should never have more than one in your app.`
  );
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React3.useMemo(
    () => ({
      basename,
      navigator: navigator2,
      static: staticProp,
      unstable_useTransitions,
      future: {}
    }),
    [basename, navigator2, staticProp, unstable_useTransitions]
  );
  if (typeof locationProp === "string") {
    locationProp = parsePath(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React3.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash, state, key, navigationType]);
  warning(
    locationContext != null,
    `<Router basename="${basename}"> is not able to match the URL "${pathname}${search}${hash}" because it does not start with the basename, so the <Router> won't render anything.`
  );
  if (locationContext == null) {
    return null;
  }
  return /* @__PURE__ */ React3.createElement(NavigationContext.Provider, { value: navigationContext }, /* @__PURE__ */ React3.createElement(LocationContext.Provider, { children, value: locationContext }));
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement(object) {
  return typeof HTMLElement !== "undefined" && object instanceof HTMLElement;
}
function isButtonElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "button";
}
function isFormElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "form";
}
function isInputElement(object) {
  return isHtmlElement(object) && object.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init = "") {
  return new URLSearchParams(
    typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
      let value = init[key];
      return memo2.concat(
        Array.isArray(value) ? value.map((v2) => [key, v2]) : [[key, value]]
      );
    }, [])
  );
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    defaultSearchParams.forEach((_2, key) => {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    });
  }
  return searchParams;
}
var _formDataSupportsSubmitter = null;
function isFormDataSubmitterSupported() {
  if (_formDataSupportsSubmitter === null) {
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      );
      _formDataSupportsSubmitter = false;
    } catch (e2) {
      _formDataSupportsSubmitter = true;
    }
  }
  return _formDataSupportsSubmitter;
}
var supportedFormEncTypes = /* @__PURE__ */ new Set([
  "application/x-www-form-urlencoded",
  "multipart/form-data",
  "text/plain"
]);
function getFormEncType(encType) {
  if (encType != null && !supportedFormEncTypes.has(encType)) {
    warning(
      false,
      `"${encType}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`
    );
    return null;
  }
  return encType;
}
function getFormSubmissionInfo(target, basename) {
  let method;
  let action;
  let encType;
  let formData;
  let body;
  if (isFormElement(target)) {
    let attr = target.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(target);
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error(
        `Cannot submit a <button> or <input type="submit"> without a <form>`
      );
    }
    let attr = target.getAttribute("formaction") || form.getAttribute("action");
    action = attr ? stripBasename(attr, basename) : null;
    method = target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    encType = getFormEncType(target.getAttribute("formenctype")) || getFormEncType(form.getAttribute("enctype")) || defaultEncType;
    formData = new FormData(form, target);
    if (!isFormDataSubmitterSupported()) {
      let { name, type, value } = target;
      if (type === "image") {
        let prefix = name ? `${name}.` : "";
        formData.append(`${prefix}x`, "0");
        formData.append(`${prefix}y`, "0");
      } else if (name) {
        formData.append(name, value);
      }
    }
  } else if (isHtmlElement(target)) {
    throw new Error(
      `Cannot submit element that is not <form>, <button>, or <input type="submit|image">`
    );
  } else {
    method = defaultMethod;
    action = null;
    encType = defaultEncType;
    body = target;
  }
  if (formData && encType === "text/plain") {
    body = formData;
    formData = void 0;
  }
  return { action, method: method.toLowerCase(), encType, formData, body };
}
var objectProtoNames2 = Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var ESCAPE_LOOKUP = {
  "&": "\\u0026",
  ">": "\\u003e",
  "<": "\\u003c",
  "\u2028": "\\u2028",
  "\u2029": "\\u2029"
};
var ESCAPE_REGEX = /[&><\u2028\u2029]/g;
function escapeHtml(html) {
  return html.replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
}
function invariant2(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function singleFetchUrl(reqUrl, basename, trailingSlashAware, extension) {
  let url = typeof reqUrl === "string" ? new URL(
    reqUrl,
    // This can be called during the SSR flow via PrefetchPageLinksImpl so
    // don't assume window is available
    typeof window === "undefined" ? "server://singlefetch/" : window.location.origin
  ) : reqUrl;
  if (trailingSlashAware) {
    if (url.pathname.endsWith("/")) {
      url.pathname = `${url.pathname}_.${extension}`;
    } else {
      url.pathname = `${url.pathname}.${extension}`;
    }
  } else {
    if (url.pathname === "/") {
      url.pathname = `_root.${extension}`;
    } else if (basename && stripBasename(url.pathname, basename) === "/") {
      url.pathname = `${basename.replace(/\/$/, "")}/_root.${extension}`;
    } else {
      url.pathname = `${url.pathname.replace(/\/$/, "")}.${extension}`;
    }
  }
  return url;
}
async function loadRouteModule(route, routeModulesCache) {
  if (route.id in routeModulesCache) {
    return routeModulesCache[route.id];
  }
  try {
    let routeModule = await import(
      /* @vite-ignore */
      /* webpackIgnore: true */
      route.module
    );
    routeModulesCache[route.id] = routeModule;
    return routeModule;
  } catch (error2) {
    console.error(
      `Error loading route module \`${route.module}\`, reloading page...`
    );
    console.error(error2);
    if (window.__reactRouterContext && window.__reactRouterContext.isSpaMode && // @ts-expect-error
    import.meta.hot) {
      throw error2;
    }
    window.location.reload();
    return new Promise(() => {
    });
  }
}
function isPageLinkDescriptor(object) {
  return object != null && typeof object.page === "string";
}
function isHtmlLinkDescriptor(object) {
  if (object == null) {
    return false;
  }
  if (object.href == null) {
    return object.rel === "preload" && typeof object.imageSrcSet === "string" && typeof object.imageSizes === "string";
  }
  return typeof object.rel === "string" && typeof object.href === "string";
}
async function getKeyedPrefetchLinks(matches, manifest, routeModules) {
  let links = await Promise.all(
    matches.map(async (match) => {
      let route = manifest.routes[match.route.id];
      if (route) {
        let mod = await loadRouteModule(route, routeModules);
        return mod.links ? mod.links() : [];
      }
      return [];
    })
  );
  return dedupeLinkDescriptors(
    links.flat(1).filter(isHtmlLinkDescriptor).filter((link) => link.rel === "stylesheet" || link.rel === "preload").map(
      (link) => link.rel === "stylesheet" ? { ...link, rel: "prefetch", as: "style" } : { ...link, rel: "prefetch" }
    )
  );
}
function getNewMatchesForLinks(page, nextMatches, currentMatches, manifest, location, mode) {
  let isNew = (match, index) => {
    if (!currentMatches[index]) return true;
    return match.route.id !== currentMatches[index].route.id;
  };
  let matchPathChanged = (match, index) => {
    return (
      // param change, /users/123 -> /users/456
      currentMatches[index].pathname !== match.pathname || // splat param changed, which is not present in match.path
      // e.g. /files/images/avatar.jpg -> files/finances.xls
      currentMatches[index].route.path?.endsWith("*") && currentMatches[index].params["*"] !== match.params["*"]
    );
  };
  if (mode === "assets") {
    return nextMatches.filter(
      (match, index) => isNew(match, index) || matchPathChanged(match, index)
    );
  }
  if (mode === "data") {
    return nextMatches.filter((match, index) => {
      let manifestRoute = manifest.routes[match.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return false;
      }
      if (isNew(match, index) || matchPathChanged(match, index)) {
        return true;
      }
      if (match.route.shouldRevalidate) {
        let routeChoice = match.route.shouldRevalidate({
          currentUrl: new URL(
            location.pathname + location.search + location.hash,
            window.origin
          ),
          currentParams: currentMatches[0]?.params || {},
          nextUrl: new URL(page, window.origin),
          nextParams: match.params,
          defaultShouldRevalidate: true
        });
        if (typeof routeChoice === "boolean") {
          return routeChoice;
        }
      }
      return true;
    });
  }
  return [];
}
function getModuleLinkHrefs(matches, manifest, { includeHydrateFallback } = {}) {
  return dedupeHrefs(
    matches.map((match) => {
      let route = manifest.routes[match.route.id];
      if (!route) return [];
      let hrefs = [route.module];
      if (route.clientActionModule) {
        hrefs = hrefs.concat(route.clientActionModule);
      }
      if (route.clientLoaderModule) {
        hrefs = hrefs.concat(route.clientLoaderModule);
      }
      if (includeHydrateFallback && route.hydrateFallbackModule) {
        hrefs = hrefs.concat(route.hydrateFallbackModule);
      }
      if (route.imports) {
        hrefs = hrefs.concat(route.imports);
      }
      return hrefs;
    }).flat(1)
  );
}
function dedupeHrefs(hrefs) {
  return [...new Set(hrefs)];
}
function sortKeys(obj) {
  let sorted = {};
  let keys = Object.keys(obj).sort();
  for (let key of keys) {
    sorted[key] = obj[key];
  }
  return sorted;
}
function dedupeLinkDescriptors(descriptors, preloads) {
  let set = /* @__PURE__ */ new Set();
  let preloadsSet = new Set(preloads);
  return descriptors.reduce((deduped, descriptor) => {
    let alreadyModulePreload = preloads && !isPageLinkDescriptor(descriptor) && descriptor.as === "script" && descriptor.href && preloadsSet.has(descriptor.href);
    if (alreadyModulePreload) {
      return deduped;
    }
    let key = JSON.stringify(sortKeys(descriptor));
    if (!set.has(key)) {
      set.add(key);
      deduped.push({ key, link: descriptor });
    }
    return deduped;
  }, []);
}
function useDataRouterContext2() {
  let context = React8.useContext(DataRouterContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterContext.Provider> element"
  );
  return context;
}
function useDataRouterStateContext() {
  let context = React8.useContext(DataRouterStateContext);
  invariant2(
    context,
    "You must render this element inside a <DataRouterStateContext.Provider> element"
  );
  return context;
}
var FrameworkContext = React8.createContext(void 0);
FrameworkContext.displayName = "FrameworkContext";
function useFrameworkContext() {
  let context = React8.useContext(FrameworkContext);
  invariant2(
    context,
    "You must render this element inside a <HydratedRouter> element"
  );
  return context;
}
function usePrefetchBehavior(prefetch, theirElementProps) {
  let frameworkContext = React8.useContext(FrameworkContext);
  let [maybePrefetch, setMaybePrefetch] = React8.useState(false);
  let [shouldPrefetch, setShouldPrefetch] = React8.useState(false);
  let { onFocus, onBlur, onMouseEnter, onMouseLeave, onTouchStart } = theirElementProps;
  let ref = React8.useRef(null);
  React8.useEffect(() => {
    if (prefetch === "render") {
      setShouldPrefetch(true);
    }
    if (prefetch === "viewport") {
      let callback = (entries) => {
        entries.forEach((entry) => {
          setShouldPrefetch(entry.isIntersecting);
        });
      };
      let observer = new IntersectionObserver(callback, { threshold: 0.5 });
      if (ref.current) observer.observe(ref.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [prefetch]);
  React8.useEffect(() => {
    if (maybePrefetch) {
      let id = setTimeout(() => {
        setShouldPrefetch(true);
      }, 100);
      return () => {
        clearTimeout(id);
      };
    }
  }, [maybePrefetch]);
  let setIntent = () => {
    setMaybePrefetch(true);
  };
  let cancelIntent = () => {
    setMaybePrefetch(false);
    setShouldPrefetch(false);
  };
  if (!frameworkContext) {
    return [false, ref, {}];
  }
  if (prefetch !== "intent") {
    return [shouldPrefetch, ref, {}];
  }
  return [
    shouldPrefetch,
    ref,
    {
      onFocus: composeEventHandlers(onFocus, setIntent),
      onBlur: composeEventHandlers(onBlur, cancelIntent),
      onMouseEnter: composeEventHandlers(onMouseEnter, setIntent),
      onMouseLeave: composeEventHandlers(onMouseLeave, cancelIntent),
      onTouchStart: composeEventHandlers(onTouchStart, setIntent)
    }
  ];
}
function composeEventHandlers(theirHandler, ourHandler) {
  return (event) => {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      ourHandler(event);
    }
  };
}
function PrefetchPageLinks({ page, ...linkProps }) {
  let { router } = useDataRouterContext2();
  let matches = React8.useMemo(
    () => matchRoutes(router.routes, page, router.basename),
    [router.routes, page, router.basename]
  );
  if (!matches) {
    return null;
  }
  return /* @__PURE__ */ React8.createElement(PrefetchPageLinksImpl, { page, matches, ...linkProps });
}
function useKeyedPrefetchLinks(matches) {
  let { manifest, routeModules } = useFrameworkContext();
  let [keyedPrefetchLinks, setKeyedPrefetchLinks] = React8.useState([]);
  React8.useEffect(() => {
    let interrupted = false;
    void getKeyedPrefetchLinks(matches, manifest, routeModules).then(
      (links) => {
        if (!interrupted) {
          setKeyedPrefetchLinks(links);
        }
      }
    );
    return () => {
      interrupted = true;
    };
  }, [matches, manifest, routeModules]);
  return keyedPrefetchLinks;
}
function PrefetchPageLinksImpl({
  page,
  matches: nextMatches,
  ...linkProps
}) {
  let location = useLocation();
  let { future, manifest, routeModules } = useFrameworkContext();
  let { basename } = useDataRouterContext2();
  let { loaderData, matches } = useDataRouterStateContext();
  let newMatchesForData = React8.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "data"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let newMatchesForAssets = React8.useMemo(
    () => getNewMatchesForLinks(
      page,
      nextMatches,
      matches,
      manifest,
      location,
      "assets"
    ),
    [page, nextMatches, matches, manifest, location]
  );
  let dataHrefs = React8.useMemo(() => {
    if (page === location.pathname + location.search + location.hash) {
      return [];
    }
    let routesParams = /* @__PURE__ */ new Set();
    let foundOptOutRoute = false;
    nextMatches.forEach((m2) => {
      let manifestRoute = manifest.routes[m2.route.id];
      if (!manifestRoute || !manifestRoute.hasLoader) {
        return;
      }
      if (!newMatchesForData.some((m22) => m22.route.id === m2.route.id) && m2.route.id in loaderData && routeModules[m2.route.id]?.shouldRevalidate) {
        foundOptOutRoute = true;
      } else if (manifestRoute.hasClientLoader) {
        foundOptOutRoute = true;
      } else {
        routesParams.add(m2.route.id);
      }
    });
    if (routesParams.size === 0) {
      return [];
    }
    let url = singleFetchUrl(
      page,
      basename,
      future.unstable_trailingSlashAwareDataRequests,
      "data"
    );
    if (foundOptOutRoute && routesParams.size > 0) {
      url.searchParams.set(
        "_routes",
        nextMatches.filter((m2) => routesParams.has(m2.route.id)).map((m2) => m2.route.id).join(",")
      );
    }
    return [url.pathname + url.search];
  }, [
    basename,
    future.unstable_trailingSlashAwareDataRequests,
    loaderData,
    location,
    manifest,
    newMatchesForData,
    nextMatches,
    page,
    routeModules
  ]);
  let moduleHrefs = React8.useMemo(
    () => getModuleLinkHrefs(newMatchesForAssets, manifest),
    [newMatchesForAssets, manifest]
  );
  let keyedPrefetchLinks = useKeyedPrefetchLinks(newMatchesForAssets);
  return /* @__PURE__ */ React8.createElement(React8.Fragment, null, dataHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", { key: href, rel: "prefetch", as: "fetch", href, ...linkProps })), moduleHrefs.map((href) => /* @__PURE__ */ React8.createElement("link", { key: href, rel: "modulepreload", href, ...linkProps })), keyedPrefetchLinks.map(({ key, link }) => (
    // these don't spread `linkProps` because they are full link descriptors
    // already with their own props
    /* @__PURE__ */ React8.createElement(
      "link",
      {
        key,
        nonce: linkProps.nonce,
        ...link,
        crossOrigin: link.crossOrigin ?? linkProps.crossOrigin
      }
    )
  )));
}
function mergeRefs(...refs) {
  return (value) => {
    refs.forEach((ref) => {
      if (typeof ref === "function") {
        ref(value);
      } else if (ref != null) {
        ref.current = value;
      }
    });
  };
}
var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
try {
  if (isBrowser2) {
    window.__reactRouterVersion = // @ts-expect-error
    "7.13.0";
  }
} catch (e2) {
}
function HistoryRouter({
  basename,
  children,
  history,
  unstable_useTransitions
}) {
  let [state, setStateImpl] = React10.useState({
    action: history.action,
    location: history.location
  });
  let setState = React10.useCallback(
    (newState) => {
      if (unstable_useTransitions === false) {
        setStateImpl(newState);
      } else {
        React10.startTransition(() => setStateImpl(newState));
      }
    },
    [unstable_useTransitions]
  );
  React10.useLayoutEffect(() => history.listen(setState), [history, setState]);
  return /* @__PURE__ */ React10.createElement(
    Router,
    {
      basename,
      children,
      location: state.location,
      navigationType: state.action,
      navigator: history,
      unstable_useTransitions
    }
  );
}
HistoryRouter.displayName = "unstable_HistoryRouter";
var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React10.forwardRef(
  function LinkWithRef({
    onClick,
    discover = "render",
    prefetch = "none",
    relative,
    reloadDocument,
    replace: replace2,
    state,
    target,
    to: to2,
    preventScrollReset,
    viewTransition,
    unstable_defaultShouldRevalidate,
    ...rest
  }, forwardedRef) {
    let { basename, unstable_useTransitions } = React10.useContext(NavigationContext);
    let isAbsolute = typeof to2 === "string" && ABSOLUTE_URL_REGEX2.test(to2);
    let parsed = parseToInfo(to2, basename);
    to2 = parsed.to;
    let href = useHref(to2, { relative });
    let [shouldPrefetch, prefetchRef, prefetchHandlers] = usePrefetchBehavior(
      prefetch,
      rest
    );
    let internalOnClick = useLinkClickHandler(to2, {
      replace: replace2,
      state,
      target,
      preventScrollReset,
      relative,
      viewTransition,
      unstable_defaultShouldRevalidate,
      unstable_useTransitions
    });
    function handleClick(event) {
      if (onClick) onClick(event);
      if (!event.defaultPrevented) {
        internalOnClick(event);
      }
    }
    let link = (
      // eslint-disable-next-line jsx-a11y/anchor-has-content
      /* @__PURE__ */ React10.createElement(
        "a",
        {
          ...rest,
          ...prefetchHandlers,
          href: parsed.absoluteURL || href,
          onClick: parsed.isExternal || reloadDocument ? onClick : handleClick,
          ref: mergeRefs(forwardedRef, prefetchRef),
          target,
          "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
        }
      )
    );
    return shouldPrefetch && !isAbsolute ? /* @__PURE__ */ React10.createElement(React10.Fragment, null, link, /* @__PURE__ */ React10.createElement(PrefetchPageLinks, { page: href })) : link;
  }
);
Link.displayName = "Link";
var NavLink = React10.forwardRef(
  function NavLinkWithRef({
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end = false,
    style: styleProp,
    to: to2,
    viewTransition,
    children,
    ...rest
  }, ref) {
    let path = useResolvedPath(to2, { relative: rest.relative });
    let location = useLocation();
    let routerState = React10.useContext(DataRouterStateContext);
    let { navigator: navigator2, basename } = React10.useContext(NavigationContext);
    let isTransitioning = routerState != null && // Conditional usage is OK here because the usage of a data router is static
    // eslint-disable-next-line react-hooks/rules-of-hooks
    useViewTransitionState(path) && viewTransition === true;
    let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
    let locationPathname = location.pathname;
    let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
    if (!caseSensitive) {
      locationPathname = locationPathname.toLowerCase();
      nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
      toPathname = toPathname.toLowerCase();
    }
    if (nextLocationPathname && basename) {
      nextLocationPathname = stripBasename(nextLocationPathname, basename) || nextLocationPathname;
    }
    const endSlashPosition = toPathname !== "/" && toPathname.endsWith("/") ? toPathname.length - 1 : toPathname.length;
    let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === "/";
    let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
    let renderProps = {
      isActive,
      isPending,
      isTransitioning
    };
    let ariaCurrent = isActive ? ariaCurrentProp : void 0;
    let className;
    if (typeof classNameProp === "function") {
      className = classNameProp(renderProps);
    } else {
      className = [
        classNameProp,
        isActive ? "active" : null,
        isPending ? "pending" : null,
        isTransitioning ? "transitioning" : null
      ].filter(Boolean).join(" ");
    }
    let style = typeof styleProp === "function" ? styleProp(renderProps) : styleProp;
    return /* @__PURE__ */ React10.createElement(
      Link,
      {
        ...rest,
        "aria-current": ariaCurrent,
        className,
        ref,
        style,
        to: to2,
        viewTransition
      },
      typeof children === "function" ? children(renderProps) : children
    );
  }
);
NavLink.displayName = "NavLink";
var Form = React10.forwardRef(
  ({
    discover = "render",
    fetcherKey,
    navigate,
    reloadDocument,
    replace: replace2,
    state,
    method = defaultMethod,
    action,
    onSubmit,
    relative,
    preventScrollReset,
    viewTransition,
    unstable_defaultShouldRevalidate,
    ...props
  }, forwardedRef) => {
    let { unstable_useTransitions } = React10.useContext(NavigationContext);
    let submit = useSubmit();
    let formAction = useFormAction(action, { relative });
    let formMethod = method.toLowerCase() === "get" ? "get" : "post";
    let isAbsolute = typeof action === "string" && ABSOLUTE_URL_REGEX2.test(action);
    let submitHandler = (event) => {
      onSubmit && onSubmit(event);
      if (event.defaultPrevented) return;
      event.preventDefault();
      let submitter = event.nativeEvent.submitter;
      let submitMethod = submitter?.getAttribute("formmethod") || method;
      let doSubmit = () => submit(submitter || event.currentTarget, {
        fetcherKey,
        method: submitMethod,
        navigate,
        replace: replace2,
        state,
        relative,
        preventScrollReset,
        viewTransition,
        unstable_defaultShouldRevalidate
      });
      if (unstable_useTransitions && navigate !== false) {
        React10.startTransition(() => doSubmit());
      } else {
        doSubmit();
      }
    };
    return /* @__PURE__ */ React10.createElement(
      "form",
      {
        ref: forwardedRef,
        method: formMethod,
        action: formAction,
        onSubmit: reloadDocument ? onSubmit : submitHandler,
        ...props,
        "data-discover": !isAbsolute && discover === "render" ? "true" : void 0
      }
    );
  }
);
Form.displayName = "Form";
function ScrollRestoration({
  getKey,
  storageKey,
  ...props
}) {
  let remixContext = React10.useContext(FrameworkContext);
  let { basename } = React10.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  useScrollRestoration({ getKey, storageKey });
  let ssrKey = React10.useMemo(
    () => {
      if (!remixContext || !getKey) return null;
      let userKey = getScrollRestorationKey(
        location,
        matches,
        basename,
        getKey
      );
      return userKey !== location.key ? userKey : null;
    },
    // Nah, we only need this the first time for the SSR render
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  if (!remixContext || remixContext.isSpaMode) {
    return null;
  }
  let restoreScroll = ((storageKey2, restoreKey) => {
    if (!window.history.state || !window.history.state.key) {
      let key = Math.random().toString(32).slice(2);
      window.history.replaceState({ key }, "");
    }
    try {
      let positions = JSON.parse(sessionStorage.getItem(storageKey2) || "{}");
      let storedY = positions[restoreKey || window.history.state.key];
      if (typeof storedY === "number") {
        window.scrollTo(0, storedY);
      }
    } catch (error2) {
      console.error(error2);
      sessionStorage.removeItem(storageKey2);
    }
  }).toString();
  return /* @__PURE__ */ React10.createElement(
    "script",
    {
      ...props,
      suppressHydrationWarning: true,
      dangerouslySetInnerHTML: {
        __html: `(${restoreScroll})(${escapeHtml(
          JSON.stringify(storageKey || SCROLL_RESTORATION_STORAGE_KEY)
        )}, ${escapeHtml(JSON.stringify(ssrKey))})`
      }
    }
  );
}
ScrollRestoration.displayName = "ScrollRestoration";
function getDataRouterConsoleError2(hookName) {
  return `${hookName} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`;
}
function useDataRouterContext3(hookName) {
  let ctx = React10.useContext(DataRouterContext);
  invariant(ctx, getDataRouterConsoleError2(hookName));
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = React10.useContext(DataRouterStateContext);
  invariant(state, getDataRouterConsoleError2(hookName));
  return state;
}
function useLinkClickHandler(to2, {
  target,
  replace: replaceProp,
  state,
  preventScrollReset,
  relative,
  viewTransition,
  unstable_defaultShouldRevalidate,
  unstable_useTransitions
} = {}) {
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to2, { relative });
  return React10.useCallback(
    (event) => {
      if (shouldProcessLinkClick(event, target)) {
        event.preventDefault();
        let replace2 = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
        let doNavigate = () => navigate(to2, {
          replace: replace2,
          state,
          preventScrollReset,
          relative,
          viewTransition,
          unstable_defaultShouldRevalidate
        });
        if (unstable_useTransitions) {
          React10.startTransition(() => doNavigate());
        } else {
          doNavigate();
        }
      }
    },
    [
      location,
      navigate,
      path,
      replaceProp,
      state,
      target,
      to2,
      preventScrollReset,
      relative,
      viewTransition,
      unstable_defaultShouldRevalidate,
      unstable_useTransitions
    ]
  );
}
function useSearchParams(defaultInit) {
  warning(
    typeof URLSearchParams !== "undefined",
    `You cannot use the \`useSearchParams\` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.`
  );
  let defaultSearchParamsRef = React10.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = React10.useRef(false);
  let location = useLocation();
  let searchParams = React10.useMemo(
    () => (
      // Only merge in the defaults if we haven't yet called setSearchParams.
      // Once we call that we want those to take precedence, otherwise you can't
      // remove a param with setSearchParams({}) if it has an initial value
      getSearchParamsForLocation(
        location.search,
        hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current
      )
    ),
    [location.search]
  );
  let navigate = useNavigate();
  let setSearchParams = React10.useCallback(
    (nextInit, navigateOptions) => {
      const newSearchParams = createSearchParams(
        typeof nextInit === "function" ? nextInit(new URLSearchParams(searchParams)) : nextInit
      );
      hasSetSearchParamsRef.current = true;
      navigate("?" + newSearchParams, navigateOptions);
    },
    [navigate, searchParams]
  );
  return [searchParams, setSearchParams];
}
var fetcherId = 0;
var getUniqueFetcherId = () => `__${String(++fetcherId)}__`;
function useSubmit() {
  let { router } = useDataRouterContext3(
    "useSubmit"
    /* UseSubmit */
  );
  let { basename } = React10.useContext(NavigationContext);
  let currentRouteId = useRouteId();
  let routerFetch = router.fetch;
  let routerNavigate = router.navigate;
  return React10.useCallback(
    async (target, options = {}) => {
      let { action, method, encType, formData, body } = getFormSubmissionInfo(
        target,
        basename
      );
      if (options.navigate === false) {
        let key = options.fetcherKey || getUniqueFetcherId();
        await routerFetch(key, currentRouteId, options.action || action, {
          unstable_defaultShouldRevalidate: options.unstable_defaultShouldRevalidate,
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          flushSync: options.flushSync
        });
      } else {
        await routerNavigate(options.action || action, {
          unstable_defaultShouldRevalidate: options.unstable_defaultShouldRevalidate,
          preventScrollReset: options.preventScrollReset,
          formData,
          body,
          formMethod: options.method || method,
          formEncType: options.encType || encType,
          replace: options.replace,
          state: options.state,
          fromRouteId: currentRouteId,
          flushSync: options.flushSync,
          viewTransition: options.viewTransition
        });
      }
    },
    [routerFetch, routerNavigate, basename, currentRouteId]
  );
}
function useFormAction(action, { relative } = {}) {
  let { basename } = React10.useContext(NavigationContext);
  let routeContext = React10.useContext(RouteContext);
  invariant(routeContext, "useFormAction must be used inside a RouteContext");
  let [match] = routeContext.matches.slice(-1);
  let path = { ...useResolvedPath(action ? action : ".", { relative }) };
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    let params = new URLSearchParams(path.search);
    let indexValues = params.getAll("index");
    let hasNakedIndexParam = indexValues.some((v2) => v2 === "");
    if (hasNakedIndexParam) {
      params.delete("index");
      indexValues.filter((v2) => v2).forEach((v2) => params.append("index", v2));
      let qs2 = params.toString();
      path.search = qs2 ? `?${qs2}` : "";
    }
  }
  if ((!action || action === ".") && match.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function getScrollRestorationKey(location, matches, basename, getKey) {
  let key = null;
  if (getKey) {
    if (basename !== "/") {
      key = getKey(
        {
          ...location,
          pathname: stripBasename(location.pathname, basename) || location.pathname
        },
        matches
      );
    } else {
      key = getKey(location, matches);
    }
  }
  if (key == null) {
    key = location.key;
  }
  return key;
}
function useScrollRestoration({
  getKey,
  storageKey
} = {}) {
  let { router } = useDataRouterContext3(
    "useScrollRestoration"
    /* UseScrollRestoration */
  );
  let { restoreScrollPosition, preventScrollReset } = useDataRouterState2(
    "useScrollRestoration"
    /* UseScrollRestoration */
  );
  let { basename } = React10.useContext(NavigationContext);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  React10.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(
    React10.useCallback(() => {
      if (navigation.state === "idle") {
        let key = getScrollRestorationKey(location, matches, basename, getKey);
        savedScrollPositions[key] = window.scrollY;
      }
      try {
        sessionStorage.setItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY,
          JSON.stringify(savedScrollPositions)
        );
      } catch (error2) {
        warning(
          false,
          `Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (${error2}).`
        );
      }
      window.history.scrollRestoration = "auto";
    }, [navigation.state, getKey, basename, location, matches, storageKey])
  );
  if (typeof document !== "undefined") {
    React10.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(
          storageKey || SCROLL_RESTORATION_STORAGE_KEY
        );
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e2) {
      }
    }, [storageKey]);
    React10.useLayoutEffect(() => {
      let disableScrollRestoration = router?.enableScrollRestoration(
        savedScrollPositions,
        () => window.scrollY,
        getKey ? (location2, matches2) => getScrollRestorationKey(location2, matches2, basename, getKey) : void 0
      );
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, basename, getKey]);
    React10.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      try {
        if (location.hash) {
          let el = document.getElementById(
            decodeURIComponent(location.hash.slice(1))
          );
          if (el) {
            el.scrollIntoView();
            return;
          }
        }
      } catch {
        warning(
          false,
          `"${location.hash.slice(
            1
          )}" is not a decodable element ID. The view will not scroll to it.`
        );
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function usePageHide(callback, options) {
  let { capture } = options || {};
  React10.useEffect(() => {
    let opts = capture != null ? { capture } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}
function useViewTransitionState(to2, { relative } = {}) {
  let vtContext = React10.useContext(ViewTransitionContext);
  invariant(
    vtContext != null,
    "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"
  );
  let { basename } = useDataRouterContext3(
    "useViewTransitionState"
    /* useViewTransitionState */
  );
  let path = useResolvedPath(to2, { relative });
  if (!vtContext.isTransitioning) {
    return false;
  }
  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;
  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;
  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;
}

// src/webrtc/MeetingPage.js
var mediasoupClient = __toESM(require_lib5());

// src/webrtc/MeetingContext.js
var import_react3 = __toESM(require_react());
var MeetingContext = (0, import_react3.createContext)(null);
var useMeeting = () => {
  const ctx = (0, import_react3.useContext)(MeetingContext);
  if (!ctx) {
    throw new Error("useMeeting must be used within MeetingProvider");
  }
  return ctx;
};

// src/lms/LMSContext.js
var import_react4 = __toESM(require_react());

// node_modules/axios/lib/helpers/bind.js
function bind(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(toStringTag in val) && !(iterator in val);
};
var isEmptyObject = (val) => {
  if (!isObject(val) || isBuffer(val)) {
    return false;
  }
  try {
    return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
  } catch (e2) {
    return false;
  }
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l2;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l2 = obj.length; i2 < l2; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    if (isBuffer(obj)) {
      return;
    }
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  if (isBuffer(obj)) {
    return null;
  }
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless, skipUndefined } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else if (!skipUndefined || !isUndefined(val)) {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l2 = arguments.length; i2 < l2; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a2, b2, thisArg, { allOwnKeys } = {}) => {
  forEach(b2, (val, key) => {
    if (thisArg && isFunction(val)) {
      Object.defineProperty(a2, key, {
        value: bind(val, thisArg),
        writable: true,
        enumerable: true,
        configurable: true
      });
    } else {
      Object.defineProperty(a2, key, {
        value: val,
        writable: true,
        enumerable: true,
        configurable: true
      });
    }
  }, { allOwnKeys });
  return a2;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  Object.defineProperty(constructor.prototype, "constructor", {
    value: constructor,
    writable: true,
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn2) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase2 = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (isBuffer(source)) {
        return source;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isEmptyObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase: toCamelCase2,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
var AxiosError = class _AxiosError extends Error {
  static from(error2, code, config, request, response, customProps) {
    const axiosError = new _AxiosError(error2.message, code || error2.code, config, request, response);
    axiosError.cause = error2;
    axiosError.name = error2.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  }
  /**
   * Create an Error with the specified message, config, error code, request and response.
   *
   * @param {string} message The error message.
   * @param {string} [code] The error code (for example, 'ECONNABORTED').
   * @param {Object} [config] The config.
   * @param {Object} [request] The request.
   * @param {Object} [response] The response.
   *
   * @returns {Error} The created error.
   */
  constructor(message, code, config, request, response) {
    super(message);
    this.name = "AxiosError";
    this.isAxiosError = true;
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    if (response) {
      this.response = response;
      this.status = response.status;
    }
  }
  toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
};
AxiosError.ERR_BAD_OPTION_VALUE = "ERR_BAD_OPTION_VALUE";
AxiosError.ERR_BAD_OPTION = "ERR_BAD_OPTION";
AxiosError.ECONNABORTED = "ECONNABORTED";
AxiosError.ETIMEDOUT = "ETIMEDOUT";
AxiosError.ERR_NETWORK = "ERR_NETWORK";
AxiosError.ERR_FR_TOO_MANY_REDIRECTS = "ERR_FR_TOO_MANY_REDIRECTS";
AxiosError.ERR_DEPRECATED = "ERR_DEPRECATED";
AxiosError.ERR_BAD_RESPONSE = "ERR_BAD_RESPONSE";
AxiosError.ERR_BAD_REQUEST = "ERR_BAD_REQUEST";
AxiosError.ERR_CANCELED = "ERR_CANCELED";
AxiosError.ERR_NOT_SUPPORT = "ERR_NOT_SUPPORT";
AxiosError.ERR_INVALID_URL = "ERR_INVALID_URL";
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (utils_default.isBoolean(value)) {
      return value.toString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const _options = utils_default.isFunction(options) ? {
    serialize: options
  } : options;
  const serializeFn = _options && _options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, _options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, _options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   * @param {Object} options The options for the interceptor, synchronous and runWhen
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {void}
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils_default.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn2(h2);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data2, options) {
  return toFormData_default(data2, new platform_default.classes.URLSearchParams(), {
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    },
    ...options
  });
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data2);
    if (isObjectPayload && utils_default.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils_default.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data2)) : data2;
    }
    if (utils_default.isArrayBuffer(data2) || utils_default.isBuffer(data2) || utils_default.isStream(data2) || utils_default.isFile(data2) || utils_default.isBlob(data2) || utils_default.isReadableStream(data2)) {
      return data2;
    }
    if (utils_default.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils_default.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data2)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data2) || utils_default.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils_default.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2, this.parseReviver);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = /* @__PURE__ */ Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data2 = context.data;
  utils_default.forEach(fns, function transform(fn2) {
    data2 = fn2.call(config, data2, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data2;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
var CanceledError = class extends AxiosError_default {
  /**
   * A `CanceledError` is an object that is thrown when an operation is canceled.
   *
   * @param {string=} message The message.
   * @param {Object=} config The config.
   * @param {Object=} request The request.
   *
   * @returns {CanceledError} The created error.
   */
  constructor(message, config, request) {
    super(message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
    this.name = "CanceledError";
    this.__CANCEL__ = true;
  }
};
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn2, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn2(...args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data2);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn2) => (...args) => utils_default.asap(() => fn2(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure, sameSite) {
      if (typeof document === "undefined") return;
      const cookie = [`${name}=${encodeURIComponent(value)}`];
      if (utils_default.isNumber(expires)) {
        cookie.push(`expires=${new Date(expires).toUTCString()}`);
      }
      if (utils_default.isString(path)) {
        cookie.push(`path=${path}`);
      }
      if (utils_default.isString(domain)) {
        cookie.push(`domain=${domain}`);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      if (utils_default.isString(sameSite)) {
        cookie.push(`SameSite=${sameSite}`);
      }
      document.cookie = cookie.join("; ");
    },
    read(name) {
      if (typeof document === "undefined") return null;
      const match = document.cookie.match(new RegExp("(?:^|; )" + name + "=([^;]*)"));
      return match ? decodeURIComponent(match[1]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5, "/");
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a2, b2, prop, caseless) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(a2, b2, prop, caseless);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2, prop, caseless);
    }
  }
  function valueFromConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    }
  }
  function defaultToConfig2(a2, b2) {
    if (!utils_default.isUndefined(b2)) {
      return getMergedValue(void 0, b2);
    } else if (!utils_default.isUndefined(a2)) {
      return getMergedValue(void 0, a2);
    }
  }
  function mergeDirectKeys(a2, b2, prop) {
    if (prop in config2) {
      return getMergedValue(a2, b2);
    } else if (prop in config1) {
      return getMergedValue(void 0, a2);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a2, b2, prop) => mergeDeepProperties(headersToObject(a2), headersToObject(b2), prop, true)
  };
  utils_default.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  if (utils_default.isFormData(data2)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if (utils_default.isFunction(data2.getHeaders)) {
      const formHeaders = data2.getHeaders();
      const allowedHeaders = ["content-type", "content-length"];
      Object.entries(formHeaders).forEach(([key, val]) => {
        if (allowedHeaders.includes(key.toLowerCase())) {
          headers.set(key, val);
        }
      });
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError(event) {
      const msg = event && event.message ? event.message : "Network Error";
      const err = new AxiosError_default(msg, AxiosError_default.ERR_NETWORK, config, request);
      err.event = event || null;
      reject(err);
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout of ${timeout}ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var { isFunction: isFunction2 } = utils_default;
var globalFetchAPI = (({ Request: Request2, Response: Response2 }) => ({
  Request: Request2,
  Response: Response2
}))(utils_default.global);
var {
  ReadableStream: ReadableStream2,
  TextEncoder: TextEncoder2
} = utils_default.global;
var test = (fn2, ...args) => {
  try {
    return !!fn2(...args);
  } catch (e2) {
    return false;
  }
};
var factory = (env) => {
  env = utils_default.merge.call({
    skipUndefined: true
  }, globalFetchAPI, env);
  const { fetch: envFetch, Request: Request2, Response: Response2 } = env;
  const isFetchSupported = envFetch ? isFunction2(envFetch) : typeof fetch === "function";
  const isRequestSupported = isFunction2(Request2);
  const isResponseSupported = isFunction2(Response2);
  if (!isFetchSupported) {
    return false;
  }
  const isReadableStreamSupported = isFetchSupported && isFunction2(ReadableStream2);
  const encodeText = isFetchSupported && (typeof TextEncoder2 === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder2()) : async (str) => new Uint8Array(await new Request2(str).arrayBuffer()));
  const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
    let duplexAccessed = false;
    const hasContentType = new Request2(platform_default.origin, {
      body: new ReadableStream2(),
      method: "POST",
      get duplex() {
        duplexAccessed = true;
        return "half";
      }
    }).headers.has("Content-Type");
    return duplexAccessed && !hasContentType;
  });
  const supportsResponseStream = isResponseSupported && isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response2("").body));
  const resolvers = {
    stream: supportsResponseStream && ((res) => res.body)
  };
  isFetchSupported && (() => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
      !resolvers[type] && (resolvers[type] = (res, config) => {
        let method = res && res[type];
        if (method) {
          return method.call(res);
        }
        throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
      });
    });
  })();
  const getBodyLength = async (body) => {
    if (body == null) {
      return 0;
    }
    if (utils_default.isBlob(body)) {
      return body.size;
    }
    if (utils_default.isSpecCompliantForm(body)) {
      const _request = new Request2(platform_default.origin, {
        method: "POST",
        body
      });
      return (await _request.arrayBuffer()).byteLength;
    }
    if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
      return body.byteLength;
    }
    if (utils_default.isURLSearchParams(body)) {
      body = body + "";
    }
    if (utils_default.isString(body)) {
      return (await encodeText(body)).byteLength;
    }
  };
  const resolveBodyLength = async (headers, body) => {
    const length = utils_default.toFiniteNumber(headers.getContentLength());
    return length == null ? getBodyLength(body) : length;
  };
  return async (config) => {
    let {
      url,
      method,
      data: data2,
      signal,
      cancelToken,
      timeout,
      onDownloadProgress,
      onUploadProgress,
      responseType,
      headers,
      withCredentials = "same-origin",
      fetchOptions
    } = resolveConfig_default(config);
    let _fetch = envFetch || fetch;
    responseType = responseType ? (responseType + "").toLowerCase() : "text";
    let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
    let request = null;
    const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
    });
    let requestContentLength;
    try {
      if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
        let _request = new Request2(url, {
          method: "POST",
          body: data2,
          duplex: "half"
        });
        let contentTypeHeader;
        if (utils_default.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
          headers.setContentType(contentTypeHeader);
        }
        if (_request.body) {
          const [onProgress, flush] = progressEventDecorator(
            requestContentLength,
            progressEventReducer(asyncDecorator(onUploadProgress))
          );
          data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
        }
      }
      if (!utils_default.isString(withCredentials)) {
        withCredentials = withCredentials ? "include" : "omit";
      }
      const isCredentialsSupported = isRequestSupported && "credentials" in Request2.prototype;
      const resolvedOptions = {
        ...fetchOptions,
        signal: composedSignal,
        method: method.toUpperCase(),
        headers: headers.normalize().toJSON(),
        body: data2,
        duplex: "half",
        credentials: isCredentialsSupported ? withCredentials : void 0
      };
      request = isRequestSupported && new Request2(url, resolvedOptions);
      let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));
      const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
      if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
        const options = {};
        ["status", "statusText", "headers"].forEach((prop) => {
          options[prop] = response[prop];
        });
        const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
        const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
          responseContentLength,
          progressEventReducer(asyncDecorator(onDownloadProgress), true)
        ) || [];
        response = new Response2(
          trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
            flush && flush();
            unsubscribe && unsubscribe();
          }),
          options
        );
      }
      responseType = responseType || "text";
      let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
      !isStreamResponse && unsubscribe && unsubscribe();
      return await new Promise((resolve, reject) => {
        settle(resolve, reject, {
          data: responseData,
          headers: AxiosHeaders_default.from(response.headers),
          status: response.status,
          statusText: response.statusText,
          config,
          request
        });
      });
    } catch (err) {
      unsubscribe && unsubscribe();
      if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
        throw Object.assign(
          new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
          {
            cause: err.cause || err
          }
        );
      }
      throw AxiosError_default.from(err, err && err.code, config, request);
    }
  };
};
var seedCache = /* @__PURE__ */ new Map();
var getFetch = (config) => {
  let env = config && config.env || {};
  const { fetch: fetch2, Request: Request2, Response: Response2 } = env;
  const seeds = [
    Request2,
    Response2,
    fetch2
  ];
  let len = seeds.length, i2 = len, seed, target, map = seedCache;
  while (i2--) {
    seed = seeds[i2];
    target = map.get(seed);
    target === void 0 && map.set(seed, target = i2 ? /* @__PURE__ */ new Map() : factory(env));
    map = target;
  }
  return target;
};
var adapter = getFetch();

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: {
    get: getFetch
  }
};
utils_default.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter2) => utils_default.isFunction(adapter2) || adapter2 === null || adapter2 === false;
function getAdapter(adapters, config) {
  adapters = utils_default.isArray(adapters) ? adapters : [adapters];
  const { length } = adapters;
  let nameOrAdapter;
  let adapter2;
  const rejectedReasons = {};
  for (let i2 = 0; i2 < length; i2++) {
    nameOrAdapter = adapters[i2];
    let id;
    adapter2 = nameOrAdapter;
    if (!isResolvedHandle(nameOrAdapter)) {
      adapter2 = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
      if (adapter2 === void 0) {
        throw new AxiosError_default(`Unknown adapter '${id}'`);
      }
    }
    if (adapter2 && (utils_default.isFunction(adapter2) || (adapter2 = adapter2.get(config)))) {
      break;
    }
    rejectedReasons[id || "#" + i2] = adapter2;
  }
  if (!adapter2) {
    const reasons = Object.entries(rejectedReasons).map(
      ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
    );
    let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
    throw new AxiosError_default(
      `There is no suitable adapter to dispatch the request ` + s2,
      "ERR_NOT_SUPPORT"
    );
  }
  return adapter2;
}
var adapters_default = {
  /**
   * Resolve an adapter from a list of adapter names or functions.
   * @type {Function}
   */
  getAdapter,
  /**
   * Exposes all known adapters
   * @type {Object<string, Function|Object>}
   */
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter2 = adapters_default.getAdapter(config.adapter || defaults_default.adapter, config);
  return adapter2(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.13.4";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift(...requestInterceptorChain);
      chain.push(...responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
  WebServerIsDown: 521,
  ConnectionTimedOut: 522,
  OriginIsUnreachable: 523,
  TimeoutOccurred: 524,
  SslHandshakeFailed: 525,
  InvalidSslCertificate: 526
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter: getAdapter2,
  mergeConfig: mergeConfig2
} = axios_default;

// src/api/api.js
var api = axios_default.create({
  baseURL: process.env.REACT_APP_API_BASE_URL || "/api",
  headers: {
    "Content-Type": "application/json"
  }
});
api.interceptors.request.use(
  (config) => {
    const token = sessionStorage.getItem("accessToken") || localStorage.getItem("accessToken");
    if (token) {
      config.headers = {
        ...config.headers,
        Authorization: `Bearer ${token}`
      };
    }
    return config;
  },
  (error2) => Promise.reject(error2)
);
api.interceptors.response.use(
  (response) => response,
  (error2) => {
    if (error2.response?.status === 401 || error2.response?.status === 403) {
      console.warn("[API] \uC778\uC99D \uC2E4\uD328:", error2.response?.status);
    }
    if (error2.code === "ERR_NETWORK" || error2.message === "Network Error") {
      console.error("[API] \uB124\uD2B8\uC6CC\uD06C \uC5D0\uB7EC:", error2.message);
    }
    return Promise.reject(error2);
  }
);
var api_default = api;

// src/lms/LMSContext.js
var LMSContext = (0, import_react4.createContext)(null);
var useLMS = () => {
  const context = (0, import_react4.useContext)(LMSContext);
  if (!context) {
    throw new Error("useLMS must be used within LMSProvider");
  }
  return context;
};

// src/toast/Toast.js
var import_react5 = __toESM(require_react());
var Toast = ({ message, visible, duration = 3e3, onClose }) => {
  const onCloseRef = (0, import_react5.useRef)(onClose);
  (0, import_react5.useEffect)(() => {
    onCloseRef.current = onClose;
  }, [onClose]);
  (0, import_react5.useEffect)(() => {
    if (!visible) return;
    const timer = setTimeout(() => {
      onCloseRef.current?.();
    }, duration);
    return () => clearTimeout(timer);
  }, [visible, duration]);
  if (!visible) return null;
  return /* @__PURE__ */ React.createElement("div", { className: "toast-container" }, /* @__PURE__ */ React.createElement("div", { className: "toast" }, message));
};
var Toast_default = Toast;

// src/utils/backendUrl.js
function getWsProtocol() {
  return window.location.protocol === "https:" ? "wss" : "ws";
}
function getHostnameWithPort() {
  const { hostname, port } = window.location;
  return port ? `${hostname}:${port}` : hostname;
}
function getWsBackendOrigin() {
  const envOrigin = process.env.REACT_APP_BACKEND_WS_ORIGIN;
  if (envOrigin) return envOrigin.replace(/\/+$/, "");
  return `${getWsProtocol()}://${getHostnameWithPort()}`;
}
function toWsBackendUrl(pathOrUrl) {
  if (!pathOrUrl) return "";
  if (/^wss?:\/\//i.test(pathOrUrl)) return pathOrUrl;
  const origin2 = getWsBackendOrigin();
  const path = pathOrUrl.startsWith("/") ? pathOrUrl : `/${pathOrUrl}`;
  return `${origin2}${path}`;
}

// node_modules/three/build/three.core.js
var REVISION = "182";
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var VSMShadowMap = 3;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var ConstantColorFactor = 211;
var OneMinusConstantColorFactor = 212;
var ConstantAlphaFactor = 213;
var OneMinusConstantAlphaFactor = 214;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var CineonToneMapping = 3;
var ACESFilmicToneMapping = 4;
var CustomToneMapping = 5;
var AgXToneMapping = 6;
var NeutralToneMapping = 7;
var AttachedBindMode = "attached";
var DetachedBindMode = "detached";
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var CubeUVReflectionMapping = 306;
var RepeatWrapping = 1e3;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var NearestFilter = 1003;
var NearestMipmapNearestFilter = 1004;
var NearestMipmapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipmapNearestFilter = 1007;
var LinearMipmapLinearFilter = 1008;
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedInt248Type = 1020;
var UnsignedInt5999Type = 35902;
var UnsignedInt101111Type = 35899;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RedFormat = 1028;
var RedIntegerFormat = 1029;
var RGFormat = 1030;
var RGIntegerFormat = 1031;
var RGBAIntegerFormat = 1033;
var RGB_S3TC_DXT1_Format = 33776;
var RGBA_S3TC_DXT1_Format = 33777;
var RGBA_S3TC_DXT3_Format = 33778;
var RGBA_S3TC_DXT5_Format = 33779;
var RGB_PVRTC_4BPPV1_Format = 35840;
var RGB_PVRTC_2BPPV1_Format = 35841;
var RGBA_PVRTC_4BPPV1_Format = 35842;
var RGBA_PVRTC_2BPPV1_Format = 35843;
var RGB_ETC1_Format = 36196;
var RGB_ETC2_Format = 37492;
var RGBA_ETC2_EAC_Format = 37496;
var R11_EAC_Format = 37488;
var SIGNED_R11_EAC_Format = 37489;
var RG11_EAC_Format = 37490;
var SIGNED_RG11_EAC_Format = 37491;
var RGBA_ASTC_4x4_Format = 37808;
var RGBA_ASTC_5x4_Format = 37809;
var RGBA_ASTC_5x5_Format = 37810;
var RGBA_ASTC_6x5_Format = 37811;
var RGBA_ASTC_6x6_Format = 37812;
var RGBA_ASTC_8x5_Format = 37813;
var RGBA_ASTC_8x6_Format = 37814;
var RGBA_ASTC_8x8_Format = 37815;
var RGBA_ASTC_10x5_Format = 37816;
var RGBA_ASTC_10x6_Format = 37817;
var RGBA_ASTC_10x8_Format = 37818;
var RGBA_ASTC_10x10_Format = 37819;
var RGBA_ASTC_12x10_Format = 37820;
var RGBA_ASTC_12x12_Format = 37821;
var RGBA_BPTC_Format = 36492;
var RGB_BPTC_SIGNED_Format = 36494;
var RGB_BPTC_UNSIGNED_Format = 36495;
var RED_RGTC1_Format = 36283;
var SIGNED_RED_RGTC1_Format = 36284;
var RED_GREEN_RGTC2_Format = 36285;
var SIGNED_RED_GREEN_RGTC2_Format = 36286;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var NormalAnimationBlendMode = 2500;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var BasicDepthPacking = 3200;
var TangentSpaceNormalMap = 0;
var ObjectSpaceNormalMap = 1;
var NoColorSpace = "";
var SRGBColorSpace = "srgb";
var LinearSRGBColorSpace = "srgb-linear";
var LinearTransfer = "linear";
var SRGBTransfer = "srgb";
var KeepStencilOp = 7680;
var AlwaysStencilFunc = 519;
var NeverCompare = 512;
var LessCompare = 513;
var EqualCompare = 514;
var LessEqualCompare = 515;
var GreaterCompare = 516;
var NotEqualCompare = 517;
var GreaterEqualCompare = 518;
var AlwaysCompare = 519;
var StaticDrawUsage = 35044;
var DynamicDrawUsage = 35048;
var GLSL3 = "300 es";
var WebGLCoordinateSystem = 2e3;
var WebGPUCoordinateSystem = 2001;
function arrayNeedsUint32(array) {
  for (let i2 = array.length - 1; i2 >= 0; --i2) {
    if (array[i2] >= 65535) return true;
  }
  return false;
}
function isTypedArray2(array) {
  return ArrayBuffer.isView(array) && !(array instanceof DataView);
}
function createElementNS(name) {
  return document.createElementNS("http://www.w3.org/1999/xhtml", name);
}
function createCanvasElement() {
  const canvas = createElementNS("canvas");
  canvas.style.display = "block";
  return canvas;
}
var _cache = {};
var _setConsoleFunction = null;
function log(...params) {
  const message = "THREE." + params.shift();
  if (_setConsoleFunction) {
    _setConsoleFunction("log", message, ...params);
  } else {
    console.log(message, ...params);
  }
}
function warn(...params) {
  const message = "THREE." + params.shift();
  if (_setConsoleFunction) {
    _setConsoleFunction("warn", message, ...params);
  } else {
    console.warn(message, ...params);
  }
}
function error(...params) {
  const message = "THREE." + params.shift();
  if (_setConsoleFunction) {
    _setConsoleFunction("error", message, ...params);
  } else {
    console.error(message, ...params);
  }
}
function warnOnce(...params) {
  const message = params.join(" ");
  if (message in _cache) return;
  _cache[message] = true;
  warn(...params);
}
function probeAsync(gl, sync, interval) {
  return new Promise(function(resolve, reject) {
    function probe() {
      switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
        case gl.WAIT_FAILED:
          reject();
          break;
        case gl.TIMEOUT_EXPIRED:
          setTimeout(probe, interval);
          break;
        default:
          resolve();
      }
    }
    setTimeout(probe, interval);
  });
}
var EventDispatcher = class {
  /**
   * Adds the given event listener to the given event type.
   *
   * @param {string} type - The type of event to listen to.
   * @param {Function} listener - The function that gets called when the event is fired.
   */
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {};
    const listeners = this._listeners;
    if (listeners[type] === void 0) {
      listeners[type] = [];
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener);
    }
  }
  /**
   * Returns `true` if the given event listener has been added to the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to check.
   * @return {boolean} Whether the given event listener has been added to the given event type.
   */
  hasEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return false;
    return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;
  }
  /**
   * Removes the given event listener from the given event type.
   *
   * @param {string} type - The type of event.
   * @param {Function} listener - The listener to remove.
   */
  removeEventListener(type, listener) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[type];
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener);
      if (index !== -1) {
        listenerArray.splice(index, 1);
      }
    }
  }
  /**
   * Dispatches an event object.
   *
   * @param {Object} event - The event that gets fired.
   */
  dispatchEvent(event) {
    const listeners = this._listeners;
    if (listeners === void 0) return;
    const listenerArray = listeners[event.type];
    if (listenerArray !== void 0) {
      event.target = this;
      const array = listenerArray.slice(0);
      for (let i2 = 0, l2 = array.length; i2 < l2; i2++) {
        array[i2].call(this, event);
      }
      event.target = null;
    }
  }
};
var _lut = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
var _seed = 1234567;
var DEG2RAD = Math.PI / 180;
var RAD2DEG = 180 / Math.PI;
function generateUUID() {
  const d0 = Math.random() * 4294967295 | 0;
  const d1 = Math.random() * 4294967295 | 0;
  const d2 = Math.random() * 4294967295 | 0;
  const d3 = Math.random() * 4294967295 | 0;
  const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + "-" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + "-" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + "-" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + "-" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];
  return uuid.toLowerCase();
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}
function euclideanModulo(n2, m2) {
  return (n2 % m2 + m2) % m2;
}
function mapLinear(x2, a1, a2, b1, b2) {
  return b1 + (x2 - a1) * (b2 - b1) / (a2 - a1);
}
function inverseLerp(x2, y2, value) {
  if (x2 !== y2) {
    return (value - x2) / (y2 - x2);
  } else {
    return 0;
  }
}
function lerp(x2, y2, t2) {
  return (1 - t2) * x2 + t2 * y2;
}
function damp(x2, y2, lambda, dt2) {
  return lerp(x2, y2, 1 - Math.exp(-lambda * dt2));
}
function pingpong(x2, length = 1) {
  return length - Math.abs(euclideanModulo(x2, length * 2) - length);
}
function smoothstep(x2, min, max) {
  if (x2 <= min) return 0;
  if (x2 >= max) return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * (3 - 2 * x2);
}
function smootherstep(x2, min, max) {
  if (x2 <= min) return 0;
  if (x2 >= max) return 1;
  x2 = (x2 - min) / (max - min);
  return x2 * x2 * x2 * (x2 * (x2 * 6 - 15) + 10);
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1));
}
function randFloat(low, high) {
  return low + Math.random() * (high - low);
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random());
}
function seededRandom(s2) {
  if (s2 !== void 0) _seed = s2;
  let t2 = _seed += 1831565813;
  t2 = Math.imul(t2 ^ t2 >>> 15, t2 | 1);
  t2 ^= t2 + Math.imul(t2 ^ t2 >>> 7, t2 | 61);
  return ((t2 ^ t2 >>> 14) >>> 0) / 4294967296;
}
function degToRad(degrees) {
  return degrees * DEG2RAD;
}
function radToDeg(radians) {
  return radians * RAD2DEG;
}
function isPowerOfTwo(value) {
  return (value & value - 1) === 0 && value !== 0;
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
}
function setQuaternionFromProperEuler(q2, a2, b2, c2, order) {
  const cos = Math.cos;
  const sin = Math.sin;
  const c22 = cos(b2 / 2);
  const s2 = sin(b2 / 2);
  const c13 = cos((a2 + c2) / 2);
  const s13 = sin((a2 + c2) / 2);
  const c1_3 = cos((a2 - c2) / 2);
  const s1_3 = sin((a2 - c2) / 2);
  const c3_1 = cos((c2 - a2) / 2);
  const s3_1 = sin((c2 - a2) / 2);
  switch (order) {
    case "XYX":
      q2.set(c22 * s13, s2 * c1_3, s2 * s1_3, c22 * c13);
      break;
    case "YZY":
      q2.set(s2 * s1_3, c22 * s13, s2 * c1_3, c22 * c13);
      break;
    case "ZXZ":
      q2.set(s2 * c1_3, s2 * s1_3, c22 * s13, c22 * c13);
      break;
    case "XZX":
      q2.set(c22 * s13, s2 * s3_1, s2 * c3_1, c22 * c13);
      break;
    case "YXY":
      q2.set(s2 * c3_1, c22 * s13, s2 * s3_1, c22 * c13);
      break;
    case "ZYZ":
      q2.set(s2 * s3_1, s2 * c3_1, c22 * s13, c22 * c13);
      break;
    default:
      warn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + order);
  }
}
function denormalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return value / 4294967295;
    case Uint16Array:
      return value / 65535;
    case Uint8Array:
      return value / 255;
    case Int32Array:
      return Math.max(value / 2147483647, -1);
    case Int16Array:
      return Math.max(value / 32767, -1);
    case Int8Array:
      return Math.max(value / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value;
    case Uint32Array:
      return Math.round(value * 4294967295);
    case Uint16Array:
      return Math.round(value * 65535);
    case Uint8Array:
      return Math.round(value * 255);
    case Int32Array:
      return Math.round(value * 2147483647);
    case Int16Array:
      return Math.round(value * 32767);
    case Int8Array:
      return Math.round(value * 127);
    default:
      throw new Error("Invalid component type.");
  }
}
var MathUtils = {
  DEG2RAD,
  RAD2DEG,
  /**
   * Generate a [UUID](https://en.wikipedia.org/wiki/Universally_unique_identifier)
   * (universally unique identifier).
   *
   * @static
   * @method
   * @return {string} The UUID.
   */
  generateUUID,
  /**
   * Clamps the given value between min and max.
   *
   * @static
   * @method
   * @param {number} value - The value to clamp.
   * @param {number} min - The min value.
   * @param {number} max - The max value.
   * @return {number} The clamped value.
   */
  clamp,
  /**
   * Computes the Euclidean modulo of the given parameters that
   * is `( ( n % m ) + m ) % m`.
   *
   * @static
   * @method
   * @param {number} n - The first parameter.
   * @param {number} m - The second parameter.
   * @return {number} The Euclidean modulo.
   */
  euclideanModulo,
  /**
   * Performs a linear mapping from range `<a1, a2>` to range `<b1, b2>`
   * for the given value.
   *
   * @static
   * @method
   * @param {number} x - The value to be mapped.
   * @param {number} a1 - Minimum value for range A.
   * @param {number} a2 - Maximum value for range A.
   * @param {number} b1 - Minimum value for range B.
   * @param {number} b2 - Maximum value for range B.
   * @return {number} The mapped value.
   */
  mapLinear,
  /**
   * Returns the percentage in the closed interval `[0, 1]` of the given value
   * between the start and end point.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} value - A value between start and end.
   * @return {number} The interpolation factor.
   */
  inverseLerp,
  /**
   * Returns a value linearly interpolated from two known points based on the given interval -
   * `t = 0` will return `x` and `t = 1` will return `y`.
   *
   * @static
   * @method
   * @param {number} x - The start point
   * @param {number} y - The end point.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {number} The interpolated value.
   */
  lerp,
  /**
   * Smoothly interpolate a number from `x` to `y` in  a spring-like manner using a delta
   * time to maintain frame rate independent movement. For details, see
   * [Frame rate independent damping using lerp](http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/).
   *
   * @static
   * @method
   * @param {number} x - The current point.
   * @param {number} y - The target point.
   * @param {number} lambda - A higher lambda value will make the movement more sudden,
   * and a lower value will make the movement more gradual.
   * @param {number} dt - Delta time in seconds.
   * @return {number} The interpolated value.
   */
  damp,
  /**
   * Returns a value that alternates between `0` and the given `length` parameter.
   *
   * @static
   * @method
   * @param {number} x - The value to pingpong.
   * @param {number} [length=1] - The positive value the function will pingpong to.
   * @return {number} The alternated value.
   */
  pingpong,
  /**
   * Returns a value in the range `[0,1]` that represents the percentage that `x` has
   * moved between `min` and `max`, but smoothed or slowed down the closer `x` is to
   * the `min` and `max`.
   *
   * See [Smoothstep](http://en.wikipedia.org/wiki/Smoothstep) for more details.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smoothstep,
  /**
   * A [variation on smoothstep](https://en.wikipedia.org/wiki/Smoothstep#Variations)
   * that has zero 1st and 2nd order derivatives at x=0 and x=1.
   *
   * @static
   * @method
   * @param {number} x - The value to evaluate based on its position between min and max.
   * @param {number} min - The min value. Any x value below min will be `0`.
   * @param {number} max - The max value. Any x value above max will be `1`.
   * @return {number} The alternated value.
   */
  smootherstep,
  /**
   * Returns a random integer from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random integer.
   */
  randInt,
  /**
   * Returns a random float from `<low, high>` interval.
   *
   * @static
   * @method
   * @param {number} low - The lower value boundary.
   * @param {number} high - The upper value boundary
   * @return {number} A random float.
   */
  randFloat,
  /**
   * Returns a random integer from `<-range/2, range/2>` interval.
   *
   * @static
   * @method
   * @param {number} range - Defines the value range.
   * @return {number} A random float.
   */
  randFloatSpread,
  /**
   * Returns a deterministic pseudo-random float in the interval `[0, 1]`.
   *
   * @static
   * @method
   * @param {number} [s] - The integer seed.
   * @return {number} A random float.
   */
  seededRandom,
  /**
   * Converts degrees to radians.
   *
   * @static
   * @method
   * @param {number} degrees - A value in degrees.
   * @return {number} The converted value in radians.
   */
  degToRad,
  /**
   * Converts radians to degrees.
   *
   * @static
   * @method
   * @param {number} radians - A value in radians.
   * @return {number} The converted value in degrees.
   */
  radToDeg,
  /**
   * Returns `true` if the given number is a power of two.
   *
   * @static
   * @method
   * @param {number} value - The value to check.
   * @return {boolean} Whether the given number is a power of two or not.
   */
  isPowerOfTwo,
  /**
   * Returns the smallest power of two that is greater than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The smallest power of two that is greater than or equal to the given number.
   */
  ceilPowerOfTwo,
  /**
   * Returns the largest power of two that is less than or equal to the given number.
   *
   * @static
   * @method
   * @param {number} value - The value to find a POT for.
   * @return {number} The largest power of two that is less than or equal to the given number.
   */
  floorPowerOfTwo,
  /**
   * Sets the given quaternion from the [Intrinsic Proper Euler Angles](https://en.wikipedia.org/wiki/Euler_angles)
   * defined by the given angles and order.
   *
   * Rotations are applied to the axes in the order specified by order:
   * rotation by angle `a` is applied first, then by angle `b`, then by angle `c`.
   *
   * @static
   * @method
   * @param {Quaternion} q - The quaternion to set.
   * @param {number} a - The rotation applied to the first axis, in radians.
   * @param {number} b - The rotation applied to the second axis, in radians.
   * @param {number} c - The rotation applied to the third axis, in radians.
   * @param {('XYX'|'XZX'|'YXY'|'YZY'|'ZXZ'|'ZYZ')} order - A string specifying the axes order.
   */
  setQuaternionFromProperEuler,
  /**
   * Normalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The float value in the range `[0,1]` to normalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The normalize value.
   */
  normalize,
  /**
   * Denormalizes the given value according to the given typed array.
   *
   * @static
   * @method
   * @param {number} value - The value to denormalize.
   * @param {TypedArray} array - The typed array that defines the data type of the value.
   * @return {number} The denormalize (float) value in the range `[0,1]`.
   */
  denormalize
};
var Vector2 = class _Vector2 {
  /**
   * Constructs a new 2D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   */
  constructor(x2 = 0, y2 = 0) {
    _Vector2.prototype.isVector2 = true;
    this.x = x2;
    this.y = y2;
  }
  /**
   * Alias for {@link Vector2#x}.
   *
   * @type {number}
   */
  get width() {
    return this.x;
  }
  set width(value) {
    this.x = value;
  }
  /**
   * Alias for {@link Vector2#y}.
   *
   * @type {number}
   */
  get height() {
    return this.y;
  }
  set height(value) {
    this.y = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @return {Vector2} A reference to this vector.
   */
  set(x2, y2) {
    this.x = x2;
    this.y = y2;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector2} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setX(x2) {
    this.x = x2;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setY(y2) {
    this.y = y2;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @param {number} value - The value to set.
   * @return {Vector2} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector2} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector2} v - The vector to copy.
   * @return {Vector2} A reference to this vector.
   */
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector2} v - The vector to add.
   * @return {Vector2} A reference to this vector.
   */
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector2} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector2} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector2} A reference to this vector.
   */
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector2} v - The vector to subtract.
   * @return {Vector2} A reference to this vector.
   */
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector2} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector2} a - The first vector.
   * @param {Vector2} b - The second vector.
   * @return {Vector2} A reference to this vector.
   */
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector2} v - The vector to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector2} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector2} v - The vector to divide.
   * @return {Vector2} A reference to this vector.
   */
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector2} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Multiplies this vector (with an implicit 1 as the 3rd component) by
   * the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {Vector2} A reference to this vector.
   */
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6];
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7];
    return this;
  }
  /**
   * If this vector's x or y value is greater than the given vector's x or y
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    return this;
  }
  /**
   * If this vector's x or y value is less than the given vector's x or y
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector2} v - The vector.
   * @return {Vector2} A reference to this vector.
   */
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    return this;
  }
  /**
   * If this vector's x or y value is greater than the max vector's x or y
   * value, it is replaced by the corresponding value.
   * If this vector's x or y value is less than the min vector's x or y value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector2} min - The minimum x and y values.
   * @param {Vector2} max - The maximum x and y values in the desired range.
   * @return {Vector2} A reference to this vector.
   */
  clamp(min, max) {
    this.x = clamp(this.x, min.x, max.x);
    this.y = clamp(this.y, min.y, max.y);
    return this;
  }
  /**
   * If this vector's x or y values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x or y values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp(this.x, minVal, maxVal);
    this.y = clamp(this.y, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector2} A reference to this vector.
   */
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector2} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector2} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x and y = -y.
   *
   * @return {Vector2} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v2) {
    return this.x * v2.x + this.y * v2.y;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector2} v - The vector to compute the cross product with.
   * @return {number} The result of the cross product.
   */
  cross(v2) {
    return this.x * v2.y - this.y * v2.x;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0) to (x, y). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0) to (x, y).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Computes the angle in radians of this vector with respect to the positive x-axis.
   *
   * @return {number} The angle in radians.
   */
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI;
    return angle;
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector2} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector2} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y;
    return dx * dx + dy * dy;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector2} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector2} A reference to this vector.
   */
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector2} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector2} v1 - The first vector.
   * @param {Vector2} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector2} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector2} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v2) {
    return v2.x === this.x && v2.y === this.y;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]` and y
   * value to be `array[ offset + 1 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector2} A reference to this vector.
   */
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    return array;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector2} A reference to this vector.
   */
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    return this;
  }
  /**
   * Rotates this vector around the given center by the given angle.
   *
   * @param {Vector2} center - The point around which to rotate.
   * @param {number} angle - The angle to rotate, in radians.
   * @return {Vector2} A reference to this vector.
   */
  rotateAround(center, angle) {
    const c2 = Math.cos(angle), s2 = Math.sin(angle);
    const x2 = this.x - center.x;
    const y2 = this.y - center.y;
    this.x = x2 * c2 - y2 * s2 + center.x;
    this.y = x2 * s2 + y2 * c2 + center.y;
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector2} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
  }
};
var Quaternion = class {
  /**
   * Constructs a new quaternion.
   *
   * @param {number} [x=0] - The x value of this quaternion.
   * @param {number} [y=0] - The y value of this quaternion.
   * @param {number} [z=0] - The z value of this quaternion.
   * @param {number} [w=1] - The w value of this quaternion.
   */
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    this.isQuaternion = true;
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
  }
  /**
   * Interpolates between two quaternions via SLERP. This implementation assumes the
   * quaternion data are managed in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @param {number} t - The interpolation factor in the range `[0,1]`.
   * @see {@link Quaternion#slerp}
   */
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t2) {
    let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];
    let x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];
    if (t2 <= 0) {
      dst[dstOffset + 0] = x0;
      dst[dstOffset + 1] = y0;
      dst[dstOffset + 2] = z0;
      dst[dstOffset + 3] = w0;
      return;
    }
    if (t2 >= 1) {
      dst[dstOffset + 0] = x1;
      dst[dstOffset + 1] = y1;
      dst[dstOffset + 2] = z1;
      dst[dstOffset + 3] = w1;
      return;
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let dot = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1;
      if (dot < 0) {
        x1 = -x1;
        y1 = -y1;
        z1 = -z1;
        w1 = -w1;
        dot = -dot;
      }
      let s2 = 1 - t2;
      if (dot < 0.9995) {
        const theta = Math.acos(dot);
        const sin = Math.sin(theta);
        s2 = Math.sin(s2 * theta) / sin;
        t2 = Math.sin(t2 * theta) / sin;
        x0 = x0 * s2 + x1 * t2;
        y0 = y0 * s2 + y1 * t2;
        z0 = z0 * s2 + z1 * t2;
        w0 = w0 * s2 + w1 * t2;
      } else {
        x0 = x0 * s2 + x1 * t2;
        y0 = y0 * s2 + y1 * t2;
        z0 = z0 * s2 + z1 * t2;
        w0 = w0 * s2 + w1 * t2;
        const f2 = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
        x0 *= f2;
        y0 *= f2;
        z0 *= f2;
        w0 *= f2;
      }
    }
    dst[dstOffset] = x0;
    dst[dstOffset + 1] = y0;
    dst[dstOffset + 2] = z0;
    dst[dstOffset + 3] = w0;
  }
  /**
   * Multiplies two quaternions. This implementation assumes the quaternion data are managed
   * in flat arrays.
   *
   * @param {Array<number>} dst - The destination array.
   * @param {number} dstOffset - An offset into the destination array.
   * @param {Array<number>} src0 - The source array of the first quaternion.
   * @param {number} srcOffset0 - An offset into the first source array.
   * @param {Array<number>} src1 -  The source array of the second quaternion.
   * @param {number} srcOffset1 - An offset into the second source array.
   * @return {Array<number>} The destination array.
   * @see {@link Quaternion#multiplyQuaternions}.
   */
  static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
    const x0 = src0[srcOffset0];
    const y0 = src0[srcOffset0 + 1];
    const z0 = src0[srcOffset0 + 2];
    const w0 = src0[srcOffset0 + 3];
    const x1 = src1[srcOffset1];
    const y1 = src1[srcOffset1 + 1];
    const z1 = src1[srcOffset1 + 2];
    const w1 = src1[srcOffset1 + 3];
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
    return dst;
  }
  /**
   * The x value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The y value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The z value of this quaternion.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * The w value of this quaternion.
   *
   * @type {number}
   * @default 1
   */
  get w() {
    return this._w;
  }
  set w(value) {
    this._w = value;
    this._onChangeCallback();
  }
  /**
   * Sets the quaternion components.
   *
   * @param {number} x - The x value of this quaternion.
   * @param {number} y - The y value of this quaternion.
   * @param {number} z - The z value of this quaternion.
   * @param {number} w - The w value of this quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  set(x2, y2, z2, w2) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._w = w2;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new quaternion with copied values from this instance.
   *
   * @return {Quaternion} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  /**
   * Copies the values of the given quaternion to this instance.
   *
   * @param {Quaternion} quaternion - The quaternion to copy.
   * @return {Quaternion} A reference to this quaternion.
   */
  copy(quaternion) {
    this._x = quaternion.x;
    this._y = quaternion.y;
    this._z = quaternion.z;
    this._w = quaternion.w;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the rotation specified by the given
   * Euler angles.
   *
   * @param {Euler} euler - The Euler angles.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromEuler(euler, update = true) {
    const x2 = euler._x, y2 = euler._y, z2 = euler._z, order = euler._order;
    const cos = Math.cos;
    const sin = Math.sin;
    const c1 = cos(x2 / 2);
    const c2 = cos(y2 / 2);
    const c3 = cos(z2 / 2);
    const s1 = sin(x2 / 2);
    const s2 = sin(y2 / 2);
    const s3 = sin(z2 / 2);
    switch (order) {
      case "XYZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "YXZ":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "ZXY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "ZYX":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      case "YZX":
        this._x = s1 * c2 * c3 + c1 * s2 * s3;
        this._y = c1 * s2 * c3 + s1 * c2 * s3;
        this._z = c1 * c2 * s3 - s1 * s2 * c3;
        this._w = c1 * c2 * c3 - s1 * s2 * s3;
        break;
      case "XZY":
        this._x = s1 * c2 * c3 - c1 * s2 * s3;
        this._y = c1 * s2 * c3 - s1 * c2 * s3;
        this._z = c1 * c2 * s3 + s1 * s2 * c3;
        this._w = c1 * c2 * c3 + s1 * s2 * s3;
        break;
      default:
        warn("Quaternion: .setFromEuler() encountered an unknown order: " + order);
    }
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given axis and angle.
   *
   * @param {Vector3} axis - The normalized axis.
   * @param {number} angle - The angle in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2, s2 = Math.sin(halfAngle);
    this._x = axis.x * s2;
    this._y = axis.y * s2;
    this._z = axis.z * s2;
    this._w = Math.cos(halfAngle);
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion from the given rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromRotationMatrix(m2) {
    const te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10], trace = m11 + m22 + m33;
    if (trace > 0) {
      const s2 = 0.5 / Math.sqrt(trace + 1);
      this._w = 0.25 / s2;
      this._x = (m32 - m23) * s2;
      this._y = (m13 - m31) * s2;
      this._z = (m21 - m12) * s2;
    } else if (m11 > m22 && m11 > m33) {
      const s2 = 2 * Math.sqrt(1 + m11 - m22 - m33);
      this._w = (m32 - m23) / s2;
      this._x = 0.25 * s2;
      this._y = (m12 + m21) / s2;
      this._z = (m13 + m31) / s2;
    } else if (m22 > m33) {
      const s2 = 2 * Math.sqrt(1 + m22 - m11 - m33);
      this._w = (m13 - m31) / s2;
      this._x = (m12 + m21) / s2;
      this._y = 0.25 * s2;
      this._z = (m23 + m32) / s2;
    } else {
      const s2 = 2 * Math.sqrt(1 + m33 - m11 - m22);
      this._w = (m21 - m12) / s2;
      this._x = (m13 + m31) / s2;
      this._y = (m23 + m32) / s2;
      this._z = 0.25 * s2;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets this quaternion to the rotation required to rotate the direction vector
   * `vFrom` to the direction vector `vTo`.
   *
   * @param {Vector3} vFrom - The first (normalized) direction vector.
   * @param {Vector3} vTo - The second (normalized) direction vector.
   * @return {Quaternion} A reference to this quaternion.
   */
  setFromUnitVectors(vFrom, vTo) {
    let r2 = vFrom.dot(vTo) + 1;
    if (r2 < 1e-8) {
      r2 = 0;
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y;
        this._y = vFrom.x;
        this._z = 0;
        this._w = r2;
      } else {
        this._x = 0;
        this._y = -vFrom.z;
        this._z = vFrom.y;
        this._w = r2;
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
      this._w = r2;
    }
    return this.normalize();
  }
  /**
   * Returns the angle between this quaternion and the given one in radians.
   *
   * @param {Quaternion} q - The quaternion to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(q2) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q2), -1, 1)));
  }
  /**
   * Rotates this quaternion by a given angular step to the given quaternion.
   * The method ensures that the final quaternion will not overshoot `q`.
   *
   * @param {Quaternion} q - The target quaternion.
   * @param {number} step - The angular step in radians.
   * @return {Quaternion} A reference to this quaternion.
   */
  rotateTowards(q2, step) {
    const angle = this.angleTo(q2);
    if (angle === 0) return this;
    const t2 = Math.min(1, step / angle);
    this.slerp(q2, t2);
    return this;
  }
  /**
   * Sets this quaternion to the identity quaternion; that is, to the
   * quaternion that represents "no rotation".
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  identity() {
    return this.set(0, 0, 0, 1);
  }
  /**
   * Inverts this quaternion via {@link Quaternion#conjugate}. The
   * quaternion is assumed to have unit length.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  invert() {
    return this.conjugate();
  }
  /**
   * Returns the rotational conjugate of this quaternion. The conjugate of a
   * quaternion represents the same rotation in the opposite direction about
   * the rotational axis.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  conjugate() {
    this._x *= -1;
    this._y *= -1;
    this._z *= -1;
    this._onChangeCallback();
    return this;
  }
  /**
   * Calculates the dot product of this quaternion and the given one.
   *
   * @param {Quaternion} v - The quaternion to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v2) {
    return this._x * v2._x + this._y * v2._y + this._z * v2._z + this._w * v2._w;
  }
  /**
   * Computes the squared Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector. This can be useful if you are comparing the
   * lengths of two quaternions, as this is a slightly more efficient calculation than
   * {@link Quaternion#length}.
   *
   * @return {number} The squared Euclidean length.
   */
  lengthSq() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  /**
   * Computes the Euclidean length (straight-line length) of this quaternion,
   * considered as a 4 dimensional vector.
   *
   * @return {number} The Euclidean length.
   */
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
  }
  /**
   * Normalizes this quaternion - that is, calculated the quaternion that performs
   * the same rotation as this one, but has a length equal to `1`.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  normalize() {
    let l2 = this.length();
    if (l2 === 0) {
      this._x = 0;
      this._y = 0;
      this._z = 0;
      this._w = 1;
    } else {
      l2 = 1 / l2;
      this._x = this._x * l2;
      this._y = this._y * l2;
      this._z = this._z * l2;
      this._w = this._w * l2;
    }
    this._onChangeCallback();
    return this;
  }
  /**
   * Multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiply(q2) {
    return this.multiplyQuaternions(this, q2);
  }
  /**
   * Pre-multiplies this quaternion by the given one.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  premultiply(q2) {
    return this.multiplyQuaternions(q2, this);
  }
  /**
   * Multiplies the given quaternions and stores the result in this instance.
   *
   * @param {Quaternion} a - The first quaternion.
   * @param {Quaternion} b - The second quaternion.
   * @return {Quaternion} A reference to this quaternion.
   */
  multiplyQuaternions(a2, b2) {
    const qax = a2._x, qay = a2._y, qaz = a2._z, qaw = a2._w;
    const qbx = b2._x, qby = b2._y, qbz = b2._z, qbw = b2._w;
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
    this._onChangeCallback();
    return this;
  }
  /**
   * Performs a spherical linear interpolation between quaternions.
   *
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerp(qb, t2) {
    if (t2 <= 0) return this;
    if (t2 >= 1) return this.copy(qb);
    let x2 = qb._x, y2 = qb._y, z2 = qb._z, w2 = qb._w;
    let dot = this.dot(qb);
    if (dot < 0) {
      x2 = -x2;
      y2 = -y2;
      z2 = -z2;
      w2 = -w2;
      dot = -dot;
    }
    let s2 = 1 - t2;
    if (dot < 0.9995) {
      const theta = Math.acos(dot);
      const sin = Math.sin(theta);
      s2 = Math.sin(s2 * theta) / sin;
      t2 = Math.sin(t2 * theta) / sin;
      this._x = this._x * s2 + x2 * t2;
      this._y = this._y * s2 + y2 * t2;
      this._z = this._z * s2 + z2 * t2;
      this._w = this._w * s2 + w2 * t2;
      this._onChangeCallback();
    } else {
      this._x = this._x * s2 + x2 * t2;
      this._y = this._y * s2 + y2 * t2;
      this._z = this._z * s2 + z2 * t2;
      this._w = this._w * s2 + w2 * t2;
      this.normalize();
    }
    return this;
  }
  /**
   * Performs a spherical linear interpolation between the given quaternions
   * and stores the result in this quaternion.
   *
   * @param {Quaternion} qa - The source quaternion.
   * @param {Quaternion} qb - The target quaternion.
   * @param {number} t - The interpolation factor in the closed interval `[0, 1]`.
   * @return {Quaternion} A reference to this quaternion.
   */
  slerpQuaternions(qa2, qb, t2) {
    return this.copy(qa2).slerp(qb, t2);
  }
  /**
   * Sets this quaternion to a uniformly random, normalized quaternion.
   *
   * @return {Quaternion} A reference to this quaternion.
   */
  random() {
    const theta1 = 2 * Math.PI * Math.random();
    const theta2 = 2 * Math.PI * Math.random();
    const x0 = Math.random();
    const r1 = Math.sqrt(1 - x0);
    const r2 = Math.sqrt(x0);
    return this.set(
      r1 * Math.sin(theta1),
      r1 * Math.cos(theta1),
      r2 * Math.sin(theta2),
      r2 * Math.cos(theta2)
    );
  }
  /**
   * Returns `true` if this quaternion is equal with the given one.
   *
   * @param {Quaternion} quaternion - The quaternion to test for equality.
   * @return {boolean} Whether this quaternion is equal with the given one.
   */
  equals(quaternion) {
    return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
  }
  /**
   * Sets this quaternion's components from the given array.
   *
   * @param {Array<number>} array - An array holding the quaternion component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromArray(array, offset = 0) {
    this._x = array[offset];
    this._y = array[offset + 1];
    this._z = array[offset + 2];
    this._w = array[offset + 3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this quaternion to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the quaternion components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The quaternion components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._w;
    return array;
  }
  /**
   * Sets the components of this quaternion from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding quaternion data.
   * @param {number} index - The index into the attribute.
   * @return {Quaternion} A reference to this quaternion.
   */
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index);
    this._y = attribute.getY(index);
    this._z = attribute.getZ(index);
    this._w = attribute.getW(index);
    this._onChangeCallback();
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the
   * numerical elements of this quaternion in an array of format `[x, y, z, w]`.
   *
   * @return {Array<number>} The serialized quaternion.
   */
  toJSON() {
    return this.toArray();
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._w;
  }
};
var Vector3 = class _Vector3 {
  /**
   * Constructs a new 3D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   */
  constructor(x2 = 0, y2 = 0, z2 = 0) {
    _Vector3.prototype.isVector3 = true;
    this.x = x2;
    this.y = y2;
    this.z = z2;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @return {Vector3} A reference to this vector.
   */
  set(x2, y2, z2) {
    if (z2 === void 0) z2 = this.z;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector3} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setX(x2) {
    this.x = x2;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setY(y2) {
    this.y = y2;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setZ(z2) {
    this.z = z2;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @param {number} value - The value to set.
   * @return {Vector3} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y, `2` equals to z.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector3} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3} v - The vector to copy.
   * @return {Vector3} A reference to this vector.
   */
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector3} v - The vector to add.
   * @return {Vector3} A reference to this vector.
   */
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector3} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector3|Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector3} A reference to this vector.
   */
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector3} v - The vector to subtract.
   * @return {Vector3} A reference to this vector.
   */
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector3} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector3} v - The vector to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector3} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    return this;
  }
  /**
   * Multiplies the given vectors and stores the result in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  multiplyVectors(a2, b2) {
    this.x = a2.x * b2.x;
    this.y = a2.y * b2.y;
    this.z = a2.z * b2.z;
    return this;
  }
  /**
   * Applies the given Euler rotation to this vector.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Vector3} A reference to this vector.
   */
  applyEuler(euler) {
    return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
  }
  /**
   * Applies a rotation specified by an axis and an angle to this vector.
   *
   * @param {Vector3} axis - A normalized vector representing the rotation axis.
   * @param {number} angle - The angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
  }
  /**
   * Multiplies this vector with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix3(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[3] * y2 + e2[6] * z2;
    this.y = e2[1] * x2 + e2[4] * y2 + e2[7] * z2;
    this.z = e2[2] * x2 + e2[5] * y2 + e2[8] * z2;
    return this;
  }
  /**
   * Multiplies this vector by the given normal matrix and normalizes
   * the result.
   *
   * @param {Matrix3} m - The normal matrix.
   * @return {Vector3} A reference to this vector.
   */
  applyNormalMatrix(m2) {
    return this.applyMatrix3(m2).normalize();
  }
  /**
   * Multiplies this vector (with an implicit 1 in the 4th dimension) by m, and
   * divides by perspective.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {Vector3} A reference to this vector.
   */
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    const w2 = 1 / (e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15]);
    this.x = (e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12]) * w2;
    this.y = (e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13]) * w2;
    this.z = (e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14]) * w2;
    return this;
  }
  /**
   * Applies the given Quaternion to this vector.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Vector3} A reference to this vector.
   */
  applyQuaternion(q2) {
    const vx = this.x, vy = this.y, vz = this.z;
    const qx = q2.x, qy = q2.y, qz = q2.z, qw = q2.w;
    const tx = 2 * (qy * vz - qz * vy);
    const ty = 2 * (qz * vx - qx * vz);
    const tz = 2 * (qx * vy - qy * vx);
    this.x = vx + qw * tx + qy * tz - qz * ty;
    this.y = vy + qw * ty + qz * tx - qx * tz;
    this.z = vz + qw * tz + qx * ty - qy * tx;
    return this;
  }
  /**
   * Projects this vector from world space into the camera's normalized
   * device coordinate (NDC) space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
  }
  /**
   * Unprojects this vector from the camera's normalized device coordinate (NDC)
   * space into world space.
   *
   * @param {Camera} camera - The camera.
   * @return {Vector3} A reference to this vector.
   */
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
  }
  /**
   * Transforms the direction of this vector by a matrix (the upper left 3 x 3
   * subset of the given 4x4 matrix and then normalizes the result.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Vector3} A reference to this vector.
   */
  transformDirection(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2;
    return this.normalize();
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector3} v - The vector to divide.
   * @return {Vector3} A reference to this vector.
   */
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector3} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * If this vector's x, y or z value is greater than the given vector's x, y or z
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is less than the given vector's x, y or z
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector3} v - The vector.
   * @return {Vector3} A reference to this vector.
   */
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    return this;
  }
  /**
   * If this vector's x, y or z value is greater than the max vector's x, y or z
   * value, it is replaced by the corresponding value.
   * If this vector's x, y or z value is less than the min vector's x, y or z value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector3} min - The minimum x, y and z values.
   * @param {Vector3} max - The maximum x, y and z values in the desired range.
   * @return {Vector3} A reference to this vector.
   */
  clamp(min, max) {
    this.x = clamp(this.x, min.x, max.x);
    this.y = clamp(this.y, min.y, max.y);
    this.z = clamp(this.z, min.z, max.z);
    return this;
  }
  /**
   * If this vector's x, y or z values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y or z values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp(this.x, minVal, maxVal);
    this.y = clamp(this.y, minVal, maxVal);
    this.z = clamp(this.z, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector3} A reference to this vector.
   */
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector3} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector3} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y and z = -z.
   *
   * @return {Vector3} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0) to (x, y, z). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0) to (x, y, z).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector3} A reference to this vector.
   */
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector3} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector3} v1 - The first vector.
   * @param {Vector3} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector3} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    return this;
  }
  /**
   * Calculates the cross product of the given vector with this instance.
   *
   * @param {Vector3} v - The vector to compute the cross product with.
   * @return {Vector3} The result of the cross product.
   */
  cross(v2) {
    return this.crossVectors(this, v2);
  }
  /**
   * Calculates the cross product of the given vectors and stores the result
   * in this instance.
   *
   * @param {Vector3} a - The first vector.
   * @param {Vector3} b - The second vector.
   * @return {Vector3} A reference to this vector.
   */
  crossVectors(a2, b2) {
    const ax = a2.x, ay = a2.y, az = a2.z;
    const bx = b2.x, by = b2.y, bz = b2.z;
    this.x = ay * bz - az * by;
    this.y = az * bx - ax * bz;
    this.z = ax * by - ay * bx;
    return this;
  }
  /**
   * Projects this vector onto the given one.
   *
   * @param {Vector3} v - The vector to project to.
   * @return {Vector3} A reference to this vector.
   */
  projectOnVector(v2) {
    const denominator = v2.lengthSq();
    if (denominator === 0) return this.set(0, 0, 0);
    const scalar = v2.dot(this) / denominator;
    return this.copy(v2).multiplyScalar(scalar);
  }
  /**
   * Projects this vector onto a plane by subtracting this
   * vector projected onto the plane's normal from this vector.
   *
   * @param {Vector3} planeNormal - The plane normal.
   * @return {Vector3} A reference to this vector.
   */
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal);
    return this.sub(_vector$c);
  }
  /**
   * Reflects this vector off a plane orthogonal to the given normal vector.
   *
   * @param {Vector3} normal - The (normalized) normal vector.
   * @return {Vector3} A reference to this vector.
   */
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
  }
  /**
   * Returns the angle between the given vector and this instance in radians.
   *
   * @param {Vector3} v - The vector to compute the angle with.
   * @return {number} The angle in radians.
   */
  angleTo(v2) {
    const denominator = Math.sqrt(this.lengthSq() * v2.lengthSq());
    if (denominator === 0) return Math.PI / 2;
    const theta = this.dot(v2) / denominator;
    return Math.acos(clamp(theta, -1, 1));
  }
  /**
   * Computes the distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the distance to.
   * @return {number} The distance.
   */
  distanceTo(v2) {
    return Math.sqrt(this.distanceToSquared(v2));
  }
  /**
   * Computes the squared distance from the given vector to this instance.
   * If you are just comparing the distance with another distance, you should compare
   * the distance squared instead as it is slightly more efficient to calculate.
   *
   * @param {Vector3} v - The vector to compute the squared distance to.
   * @return {number} The squared distance.
   */
  distanceToSquared(v2) {
    const dx = this.x - v2.x, dy = this.y - v2.y, dz = this.z - v2.z;
    return dx * dx + dy * dy + dz * dz;
  }
  /**
   * Computes the Manhattan distance from the given vector to this instance.
   *
   * @param {Vector3} v - The vector to compute the Manhattan distance to.
   * @return {number} The Manhattan distance.
   */
  manhattanDistanceTo(v2) {
    return Math.abs(this.x - v2.x) + Math.abs(this.y - v2.y) + Math.abs(this.z - v2.z);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {Spherical} s - The spherical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromSpherical(s2) {
    return this.setFromSphericalCoords(s2.radius, s2.phi, s2.theta);
  }
  /**
   * Sets the vector components from the given spherical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} phi - The phi angle in radians.
   * @param {number} theta - The theta angle in radians.
   * @return {Vector3} A reference to this vector.
   */
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius;
    this.x = sinPhiRadius * Math.sin(theta);
    this.y = Math.cos(phi) * radius;
    this.z = sinPhiRadius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {Cylindrical} c - The cylindrical coordinates.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindrical(c2) {
    return this.setFromCylindricalCoords(c2.radius, c2.theta, c2.y);
  }
  /**
   * Sets the vector components from the given cylindrical coordinates.
   *
   * @param {number} radius - The radius.
   * @param {number} theta - The theta angle in radians.
   * @param {number} y - The y value.
   * @return {Vector3} A reference to this vector.
   */
  setFromCylindricalCoords(radius, theta, y2) {
    this.x = radius * Math.sin(theta);
    this.y = y2;
    this.z = radius * Math.cos(theta);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    return this;
  }
  /**
   * Sets the vector components to the scale elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixScale(m2) {
    const sx = this.setFromMatrixColumn(m2, 0).length();
    const sy = this.setFromMatrixColumn(m2, 1).length();
    const sz = this.setFromMatrixColumn(m2, 2).length();
    this.x = sx;
    this.y = sy;
    this.z = sz;
    return this;
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrixColumn(m2, index) {
    return this.fromArray(m2.elements, index * 4);
  }
  /**
   * Sets the vector components from the specified matrix column.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @param {number} index - The column index.
   * @return {Vector3} A reference to this vector.
   */
  setFromMatrix3Column(m2, index) {
    return this.fromArray(m2.elements, index * 3);
  }
  /**
   * Sets the vector components from the given Euler angles.
   *
   * @param {Euler} e - The Euler angles to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromEuler(e2) {
    this.x = e2._x;
    this.y = e2._y;
    this.z = e2._z;
    return this;
  }
  /**
   * Sets the vector components from the RGB components of the
   * given color.
   *
   * @param {Color} c - The color to set.
   * @return {Vector3} A reference to this vector.
   */
  setFromColor(c2) {
    this.x = c2.r;
    this.y = c2.g;
    this.z = c2.b;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector3} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`
   * and z value to be `array[ offset + 2 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector3} A reference to this vector.
   */
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    return array;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector3} A reference to this vector.
   */
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector3} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    return this;
  }
  /**
   * Sets this vector to a uniformly random point on a unit sphere.
   *
   * @return {Vector3} A reference to this vector.
   */
  randomDirection() {
    const theta = Math.random() * Math.PI * 2;
    const u2 = Math.random() * 2 - 1;
    const c2 = Math.sqrt(1 - u2 * u2);
    this.x = c2 * Math.cos(theta);
    this.y = u2;
    this.z = c2 * Math.sin(theta);
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
  }
};
var _vector$c = /* @__PURE__ */ new Vector3();
var _quaternion$4 = /* @__PURE__ */ new Quaternion();
var Matrix3 = class _Matrix3 {
  /**
   * Constructs a new 3x3 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   */
  constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    _Matrix3.prototype.isMatrix3 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @return {Matrix3} A reference to this matrix.
   */
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[1] = n21;
    te2[2] = n31;
    te2[3] = n12;
    te2[4] = n22;
    te2[5] = n32;
    te2[6] = n13;
    te2[7] = n23;
    te2[8] = n33;
    return this;
  }
  /**
   * Sets this matrix to the 3x3 identity matrix.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix3} m - The matrix to copy.
   * @return {Matrix3} A reference to this matrix.
   */
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix3} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0);
    yAxis.setFromMatrix3Column(this, 1);
    zAxis.setFromMatrix3Column(this, 2);
    return this;
  }
  /**
   * Set this matrix to the upper 3x3 matrix of the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  setFromMatrix4(m2) {
    const me2 = m2.elements;
    this.set(
      me2[0],
      me2[4],
      me2[8],
      me2[1],
      me2[5],
      me2[9],
      me2[2],
      me2[6],
      me2[10]
    );
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  /**
   * Pre-multiplies this matrix by the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix to multiply with.
   * @return {Matrix3} A reference to this matrix.
   */
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  /**
   * Multiples the given 3x3 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix3} a - The first matrix.
   * @param {Matrix3} b - The second matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[3], a13 = ae2[6];
    const a21 = ae2[1], a22 = ae2[4], a23 = ae2[7];
    const a31 = ae2[2], a32 = ae2[5], a33 = ae2[8];
    const b11 = be2[0], b12 = be2[3], b13 = be2[6];
    const b21 = be2[1], b22 = be2[4], b23 = be2[7];
    const b31 = be2[2], b32 = be2[5], b33 = be2[8];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31;
    te2[3] = a11 * b12 + a12 * b22 + a13 * b32;
    te2[6] = a11 * b13 + a12 * b23 + a13 * b33;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31;
    te2[4] = a21 * b12 + a22 * b22 + a23 * b32;
    te2[7] = a21 * b13 + a22 * b23 + a23 * b33;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31;
    te2[5] = a31 * b12 + a32 * b22 + a33 * b32;
    te2[8] = a31 * b13 + a32 * b23 + a33 * b33;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix3} A reference to this matrix.
   */
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[3] *= s2;
    te2[6] *= s2;
    te2[1] *= s2;
    te2[4] *= s2;
    te2[7] *= s2;
    te2[2] *= s2;
    te2[5] *= s2;
    te2[8] *= s2;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te2 = this.elements;
    const a2 = te2[0], b2 = te2[1], c2 = te2[2], d2 = te2[3], e2 = te2[4], f2 = te2[5], g2 = te2[6], h2 = te2[7], i2 = te2[8];
    return a2 * e2 * i2 - a2 * f2 * h2 - b2 * d2 * i2 + b2 * f2 * g2 + c2 * d2 * h2 - c2 * e2 * g2;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n12 = te2[3], n22 = te2[4], n32 = te2[5], n13 = te2[6], n23 = te2[7], n33 = te2[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n31 * n23 - n33 * n21) * detInv;
    te2[2] = (n32 * n21 - n31 * n22) * detInv;
    te2[3] = t12 * detInv;
    te2[4] = (n33 * n11 - n31 * n13) * detInv;
    te2[5] = (n31 * n12 - n32 * n11) * detInv;
    te2[6] = t13 * detInv;
    te2[7] = (n21 * n13 - n23 * n11) * detInv;
    te2[8] = (n22 * n11 - n21 * n12) * detInv;
    return this;
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix3} A reference to this matrix.
   */
  transpose() {
    let tmp;
    const m2 = this.elements;
    tmp = m2[1];
    m2[1] = m2[3];
    m2[3] = tmp;
    tmp = m2[2];
    m2[2] = m2[6];
    m2[6] = tmp;
    tmp = m2[5];
    m2[5] = m2[7];
    m2[7] = tmp;
    return this;
  }
  /**
   * Computes the normal matrix which is the inverse transpose of the upper
   * left 3x3 portion of the given 4x4 matrix.
   *
   * @param {Matrix4} matrix4 - The 4x4 matrix.
   * @return {Matrix3} A reference to this matrix.
   */
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose();
  }
  /**
   * Transposes this matrix into the supplied array, and returns itself unchanged.
   *
   * @param {Array<number>} r - An array to store the transposed matrix elements.
   * @return {Matrix3} A reference to this matrix.
   */
  transposeIntoArray(r2) {
    const m2 = this.elements;
    r2[0] = m2[0];
    r2[1] = m2[3];
    r2[2] = m2[6];
    r2[3] = m2[1];
    r2[4] = m2[4];
    r2[5] = m2[7];
    r2[6] = m2[2];
    r2[7] = m2[5];
    r2[8] = m2[8];
    return this;
  }
  /**
   * Sets the UV transform matrix from offset, repeat, rotation, and center.
   *
   * @param {number} tx - Offset x.
   * @param {number} ty - Offset y.
   * @param {number} sx - Repeat x.
   * @param {number} sy - Repeat y.
   * @param {number} rotation - Rotation, in radians. Positive values rotate counterclockwise.
   * @param {number} cx - Center x of rotation.
   * @param {number} cy - Center y of rotation
   * @return {Matrix3} A reference to this matrix.
   */
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c2 = Math.cos(rotation);
    const s2 = Math.sin(rotation);
    this.set(
      sx * c2,
      sx * s2,
      -sx * (c2 * cx + s2 * cy) + cx + tx,
      -sy * s2,
      sy * c2,
      -sy * (-s2 * cx + c2 * cy) + cy + ty,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Scales this matrix with the given scalar values.
   *
   * @param {number} sx - The amount to scale in the X axis.
   * @param {number} sy - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  scale(sx, sy) {
    this.premultiply(_m3.makeScale(sx, sy));
    return this;
  }
  /**
   * Rotates this matrix by the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  rotate(theta) {
    this.premultiply(_m3.makeRotation(-theta));
    return this;
  }
  /**
   * Translates this matrix by the given scalar values.
   *
   * @param {number} tx - The amount to translate in the X axis.
   * @param {number} ty - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  translate(tx, ty) {
    this.premultiply(_m3.makeTranslation(tx, ty));
    return this;
  }
  // for 2D Transforms
  /**
   * Sets this matrix as a 2D translation transform.
   *
   * @param {number|Vector2} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeTranslation(x2, y2) {
    if (x2.isVector2) {
      this.set(
        1,
        0,
        x2.x,
        0,
        1,
        x2.y,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        x2,
        0,
        1,
        y2,
        0,
        0,
        1
      );
    }
    return this;
  }
  /**
   * Sets this matrix as a 2D rotational transformation.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix3} A reference to this matrix.
   */
  makeRotation(theta) {
    const c2 = Math.cos(theta);
    const s2 = Math.sin(theta);
    this.set(
      c2,
      -s2,
      0,
      s2,
      c2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a 2D scale transform.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @return {Matrix3} A reference to this matrix.
   */
  makeScale(x2, y2) {
    this.set(
      x2,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix3} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 9; i2++) {
      if (te2[i2] !== me2[i2]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix3} A reference to this matrix.
   */
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 9; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    return array;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix3} A clone of this instance.
   */
  clone() {
    return new this.constructor().fromArray(this.elements);
  }
};
var _m3 = /* @__PURE__ */ new Matrix3();
var LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(
  0.4123908,
  0.3575843,
  0.1804808,
  0.212639,
  0.7151687,
  0.0721923,
  0.0193308,
  0.1191948,
  0.9505322
);
var XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(
  3.2409699,
  -1.5373832,
  -0.4986108,
  -0.9692436,
  1.8759675,
  0.0415551,
  0.0556301,
  -0.203977,
  1.0569715
);
function createColorManagement() {
  const ColorManagement2 = {
    enabled: true,
    workingColorSpace: LinearSRGBColorSpace,
    /**
     * Implementations of supported color spaces.
     *
     * Required:
     *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
     *	- whitePoint: reference white [ x y ]
     *	- transfer: transfer function (pre-defined)
     *	- toXYZ: Matrix3 RGB to XYZ transform
     *	- fromXYZ: Matrix3 XYZ to RGB transform
     *	- luminanceCoefficients: RGB luminance coefficients
     *
     * Optional:
     *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace, toneMappingMode: 'extended' | 'standard' }
     *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
     *
     * Reference:
     * - https://www.russellcottrell.com/photo/matrixCalculator.htm
     */
    spaces: {},
    convert: function(color, sourceColorSpace, targetColorSpace) {
      if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
        return color;
      }
      if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
        color.r = SRGBToLinear(color.r);
        color.g = SRGBToLinear(color.g);
        color.b = SRGBToLinear(color.b);
      }
      if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
        color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
        color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
      }
      if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
        color.r = LinearToSRGB(color.r);
        color.g = LinearToSRGB(color.g);
        color.b = LinearToSRGB(color.b);
      }
      return color;
    },
    workingToColorSpace: function(color, targetColorSpace) {
      return this.convert(color, this.workingColorSpace, targetColorSpace);
    },
    colorSpaceToWorking: function(color, sourceColorSpace) {
      return this.convert(color, sourceColorSpace, this.workingColorSpace);
    },
    getPrimaries: function(colorSpace) {
      return this.spaces[colorSpace].primaries;
    },
    getTransfer: function(colorSpace) {
      if (colorSpace === NoColorSpace) return LinearTransfer;
      return this.spaces[colorSpace].transfer;
    },
    getToneMappingMode: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode || "standard";
    },
    getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {
      return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
    },
    define: function(colorSpaces) {
      Object.assign(this.spaces, colorSpaces);
    },
    // Internal APIs
    _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {
      return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
    },
    _getDrawingBufferColorSpace: function(colorSpace) {
      return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
    },
    _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {
      return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
    },
    // Deprecated
    fromWorkingColorSpace: function(color, targetColorSpace) {
      warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace().");
      return ColorManagement2.workingToColorSpace(color, targetColorSpace);
    },
    toWorkingColorSpace: function(color, sourceColorSpace) {
      warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking().");
      return ColorManagement2.colorSpaceToWorking(color, sourceColorSpace);
    }
  };
  const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];
  const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
  const D65 = [0.3127, 0.329];
  ColorManagement2.define({
    [LinearSRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    },
    [SRGBColorSpace]: {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }
    }
  });
  return ColorManagement2;
}
var ColorManagement = /* @__PURE__ */ createColorManagement();
function SRGBToLinear(c2) {
  return c2 < 0.04045 ? c2 * 0.0773993808 : Math.pow(c2 * 0.9478672986 + 0.0521327014, 2.4);
}
function LinearToSRGB(c2) {
  return c2 < 31308e-7 ? c2 * 12.92 : 1.055 * Math.pow(c2, 0.41666) - 0.055;
}
var _canvas;
var ImageUtils = class {
  /**
   * Returns a data URI containing a representation of the given image.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement)} image - The image object.
   * @param {string} [type='image/png'] - Indicates the image format.
   * @return {string} The data URI.
   */
  static getDataURL(image, type = "image/png") {
    if (/^data:/i.test(image.src)) {
      return image.src;
    }
    if (typeof HTMLCanvasElement === "undefined") {
      return image.src;
    }
    let canvas;
    if (image instanceof HTMLCanvasElement) {
      canvas = image;
    } else {
      if (_canvas === void 0) _canvas = createElementNS("canvas");
      _canvas.width = image.width;
      _canvas.height = image.height;
      const context = _canvas.getContext("2d");
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0);
      } else {
        context.drawImage(image, 0, 0, image.width, image.height);
      }
      canvas = _canvas;
    }
    return canvas.toDataURL(type);
  }
  /**
   * Converts the given sRGB image data to linear color space.
   *
   * @param {(HTMLImageElement|HTMLCanvasElement|ImageBitmap|Object)} image - The image object.
   * @return {HTMLCanvasElement|Object} The converted image.
   */
  static sRGBToLinear(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
      const canvas = createElementNS("canvas");
      canvas.width = image.width;
      canvas.height = image.height;
      const context = canvas.getContext("2d");
      context.drawImage(image, 0, 0, image.width, image.height);
      const imageData = context.getImageData(0, 0, image.width, image.height);
      const data2 = imageData.data;
      for (let i2 = 0; i2 < data2.length; i2++) {
        data2[i2] = SRGBToLinear(data2[i2] / 255) * 255;
      }
      context.putImageData(imageData, 0, 0);
      return canvas;
    } else if (image.data) {
      const data2 = image.data.slice(0);
      for (let i2 = 0; i2 < data2.length; i2++) {
        if (data2 instanceof Uint8Array || data2 instanceof Uint8ClampedArray) {
          data2[i2] = Math.floor(SRGBToLinear(data2[i2] / 255) * 255);
        } else {
          data2[i2] = SRGBToLinear(data2[i2]);
        }
      }
      return {
        data: data2,
        width: image.width,
        height: image.height
      };
    } else {
      warn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");
      return image;
    }
  }
};
var _sourceId = 0;
var Source = class {
  /**
   * Constructs a new video texture.
   *
   * @param {any} [data=null] - The data definition of a texture.
   */
  constructor(data2 = null) {
    this.isSource = true;
    Object.defineProperty(this, "id", { value: _sourceId++ });
    this.uuid = generateUUID();
    this.data = data2;
    this.dataReady = true;
    this.version = 0;
  }
  /**
   * Returns the dimensions of the source into the given target vector.
   *
   * @param {(Vector2|Vector3)} target - The target object the result is written into.
   * @return {(Vector2|Vector3)} The dimensions of the source.
   */
  getSize(target) {
    const data2 = this.data;
    if (typeof HTMLVideoElement !== "undefined" && data2 instanceof HTMLVideoElement) {
      target.set(data2.videoWidth, data2.videoHeight, 0);
    } else if (typeof VideoFrame !== "undefined" && data2 instanceof VideoFrame) {
      target.set(data2.displayHeight, data2.displayWidth, 0);
    } else if (data2 !== null) {
      target.set(data2.width, data2.height, data2.depth || 0);
    } else {
      target.set(0, 0, 0);
    }
    return target;
  }
  /**
   * When the property is set to `true`, the engine allocates the memory
   * for the texture (if necessary) and triggers the actual texture upload
   * to the GPU next time the source is used.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Serializes the source into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized source.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid];
    }
    const output = {
      uuid: this.uuid,
      url: ""
    };
    const data2 = this.data;
    if (data2 !== null) {
      let url;
      if (Array.isArray(data2)) {
        url = [];
        for (let i2 = 0, l2 = data2.length; i2 < l2; i2++) {
          if (data2[i2].isDataTexture) {
            url.push(serializeImage(data2[i2].image));
          } else {
            url.push(serializeImage(data2[i2]));
          }
        }
      } else {
        url = serializeImage(data2);
      }
      output.url = url;
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output;
    }
    return output;
  }
};
function serializeImage(image) {
  if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap) {
    return ImageUtils.getDataURL(image);
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name
      };
    } else {
      warn("Texture: Unable to serialize Texture.");
      return {};
    }
  }
}
var _textureId = 0;
var _tempVec3 = /* @__PURE__ */ new Vector3();
var Texture = class _Texture extends EventDispatcher {
  /**
   * Constructs a new texture.
   *
   * @param {?Object} [image=Texture.DEFAULT_IMAGE] - The image holding the texture data.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(image = _Texture.DEFAULT_IMAGE, mapping = _Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = _Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {
    super();
    this.isTexture = true;
    Object.defineProperty(this, "id", { value: _textureId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.source = new Source(image);
    this.mipmaps = [];
    this.mapping = mapping;
    this.channel = 0;
    this.wrapS = wrapS;
    this.wrapT = wrapT;
    this.magFilter = magFilter;
    this.minFilter = minFilter;
    this.anisotropy = anisotropy;
    this.format = format;
    this.internalFormat = null;
    this.type = type;
    this.offset = new Vector2(0, 0);
    this.repeat = new Vector2(1, 1);
    this.center = new Vector2(0, 0);
    this.rotation = 0;
    this.matrixAutoUpdate = true;
    this.matrix = new Matrix3();
    this.generateMipmaps = true;
    this.premultiplyAlpha = false;
    this.flipY = true;
    this.unpackAlignment = 4;
    this.colorSpace = colorSpace;
    this.userData = {};
    this.updateRanges = [];
    this.version = 0;
    this.onUpdate = null;
    this.renderTarget = null;
    this.isRenderTargetTexture = false;
    this.isArrayTexture = image && image.depth && image.depth > 1 ? true : false;
    this.pmremVersion = 0;
  }
  /**
   * The width of the texture in pixels.
   */
  get width() {
    return this.source.getSize(_tempVec3).x;
  }
  /**
   * The height of the texture in pixels.
   */
  get height() {
    return this.source.getSize(_tempVec3).y;
  }
  /**
   * The depth of the texture in pixels.
   */
  get depth() {
    return this.source.getSize(_tempVec3).z;
  }
  /**
   * The image object holding the texture data.
   *
   * @type {?Object}
   */
  get image() {
    return this.source.data;
  }
  set image(value = null) {
    this.source.data = value;
  }
  /**
   * Updates the texture transformation matrix from the from the properties {@link Texture#offset},
   * {@link Texture#repeat}, {@link Texture#rotation}, and {@link Texture#center}.
   */
  updateMatrix() {
    this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
  }
  /**
   * Adds a range of data in the data texture to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Returns a new texture with copied values from this instance.
   *
   * @return {Texture} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given texture to this instance.
   *
   * @param {Texture} source - The texture to copy.
   * @return {Texture} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.source = source.source;
    this.mipmaps = source.mipmaps.slice(0);
    this.mapping = source.mapping;
    this.channel = source.channel;
    this.wrapS = source.wrapS;
    this.wrapT = source.wrapT;
    this.magFilter = source.magFilter;
    this.minFilter = source.minFilter;
    this.anisotropy = source.anisotropy;
    this.format = source.format;
    this.internalFormat = source.internalFormat;
    this.type = source.type;
    this.offset.copy(source.offset);
    this.repeat.copy(source.repeat);
    this.center.copy(source.center);
    this.rotation = source.rotation;
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrix.copy(source.matrix);
    this.generateMipmaps = source.generateMipmaps;
    this.premultiplyAlpha = source.premultiplyAlpha;
    this.flipY = source.flipY;
    this.unpackAlignment = source.unpackAlignment;
    this.colorSpace = source.colorSpace;
    this.renderTarget = source.renderTarget;
    this.isRenderTargetTexture = source.isRenderTargetTexture;
    this.isArrayTexture = source.isArrayTexture;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    this.needsUpdate = true;
    return this;
  }
  /**
   * Sets this texture's properties based on `values`.
   * @param {Object} values - A container with texture parameters.
   */
  setValues(values) {
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        warn(`Texture.setValues(): parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        warn(`Texture.setValues(): property '${key}' does not exist.`);
        continue;
      }
      if (currentValue && newValue && (currentValue.isVector2 && newValue.isVector2)) {
        currentValue.copy(newValue);
      } else if (currentValue && newValue && (currentValue.isVector3 && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else if (currentValue && newValue && (currentValue.isMatrix3 && newValue.isMatrix3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the texture into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized texture.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid];
    }
    const output = {
      metadata: {
        version: 4.7,
        type: "Texture",
        generator: "Texture.toJSON"
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      channel: this.channel,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      internalFormat: this.internalFormat,
      type: this.type,
      colorSpace: this.colorSpace,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      generateMipmaps: this.generateMipmaps,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment
    };
    if (Object.keys(this.userData).length > 0) output.userData = this.userData;
    if (!isRootObject) {
      meta.textures[this.uuid] = output;
    }
    return output;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Texture#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Transforms the given uv vector with the textures uv transformation matrix.
   *
   * @param {Vector2} uv - The uv vector.
   * @return {Vector2} The transformed uv vector.
   */
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv;
    uv.applyMatrix3(this.matrix);
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x);
          break;
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x;
          } else {
            uv.x = uv.x - Math.floor(uv.x);
          }
          break;
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y);
          break;
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1;
          break;
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y;
          } else {
            uv.y = uv.y - Math.floor(uv.y);
          }
          break;
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y;
    }
    return uv;
  }
  /**
   * Setting this property to `true` indicates the engine the texture
   * must be updated in the next render. This triggers a texture upload
   * to the GPU and ensures correct texture parameter configuration.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) {
      this.version++;
      this.source.needsUpdate = true;
    }
  }
  /**
   * Setting this property to `true` indicates the engine the PMREM
   * must be regenerated.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsPMREMUpdate(value) {
    if (value === true) {
      this.pmremVersion++;
    }
  }
};
Texture.DEFAULT_IMAGE = null;
Texture.DEFAULT_MAPPING = UVMapping;
Texture.DEFAULT_ANISOTROPY = 1;
var Vector4 = class _Vector4 {
  /**
   * Constructs a new 4D vector.
   *
   * @param {number} [x=0] - The x value of this vector.
   * @param {number} [y=0] - The y value of this vector.
   * @param {number} [z=0] - The z value of this vector.
   * @param {number} [w=1] - The w value of this vector.
   */
  constructor(x2 = 0, y2 = 0, z2 = 0, w2 = 1) {
    _Vector4.prototype.isVector4 = true;
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
  }
  /**
   * Alias for {@link Vector4#z}.
   *
   * @type {number}
   */
  get width() {
    return this.z;
  }
  set width(value) {
    this.z = value;
  }
  /**
   * Alias for {@link Vector4#w}.
   *
   * @type {number}
   */
  get height() {
    return this.w;
  }
  set height(value) {
    this.w = value;
  }
  /**
   * Sets the vector components.
   *
   * @param {number} x - The value of the x component.
   * @param {number} y - The value of the y component.
   * @param {number} z - The value of the z component.
   * @param {number} w - The value of the w component.
   * @return {Vector4} A reference to this vector.
   */
  set(x2, y2, z2, w2) {
    this.x = x2;
    this.y = y2;
    this.z = z2;
    this.w = w2;
    return this;
  }
  /**
   * Sets the vector components to the same value.
   *
   * @param {number} scalar - The value to set for all vector components.
   * @return {Vector4} A reference to this vector.
   */
  setScalar(scalar) {
    this.x = scalar;
    this.y = scalar;
    this.z = scalar;
    this.w = scalar;
    return this;
  }
  /**
   * Sets the vector's x component to the given value
   *
   * @param {number} x - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setX(x2) {
    this.x = x2;
    return this;
  }
  /**
   * Sets the vector's y component to the given value
   *
   * @param {number} y - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setY(y2) {
    this.y = y2;
    return this;
  }
  /**
   * Sets the vector's z component to the given value
   *
   * @param {number} z - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setZ(z2) {
    this.z = z2;
    return this;
  }
  /**
   * Sets the vector's w component to the given value
   *
   * @param {number} w - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setW(w2) {
    this.w = w2;
    return this;
  }
  /**
   * Allows to set a vector component with an index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @param {number} value - The value to set.
   * @return {Vector4} A reference to this vector.
   */
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value;
        break;
      case 1:
        this.y = value;
        break;
      case 2:
        this.z = value;
        break;
      case 3:
        this.w = value;
        break;
      default:
        throw new Error("index is out of range: " + index);
    }
    return this;
  }
  /**
   * Returns the value of the vector component which matches the given index.
   *
   * @param {number} index - The component index. `0` equals to x, `1` equals to y,
   * `2` equals to z, `3` equals to w.
   * @return {number} A vector component value.
   */
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      case 3:
        return this.w;
      default:
        throw new Error("index is out of range: " + index);
    }
  }
  /**
   * Returns a new vector with copied values from this instance.
   *
   * @return {Vector4} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  /**
   * Copies the values of the given vector to this instance.
   *
   * @param {Vector3|Vector4} v - The vector to copy.
   * @return {Vector4} A reference to this vector.
   */
  copy(v2) {
    this.x = v2.x;
    this.y = v2.y;
    this.z = v2.z;
    this.w = v2.w !== void 0 ? v2.w : 1;
    return this;
  }
  /**
   * Adds the given vector to this instance.
   *
   * @param {Vector4} v - The vector to add.
   * @return {Vector4} A reference to this vector.
   */
  add(v2) {
    this.x += v2.x;
    this.y += v2.y;
    this.z += v2.z;
    this.w += v2.w;
    return this;
  }
  /**
   * Adds the given scalar value to all components of this instance.
   *
   * @param {number} s - The scalar to add.
   * @return {Vector4} A reference to this vector.
   */
  addScalar(s2) {
    this.x += s2;
    this.y += s2;
    this.z += s2;
    this.w += s2;
    return this;
  }
  /**
   * Adds the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  addVectors(a2, b2) {
    this.x = a2.x + b2.x;
    this.y = a2.y + b2.y;
    this.z = a2.z + b2.z;
    this.w = a2.w + b2.w;
    return this;
  }
  /**
   * Adds the given vector scaled by the given factor to this instance.
   *
   * @param {Vector4} v - The vector.
   * @param {number} s - The factor that scales `v`.
   * @return {Vector4} A reference to this vector.
   */
  addScaledVector(v2, s2) {
    this.x += v2.x * s2;
    this.y += v2.y * s2;
    this.z += v2.z * s2;
    this.w += v2.w * s2;
    return this;
  }
  /**
   * Subtracts the given vector from this instance.
   *
   * @param {Vector4} v - The vector to subtract.
   * @return {Vector4} A reference to this vector.
   */
  sub(v2) {
    this.x -= v2.x;
    this.y -= v2.y;
    this.z -= v2.z;
    this.w -= v2.w;
    return this;
  }
  /**
   * Subtracts the given scalar value from all components of this instance.
   *
   * @param {number} s - The scalar to subtract.
   * @return {Vector4} A reference to this vector.
   */
  subScalar(s2) {
    this.x -= s2;
    this.y -= s2;
    this.z -= s2;
    this.w -= s2;
    return this;
  }
  /**
   * Subtracts the given vectors and stores the result in this instance.
   *
   * @param {Vector4} a - The first vector.
   * @param {Vector4} b - The second vector.
   * @return {Vector4} A reference to this vector.
   */
  subVectors(a2, b2) {
    this.x = a2.x - b2.x;
    this.y = a2.y - b2.y;
    this.z = a2.z - b2.z;
    this.w = a2.w - b2.w;
    return this;
  }
  /**
   * Multiplies the given vector with this instance.
   *
   * @param {Vector4} v - The vector to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiply(v2) {
    this.x *= v2.x;
    this.y *= v2.y;
    this.z *= v2.z;
    this.w *= v2.w;
    return this;
  }
  /**
   * Multiplies the given scalar value with all components of this instance.
   *
   * @param {number} scalar - The scalar to multiply.
   * @return {Vector4} A reference to this vector.
   */
  multiplyScalar(scalar) {
    this.x *= scalar;
    this.y *= scalar;
    this.z *= scalar;
    this.w *= scalar;
    return this;
  }
  /**
   * Multiplies this vector with the given 4x4 matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  applyMatrix4(m2) {
    const x2 = this.x, y2 = this.y, z2 = this.z, w2 = this.w;
    const e2 = m2.elements;
    this.x = e2[0] * x2 + e2[4] * y2 + e2[8] * z2 + e2[12] * w2;
    this.y = e2[1] * x2 + e2[5] * y2 + e2[9] * z2 + e2[13] * w2;
    this.z = e2[2] * x2 + e2[6] * y2 + e2[10] * z2 + e2[14] * w2;
    this.w = e2[3] * x2 + e2[7] * y2 + e2[11] * z2 + e2[15] * w2;
    return this;
  }
  /**
   * Divides this instance by the given vector.
   *
   * @param {Vector4} v - The vector to divide.
   * @return {Vector4} A reference to this vector.
   */
  divide(v2) {
    this.x /= v2.x;
    this.y /= v2.y;
    this.z /= v2.z;
    this.w /= v2.w;
    return this;
  }
  /**
   * Divides this vector by the given scalar.
   *
   * @param {number} scalar - The scalar to divide.
   * @return {Vector4} A reference to this vector.
   */
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar);
  }
  /**
   * Sets the x, y and z components of this
   * vector to the quaternion's axis and w to the angle.
   *
   * @param {Quaternion} q - The Quaternion to set.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromQuaternion(q2) {
    this.w = 2 * Math.acos(q2.w);
    const s2 = Math.sqrt(1 - q2.w * q2.w);
    if (s2 < 1e-4) {
      this.x = 1;
      this.y = 0;
      this.z = 0;
    } else {
      this.x = q2.x / s2;
      this.y = q2.y / s2;
      this.z = q2.z / s2;
    }
    return this;
  }
  /**
   * Sets the x, y and z components of this
   * vector to the axis of rotation and w to the angle.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper left 3x3 matrix is a pure rotation matrix.
   * @return {Vector4} A reference to this vector.
   */
  setAxisAngleFromRotationMatrix(m2) {
    let angle, x2, y2, z2;
    const epsilon = 0.01, epsilon2 = 0.1, te2 = m2.elements, m11 = te2[0], m12 = te2[4], m13 = te2[8], m21 = te2[1], m22 = te2[5], m23 = te2[9], m31 = te2[2], m32 = te2[6], m33 = te2[10];
    if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
      if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
        this.set(1, 0, 0, 0);
        return this;
      }
      angle = Math.PI;
      const xx = (m11 + 1) / 2;
      const yy = (m22 + 1) / 2;
      const zz = (m33 + 1) / 2;
      const xy = (m12 + m21) / 4;
      const xz = (m13 + m31) / 4;
      const yz = (m23 + m32) / 4;
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x2 = 0;
          y2 = 0.707106781;
          z2 = 0.707106781;
        } else {
          x2 = Math.sqrt(xx);
          y2 = xy / x2;
          z2 = xz / x2;
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x2 = 0.707106781;
          y2 = 0;
          z2 = 0.707106781;
        } else {
          y2 = Math.sqrt(yy);
          x2 = xy / y2;
          z2 = yz / y2;
        }
      } else {
        if (zz < epsilon) {
          x2 = 0.707106781;
          y2 = 0.707106781;
          z2 = 0;
        } else {
          z2 = Math.sqrt(zz);
          x2 = xz / z2;
          y2 = yz / z2;
        }
      }
      this.set(x2, y2, z2, angle);
      return this;
    }
    let s2 = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));
    if (Math.abs(s2) < 1e-3) s2 = 1;
    this.x = (m32 - m23) / s2;
    this.y = (m13 - m31) / s2;
    this.z = (m21 - m12) / s2;
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
    return this;
  }
  /**
   * Sets the vector components to the position elements of the
   * given transformation matrix.
   *
   * @param {Matrix4} m - The 4x4 matrix.
   * @return {Vector4} A reference to this vector.
   */
  setFromMatrixPosition(m2) {
    const e2 = m2.elements;
    this.x = e2[12];
    this.y = e2[13];
    this.z = e2[14];
    this.w = e2[15];
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the given vector's x, y, z or w
   * value, replace that value with the corresponding min value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  min(v2) {
    this.x = Math.min(this.x, v2.x);
    this.y = Math.min(this.y, v2.y);
    this.z = Math.min(this.z, v2.z);
    this.w = Math.min(this.w, v2.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is less than the given vector's x, y, z or w
   * value, replace that value with the corresponding max value.
   *
   * @param {Vector4} v - The vector.
   * @return {Vector4} A reference to this vector.
   */
  max(v2) {
    this.x = Math.max(this.x, v2.x);
    this.y = Math.max(this.y, v2.y);
    this.z = Math.max(this.z, v2.z);
    this.w = Math.max(this.w, v2.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w value is greater than the max vector's x, y, z or w
   * value, it is replaced by the corresponding value.
   * If this vector's x, y, z or w value is less than the min vector's x, y, z or w value,
   * it is replaced by the corresponding value.
   *
   * @param {Vector4} min - The minimum x, y and z values.
   * @param {Vector4} max - The maximum x, y and z values in the desired range.
   * @return {Vector4} A reference to this vector.
   */
  clamp(min, max) {
    this.x = clamp(this.x, min.x, max.x);
    this.y = clamp(this.y, min.y, max.y);
    this.z = clamp(this.z, min.z, max.z);
    this.w = clamp(this.w, min.w, max.w);
    return this;
  }
  /**
   * If this vector's x, y, z or w values are greater than the max value, they are
   * replaced by the max value.
   * If this vector's x, y, z or w values are less than the min value, they are
   * replaced by the min value.
   *
   * @param {number} minVal - The minimum value the components will be clamped to.
   * @param {number} maxVal - The maximum value the components will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampScalar(minVal, maxVal) {
    this.x = clamp(this.x, minVal, maxVal);
    this.y = clamp(this.y, minVal, maxVal);
    this.z = clamp(this.z, minVal, maxVal);
    this.w = clamp(this.w, minVal, maxVal);
    return this;
  }
  /**
   * If this vector's length is greater than the max value, it is replaced by
   * the max value.
   * If this vector's length is less than the min value, it is replaced by the
   * min value.
   *
   * @param {number} min - The minimum value the vector length will be clamped to.
   * @param {number} max - The maximum value the vector length will be clamped to.
   * @return {Vector4} A reference to this vector.
   */
  clampLength(min, max) {
    const length = this.length();
    return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max));
  }
  /**
   * The components of this vector are rounded down to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  floor() {
    this.x = Math.floor(this.x);
    this.y = Math.floor(this.y);
    this.z = Math.floor(this.z);
    this.w = Math.floor(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded up to the nearest integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  ceil() {
    this.x = Math.ceil(this.x);
    this.y = Math.ceil(this.y);
    this.z = Math.ceil(this.z);
    this.w = Math.ceil(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded to the nearest integer value
   *
   * @return {Vector4} A reference to this vector.
   */
  round() {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
    this.z = Math.round(this.z);
    this.w = Math.round(this.w);
    return this;
  }
  /**
   * The components of this vector are rounded towards zero (up if negative,
   * down if positive) to an integer value.
   *
   * @return {Vector4} A reference to this vector.
   */
  roundToZero() {
    this.x = Math.trunc(this.x);
    this.y = Math.trunc(this.y);
    this.z = Math.trunc(this.z);
    this.w = Math.trunc(this.w);
    return this;
  }
  /**
   * Inverts this vector - i.e. sets x = -x, y = -y, z = -z, w = -w.
   *
   * @return {Vector4} A reference to this vector.
   */
  negate() {
    this.x = -this.x;
    this.y = -this.y;
    this.z = -this.z;
    this.w = -this.w;
    return this;
  }
  /**
   * Calculates the dot product of the given vector with this instance.
   *
   * @param {Vector4} v - The vector to compute the dot product with.
   * @return {number} The result of the dot product.
   */
  dot(v2) {
    return this.x * v2.x + this.y * v2.y + this.z * v2.z + this.w * v2.w;
  }
  /**
   * Computes the square of the Euclidean length (straight-line length) from
   * (0, 0, 0, 0) to (x, y, z, w). If you are comparing the lengths of vectors, you should
   * compare the length squared instead as it is slightly more efficient to calculate.
   *
   * @return {number} The square length of this vector.
   */
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  /**
   * Computes the  Euclidean length (straight-line length) from (0, 0, 0, 0) to (x, y, z, w).
   *
   * @return {number} The length of this vector.
   */
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  /**
   * Computes the Manhattan length of this vector.
   *
   * @return {number} The length of this vector.
   */
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
  }
  /**
   * Converts this vector to a unit vector - that is, sets it equal to a vector
   * with the same direction as this one, but with a vector length of `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  /**
   * Sets this vector to a vector with the same direction as this one, but
   * with the specified length.
   *
   * @param {number} length - The new length of this vector.
   * @return {Vector4} A reference to this vector.
   */
  setLength(length) {
    return this.normalize().multiplyScalar(length);
  }
  /**
   * Linearly interpolates between the given vector and this instance, where
   * alpha is the percent distance along the line - alpha = 0 will be this
   * vector, and alpha = 1 will be the given one.
   *
   * @param {Vector4} v - The vector to interpolate towards.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerp(v2, alpha) {
    this.x += (v2.x - this.x) * alpha;
    this.y += (v2.y - this.y) * alpha;
    this.z += (v2.z - this.z) * alpha;
    this.w += (v2.w - this.w) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given vectors, where alpha is the percent
   * distance along the line - alpha = 0 will be first vector, and alpha = 1 will
   * be the second one. The result is stored in this instance.
   *
   * @param {Vector4} v1 - The first vector.
   * @param {Vector4} v2 - The second vector.
   * @param {number} alpha - The interpolation factor, typically in the closed interval `[0, 1]`.
   * @return {Vector4} A reference to this vector.
   */
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha;
    this.y = v1.y + (v2.y - v1.y) * alpha;
    this.z = v1.z + (v2.z - v1.z) * alpha;
    this.w = v1.w + (v2.w - v1.w) * alpha;
    return this;
  }
  /**
   * Returns `true` if this vector is equal with the given one.
   *
   * @param {Vector4} v - The vector to test for equality.
   * @return {boolean} Whether this vector is equal with the given one.
   */
  equals(v2) {
    return v2.x === this.x && v2.y === this.y && v2.z === this.z && v2.w === this.w;
  }
  /**
   * Sets this vector's x value to be `array[ offset ]`, y value to be `array[ offset + 1 ]`,
   * z value to be `array[ offset + 2 ]`, w value to be `array[ offset + 3 ]`.
   *
   * @param {Array<number>} array - An array holding the vector component values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Vector4} A reference to this vector.
   */
  fromArray(array, offset = 0) {
    this.x = array[offset];
    this.y = array[offset + 1];
    this.z = array[offset + 2];
    this.w = array[offset + 3];
    return this;
  }
  /**
   * Writes the components of this vector to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the vector components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The vector components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this.x;
    array[offset + 1] = this.y;
    array[offset + 2] = this.z;
    array[offset + 3] = this.w;
    return array;
  }
  /**
   * Sets the components of this vector from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding vector data.
   * @param {number} index - The index into the attribute.
   * @return {Vector4} A reference to this vector.
   */
  fromBufferAttribute(attribute, index) {
    this.x = attribute.getX(index);
    this.y = attribute.getY(index);
    this.z = attribute.getZ(index);
    this.w = attribute.getW(index);
    return this;
  }
  /**
   * Sets each component of this vector to a pseudo-random value between `0` and
   * `1`, excluding `1`.
   *
   * @return {Vector4} A reference to this vector.
   */
  random() {
    this.x = Math.random();
    this.y = Math.random();
    this.z = Math.random();
    this.w = Math.random();
    return this;
  }
  *[Symbol.iterator]() {
    yield this.x;
    yield this.y;
    yield this.z;
    yield this.w;
  }
};
var RenderTarget = class extends EventDispatcher {
  /**
   * Render target options.
   *
   * @typedef {Object} RenderTarget~Options
   * @property {boolean} [generateMipmaps=false] - Whether to generate mipmaps or not.
   * @property {number} [magFilter=LinearFilter] - The mag filter.
   * @property {number} [minFilter=LinearFilter] - The min filter.
   * @property {number} [format=RGBAFormat] - The texture format.
   * @property {number} [type=UnsignedByteType] - The texture type.
   * @property {?string} [internalFormat=null] - The texture's internal format.
   * @property {number} [wrapS=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [wrapT=ClampToEdgeWrapping] - The texture's uv wrapping mode.
   * @property {number} [anisotropy=1] - The texture's anisotropy value.
   * @property {string} [colorSpace=NoColorSpace] - The texture's color space.
   * @property {boolean} [depthBuffer=true] - Whether to allocate a depth buffer or not.
   * @property {boolean} [stencilBuffer=false] - Whether to allocate a stencil buffer or not.
   * @property {boolean} [resolveDepthBuffer=true] - Whether to resolve the depth buffer or not.
   * @property {boolean} [resolveStencilBuffer=true] - Whether  to resolve the stencil buffer or not.
   * @property {?Texture} [depthTexture=null] - Reference to a depth texture.
   * @property {number} [samples=0] - The MSAA samples count.
   * @property {number} [count=1] - Defines the number of color attachments . Must be at least `1`.
   * @property {number} [depth=1] - The texture depth.
   * @property {boolean} [multiview=false] - Whether this target is used for multiview rendering.
   */
  /**
   * Constructs a new render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(width = 1, height = 1, options = {}) {
    super();
    options = Object.assign({
      generateMipmaps: false,
      internalFormat: null,
      minFilter: LinearFilter,
      depthBuffer: true,
      stencilBuffer: false,
      resolveDepthBuffer: true,
      resolveStencilBuffer: true,
      depthTexture: null,
      samples: 0,
      count: 1,
      depth: 1,
      multiview: false
    }, options);
    this.isRenderTarget = true;
    this.width = width;
    this.height = height;
    this.depth = options.depth;
    this.scissor = new Vector4(0, 0, width, height);
    this.scissorTest = false;
    this.viewport = new Vector4(0, 0, width, height);
    const image = { width, height, depth: options.depth };
    const texture = new Texture(image);
    this.textures = [];
    const count = options.count;
    for (let i2 = 0; i2 < count; i2++) {
      this.textures[i2] = texture.clone();
      this.textures[i2].isRenderTargetTexture = true;
      this.textures[i2].renderTarget = this;
    }
    this._setTextureOptions(options);
    this.depthBuffer = options.depthBuffer;
    this.stencilBuffer = options.stencilBuffer;
    this.resolveDepthBuffer = options.resolveDepthBuffer;
    this.resolveStencilBuffer = options.resolveStencilBuffer;
    this._depthTexture = null;
    this.depthTexture = options.depthTexture;
    this.samples = options.samples;
    this.multiview = options.multiview;
  }
  _setTextureOptions(options = {}) {
    const values = {
      minFilter: LinearFilter,
      generateMipmaps: false,
      flipY: false,
      internalFormat: null
    };
    if (options.mapping !== void 0) values.mapping = options.mapping;
    if (options.wrapS !== void 0) values.wrapS = options.wrapS;
    if (options.wrapT !== void 0) values.wrapT = options.wrapT;
    if (options.wrapR !== void 0) values.wrapR = options.wrapR;
    if (options.magFilter !== void 0) values.magFilter = options.magFilter;
    if (options.minFilter !== void 0) values.minFilter = options.minFilter;
    if (options.format !== void 0) values.format = options.format;
    if (options.type !== void 0) values.type = options.type;
    if (options.anisotropy !== void 0) values.anisotropy = options.anisotropy;
    if (options.colorSpace !== void 0) values.colorSpace = options.colorSpace;
    if (options.flipY !== void 0) values.flipY = options.flipY;
    if (options.generateMipmaps !== void 0) values.generateMipmaps = options.generateMipmaps;
    if (options.internalFormat !== void 0) values.internalFormat = options.internalFormat;
    for (let i2 = 0; i2 < this.textures.length; i2++) {
      const texture = this.textures[i2];
      texture.setValues(values);
    }
  }
  /**
   * The texture representing the default color attachment.
   *
   * @type {Texture}
   */
  get texture() {
    return this.textures[0];
  }
  set texture(value) {
    this.textures[0] = value;
  }
  set depthTexture(current) {
    if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
    if (current !== null) current.renderTarget = this;
    this._depthTexture = current;
  }
  /**
   * Instead of saving the depth in a renderbuffer, a texture
   * can be used instead which is useful for further processing
   * e.g. in context of post-processing.
   *
   * @type {?DepthTexture}
   * @default null
   */
  get depthTexture() {
    return this._depthTexture;
  }
  /**
   * Sets the size of this render target.
   *
   * @param {number} width - The width.
   * @param {number} height - The height.
   * @param {number} [depth=1] - The depth.
   */
  setSize(width, height, depth = 1) {
    if (this.width !== width || this.height !== height || this.depth !== depth) {
      this.width = width;
      this.height = height;
      this.depth = depth;
      for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {
        this.textures[i2].image.width = width;
        this.textures[i2].image.height = height;
        this.textures[i2].image.depth = depth;
        if (this.textures[i2].isData3DTexture !== true) {
          this.textures[i2].isArrayTexture = this.textures[i2].image.depth > 1;
        }
      }
      this.dispose();
    }
    this.viewport.set(0, 0, width, height);
    this.scissor.set(0, 0, width, height);
  }
  /**
   * Returns a new render target with copied values from this instance.
   *
   * @return {RenderTarget} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the settings of the given render target. This is a structural copy so
   * no resources are shared between render targets after the copy. That includes
   * all MRT textures and the depth texture.
   *
   * @param {RenderTarget} source - The render target to copy.
   * @return {RenderTarget} A reference to this instance.
   */
  copy(source) {
    this.width = source.width;
    this.height = source.height;
    this.depth = source.depth;
    this.scissor.copy(source.scissor);
    this.scissorTest = source.scissorTest;
    this.viewport.copy(source.viewport);
    this.textures.length = 0;
    for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {
      this.textures[i2] = source.textures[i2].clone();
      this.textures[i2].isRenderTargetTexture = true;
      this.textures[i2].renderTarget = this;
      const image = Object.assign({}, source.textures[i2].image);
      this.textures[i2].source = new Source(image);
    }
    this.depthBuffer = source.depthBuffer;
    this.stencilBuffer = source.stencilBuffer;
    this.resolveDepthBuffer = source.resolveDepthBuffer;
    this.resolveStencilBuffer = source.resolveStencilBuffer;
    if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
    this.samples = source.samples;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires RenderTarget#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var WebGLRenderTarget = class extends RenderTarget {
  /**
   * Constructs a new 3D render target.
   *
   * @param {number} [width=1] - The width of the render target.
   * @param {number} [height=1] - The height of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(width = 1, height = 1, options = {}) {
    super(width, height, options);
    this.isWebGLRenderTarget = true;
  }
};
var DataArrayTexture = class extends Texture {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(data2 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isDataArrayTexture = true;
    this.image = { data: data2, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
    this.layerUpdates = /* @__PURE__ */ new Set();
  }
  /**
   * Describes that a specific layer of the texture needs to be updated.
   * Normally when {@link Texture#needsUpdate} is set to `true`, the
   * entire data texture array is sent to the GPU. Marking specific
   * layers will only transmit subsets of all mipmaps associated with a
   * specific depth in the array which is often much more performant.
   *
   * @param {number} layerIndex - The layer index that should be updated.
   */
  addLayerUpdate(layerIndex) {
    this.layerUpdates.add(layerIndex);
  }
  /**
   * Resets the layer updates registry.
   */
  clearLayerUpdates() {
    this.layerUpdates.clear();
  }
};
var Data3DTexture = class extends Texture {
  /**
   * Constructs a new data array texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(data2 = null, width = 1, height = 1, depth = 1) {
    super(null);
    this.isData3DTexture = true;
    this.image = { data: data2, width, height, depth };
    this.magFilter = NearestFilter;
    this.minFilter = NearestFilter;
    this.wrapR = ClampToEdgeWrapping;
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var Box3 = class {
  /**
   * Constructs a new bounding box.
   *
   * @param {Vector3} [min=(Infinity,Infinity,Infinity)] - A vector representing the lower boundary of the box.
   * @param {Vector3} [max=(-Infinity,-Infinity,-Infinity)] - A vector representing the upper boundary of the box.
   */
  constructor(min = new Vector3(Infinity, Infinity, Infinity), max = new Vector3(-Infinity, -Infinity, -Infinity)) {
    this.isBox3 = true;
    this.min = min;
    this.max = max;
  }
  /**
   * Sets the lower and upper boundaries of this box.
   * Please note that this method only copies the values from the given objects.
   *
   * @param {Vector3} min - The lower boundary of the box.
   * @param {Vector3} max - The upper boundary of the box.
   * @return {Box3} A reference to this bounding box.
   */
  set(min, max) {
    this.min.copy(min);
    this.max.copy(max);
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<number>} array - An array holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromArray(array) {
    this.makeEmpty();
    for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {
      this.expandByPoint(_vector$b.fromArray(array, i2));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - A buffer attribute holding 3D position data.
   * @return {Box3} A reference to this bounding box.
   */
  setFromBufferAttribute(attribute) {
    this.makeEmpty();
    for (let i2 = 0, il = attribute.count; i2 < il; i2++) {
      this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));
    }
    return this;
  }
  /**
   * Sets the upper and lower bounds of this box so it encloses the position data
   * in the given array.
   *
   * @param {Array<Vector3>} points - An array holding 3D position data as instances of {@link Vector3}.
   * @return {Box3} A reference to this bounding box.
   */
  setFromPoints(points) {
    this.makeEmpty();
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      this.expandByPoint(points[i2]);
    }
    return this;
  }
  /**
   * Centers this box on the given center vector and sets this box's width, height and
   * depth to the given size values.
   *
   * @param {Vector3} center - The center of the box.
   * @param {Vector3} size - The x, y and z dimensions of the box.
   * @return {Box3} A reference to this bounding box.
   */
  setFromCenterAndSize(center, size) {
    const halfSize = _vector$b.copy(size).multiplyScalar(0.5);
    this.min.copy(center).sub(halfSize);
    this.max.copy(center).add(halfSize);
    return this;
  }
  /**
   * Computes the world-axis-aligned bounding box for the given 3D object
   * (including its children), accounting for the object's, and children's,
   * world transforms. The function may result in a larger box than strictly necessary.
   *
   * @param {Object3D} object - The 3D object to compute the bounding box for.
   * @param {boolean} [precise=false] - If set to `true`, the method computes the smallest
   * world-axis-aligned bounding box at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  setFromObject(object, precise = false) {
    this.makeEmpty();
    return this.expandByObject(object, precise);
  }
  /**
   * Returns a new box with copied values from this instance.
   *
   * @return {Box3} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given box to this instance.
   *
   * @param {Box3} box - The box to copy.
   * @return {Box3} A reference to this bounding box.
   */
  copy(box) {
    this.min.copy(box.min);
    this.max.copy(box.max);
    return this;
  }
  /**
   * Makes this box empty which means in encloses a zero space in 3D.
   *
   * @return {Box3} A reference to this bounding box.
   */
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity;
    this.max.x = this.max.y = this.max.z = -Infinity;
    return this;
  }
  /**
   * Returns true if this box includes zero points within its bounds.
   * Note that a box with equal lower and upper bounds still includes one
   * point, the one both bounds share.
   *
   * @return {boolean} Whether this box is empty or not.
   */
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
  }
  /**
   * Returns the center point of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The center point.
   */
  getCenter(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  /**
   * Returns the dimensions of this box.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The size.
   */
  getSize(target) {
    return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
  }
  /**
   * Expands the boundaries of this box to include the given point.
   *
   * @param {Vector3} point - The point that should be included by the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByPoint(point) {
    this.min.min(point);
    this.max.max(point);
    return this;
  }
  /**
   * Expands this box equilaterally by the given vector. The width of this
   * box will be expanded by the x component of the vector in both
   * directions. The height of this box will be expanded by the y component of
   * the vector in both directions. The depth of this box will be
   * expanded by the z component of the vector in both directions.
   *
   * @param {Vector3} vector - The vector that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByVector(vector) {
    this.min.sub(vector);
    this.max.add(vector);
    return this;
  }
  /**
   * Expands each dimension of the box by the given scalar. If negative, the
   * dimensions of the box will be contracted.
   *
   * @param {number} scalar - The scalar value that should expand the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  expandByScalar(scalar) {
    this.min.addScalar(-scalar);
    this.max.addScalar(scalar);
    return this;
  }
  /**
   * Expands the boundaries of this box to include the given 3D object and
   * its children, accounting for the object's, and children's, world
   * transforms. The function may result in a larger box than strictly
   * necessary (unless the precise parameter is set to true).
   *
   * @param {Object3D} object - The 3D object that should expand the bounding box.
   * @param {boolean} precise - If set to `true`, the method expands the bounding box
   * as little as necessary at the expense of more computation.
   * @return {Box3} A reference to this bounding box.
   */
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false);
    const geometry = object.geometry;
    if (geometry !== void 0) {
      const positionAttribute = geometry.getAttribute("position");
      if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {
        for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2++) {
          if (object.isMesh === true) {
            object.getVertexPosition(i2, _vector$b);
          } else {
            _vector$b.fromBufferAttribute(positionAttribute, i2);
          }
          _vector$b.applyMatrix4(object.matrixWorld);
          this.expandByPoint(_vector$b);
        }
      } else {
        if (object.boundingBox !== void 0) {
          if (object.boundingBox === null) {
            object.computeBoundingBox();
          }
          _box$4.copy(object.boundingBox);
        } else {
          if (geometry.boundingBox === null) {
            geometry.computeBoundingBox();
          }
          _box$4.copy(geometry.boundingBox);
        }
        _box$4.applyMatrix4(object.matrixWorld);
        this.union(_box$4);
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      this.expandByObject(children[i2], precise);
    }
    return this;
  }
  /**
   * Returns `true` if the given point lies within or on the boundaries of this box.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the bounding box contains the given point or not.
   */
  containsPoint(point) {
    return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
  }
  /**
   * Returns `true` if this bounding box includes the entirety of the given bounding box.
   * If this box and the given one are identical, this function also returns `true`.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box contains the given bounding box or not.
   */
  containsBox(box) {
    return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
  }
  /**
   * Returns a point as a proportion of this box's width, height and depth.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A point as a proportion of this box's width, height and depth.
   */
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  /**
   * Returns `true` if the given bounding box intersects with this bounding box.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with this bounding box.
   */
  intersectsBox(box) {
    return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
  }
  /**
   * Returns `true` if the given bounding sphere intersects with this bounding box.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with this bounding box.
   */
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b);
    return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
  }
  /**
   * Returns `true` if the given plane intersects with this bounding box.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether the given plane intersects with this bounding box.
   */
  intersectsPlane(plane) {
    let min, max;
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x;
      max = plane.normal.x * this.max.x;
    } else {
      min = plane.normal.x * this.max.x;
      max = plane.normal.x * this.min.x;
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y;
      max += plane.normal.y * this.max.y;
    } else {
      min += plane.normal.y * this.max.y;
      max += plane.normal.y * this.min.y;
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z;
      max += plane.normal.z * this.max.z;
    } else {
      min += plane.normal.z * this.max.z;
      max += plane.normal.z * this.min.z;
    }
    return min <= -plane.constant && max >= -plane.constant;
  }
  /**
   * Returns `true` if the given triangle intersects with this bounding box.
   *
   * @param {Triangle} triangle - The triangle to test.
   * @return {boolean} Whether the given triangle intersects with this bounding box.
   */
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false;
    }
    this.getCenter(_center);
    _extents.subVectors(this.max, _center);
    _v0$2.subVectors(triangle.a, _center);
    _v1$7.subVectors(triangle.b, _center);
    _v2$4.subVectors(triangle.c, _center);
    _f0.subVectors(_v1$7, _v0$2);
    _f1.subVectors(_v2$4, _v1$7);
    _f2.subVectors(_v0$2, _v2$4);
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0
    ];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
    if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
      return false;
    }
    _triangleNormal.crossVectors(_f0, _f1);
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
    return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
  }
  /**
   * Clamps the given point within the bounds of this box.
   *
   * @param {Vector3} point - The point to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max);
  }
  /**
   * Returns the euclidean distance from any edge of this box to the specified point. If
   * the given point lies inside of this box, the distance will be `0`.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The euclidean distance.
   */
  distanceToPoint(point) {
    return this.clampPoint(point, _vector$b).distanceTo(point);
  }
  /**
   * Returns a bounding sphere that encloses this bounding box.
   *
   * @param {Sphere} target - The target sphere that is used to store the method's result.
   * @return {Sphere} The bounding sphere that encloses this bounding box.
   */
  getBoundingSphere(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
    } else {
      this.getCenter(target.center);
      target.radius = this.getSize(_vector$b).length() * 0.5;
    }
    return target;
  }
  /**
   * Computes the intersection of this bounding box and the given one, setting the upper
   * bound of this box to the lesser of the two boxes' upper bounds and the
   * lower bound of this box to the greater of the two boxes' lower bounds. If
   * there's no overlap, makes this box empty.
   *
   * @param {Box3} box - The bounding box to intersect with.
   * @return {Box3} A reference to this bounding box.
   */
  intersect(box) {
    this.min.max(box.min);
    this.max.min(box.max);
    if (this.isEmpty()) this.makeEmpty();
    return this;
  }
  /**
   * Computes the union of this box and another and the given one, setting the upper
   * bound of this box to the greater of the two boxes' upper bounds and the
   * lower bound of this box to the lesser of the two boxes' lower bounds.
   *
   * @param {Box3} box - The bounding box that will be unioned with this instance.
   * @return {Box3} A reference to this bounding box.
   */
  union(box) {
    this.min.min(box.min);
    this.max.max(box.max);
    return this;
  }
  /**
   * Transforms this bounding box by the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Box3} A reference to this bounding box.
   */
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this;
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);
    this.setFromPoints(_points);
    return this;
  }
  /**
   * Adds the given offset to both the upper and lower bounds of this bounding box,
   * effectively moving it in 3D space.
   *
   * @param {Vector3} offset - The offset that should be used to translate the bounding box.
   * @return {Box3} A reference to this bounding box.
   */
  translate(offset) {
    this.min.add(offset);
    this.max.add(offset);
    return this;
  }
  /**
   * Returns `true` if this bounding box is equal with the given one.
   *
   * @param {Box3} box - The box to test for equality.
   * @return {boolean} Whether this bounding box is equal with the given one.
   */
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max);
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      min: this.min.toArray(),
      max: this.max.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding box.
   *
   * @param {Object} json - The serialized json to set the box from.
   * @return {Box3} A reference to this bounding box.
   */
  fromJSON(json) {
    this.min.fromArray(json.min);
    this.max.fromArray(json.max);
    return this;
  }
};
var _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3()
];
var _vector$b = /* @__PURE__ */ new Vector3();
var _box$4 = /* @__PURE__ */ new Box3();
var _v0$2 = /* @__PURE__ */ new Vector3();
var _v1$7 = /* @__PURE__ */ new Vector3();
var _v2$4 = /* @__PURE__ */ new Vector3();
var _f0 = /* @__PURE__ */ new Vector3();
var _f1 = /* @__PURE__ */ new Vector3();
var _f2 = /* @__PURE__ */ new Vector3();
var _center = /* @__PURE__ */ new Vector3();
var _extents = /* @__PURE__ */ new Vector3();
var _triangleNormal = /* @__PURE__ */ new Vector3();
var _testAxis = /* @__PURE__ */ new Vector3();
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i2 = 0, j2 = axes.length - 3; i2 <= j2; i2 += 3) {
    _testAxis.fromArray(axes, i2);
    const r2 = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
    const p0 = v0.dot(_testAxis);
    const p1 = v1.dot(_testAxis);
    const p2 = v2.dot(_testAxis);
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r2) {
      return false;
    }
  }
  return true;
}
var _box$3 = /* @__PURE__ */ new Box3();
var _v1$6 = /* @__PURE__ */ new Vector3();
var _v2$3 = /* @__PURE__ */ new Vector3();
var Sphere = class {
  /**
   * Constructs a new sphere.
   *
   * @param {Vector3} [center=(0,0,0)] - The center of the sphere
   * @param {number} [radius=-1] - The radius of the sphere.
   */
  constructor(center = new Vector3(), radius = -1) {
    this.isSphere = true;
    this.center = center;
    this.radius = radius;
  }
  /**
   * Sets the sphere's components by copying the given values.
   *
   * @param {Vector3} center - The center.
   * @param {number} radius - The radius.
   * @return {Sphere} A reference to this sphere.
   */
  set(center, radius) {
    this.center.copy(center);
    this.radius = radius;
    return this;
  }
  /**
   * Computes the minimum bounding sphere for list of points.
   * If the optional center point is given, it is used as the sphere's
   * center. Otherwise, the center of the axis-aligned bounding box
   * encompassing the points is calculated.
   *
   * @param {Array<Vector3>} points - A list of points in 3D space.
   * @param {Vector3} [optionalCenter] - The center of the sphere.
   * @return {Sphere} A reference to this sphere.
   */
  setFromPoints(points, optionalCenter) {
    const center = this.center;
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter);
    } else {
      _box$3.setFromPoints(points).getCenter(center);
    }
    let maxRadiusSq = 0;
    for (let i2 = 0, il = points.length; i2 < il; i2++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));
    }
    this.radius = Math.sqrt(maxRadiusSq);
    return this;
  }
  /**
   * Copies the values of the given sphere to this instance.
   *
   * @param {Sphere} sphere - The sphere to copy.
   * @return {Sphere} A reference to this sphere.
   */
  copy(sphere) {
    this.center.copy(sphere.center);
    this.radius = sphere.radius;
    return this;
  }
  /**
   * Returns `true` if the sphere is empty (the radius set to a negative number).
   *
   * Spheres with a radius of `0` contain only their center point and are not
   * considered to be empty.
   *
   * @return {boolean} Whether this sphere is empty or not.
   */
  isEmpty() {
    return this.radius < 0;
  }
  /**
   * Makes this sphere empty which means in encloses a zero space in 3D.
   *
   * @return {Sphere} A reference to this sphere.
   */
  makeEmpty() {
    this.center.set(0, 0, 0);
    this.radius = -1;
    return this;
  }
  /**
   * Returns `true` if this sphere contains the given point inclusive of
   * the surface of the sphere.
   *
   * @param {Vector3} point - The point to check.
   * @return {boolean} Whether this sphere contains the given point or not.
   */
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  /**
   * Returns the closest distance from the boundary of the sphere to the
   * given point. If the sphere contains the point, the distance will
   * be negative.
   *
   * @param {Vector3} point - The point to compute the distance to.
   * @return {number} The distance to the point.
   */
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius;
  }
  /**
   * Returns `true` if this sphere intersects with the given one.
   *
   * @param {Sphere} sphere - The sphere to test.
   * @return {boolean} Whether this sphere intersects with the given one or not.
   */
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius;
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
  }
  /**
   * Returns `true` if this sphere intersects with the given box.
   *
   * @param {Box3} box - The box to test.
   * @return {boolean} Whether this sphere intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsSphere(this);
  }
  /**
   * Returns `true` if this sphere intersects with the given plane.
   *
   * @param {Plane} plane - The plane to test.
   * @return {boolean} Whether this sphere intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
  }
  /**
   * Clamps a point within the sphere. If the point is outside the sphere, it
   * will clamp it to the closest point on the edge of the sphere. Points
   * already inside the sphere will not be affected.
   *
   * @param {Vector3} point - The plane to clamp.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The clamped point.
   */
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point);
    target.copy(point);
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize();
      target.multiplyScalar(this.radius).add(this.center);
    }
    return target;
  }
  /**
   * Returns a bounding box that encloses this sphere.
   *
   * @param {Box3} target - The target box that is used to store the method's result.
   * @return {Box3} The bounding box that encloses this sphere.
   */
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty();
      return target;
    }
    target.set(this.center, this.center);
    target.expandByScalar(this.radius);
    return target;
  }
  /**
   * Transforms this sphere with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @return {Sphere} A reference to this sphere.
   */
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix);
    this.radius = this.radius * matrix.getMaxScaleOnAxis();
    return this;
  }
  /**
   * Translates the sphere's center by the given offset.
   *
   * @param {Vector3} offset - The offset.
   * @return {Sphere} A reference to this sphere.
   */
  translate(offset) {
    this.center.add(offset);
    return this;
  }
  /**
   * Expands the boundaries of this sphere to include the given point.
   *
   * @param {Vector3} point - The point to include.
   * @return {Sphere} A reference to this sphere.
   */
  expandByPoint(point) {
    if (this.isEmpty()) {
      this.center.copy(point);
      this.radius = 0;
      return this;
    }
    _v1$6.subVectors(point, this.center);
    const lengthSq = _v1$6.lengthSq();
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq);
      const delta = (length - this.radius) * 0.5;
      this.center.addScaledVector(_v1$6, delta / length);
      this.radius += delta;
    }
    return this;
  }
  /**
   * Expands this sphere to enclose both the original sphere and the given sphere.
   *
   * @param {Sphere} sphere - The sphere to include.
   * @return {Sphere} A reference to this sphere.
   */
  union(sphere) {
    if (sphere.isEmpty()) {
      return this;
    }
    if (this.isEmpty()) {
      this.copy(sphere);
      return this;
    }
    if (this.center.equals(sphere.center) === true) {
      this.radius = Math.max(this.radius, sphere.radius);
    } else {
      _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
      this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
      this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
    }
    return this;
  }
  /**
   * Returns `true` if this sphere is equal with the given one.
   *
   * @param {Sphere} sphere - The sphere to test for equality.
   * @return {boolean} Whether this bounding sphere is equal with the given one.
   */
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius;
  }
  /**
   * Returns a new sphere with copied values from this instance.
   *
   * @return {Sphere} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @return {Object} Serialized structure with fields representing the object state.
   */
  toJSON() {
    return {
      radius: this.radius,
      center: this.center.toArray()
    };
  }
  /**
   * Returns a serialized structure of the bounding sphere.
   *
   * @param {Object} json - The serialized json to set the sphere from.
   * @return {Sphere} A reference to this bounding sphere.
   */
  fromJSON(json) {
    this.radius = json.radius;
    this.center.fromArray(json.center);
    return this;
  }
};
var _vector$a = /* @__PURE__ */ new Vector3();
var _segCenter = /* @__PURE__ */ new Vector3();
var _segDir = /* @__PURE__ */ new Vector3();
var _diff = /* @__PURE__ */ new Vector3();
var _edge1 = /* @__PURE__ */ new Vector3();
var _edge2 = /* @__PURE__ */ new Vector3();
var _normal$1 = /* @__PURE__ */ new Vector3();
var Ray = class {
  /**
   * Constructs a new ray.
   *
   * @param {Vector3} [origin=(0,0,0)] - The origin of the ray.
   * @param {Vector3} [direction=(0,0,-1)] - The (normalized) direction of the ray.
   */
  constructor(origin2 = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin2;
    this.direction = direction;
  }
  /**
   * Sets the ray's components by copying the given values.
   *
   * @param {Vector3} origin - The origin.
   * @param {Vector3} direction - The direction.
   * @return {Ray} A reference to this ray.
   */
  set(origin2, direction) {
    this.origin.copy(origin2);
    this.direction.copy(direction);
    return this;
  }
  /**
   * Copies the values of the given ray to this instance.
   *
   * @param {Ray} ray - The ray to copy.
   * @return {Ray} A reference to this ray.
   */
  copy(ray) {
    this.origin.copy(ray.origin);
    this.direction.copy(ray.direction);
    return this;
  }
  /**
   * Returns a vector that is located at a given distance along this ray.
   *
   * @param {number} t - The distance along the ray to retrieve a position for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} A position on the ray.
   */
  at(t2, target) {
    return target.copy(this.origin).addScaledVector(this.direction, t2);
  }
  /**
   * Adjusts the direction of the ray to point at the given vector in world space.
   *
   * @param {Vector3} v - The target position.
   * @return {Ray} A reference to this ray.
   */
  lookAt(v2) {
    this.direction.copy(v2).sub(this.origin).normalize();
    return this;
  }
  /**
   * Shift the origin of this ray along its direction by the given distance.
   *
   * @param {number} t - The distance along the ray to interpolate.
   * @return {Ray} A reference to this ray.
   */
  recast(t2) {
    this.origin.copy(this.at(t2, _vector$a));
    return this;
  }
  /**
   * Returns the point along this ray that is closest to the given point.
   *
   * @param {Vector3} point - A point in 3D space to get the closet location on the ray for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on this ray.
   */
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin);
    const directionDistance = target.dot(this.direction);
    if (directionDistance < 0) {
      return target.copy(this.origin);
    }
    return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
  }
  /**
   * Returns the distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The distance.
   */
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point));
  }
  /**
   * Returns the squared distance of the closest approach between this ray and the given point.
   *
   * @param {Vector3} point - A point in 3D space to compute the distance to.
   * @return {number} The squared distance.
   */
  distanceSqToPoint(point) {
    const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point);
    }
    _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
    return _vector$a.distanceToSquared(point);
  }
  /**
   * Returns the squared distance between this ray and the given line segment.
   *
   * @param {Vector3} v0 - The start point of the line segment.
   * @param {Vector3} v1 - The end point of the line segment.
   * @param {Vector3} [optionalPointOnRay] - When provided, it receives the point on this ray that is closest to the segment.
   * @param {Vector3} [optionalPointOnSegment] - When provided, it receives the point on the line segment that is closest to this ray.
   * @return {number} The squared distance.
   */
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
    _segDir.copy(v1).sub(v0).normalize();
    _diff.copy(this.origin).sub(_segCenter);
    const segExtent = v0.distanceTo(v1) * 0.5;
    const a01 = -this.direction.dot(_segDir);
    const b0 = _diff.dot(this.direction);
    const b1 = -_diff.dot(_segDir);
    const c2 = _diff.lengthSq();
    const det = Math.abs(1 - a01 * a01);
    let s0, s1, sqrDist, extDet;
    if (det > 0) {
      s0 = a01 * b1 - b0;
      s1 = a01 * b0 - b1;
      extDet = segExtent * det;
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det;
            s0 *= invDet;
            s1 *= invDet;
            sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c2;
          } else {
            s1 = segExtent;
            s0 = Math.max(0, -(a01 * s1 + b0));
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
          }
        } else {
          s1 = -segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0));
          s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        } else if (s1 <= extDet) {
          s0 = 0;
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = s1 * (s1 + 2 * b1) + c2;
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0));
          s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent;
      s0 = Math.max(0, -(a01 * s1 + b0));
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c2;
    }
    if (optionalPointOnRay) {
      optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
    }
    return sqrDist;
  }
  /**
   * Intersects this ray with the given sphere, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin);
    const tca = _vector$a.dot(this.direction);
    const d2 = _vector$a.dot(_vector$a) - tca * tca;
    const radius2 = sphere.radius * sphere.radius;
    if (d2 > radius2) return null;
    const thc = Math.sqrt(radius2 - d2);
    const t0 = tca - thc;
    const t1 = tca + thc;
    if (t1 < 0) return null;
    if (t0 < 0) return this.at(t1, target);
    return this.at(t0, target);
  }
  /**
   * Returns `true` if this ray intersects with the given sphere.
   *
   * @param {Sphere} sphere - The sphere to intersect.
   * @return {boolean} Whether this ray intersects with the given sphere or not.
   */
  intersectsSphere(sphere) {
    if (sphere.radius < 0) return false;
    return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
  }
  /**
   * Computes the distance from the ray's origin to the given plane. Returns `null` if the ray
   * does not intersect with the plane.
   *
   * @param {Plane} plane - The plane to compute the distance to.
   * @return {?number} Whether this ray intersects with the given sphere or not.
   */
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction);
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0;
      }
      return null;
    }
    const t2 = -(this.origin.dot(plane.normal) + plane.constant) / denominator;
    return t2 >= 0 ? t2 : null;
  }
  /**
   * Intersects this ray with the given plane, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Plane} plane - The plane to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectPlane(plane, target) {
    const t2 = this.distanceToPlane(plane);
    if (t2 === null) {
      return null;
    }
    return this.at(t2, target);
  }
  /**
   * Returns `true` if this ray intersects with the given plane.
   *
   * @param {Plane} plane - The plane to intersect.
   * @return {boolean} Whether this ray intersects with the given plane or not.
   */
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin);
    if (distToPoint === 0) {
      return true;
    }
    const denominator = plane.normal.dot(this.direction);
    if (denominator * distToPoint < 0) {
      return true;
    }
    return false;
  }
  /**
   * Intersects this ray with the given bounding box, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Box3} box - The box to intersect.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax;
    const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;
    const origin2 = this.origin;
    if (invdirx >= 0) {
      tmin = (box.min.x - origin2.x) * invdirx;
      tmax = (box.max.x - origin2.x) * invdirx;
    } else {
      tmin = (box.max.x - origin2.x) * invdirx;
      tmax = (box.min.x - origin2.x) * invdirx;
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin2.y) * invdiry;
      tymax = (box.max.y - origin2.y) * invdiry;
    } else {
      tymin = (box.max.y - origin2.y) * invdiry;
      tymax = (box.min.y - origin2.y) * invdiry;
    }
    if (tmin > tymax || tymin > tmax) return null;
    if (tymin > tmin || isNaN(tmin)) tmin = tymin;
    if (tymax < tmax || isNaN(tmax)) tmax = tymax;
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin2.z) * invdirz;
      tzmax = (box.max.z - origin2.z) * invdirz;
    } else {
      tzmin = (box.max.z - origin2.z) * invdirz;
      tzmax = (box.min.z - origin2.z) * invdirz;
    }
    if (tmin > tzmax || tzmin > tmax) return null;
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax;
    if (tmax < 0) return null;
    return this.at(tmin >= 0 ? tmin : tmax, target);
  }
  /**
   * Returns `true` if this ray intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this ray intersects with the given box or not.
   */
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null;
  }
  /**
   * Intersects this ray with the given triangle, returning the intersection
   * point or `null` if there is no intersection.
   *
   * @param {Vector3} a - The first vertex of the triangle.
   * @param {Vector3} b - The second vertex of the triangle.
   * @param {Vector3} c - The third vertex of the triangle.
   * @param {boolean} backfaceCulling - Whether to use backface culling or not.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectTriangle(a2, b2, c2, backfaceCulling, target) {
    _edge1.subVectors(b2, a2);
    _edge2.subVectors(c2, a2);
    _normal$1.crossVectors(_edge1, _edge2);
    let DdN = this.direction.dot(_normal$1);
    let sign;
    if (DdN > 0) {
      if (backfaceCulling) return null;
      sign = 1;
    } else if (DdN < 0) {
      sign = -1;
      DdN = -DdN;
    } else {
      return null;
    }
    _diff.subVectors(this.origin, a2);
    const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));
    if (DdQxE2 < 0) {
      return null;
    }
    const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));
    if (DdE1xQ < 0) {
      return null;
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null;
    }
    const QdN = -sign * _diff.dot(_normal$1);
    if (QdN < 0) {
      return null;
    }
    return this.at(QdN / DdN, target);
  }
  /**
   * Transforms this ray with the given 4x4 transformation matrix.
   *
   * @param {Matrix4} matrix4 - The transformation matrix.
   * @return {Ray} A reference to this ray.
   */
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4);
    this.direction.transformDirection(matrix4);
    return this;
  }
  /**
   * Returns `true` if this ray is equal with the given one.
   *
   * @param {Ray} ray - The ray to test for equality.
   * @return {boolean} Whether this ray is equal with the given one.
   */
  equals(ray) {
    return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
  }
  /**
   * Returns a new ray with copied values from this instance.
   *
   * @return {Ray} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
};
var Matrix4 = class _Matrix4 {
  /**
   * Constructs a new 4x4 matrix. The arguments are supposed to be
   * in row-major order. If no arguments are provided, the constructor
   * initializes the matrix as an identity matrix.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   */
  constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    _Matrix4.prototype.isMatrix4 = true;
    this.elements = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
    if (n11 !== void 0) {
      this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
    }
  }
  /**
   * Sets the elements of the matrix.The arguments are supposed to be
   * in row-major order.
   *
   * @param {number} [n11] - 1-1 matrix element.
   * @param {number} [n12] - 1-2 matrix element.
   * @param {number} [n13] - 1-3 matrix element.
   * @param {number} [n14] - 1-4 matrix element.
   * @param {number} [n21] - 2-1 matrix element.
   * @param {number} [n22] - 2-2 matrix element.
   * @param {number} [n23] - 2-3 matrix element.
   * @param {number} [n24] - 2-4 matrix element.
   * @param {number} [n31] - 3-1 matrix element.
   * @param {number} [n32] - 3-2 matrix element.
   * @param {number} [n33] - 3-3 matrix element.
   * @param {number} [n34] - 3-4 matrix element.
   * @param {number} [n41] - 4-1 matrix element.
   * @param {number} [n42] - 4-2 matrix element.
   * @param {number} [n43] - 4-3 matrix element.
   * @param {number} [n44] - 4-4 matrix element.
   * @return {Matrix4} A reference to this matrix.
   */
  set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
    const te2 = this.elements;
    te2[0] = n11;
    te2[4] = n12;
    te2[8] = n13;
    te2[12] = n14;
    te2[1] = n21;
    te2[5] = n22;
    te2[9] = n23;
    te2[13] = n24;
    te2[2] = n31;
    te2[6] = n32;
    te2[10] = n33;
    te2[14] = n34;
    te2[3] = n41;
    te2[7] = n42;
    te2[11] = n43;
    te2[15] = n44;
    return this;
  }
  /**
   * Sets this matrix to the 4x4 identity matrix.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  identity() {
    this.set(
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Returns a matrix with copied values from this instance.
   *
   * @return {Matrix4} A clone of this instance.
   */
  clone() {
    return new _Matrix4().fromArray(this.elements);
  }
  /**
   * Copies the values of the given matrix to this instance.
   *
   * @param {Matrix4} m - The matrix to copy.
   * @return {Matrix4} A reference to this matrix.
   */
  copy(m2) {
    const te2 = this.elements;
    const me2 = m2.elements;
    te2[0] = me2[0];
    te2[1] = me2[1];
    te2[2] = me2[2];
    te2[3] = me2[3];
    te2[4] = me2[4];
    te2[5] = me2[5];
    te2[6] = me2[6];
    te2[7] = me2[7];
    te2[8] = me2[8];
    te2[9] = me2[9];
    te2[10] = me2[10];
    te2[11] = me2[11];
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    te2[15] = me2[15];
    return this;
  }
  /**
   * Copies the translation component of the given matrix
   * into this matrix's translation component.
   *
   * @param {Matrix4} m - The matrix to copy the translation component.
   * @return {Matrix4} A reference to this matrix.
   */
  copyPosition(m2) {
    const te2 = this.elements, me2 = m2.elements;
    te2[12] = me2[12];
    te2[13] = me2[13];
    te2[14] = me2[14];
    return this;
  }
  /**
   * Set the upper 3x3 elements of this matrix to the values of given 3x3 matrix.
   *
   * @param {Matrix3} m - The 3x3 matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  setFromMatrix3(m2) {
    const me2 = m2.elements;
    this.set(
      me2[0],
      me2[3],
      me2[6],
      0,
      me2[1],
      me2[4],
      me2[7],
      0,
      me2[2],
      me2[5],
      me2[8],
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the basis of this matrix into the three axis vectors provided.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  extractBasis(xAxis, yAxis, zAxis) {
    if (this.determinant() === 0) {
      xAxis.set(1, 0, 0);
      yAxis.set(0, 1, 0);
      zAxis.set(0, 0, 1);
      return this;
    }
    xAxis.setFromMatrixColumn(this, 0);
    yAxis.setFromMatrixColumn(this, 1);
    zAxis.setFromMatrixColumn(this, 2);
    return this;
  }
  /**
   * Sets the given basis vectors to this matrix.
   *
   * @param {Vector3} xAxis - The basis's x axis.
   * @param {Vector3} yAxis - The basis's y axis.
   * @param {Vector3} zAxis - The basis's z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Extracts the rotation component of the given matrix
   * into this matrix's rotation component.
   *
   * Note: This method does not support reflection matrices.
   *
   * @param {Matrix4} m - The matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  extractRotation(m2) {
    if (m2.determinant() === 0) {
      return this.identity();
    }
    const te2 = this.elements;
    const me2 = m2.elements;
    const scaleX = 1 / _v1$5.setFromMatrixColumn(m2, 0).length();
    const scaleY = 1 / _v1$5.setFromMatrixColumn(m2, 1).length();
    const scaleZ = 1 / _v1$5.setFromMatrixColumn(m2, 2).length();
    te2[0] = me2[0] * scaleX;
    te2[1] = me2[1] * scaleX;
    te2[2] = me2[2] * scaleX;
    te2[3] = 0;
    te2[4] = me2[4] * scaleY;
    te2[5] = me2[5] * scaleY;
    te2[6] = me2[6] * scaleY;
    te2[7] = 0;
    te2[8] = me2[8] * scaleZ;
    te2[9] = me2[9] * scaleZ;
    te2[10] = me2[10] * scaleZ;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component (the upper left 3x3 matrix) of this matrix to
   * the rotation specified by the given Euler angles. The rest of
   * the matrix is set to the identity. Depending on the {@link Euler#order},
   * there are six possible outcomes. See [this page](https://en.wikipedia.org/wiki/Euler_angles#Rotation_matrix)
   * for a complete list.
   *
   * @param {Euler} euler - The Euler angles.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromEuler(euler) {
    const te2 = this.elements;
    const x2 = euler.x, y2 = euler.y, z2 = euler.z;
    const a2 = Math.cos(x2), b2 = Math.sin(x2);
    const c2 = Math.cos(y2), d2 = Math.sin(y2);
    const e2 = Math.cos(z2), f2 = Math.sin(z2);
    if (euler.order === "XYZ") {
      const ae2 = a2 * e2, af = a2 * f2, be2 = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = -c2 * f2;
      te2[8] = d2;
      te2[1] = af + be2 * d2;
      te2[5] = ae2 - bf * d2;
      te2[9] = -b2 * c2;
      te2[2] = bf - ae2 * d2;
      te2[6] = be2 + af * d2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YXZ") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 + df * b2;
      te2[4] = de2 * b2 - cf;
      te2[8] = a2 * d2;
      te2[1] = a2 * f2;
      te2[5] = a2 * e2;
      te2[9] = -b2;
      te2[2] = cf * b2 - de2;
      te2[6] = df + ce2 * b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZXY") {
      const ce2 = c2 * e2, cf = c2 * f2, de2 = d2 * e2, df = d2 * f2;
      te2[0] = ce2 - df * b2;
      te2[4] = -a2 * f2;
      te2[8] = de2 + cf * b2;
      te2[1] = cf + de2 * b2;
      te2[5] = a2 * e2;
      te2[9] = df - ce2 * b2;
      te2[2] = -a2 * d2;
      te2[6] = b2;
      te2[10] = a2 * c2;
    } else if (euler.order === "ZYX") {
      const ae2 = a2 * e2, af = a2 * f2, be2 = b2 * e2, bf = b2 * f2;
      te2[0] = c2 * e2;
      te2[4] = be2 * d2 - af;
      te2[8] = ae2 * d2 + bf;
      te2[1] = c2 * f2;
      te2[5] = bf * d2 + ae2;
      te2[9] = af * d2 - be2;
      te2[2] = -d2;
      te2[6] = b2 * c2;
      te2[10] = a2 * c2;
    } else if (euler.order === "YZX") {
      const ac2 = a2 * c2, ad = a2 * d2, bc2 = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = bd - ac2 * f2;
      te2[8] = bc2 * f2 + ad;
      te2[1] = f2;
      te2[5] = a2 * e2;
      te2[9] = -b2 * e2;
      te2[2] = -d2 * e2;
      te2[6] = ad * f2 + bc2;
      te2[10] = ac2 - bd * f2;
    } else if (euler.order === "XZY") {
      const ac2 = a2 * c2, ad = a2 * d2, bc2 = b2 * c2, bd = b2 * d2;
      te2[0] = c2 * e2;
      te2[4] = -f2;
      te2[8] = d2 * e2;
      te2[1] = ac2 * f2 + bd;
      te2[5] = a2 * e2;
      te2[9] = ad * f2 - bc2;
      te2[2] = bc2 * f2 - ad;
      te2[6] = b2 * e2;
      te2[10] = bd * f2 + ac2;
    }
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[12] = 0;
    te2[13] = 0;
    te2[14] = 0;
    te2[15] = 1;
    return this;
  }
  /**
   * Sets the rotation component of this matrix to the rotation specified by
   * the given Quaternion as outlined [here](https://en.wikipedia.org/wiki/Rotation_matrix#Quaternion)
   * The rest of the matrix is set to the identity.
   *
   * @param {Quaternion} q - The Quaternion.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationFromQuaternion(q2) {
    return this.compose(_zero, q2, _one);
  }
  /**
   * Sets the rotation component of the transformation matrix, looking from `eye` towards
   * `target`, and oriented by the up-direction.
   *
   * @param {Vector3} eye - The eye vector.
   * @param {Vector3} target - The target vector.
   * @param {Vector3} up - The up vector.
   * @return {Matrix4} A reference to this matrix.
   */
  lookAt(eye, target, up) {
    const te2 = this.elements;
    _z.subVectors(eye, target);
    if (_z.lengthSq() === 0) {
      _z.z = 1;
    }
    _z.normalize();
    _x.crossVectors(up, _z);
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4;
      } else {
        _z.z += 1e-4;
      }
      _z.normalize();
      _x.crossVectors(up, _z);
    }
    _x.normalize();
    _y.crossVectors(_z, _x);
    te2[0] = _x.x;
    te2[4] = _y.x;
    te2[8] = _z.x;
    te2[1] = _x.y;
    te2[5] = _y.y;
    te2[9] = _z.y;
    te2[2] = _x.z;
    te2[6] = _y.z;
    te2[10] = _z.z;
    return this;
  }
  /**
   * Post-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  multiply(m2) {
    return this.multiplyMatrices(this, m2);
  }
  /**
   * Pre-multiplies this matrix by the given 4x4 matrix.
   *
   * @param {Matrix4} m - The matrix to multiply with.
   * @return {Matrix4} A reference to this matrix.
   */
  premultiply(m2) {
    return this.multiplyMatrices(m2, this);
  }
  /**
   * Multiples the given 4x4 matrices and stores the result
   * in this matrix.
   *
   * @param {Matrix4} a - The first matrix.
   * @param {Matrix4} b - The second matrix.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyMatrices(a2, b2) {
    const ae2 = a2.elements;
    const be2 = b2.elements;
    const te2 = this.elements;
    const a11 = ae2[0], a12 = ae2[4], a13 = ae2[8], a14 = ae2[12];
    const a21 = ae2[1], a22 = ae2[5], a23 = ae2[9], a24 = ae2[13];
    const a31 = ae2[2], a32 = ae2[6], a33 = ae2[10], a34 = ae2[14];
    const a41 = ae2[3], a42 = ae2[7], a43 = ae2[11], a44 = ae2[15];
    const b11 = be2[0], b12 = be2[4], b13 = be2[8], b14 = be2[12];
    const b21 = be2[1], b22 = be2[5], b23 = be2[9], b24 = be2[13];
    const b31 = be2[2], b32 = be2[6], b33 = be2[10], b34 = be2[14];
    const b41 = be2[3], b42 = be2[7], b43 = be2[11], b44 = be2[15];
    te2[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
    te2[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
    te2[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
    te2[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
    te2[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
    te2[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
    te2[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
    te2[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
    te2[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
    te2[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
    te2[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
    te2[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
    te2[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
    te2[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
    te2[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
    te2[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
    return this;
  }
  /**
   * Multiplies every component of the matrix by the given scalar.
   *
   * @param {number} s - The scalar.
   * @return {Matrix4} A reference to this matrix.
   */
  multiplyScalar(s2) {
    const te2 = this.elements;
    te2[0] *= s2;
    te2[4] *= s2;
    te2[8] *= s2;
    te2[12] *= s2;
    te2[1] *= s2;
    te2[5] *= s2;
    te2[9] *= s2;
    te2[13] *= s2;
    te2[2] *= s2;
    te2[6] *= s2;
    te2[10] *= s2;
    te2[14] *= s2;
    te2[3] *= s2;
    te2[7] *= s2;
    te2[11] *= s2;
    te2[15] *= s2;
    return this;
  }
  /**
   * Computes and returns the determinant of this matrix.
   *
   * Based on the method outlined [here](http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.html).
   *
   * @return {number} The determinant.
   */
  determinant() {
    const te2 = this.elements;
    const n11 = te2[0], n12 = te2[4], n13 = te2[8], n14 = te2[12];
    const n21 = te2[1], n22 = te2[5], n23 = te2[9], n24 = te2[13];
    const n31 = te2[2], n32 = te2[6], n33 = te2[10], n34 = te2[14];
    const n41 = te2[3], n42 = te2[7], n43 = te2[11], n44 = te2[15];
    const t11 = n23 * n34 - n24 * n33;
    const t12 = n22 * n34 - n24 * n32;
    const t13 = n22 * n33 - n23 * n32;
    const t21 = n21 * n34 - n24 * n31;
    const t22 = n21 * n33 - n23 * n31;
    const t23 = n21 * n32 - n22 * n31;
    return n11 * (n42 * t11 - n43 * t12 + n44 * t13) - n12 * (n41 * t11 - n43 * t21 + n44 * t22) + n13 * (n41 * t12 - n42 * t21 + n44 * t23) - n14 * (n41 * t13 - n42 * t22 + n43 * t23);
  }
  /**
   * Transposes this matrix in place.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  transpose() {
    const te2 = this.elements;
    let tmp;
    tmp = te2[1];
    te2[1] = te2[4];
    te2[4] = tmp;
    tmp = te2[2];
    te2[2] = te2[8];
    te2[8] = tmp;
    tmp = te2[6];
    te2[6] = te2[9];
    te2[9] = tmp;
    tmp = te2[3];
    te2[3] = te2[12];
    te2[12] = tmp;
    tmp = te2[7];
    te2[7] = te2[13];
    te2[13] = tmp;
    tmp = te2[11];
    te2[11] = te2[14];
    te2[14] = tmp;
    return this;
  }
  /**
   * Sets the position component for this matrix from the given vector,
   * without affecting the rest of the matrix.
   *
   * @param {number|Vector3} x - The x component of the vector or alternatively the vector object.
   * @param {number} y - The y component of the vector.
   * @param {number} z - The z component of the vector.
   * @return {Matrix4} A reference to this matrix.
   */
  setPosition(x2, y2, z2) {
    const te2 = this.elements;
    if (x2.isVector3) {
      te2[12] = x2.x;
      te2[13] = x2.y;
      te2[14] = x2.z;
    } else {
      te2[12] = x2;
      te2[13] = y2;
      te2[14] = z2;
    }
    return this;
  }
  /**
   * Inverts this matrix, using the [analytic method](https://en.wikipedia.org/wiki/Invertible_matrix#Analytic_solution).
   * You can not invert with a determinant of zero. If you attempt this, the method produces
   * a zero matrix instead.
   *
   * @return {Matrix4} A reference to this matrix.
   */
  invert() {
    const te2 = this.elements, n11 = te2[0], n21 = te2[1], n31 = te2[2], n41 = te2[3], n12 = te2[4], n22 = te2[5], n32 = te2[6], n42 = te2[7], n13 = te2[8], n23 = te2[9], n33 = te2[10], n43 = te2[11], n14 = te2[12], n24 = te2[13], n34 = te2[14], n44 = te2[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const detInv = 1 / det;
    te2[0] = t11 * detInv;
    te2[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
    te2[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
    te2[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
    te2[4] = t12 * detInv;
    te2[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
    te2[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
    te2[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
    te2[8] = t13 * detInv;
    te2[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
    te2[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
    te2[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
    te2[12] = t14 * detInv;
    te2[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
    te2[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
    te2[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
    return this;
  }
  /**
   * Multiplies the columns of this matrix by the given vector.
   *
   * @param {Vector3} v - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  scale(v2) {
    const te2 = this.elements;
    const x2 = v2.x, y2 = v2.y, z2 = v2.z;
    te2[0] *= x2;
    te2[4] *= y2;
    te2[8] *= z2;
    te2[1] *= x2;
    te2[5] *= y2;
    te2[9] *= z2;
    te2[2] *= x2;
    te2[6] *= y2;
    te2[10] *= z2;
    te2[3] *= x2;
    te2[7] *= y2;
    te2[11] *= z2;
    return this;
  }
  /**
   * Gets the maximum scale value of the three axes.
   *
   * @return {number} The maximum scale.
   */
  getMaxScaleOnAxis() {
    const te2 = this.elements;
    const scaleXSq = te2[0] * te2[0] + te2[1] * te2[1] + te2[2] * te2[2];
    const scaleYSq = te2[4] * te2[4] + te2[5] * te2[5] + te2[6] * te2[6];
    const scaleZSq = te2[8] * te2[8] + te2[9] * te2[9] + te2[10] * te2[10];
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
  }
  /**
   * Sets this matrix as a translation transform from the given vector.
   *
   * @param {number|Vector3} x - The amount to translate in the X axis or alternatively a translation vector.
   * @param {number} y - The amount to translate in the Y axis.
   * @param {number} z - The amount to translate in the z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeTranslation(x2, y2, z2) {
    if (x2.isVector3) {
      this.set(
        1,
        0,
        0,
        x2.x,
        0,
        1,
        0,
        x2.y,
        0,
        0,
        1,
        x2.z,
        0,
        0,
        0,
        1
      );
    } else {
      this.set(
        1,
        0,
        0,
        x2,
        0,
        1,
        0,
        y2,
        0,
        0,
        1,
        z2,
        0,
        0,
        0,
        1
      );
    }
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the X axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationX(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      1,
      0,
      0,
      0,
      0,
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Y axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationY(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      0,
      s2,
      0,
      0,
      1,
      0,
      0,
      -s2,
      0,
      c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the Z axis by
   * the given angle.
   *
   * @param {number} theta - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationZ(theta) {
    const c2 = Math.cos(theta), s2 = Math.sin(theta);
    this.set(
      c2,
      -s2,
      0,
      0,
      s2,
      c2,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a rotational transformation around the given axis by
   * the given angle.
   *
   * This is a somewhat controversial but mathematically sound alternative to
   * rotating via Quaternions. See the discussion [here](https://www.gamedev.net/articles/programming/math-and-physics/do-we-really-need-quaternions-r1199).
   *
   * @param {Vector3} axis - The normalized rotation axis.
   * @param {number} angle - The rotation in radians.
   * @return {Matrix4} A reference to this matrix.
   */
  makeRotationAxis(axis, angle) {
    const c2 = Math.cos(angle);
    const s2 = Math.sin(angle);
    const t2 = 1 - c2;
    const x2 = axis.x, y2 = axis.y, z2 = axis.z;
    const tx = t2 * x2, ty = t2 * y2;
    this.set(
      tx * x2 + c2,
      tx * y2 - s2 * z2,
      tx * z2 + s2 * y2,
      0,
      tx * y2 + s2 * z2,
      ty * y2 + c2,
      ty * z2 - s2 * x2,
      0,
      tx * z2 - s2 * y2,
      ty * z2 + s2 * x2,
      t2 * z2 * z2 + c2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a scale transformation.
   *
   * @param {number} x - The amount to scale in the X axis.
   * @param {number} y - The amount to scale in the Y axis.
   * @param {number} z - The amount to scale in the Z axis.
   * @return {Matrix4} A reference to this matrix.
   */
  makeScale(x2, y2, z2) {
    this.set(
      x2,
      0,
      0,
      0,
      0,
      y2,
      0,
      0,
      0,
      0,
      z2,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix as a shear transformation.
   *
   * @param {number} xy - The amount to shear X by Y.
   * @param {number} xz - The amount to shear X by Z.
   * @param {number} yx - The amount to shear Y by X.
   * @param {number} yz - The amount to shear Y by Z.
   * @param {number} zx - The amount to shear Z by X.
   * @param {number} zy - The amount to shear Z by Y.
   * @return {Matrix4} A reference to this matrix.
   */
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(
      1,
      yx,
      zx,
      0,
      xy,
      1,
      zy,
      0,
      xz,
      yz,
      1,
      0,
      0,
      0,
      0,
      1
    );
    return this;
  }
  /**
   * Sets this matrix to the transformation composed of the given position,
   * rotation (Quaternion) and scale.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  compose(position, quaternion, scale) {
    const te2 = this.elements;
    const x2 = quaternion._x, y2 = quaternion._y, z2 = quaternion._z, w2 = quaternion._w;
    const x22 = x2 + x2, y22 = y2 + y2, z22 = z2 + z2;
    const xx = x2 * x22, xy = x2 * y22, xz = x2 * z22;
    const yy = y2 * y22, yz = y2 * z22, zz = z2 * z22;
    const wx = w2 * x22, wy = w2 * y22, wz = w2 * z22;
    const sx = scale.x, sy = scale.y, sz = scale.z;
    te2[0] = (1 - (yy + zz)) * sx;
    te2[1] = (xy + wz) * sx;
    te2[2] = (xz - wy) * sx;
    te2[3] = 0;
    te2[4] = (xy - wz) * sy;
    te2[5] = (1 - (xx + zz)) * sy;
    te2[6] = (yz + wx) * sy;
    te2[7] = 0;
    te2[8] = (xz + wy) * sz;
    te2[9] = (yz - wx) * sz;
    te2[10] = (1 - (xx + yy)) * sz;
    te2[11] = 0;
    te2[12] = position.x;
    te2[13] = position.y;
    te2[14] = position.z;
    te2[15] = 1;
    return this;
  }
  /**
   * Decomposes this matrix into its position, rotation and scale components
   * and provides the result in the given objects.
   *
   * Note: Not all matrices are decomposable in this way. For example, if an
   * object has a non-uniformly scaled parent, then the object's world matrix
   * may not be decomposable, and this method may not be appropriate.
   *
   * @param {Vector3} position - The position vector.
   * @param {Quaternion} quaternion - The rotation as a Quaternion.
   * @param {Vector3} scale - The scale vector.
   * @return {Matrix4} A reference to this matrix.
   */
  decompose(position, quaternion, scale) {
    const te2 = this.elements;
    position.x = te2[12];
    position.y = te2[13];
    position.z = te2[14];
    if (this.determinant() === 0) {
      scale.set(1, 1, 1);
      quaternion.identity();
      return this;
    }
    let sx = _v1$5.set(te2[0], te2[1], te2[2]).length();
    const sy = _v1$5.set(te2[4], te2[5], te2[6]).length();
    const sz = _v1$5.set(te2[8], te2[9], te2[10]).length();
    const det = this.determinant();
    if (det < 0) sx = -sx;
    _m1$2.copy(this);
    const invSX = 1 / sx;
    const invSY = 1 / sy;
    const invSZ = 1 / sz;
    _m1$2.elements[0] *= invSX;
    _m1$2.elements[1] *= invSX;
    _m1$2.elements[2] *= invSX;
    _m1$2.elements[4] *= invSY;
    _m1$2.elements[5] *= invSY;
    _m1$2.elements[6] *= invSY;
    _m1$2.elements[8] *= invSZ;
    _m1$2.elements[9] *= invSZ;
    _m1$2.elements[10] *= invSZ;
    quaternion.setFromRotationMatrix(_m1$2);
    scale.x = sx;
    scale.y = sy;
    scale.z = sz;
    return this;
  }
  /**
  	 * Creates a perspective projection matrix. This is used internally by
  	 * {@link PerspectiveCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
    const te2 = this.elements;
    const x2 = 2 * near / (right - left);
    const y2 = 2 * near / (top - bottom);
    const a2 = (right + left) / (right - left);
    const b2 = (top + bottom) / (top - bottom);
    let c2, d2;
    if (reversedDepth) {
      c2 = near / (far - near);
      d2 = far * near / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c2 = -(far + near) / (far - near);
        d2 = -2 * far * near / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c2 = -far / (far - near);
        d2 = -far * near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + coordinateSystem);
      }
    }
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = a2;
    te2[12] = 0;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = b2;
    te2[13] = 0;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = -1;
    te2[15] = 0;
    return this;
  }
  /**
  	 * Creates a orthographic projection matrix. This is used internally by
  	 * {@link OrthographicCamera#updateProjectionMatrix}.
  
  	 * @param {number} left - Left boundary of the viewing frustum at the near plane.
  	 * @param {number} right - Right boundary of the viewing frustum at the near plane.
  	 * @param {number} top - Top boundary of the viewing frustum at the near plane.
  	 * @param {number} bottom - Bottom boundary of the viewing frustum at the near plane.
  	 * @param {number} near - The distance from the camera to the near plane.
  	 * @param {number} far - The distance from the camera to the far plane.
  	 * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} [coordinateSystem=WebGLCoordinateSystem] - The coordinate system.
  	 * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
  	 * @return {Matrix4} A reference to this matrix.
  	 */
  makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
    const te2 = this.elements;
    const x2 = 2 / (right - left);
    const y2 = 2 / (top - bottom);
    const a2 = -(right + left) / (right - left);
    const b2 = -(top + bottom) / (top - bottom);
    let c2, d2;
    if (reversedDepth) {
      c2 = 1 / (far - near);
      d2 = far / (far - near);
    } else {
      if (coordinateSystem === WebGLCoordinateSystem) {
        c2 = -2 / (far - near);
        d2 = -(far + near) / (far - near);
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        c2 = -1 / (far - near);
        d2 = -near / (far - near);
      } else {
        throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + coordinateSystem);
      }
    }
    te2[0] = x2;
    te2[4] = 0;
    te2[8] = 0;
    te2[12] = a2;
    te2[1] = 0;
    te2[5] = y2;
    te2[9] = 0;
    te2[13] = b2;
    te2[2] = 0;
    te2[6] = 0;
    te2[10] = c2;
    te2[14] = d2;
    te2[3] = 0;
    te2[7] = 0;
    te2[11] = 0;
    te2[15] = 1;
    return this;
  }
  /**
   * Returns `true` if this matrix is equal with the given one.
   *
   * @param {Matrix4} matrix - The matrix to test for equality.
   * @return {boolean} Whether this matrix is equal with the given one.
   */
  equals(matrix) {
    const te2 = this.elements;
    const me2 = matrix.elements;
    for (let i2 = 0; i2 < 16; i2++) {
      if (te2[i2] !== me2[i2]) return false;
    }
    return true;
  }
  /**
   * Sets the elements of the matrix from the given array.
   *
   * @param {Array<number>} array - The matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Matrix4} A reference to this matrix.
   */
  fromArray(array, offset = 0) {
    for (let i2 = 0; i2 < 16; i2++) {
      this.elements[i2] = array[i2 + offset];
    }
    return this;
  }
  /**
   * Writes the elements of this matrix to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the matrix elements in column-major order.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The matrix elements in column-major order.
   */
  toArray(array = [], offset = 0) {
    const te2 = this.elements;
    array[offset] = te2[0];
    array[offset + 1] = te2[1];
    array[offset + 2] = te2[2];
    array[offset + 3] = te2[3];
    array[offset + 4] = te2[4];
    array[offset + 5] = te2[5];
    array[offset + 6] = te2[6];
    array[offset + 7] = te2[7];
    array[offset + 8] = te2[8];
    array[offset + 9] = te2[9];
    array[offset + 10] = te2[10];
    array[offset + 11] = te2[11];
    array[offset + 12] = te2[12];
    array[offset + 13] = te2[13];
    array[offset + 14] = te2[14];
    array[offset + 15] = te2[15];
    return array;
  }
};
var _v1$5 = /* @__PURE__ */ new Vector3();
var _m1$2 = /* @__PURE__ */ new Matrix4();
var _zero = /* @__PURE__ */ new Vector3(0, 0, 0);
var _one = /* @__PURE__ */ new Vector3(1, 1, 1);
var _x = /* @__PURE__ */ new Vector3();
var _y = /* @__PURE__ */ new Vector3();
var _z = /* @__PURE__ */ new Vector3();
var _matrix$2 = /* @__PURE__ */ new Matrix4();
var _quaternion$3 = /* @__PURE__ */ new Quaternion();
var Euler = class _Euler {
  /**
   * Constructs a new euler instance.
   *
   * @param {number} [x=0] - The angle of the x axis in radians.
   * @param {number} [y=0] - The angle of the y axis in radians.
   * @param {number} [z=0] - The angle of the z axis in radians.
   * @param {string} [order=Euler.DEFAULT_ORDER] - A string representing the order that the rotations are applied.
   */
  constructor(x2 = 0, y2 = 0, z2 = 0, order = _Euler.DEFAULT_ORDER) {
    this.isEuler = true;
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
  }
  /**
   * The angle of the x axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get x() {
    return this._x;
  }
  set x(value) {
    this._x = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the y axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get y() {
    return this._y;
  }
  set y(value) {
    this._y = value;
    this._onChangeCallback();
  }
  /**
   * The angle of the z axis in radians.
   *
   * @type {number}
   * @default 0
   */
  get z() {
    return this._z;
  }
  set z(value) {
    this._z = value;
    this._onChangeCallback();
  }
  /**
   * A string representing the order that the rotations are applied.
   *
   * @type {string}
   * @default 'XYZ'
   */
  get order() {
    return this._order;
  }
  set order(value) {
    this._order = value;
    this._onChangeCallback();
  }
  /**
   * Sets the Euler components.
   *
   * @param {number} x - The angle of the x axis in radians.
   * @param {number} y - The angle of the y axis in radians.
   * @param {number} z - The angle of the z axis in radians.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  set(x2, y2, z2, order = this._order) {
    this._x = x2;
    this._y = y2;
    this._z = z2;
    this._order = order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Returns a new Euler instance with copied values from this instance.
   *
   * @return {Euler} A clone of this instance.
   */
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  /**
   * Copies the values of the given Euler instance to this instance.
   *
   * @param {Euler} euler - The Euler instance to copy.
   * @return {Euler} A reference to this Euler instance.
   */
  copy(euler) {
    this._x = euler._x;
    this._y = euler._y;
    this._z = euler._z;
    this._order = euler._order;
    this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a pure rotation matrix.
   *
   * @param {Matrix4} m - A 4x4 matrix of which the upper 3x3 of matrix is a pure rotation matrix (i.e. unscaled).
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromRotationMatrix(m2, order = this._order, update = true) {
    const te2 = m2.elements;
    const m11 = te2[0], m12 = te2[4], m13 = te2[8];
    const m21 = te2[1], m22 = te2[5], m23 = te2[9];
    const m31 = te2[2], m32 = te2[6], m33 = te2[10];
    switch (order) {
      case "XYZ":
        this._y = Math.asin(clamp(m13, -1, 1));
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33);
          this._z = Math.atan2(-m12, m11);
        } else {
          this._x = Math.atan2(m32, m22);
          this._z = 0;
        }
        break;
      case "YXZ":
        this._x = Math.asin(-clamp(m23, -1, 1));
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33);
          this._z = Math.atan2(m21, m22);
        } else {
          this._y = Math.atan2(-m31, m11);
          this._z = 0;
        }
        break;
      case "ZXY":
        this._x = Math.asin(clamp(m32, -1, 1));
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33);
          this._z = Math.atan2(-m12, m22);
        } else {
          this._y = 0;
          this._z = Math.atan2(m21, m11);
        }
        break;
      case "ZYX":
        this._y = Math.asin(-clamp(m31, -1, 1));
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33);
          this._z = Math.atan2(m21, m11);
        } else {
          this._x = 0;
          this._z = Math.atan2(-m12, m22);
        }
        break;
      case "YZX":
        this._z = Math.asin(clamp(m21, -1, 1));
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22);
          this._y = Math.atan2(-m31, m11);
        } else {
          this._x = 0;
          this._y = Math.atan2(m13, m33);
        }
        break;
      case "XZY":
        this._z = Math.asin(-clamp(m12, -1, 1));
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22);
          this._y = Math.atan2(m13, m11);
        } else {
          this._x = Math.atan2(-m23, m33);
          this._y = 0;
        }
        break;
      default:
        warn("Euler: .setFromRotationMatrix() encountered an unknown order: " + order);
    }
    this._order = order;
    if (update === true) this._onChangeCallback();
    return this;
  }
  /**
   * Sets the angles of this Euler instance from a normalized quaternion.
   *
   * @param {Quaternion} q - A normalized Quaternion.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @param {boolean} [update=true] - Whether the internal `onChange` callback should be executed or not.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromQuaternion(q2, order, update) {
    _matrix$2.makeRotationFromQuaternion(q2);
    return this.setFromRotationMatrix(_matrix$2, order, update);
  }
  /**
   * Sets the angles of this Euler instance from the given vector.
   *
   * @param {Vector3} v - The vector.
   * @param {string} [order] - A string representing the order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  setFromVector3(v2, order = this._order) {
    return this.set(v2.x, v2.y, v2.z, order);
  }
  /**
   * Resets the euler angle with a new order by creating a quaternion from this
   * euler angle and then setting this euler angle with the quaternion and the
   * new order.
   *
   * Warning: This discards revolution information.
   *
   * @param {string} [newOrder] - A string representing the new order that the rotations are applied.
   * @return {Euler} A reference to this Euler instance.
   */
  reorder(newOrder) {
    _quaternion$3.setFromEuler(this);
    return this.setFromQuaternion(_quaternion$3, newOrder);
  }
  /**
   * Returns `true` if this Euler instance is equal with the given one.
   *
   * @param {Euler} euler - The Euler instance to test for equality.
   * @return {boolean} Whether this Euler instance is equal with the given one.
   */
  equals(euler) {
    return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
  }
  /**
   * Sets this Euler instance's components to values from the given array. The first three
   * entries of the array are assign to the x,y and z components. An optional fourth entry
   * defines the Euler order.
   *
   * @param {Array<number,number,number,?string>} array - An array holding the Euler component values.
   * @return {Euler} A reference to this Euler instance.
   */
  fromArray(array) {
    this._x = array[0];
    this._y = array[1];
    this._z = array[2];
    if (array[3] !== void 0) this._order = array[3];
    this._onChangeCallback();
    return this;
  }
  /**
   * Writes the components of this Euler instance to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number,number,number,string>} [array=[]] - The target array holding the Euler components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number,number,number,string>} The Euler components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this._x;
    array[offset + 1] = this._y;
    array[offset + 2] = this._z;
    array[offset + 3] = this._order;
    return array;
  }
  _onChange(callback) {
    this._onChangeCallback = callback;
    return this;
  }
  _onChangeCallback() {
  }
  *[Symbol.iterator]() {
    yield this._x;
    yield this._y;
    yield this._z;
    yield this._order;
  }
};
Euler.DEFAULT_ORDER = "XYZ";
var Layers = class {
  /**
   * Constructs a new layers instance, with membership
   * initially set to layer `0`.
   */
  constructor() {
    this.mask = 1 | 0;
  }
  /**
   * Sets membership to the given layer, and remove membership all other layers.
   *
   * @param {number} layer - The layer to set.
   */
  set(layer) {
    this.mask = (1 << layer | 0) >>> 0;
  }
  /**
   * Adds membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  enable(layer) {
    this.mask |= 1 << layer | 0;
  }
  /**
   * Adds membership to all layers.
   */
  enableAll() {
    this.mask = 4294967295 | 0;
  }
  /**
   * Toggles the membership of the given layer.
   *
   * @param {number} layer - The layer to toggle.
   */
  toggle(layer) {
    this.mask ^= 1 << layer | 0;
  }
  /**
   * Removes membership of the given layer.
   *
   * @param {number} layer - The layer to enable.
   */
  disable(layer) {
    this.mask &= ~(1 << layer | 0);
  }
  /**
   * Removes the membership from all layers.
   */
  disableAll() {
    this.mask = 0;
  }
  /**
   * Returns `true` if this and the given layers object have at least one
   * layer in common.
   *
   * @param {Layers} layers - The layers to test.
   * @return {boolean } Whether this and the given layers object have at least one layer in common or not.
   */
  test(layers) {
    return (this.mask & layers.mask) !== 0;
  }
  /**
   * Returns `true` if the given layer is enabled.
   *
   * @param {number} layer - The layer to test.
   * @return {boolean } Whether the given layer is enabled or not.
   */
  isEnabled(layer) {
    return (this.mask & (1 << layer | 0)) !== 0;
  }
};
var _object3DId = 0;
var _v1$4 = /* @__PURE__ */ new Vector3();
var _q1 = /* @__PURE__ */ new Quaternion();
var _m1$1 = /* @__PURE__ */ new Matrix4();
var _target = /* @__PURE__ */ new Vector3();
var _position$3 = /* @__PURE__ */ new Vector3();
var _scale$2 = /* @__PURE__ */ new Vector3();
var _quaternion$2 = /* @__PURE__ */ new Quaternion();
var _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);
var _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);
var _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);
var _addedEvent = { type: "added" };
var _removedEvent = { type: "removed" };
var _childaddedEvent = { type: "childadded", child: null };
var _childremovedEvent = { type: "childremoved", child: null };
var Object3D = class _Object3D extends EventDispatcher {
  /**
   * Constructs a new 3D object.
   */
  constructor() {
    super();
    this.isObject3D = true;
    Object.defineProperty(this, "id", { value: _object3DId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Object3D";
    this.parent = null;
    this.children = [];
    this.up = _Object3D.DEFAULT_UP.clone();
    const position = new Vector3();
    const rotation = new Euler();
    const quaternion = new Quaternion();
    const scale = new Vector3(1, 1, 1);
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false);
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false);
    }
    rotation._onChange(onRotationChange);
    quaternion._onChange(onQuaternionChange);
    Object.defineProperties(this, {
      /**
       * Represents the object's local position.
       *
       * @name Object3D#position
       * @type {Vector3}
       * @default (0,0,0)
       */
      position: {
        configurable: true,
        enumerable: true,
        value: position
      },
      /**
       * Represents the object's local rotation as Euler angles, in radians.
       *
       * @name Object3D#rotation
       * @type {Euler}
       * @default (0,0,0)
       */
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation
      },
      /**
       * Represents the object's local rotation as Quaternions.
       *
       * @name Object3D#quaternion
       * @type {Quaternion}
       */
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion
      },
      /**
       * Represents the object's local scale.
       *
       * @name Object3D#scale
       * @type {Vector3}
       * @default (1,1,1)
       */
      scale: {
        configurable: true,
        enumerable: true,
        value: scale
      },
      /**
       * Represents the object's model-view matrix.
       *
       * @name Object3D#modelViewMatrix
       * @type {Matrix4}
       */
      modelViewMatrix: {
        value: new Matrix4()
      },
      /**
       * Represents the object's normal matrix.
       *
       * @name Object3D#normalMatrix
       * @type {Matrix3}
       */
      normalMatrix: {
        value: new Matrix3()
      }
    });
    this.matrix = new Matrix4();
    this.matrixWorld = new Matrix4();
    this.matrixAutoUpdate = _Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
    this.matrixWorldAutoUpdate = _Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;
    this.matrixWorldNeedsUpdate = false;
    this.layers = new Layers();
    this.visible = true;
    this.castShadow = false;
    this.receiveShadow = false;
    this.frustumCulled = true;
    this.renderOrder = 0;
    this.animations = [];
    this.customDepthMaterial = void 0;
    this.customDistanceMaterial = void 0;
    this.userData = {};
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeShadow() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered to a shadow map.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {Camera} shadowCamera - The shadow camera.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} depthMaterial - The depth material.
   * @param {Object} group - The geometry group data.
   */
  onAfterShadow() {
  }
  /**
   * A callback that is executed immediately before a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * A callback that is executed immediately after a 3D object is rendered.
   *
   * @param {Renderer|WebGLRenderer} renderer - The renderer.
   * @param {Object3D} object - The 3D object.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Material} material - The 3D object's material.
   * @param {Object} group - The geometry group data.
   */
  onAfterRender() {
  }
  /**
   * Applies the given transformation matrix to the object and updates the object's position,
   * rotation and scale.
   *
   * @param {Matrix4} matrix - The transformation matrix.
   */
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    this.matrix.premultiply(matrix);
    this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  /**
   * Applies a rotation represented by given the quaternion to the 3D object.
   *
   * @param {Quaternion} q - The quaternion.
   * @return {Object3D} A reference to this instance.
   */
  applyQuaternion(q2) {
    this.quaternion.premultiply(q2);
    return this;
  }
  /**
   * Sets the given rotation represented as an axis/angle couple to the 3D object.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   */
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle);
  }
  /**
   * Sets the given rotation represented as Euler angles to the 3D object.
   *
   * @param {Euler} euler - The Euler angles.
   */
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true);
  }
  /**
   * Sets the given rotation represented as rotation matrix to the 3D object.
   *
   * @param {Matrix4} m - Although a 4x4 matrix is expected, the upper 3x3 portion must be
   * a pure rotation matrix (i.e, unscaled).
   */
  setRotationFromMatrix(m2) {
    this.quaternion.setFromRotationMatrix(m2);
  }
  /**
   * Sets the given rotation represented as a Quaternion to the 3D object.
   *
   * @param {Quaternion} q - The Quaternion
   */
  setRotationFromQuaternion(q2) {
    this.quaternion.copy(q2);
  }
  /**
   * Rotates the 3D object along an axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.multiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object along an axis in world space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle);
    this.quaternion.premultiply(_q1);
    return this;
  }
  /**
   * Rotates the 3D object around its X axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle);
  }
  /**
   * Rotates the 3D object around its Y axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle);
  }
  /**
   * Rotates the 3D object around its Z axis in local space.
   *
   * @param {number} angle - The angle in radians.
   * @return {Object3D} A reference to this instance.
   */
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle);
  }
  /**
   * Translate the 3D object by a distance along the given axis in local space.
   *
   * @param {Vector3} axis - The (normalized) axis vector.
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateOnAxis(axis, distance) {
    _v1$4.copy(axis).applyQuaternion(this.quaternion);
    this.position.add(_v1$4.multiplyScalar(distance));
    return this;
  }
  /**
   * Translate the 3D object by a distance along its X-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance);
  }
  /**
   * Translate the 3D object by a distance along its Y-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance);
  }
  /**
   * Translate the 3D object by a distance along its Z-axis in local space.
   *
   * @param {number} distance - The distance in world units.
   * @return {Object3D} A reference to this instance.
   */
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance);
  }
  /**
   * Converts the given vector from this 3D object's local space to world space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  localToWorld(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(this.matrixWorld);
  }
  /**
   * Converts the given vector from this 3D object's word space to local space.
   *
   * @param {Vector3} vector - The vector to convert.
   * @return {Vector3} The converted vector.
   */
  worldToLocal(vector) {
    this.updateWorldMatrix(true, false);
    return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
  }
  /**
   * Rotates the object to face a point in world space.
   *
   * This method does not support objects having non-uniformly-scaled parent(s).
   *
   * @param {number|Vector3} x - The x coordinate in world space. Alternatively, a vector representing a position in world space
   * @param {number} [y] - The y coordinate in world space.
   * @param {number} [z] - The z coordinate in world space.
   */
  lookAt(x2, y2, z2) {
    if (x2.isVector3) {
      _target.copy(x2);
    } else {
      _target.set(x2, y2, z2);
    }
    const parent = this.parent;
    this.updateWorldMatrix(true, false);
    _position$3.setFromMatrixPosition(this.matrixWorld);
    if (this.isCamera || this.isLight) {
      _m1$1.lookAt(_position$3, _target, this.up);
    } else {
      _m1$1.lookAt(_target, _position$3, this.up);
    }
    this.quaternion.setFromRotationMatrix(_m1$1);
    if (parent) {
      _m1$1.extractRotation(parent.matrixWorld);
      _q1.setFromRotationMatrix(_m1$1);
      this.quaternion.premultiply(_q1.invert());
    }
  }
  /**
   * Adds the given 3D object as a child to this 3D object. An arbitrary number of
   * objects may be added. Any current parent on an object passed in here will be
   * removed, since an object can have at most one parent.
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to add.
   * @return {Object3D} A reference to this instance.
   */
  add(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.add(arguments[i2]);
      }
      return this;
    }
    if (object === this) {
      error("Object3D.add: object can't be added as a child of itself.", object);
      return this;
    }
    if (object && object.isObject3D) {
      object.removeFromParent();
      object.parent = this;
      this.children.push(object);
      object.dispatchEvent(_addedEvent);
      _childaddedEvent.child = object;
      this.dispatchEvent(_childaddedEvent);
      _childaddedEvent.child = null;
    } else {
      error("Object3D.add: object not an instance of THREE.Object3D.", object);
    }
    return this;
  }
  /**
   * Removes the given 3D object as child from this 3D object.
   * An arbitrary number of objects may be removed.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @param {Object3D} object - The 3D object to remove.
   * @return {Object3D} A reference to this instance.
   */
  remove(object) {
    if (arguments.length > 1) {
      for (let i2 = 0; i2 < arguments.length; i2++) {
        this.remove(arguments[i2]);
      }
      return this;
    }
    const index = this.children.indexOf(object);
    if (index !== -1) {
      object.parent = null;
      this.children.splice(index, 1);
      object.dispatchEvent(_removedEvent);
      _childremovedEvent.child = object;
      this.dispatchEvent(_childremovedEvent);
      _childremovedEvent.child = null;
    }
    return this;
  }
  /**
   * Removes this 3D object from its current parent.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  removeFromParent() {
    const parent = this.parent;
    if (parent !== null) {
      parent.remove(this);
    }
    return this;
  }
  /**
   * Removes all child objects.
   *
   * @fires Object3D#removed
   * @fires Object3D#childremoved
   * @return {Object3D} A reference to this instance.
   */
  clear() {
    return this.remove(...this.children);
  }
  /**
   * Adds the given 3D object as a child of this 3D object, while maintaining the object's world
   * transform. This method does not support scene graphs having non-uniformly-scaled nodes(s).
   *
   * @fires Object3D#added
   * @fires Object3D#childadded
   * @param {Object3D} object - The 3D object to attach.
   * @return {Object3D} A reference to this instance.
   */
  attach(object) {
    this.updateWorldMatrix(true, false);
    _m1$1.copy(this.matrixWorld).invert();
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false);
      _m1$1.multiply(object.parent.matrixWorld);
    }
    object.applyMatrix4(_m1$1);
    object.removeFromParent();
    object.parent = this;
    this.children.push(object);
    object.updateWorldMatrix(false, true);
    object.dispatchEvent(_addedEvent);
    _childaddedEvent.child = object;
    this.dispatchEvent(_childaddedEvent);
    _childaddedEvent.child = null;
    return this;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching ID.
   *
   * @param {number} id - The id.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectById(id) {
    return this.getObjectByProperty("id", id);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching name.
   *
   * @param {string} name - The name.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByName(name) {
    return this.getObjectByProperty("name", name);
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns the first with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @return {Object3D|undefined} The found 3D object. Returns `undefined` if no 3D object has been found.
   */
  getObjectByProperty(name, value) {
    if (this[name] === value) return this;
    for (let i2 = 0, l2 = this.children.length; i2 < l2; i2++) {
      const child = this.children[i2];
      const object = child.getObjectByProperty(name, value);
      if (object !== void 0) {
        return object;
      }
    }
    return void 0;
  }
  /**
   * Searches through the 3D object and its children, starting with the 3D object
   * itself, and returns all 3D objects with a matching property value.
   *
   * @param {string} name - The name of the property.
   * @param {any} value - The value.
   * @param {Array<Object3D>} result - The method stores the result in this array.
   * @return {Array<Object3D>} The found 3D objects.
   */
  getObjectsByProperty(name, value, result = []) {
    if (this[name] === value) result.push(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].getObjectsByProperty(name, value, result);
    }
    return result;
  }
  /**
   * Returns a vector representing the position of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's position in world space.
   */
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false);
    return target.setFromMatrixPosition(this.matrixWorld);
  }
  /**
   * Returns a Quaternion representing the position of the 3D object in world space.
   *
   * @param {Quaternion} target - The target Quaternion the result is stored to.
   * @return {Quaternion} The 3D object's rotation in world space.
   */
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, target, _scale$2);
    return target;
  }
  /**
   * Returns a vector representing the scale of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's scale in world space.
   */
  getWorldScale(target) {
    this.updateWorldMatrix(true, false);
    this.matrixWorld.decompose(_position$3, _quaternion$2, target);
    return target;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false);
    const e2 = this.matrixWorld.elements;
    return target.set(e2[8], e2[9], e2[10]).normalize();
  }
  /**
   * Abstract method to get intersections between a casted ray and this
   * 3D object. Renderable 3D objects such as {@link Mesh}, {@link Line} or {@link Points}
   * implement this method in order to use raycasting.
   *
   * @abstract
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - An array holding the result of the method.
   */
  raycast() {
  }
  /**
   * Executes the callback on this 3D object and all descendants.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverse(callback) {
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverse(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for visible 3D objects.
   * Descendants of invisible 3D objects are not traversed.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseVisible(callback) {
    if (this.visible === false) return;
    callback(this);
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      children[i2].traverseVisible(callback);
    }
  }
  /**
   * Like {@link Object3D#traverse}, but the callback will only be executed for all ancestors.
   *
   * Note: Modifying the scene graph inside the callback is discouraged.
   *
   * @param {Function} callback - A callback function that allows to process the current 3D object.
   */
  traverseAncestors(callback) {
    const parent = this.parent;
    if (parent !== null) {
      callback(parent);
      parent.traverseAncestors(callback);
    }
  }
  /**
   * Updates the transformation matrix in local space by computing it from the current
   * position, rotation and scale values.
   */
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale);
    this.matrixWorldNeedsUpdate = true;
  }
  /**
   * Updates the transformation matrix in world space of this 3D objects and its descendants.
   *
   * To ensure correct results, this method also recomputes the 3D object's transformation matrix in
   * local space. The computation of the local and world matrix can be controlled with the
   * {@link Object3D#matrixAutoUpdate} and {@link Object3D#matrixWorldAutoUpdate} flags which are both
   * `true` by default.  Set these flags to `false` if you need more control over the update matrix process.
   *
   * @param {boolean} [force=false] - When set to `true`, a recomputation of world matrices is forced even
   * when {@link Object3D#matrixWorldAutoUpdate} is set to `false`.
   */
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.matrixWorldAutoUpdate === true) {
        if (this.parent === null) {
          this.matrixWorld.copy(this.matrix);
        } else {
          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
        }
      }
      this.matrixWorldNeedsUpdate = false;
      force = true;
    }
    const children = this.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      const child = children[i2];
      child.updateMatrixWorld(force);
    }
  }
  /**
   * An alternative version of {@link Object3D#updateMatrixWorld} with more control over the
   * update of ancestor and descendant nodes.
   *
   * @param {boolean} [updateParents=false] Whether ancestor nodes should be updated or not.
   * @param {boolean} [updateChildren=false] Whether descendant nodes should be updated or not.
   */
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent;
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false);
    }
    if (this.matrixAutoUpdate) this.updateMatrix();
    if (this.matrixWorldAutoUpdate === true) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix);
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
      }
    }
    if (updateChildren === true) {
      const children = this.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        const child = children[i2];
        child.updateWorldMatrix(false, true);
      }
    }
  }
  /**
   * Serializes the 3D object into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized 3D object.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    const output = {};
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {}
      };
      output.metadata = {
        version: 4.7,
        type: "Object",
        generator: "Object3D.toJSON"
      };
    }
    const object = {};
    object.uuid = this.uuid;
    object.type = this.type;
    if (this.name !== "") object.name = this.name;
    if (this.castShadow === true) object.castShadow = true;
    if (this.receiveShadow === true) object.receiveShadow = true;
    if (this.visible === false) object.visible = false;
    if (this.frustumCulled === false) object.frustumCulled = false;
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
    if (Object.keys(this.userData).length > 0) object.userData = this.userData;
    object.layers = this.layers.mask;
    object.matrix = this.matrix.toArray();
    object.up = this.up.toArray();
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;
    if (this.isInstancedMesh) {
      object.type = "InstancedMesh";
      object.count = this.count;
      object.instanceMatrix = this.instanceMatrix.toJSON();
      if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
    }
    if (this.isBatchedMesh) {
      object.type = "BatchedMesh";
      object.perObjectFrustumCulled = this.perObjectFrustumCulled;
      object.sortObjects = this.sortObjects;
      object.drawRanges = this._drawRanges;
      object.reservedRanges = this._reservedRanges;
      object.geometryInfo = this._geometryInfo.map((info) => ({
        ...info,
        boundingBox: info.boundingBox ? info.boundingBox.toJSON() : void 0,
        boundingSphere: info.boundingSphere ? info.boundingSphere.toJSON() : void 0
      }));
      object.instanceInfo = this._instanceInfo.map((info) => ({ ...info }));
      object.availableInstanceIds = this._availableInstanceIds.slice();
      object.availableGeometryIds = this._availableGeometryIds.slice();
      object.nextIndexStart = this._nextIndexStart;
      object.nextVertexStart = this._nextVertexStart;
      object.geometryCount = this._geometryCount;
      object.maxInstanceCount = this._maxInstanceCount;
      object.maxVertexCount = this._maxVertexCount;
      object.maxIndexCount = this._maxIndexCount;
      object.geometryInitialized = this._geometryInitialized;
      object.matricesTexture = this._matricesTexture.toJSON(meta);
      object.indirectTexture = this._indirectTexture.toJSON(meta);
      if (this._colorsTexture !== null) {
        object.colorsTexture = this._colorsTexture.toJSON(meta);
      }
      if (this.boundingSphere !== null) {
        object.boundingSphere = this.boundingSphere.toJSON();
      }
      if (this.boundingBox !== null) {
        object.boundingBox = this.boundingBox.toJSON();
      }
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta);
      }
      return element.uuid;
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON();
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid;
        }
      }
      if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
        object.environment = this.environment.toJSON(meta).uuid;
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry);
      const parameters = this.geometry.parameters;
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes;
        if (Array.isArray(shapes)) {
          for (let i2 = 0, l2 = shapes.length; i2 < l2; i2++) {
            const shape = shapes[i2];
            serialize(meta.shapes, shape);
          }
        } else {
          serialize(meta.shapes, shapes);
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode;
      object.bindMatrix = this.bindMatrix.toArray();
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton);
        object.skeleton = this.skeleton.uuid;
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = [];
        for (let i2 = 0, l2 = this.material.length; i2 < l2; i2++) {
          uuids.push(serialize(meta.materials, this.material[i2]));
        }
        object.material = uuids;
      } else {
        object.material = serialize(meta.materials, this.material);
      }
    }
    if (this.children.length > 0) {
      object.children = [];
      for (let i2 = 0; i2 < this.children.length; i2++) {
        object.children.push(this.children[i2].toJSON(meta).object);
      }
    }
    if (this.animations.length > 0) {
      object.animations = [];
      for (let i2 = 0; i2 < this.animations.length; i2++) {
        const animation = this.animations[i2];
        object.animations.push(serialize(meta.animations, animation));
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries);
      const materials = extractFromCache(meta.materials);
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const shapes = extractFromCache(meta.shapes);
      const skeletons = extractFromCache(meta.skeletons);
      const animations = extractFromCache(meta.animations);
      const nodes = extractFromCache(meta.nodes);
      if (geometries.length > 0) output.geometries = geometries;
      if (materials.length > 0) output.materials = materials;
      if (textures.length > 0) output.textures = textures;
      if (images.length > 0) output.images = images;
      if (shapes.length > 0) output.shapes = shapes;
      if (skeletons.length > 0) output.skeletons = skeletons;
      if (animations.length > 0) output.animations = animations;
      if (nodes.length > 0) output.nodes = nodes;
    }
    output.object = object;
    return output;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
  }
  /**
   * Returns a new 3D object with copied values from this instance.
   *
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are also cloned.
   * @return {Object3D} A clone of this instance.
   */
  clone(recursive) {
    return new this.constructor().copy(this, recursive);
  }
  /**
   * Copies the values of the given 3D object to this instance.
   *
   * @param {Object3D} source - The 3D object to copy.
   * @param {boolean} [recursive=true] - When set to `true`, descendants of the 3D object are cloned.
   * @return {Object3D} A reference to this instance.
   */
  copy(source, recursive = true) {
    this.name = source.name;
    this.up.copy(source.up);
    this.position.copy(source.position);
    this.rotation.order = source.rotation.order;
    this.quaternion.copy(source.quaternion);
    this.scale.copy(source.scale);
    this.matrix.copy(source.matrix);
    this.matrixWorld.copy(source.matrixWorld);
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
    this.layers.mask = source.layers.mask;
    this.visible = source.visible;
    this.castShadow = source.castShadow;
    this.receiveShadow = source.receiveShadow;
    this.frustumCulled = source.frustumCulled;
    this.renderOrder = source.renderOrder;
    this.animations = source.animations.slice();
    this.userData = JSON.parse(JSON.stringify(source.userData));
    if (recursive === true) {
      for (let i2 = 0; i2 < source.children.length; i2++) {
        const child = source.children[i2];
        this.add(child.clone());
      }
    }
    return this;
  }
};
Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);
Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
var _v0$1 = /* @__PURE__ */ new Vector3();
var _v1$3 = /* @__PURE__ */ new Vector3();
var _v2$2 = /* @__PURE__ */ new Vector3();
var _v3$2 = /* @__PURE__ */ new Vector3();
var _vab = /* @__PURE__ */ new Vector3();
var _vac = /* @__PURE__ */ new Vector3();
var _vbc = /* @__PURE__ */ new Vector3();
var _vap = /* @__PURE__ */ new Vector3();
var _vbp = /* @__PURE__ */ new Vector3();
var _vcp = /* @__PURE__ */ new Vector3();
var _v40 = /* @__PURE__ */ new Vector4();
var _v41 = /* @__PURE__ */ new Vector4();
var _v42 = /* @__PURE__ */ new Vector4();
var Triangle = class _Triangle {
  /**
   * Constructs a new triangle.
   *
   * @param {Vector3} [a=(0,0,0)] - The first corner of the triangle.
   * @param {Vector3} [b=(0,0,0)] - The second corner of the triangle.
   * @param {Vector3} [c=(0,0,0)] - The third corner of the triangle.
   */
  constructor(a2 = new Vector3(), b2 = new Vector3(), c2 = new Vector3()) {
    this.a = a2;
    this.b = b2;
    this.c = c2;
  }
  /**
   * Computes the normal vector of a triangle.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  static getNormal(a2, b2, c2, target) {
    target.subVectors(c2, b2);
    _v0$1.subVectors(a2, b2);
    target.cross(_v0$1);
    const targetLengthSq = target.lengthSq();
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
    }
    return target.set(0, 0, 0);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  static getBarycoord(point, a2, b2, c2, target) {
    _v0$1.subVectors(c2, a2);
    _v1$3.subVectors(b2, a2);
    _v2$2.subVectors(point, a2);
    const dot00 = _v0$1.dot(_v0$1);
    const dot01 = _v0$1.dot(_v1$3);
    const dot02 = _v0$1.dot(_v2$2);
    const dot11 = _v1$3.dot(_v1$3);
    const dot12 = _v1$3.dot(_v2$2);
    const denom = dot00 * dot11 - dot01 * dot01;
    if (denom === 0) {
      target.set(0, 0, 0);
      return null;
    }
    const invDenom = 1 / denom;
    const u2 = (dot11 * dot02 - dot01 * dot12) * invDenom;
    const v2 = (dot00 * dot12 - dot01 * dot02) * invDenom;
    return target.set(1 - u2 - v2, v2, u2);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  static containsPoint(point, a2, b2, c2) {
    if (this.getBarycoord(point, a2, b2, c2, _v3$2) === null) {
      return false;
    }
    return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} p1 - The first corner of the triangle.
   * @param {Vector3} p2 - The second corner of the triangle.
   * @param {Vector3} p3 - The third corner of the triangle.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
    if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
      target.x = 0;
      target.y = 0;
      if ("z" in target) target.z = 0;
      if ("w" in target) target.w = 0;
      return null;
    }
    target.setScalar(0);
    target.addScaledVector(v1, _v3$2.x);
    target.addScaledVector(v2, _v3$2.y);
    target.addScaledVector(v3, _v3$2.z);
    return target;
  }
  /**
   * Computes the value barycentrically interpolated for the given attribute and indices.
   *
   * @param {BufferAttribute} attr - The attribute to interpolate.
   * @param {number} i1 - Index of first vertex.
   * @param {number} i2 - Index of second vertex.
   * @param {number} i3 - Index of third vertex.
   * @param {Vector3} barycoord - The barycoordinate value to use to interpolate.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The interpolated attribute value.
   */
  static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
    _v40.setScalar(0);
    _v41.setScalar(0);
    _v42.setScalar(0);
    _v40.fromBufferAttribute(attr, i1);
    _v41.fromBufferAttribute(attr, i2);
    _v42.fromBufferAttribute(attr, i3);
    target.setScalar(0);
    target.addScaledVector(_v40, barycoord.x);
    target.addScaledVector(_v41, barycoord.y);
    target.addScaledVector(_v42, barycoord.z);
    return target;
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  static isFrontFacing(a2, b2, c2, direction) {
    _v0$1.subVectors(c2, b2);
    _v1$3.subVectors(a2, b2);
    return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
  }
  /**
   * Sets the triangle's vertices by copying the given values.
   *
   * @param {Vector3} a - The first corner of the triangle.
   * @param {Vector3} b - The second corner of the triangle.
   * @param {Vector3} c - The third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  set(a2, b2, c2) {
    this.a.copy(a2);
    this.b.copy(b2);
    this.c.copy(c2);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given array values.
   *
   * @param {Array<Vector3>} points - An array with 3D points.
   * @param {number} i0 - The array index representing the first corner of the triangle.
   * @param {number} i1 - The array index representing the second corner of the triangle.
   * @param {number} i2 - The array index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0]);
    this.b.copy(points[i1]);
    this.c.copy(points[i2]);
    return this;
  }
  /**
   * Sets the triangle's vertices by copying the given attribute values.
   *
   * @param {BufferAttribute} attribute - A buffer attribute with 3D points data.
   * @param {number} i0 - The attribute index representing the first corner of the triangle.
   * @param {number} i1 - The attribute index representing the second corner of the triangle.
   * @param {number} i2 - The attribute index representing the third corner of the triangle.
   * @return {Triangle} A reference to this triangle.
   */
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0);
    this.b.fromBufferAttribute(attribute, i1);
    this.c.fromBufferAttribute(attribute, i2);
    return this;
  }
  /**
   * Returns a new triangle with copied values from this instance.
   *
   * @return {Triangle} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given triangle to this instance.
   *
   * @param {Triangle} triangle - The triangle to copy.
   * @return {Triangle} A reference to this triangle.
   */
  copy(triangle) {
    this.a.copy(triangle.a);
    this.b.copy(triangle.b);
    this.c.copy(triangle.c);
    return this;
  }
  /**
   * Computes the area of the triangle.
   *
   * @return {number} The triangle's area.
   */
  getArea() {
    _v0$1.subVectors(this.c, this.b);
    _v1$3.subVectors(this.a, this.b);
    return _v0$1.cross(_v1$3).length() * 0.5;
  }
  /**
   * Computes the midpoint of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's midpoint.
   */
  getMidpoint(target) {
    return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
  }
  /**
   * Computes the normal of the triangle.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The triangle's normal.
   */
  getNormal(target) {
    return _Triangle.getNormal(this.a, this.b, this.c, target);
  }
  /**
   * Computes a plane the triangle lies within.
   *
   * @param {Plane} target - The target vector that is used to store the method's result.
   * @return {Plane} The plane the triangle lies within.
   */
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  /**
   * Computes a barycentric coordinates from the given vector.
   * Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - A point in 3D space.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The barycentric coordinates for the given point
   */
  getBarycoord(point, target) {
    return _Triangle.getBarycoord(point, this.a, this.b, this.c, target);
  }
  /**
   * Computes the value barycentrically interpolated for the given point on the
   * triangle. Returns `null` if the triangle is degenerate.
   *
   * @param {Vector3} point - Position of interpolated point.
   * @param {Vector3} v1 - Value to interpolate of first vertex.
   * @param {Vector3} v2 - Value to interpolate of second vertex.
   * @param {Vector3} v3 - Value to interpolate of third vertex.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The interpolated value.
   */
  getInterpolation(point, v1, v2, v3, target) {
    return _Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
  }
  /**
   * Returns `true` if the given point, when projected onto the plane of the
   * triangle, lies within the triangle.
   *
   * @param {Vector3} point - The point in 3D space to test.
   * @return {boolean} Whether the given point, when projected onto the plane of the
   * triangle, lies within the triangle or not.
   */
  containsPoint(point) {
    return _Triangle.containsPoint(point, this.a, this.b, this.c);
  }
  /**
   * Returns `true` if the triangle is oriented towards the given direction.
   *
   * @param {Vector3} direction - The (normalized) direction vector.
   * @return {boolean} Whether the triangle is oriented towards the given direction or not.
   */
  isFrontFacing(direction) {
    return _Triangle.isFrontFacing(this.a, this.b, this.c, direction);
  }
  /**
   * Returns `true` if this triangle intersects with the given box.
   *
   * @param {Box3} box - The box to intersect.
   * @return {boolean} Whether this triangle intersects with the given box or not.
   */
  intersectsBox(box) {
    return box.intersectsTriangle(this);
  }
  /**
   * Returns the closest point on the triangle to the given point.
   *
   * @param {Vector3} p - The point to compute the closest point for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The closest point on the triangle.
   */
  closestPointToPoint(p2, target) {
    const a2 = this.a, b2 = this.b, c2 = this.c;
    let v2, w2;
    _vab.subVectors(b2, a2);
    _vac.subVectors(c2, a2);
    _vap.subVectors(p2, a2);
    const d1 = _vab.dot(_vap);
    const d2 = _vac.dot(_vap);
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a2);
    }
    _vbp.subVectors(p2, b2);
    const d3 = _vab.dot(_vbp);
    const d4 = _vac.dot(_vbp);
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b2);
    }
    const vc2 = d1 * d4 - d3 * d2;
    if (vc2 <= 0 && d1 >= 0 && d3 <= 0) {
      v2 = d1 / (d1 - d3);
      return target.copy(a2).addScaledVector(_vab, v2);
    }
    _vcp.subVectors(p2, c2);
    const d5 = _vab.dot(_vcp);
    const d6 = _vac.dot(_vcp);
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c2);
    }
    const vb = d5 * d2 - d1 * d6;
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w2 = d2 / (d2 - d6);
      return target.copy(a2).addScaledVector(_vac, w2);
    }
    const va2 = d3 * d6 - d5 * d4;
    if (va2 <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c2, b2);
      w2 = (d4 - d3) / (d4 - d3 + (d5 - d6));
      return target.copy(b2).addScaledVector(_vbc, w2);
    }
    const denom = 1 / (va2 + vb + vc2);
    v2 = vb * denom;
    w2 = vc2 * denom;
    return target.copy(a2).addScaledVector(_vab, v2).addScaledVector(_vac, w2);
  }
  /**
   * Returns `true` if this triangle is equal with the given one.
   *
   * @param {Triangle} triangle - The triangle to test for equality.
   * @return {boolean} Whether this triangle is equal with the given one.
   */
  equals(triangle) {
    return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
  }
};
var _colorKeywords = {
  "aliceblue": 15792383,
  "antiquewhite": 16444375,
  "aqua": 65535,
  "aquamarine": 8388564,
  "azure": 15794175,
  "beige": 16119260,
  "bisque": 16770244,
  "black": 0,
  "blanchedalmond": 16772045,
  "blue": 255,
  "blueviolet": 9055202,
  "brown": 10824234,
  "burlywood": 14596231,
  "cadetblue": 6266528,
  "chartreuse": 8388352,
  "chocolate": 13789470,
  "coral": 16744272,
  "cornflowerblue": 6591981,
  "cornsilk": 16775388,
  "crimson": 14423100,
  "cyan": 65535,
  "darkblue": 139,
  "darkcyan": 35723,
  "darkgoldenrod": 12092939,
  "darkgray": 11119017,
  "darkgreen": 25600,
  "darkgrey": 11119017,
  "darkkhaki": 12433259,
  "darkmagenta": 9109643,
  "darkolivegreen": 5597999,
  "darkorange": 16747520,
  "darkorchid": 10040012,
  "darkred": 9109504,
  "darksalmon": 15308410,
  "darkseagreen": 9419919,
  "darkslateblue": 4734347,
  "darkslategray": 3100495,
  "darkslategrey": 3100495,
  "darkturquoise": 52945,
  "darkviolet": 9699539,
  "deeppink": 16716947,
  "deepskyblue": 49151,
  "dimgray": 6908265,
  "dimgrey": 6908265,
  "dodgerblue": 2003199,
  "firebrick": 11674146,
  "floralwhite": 16775920,
  "forestgreen": 2263842,
  "fuchsia": 16711935,
  "gainsboro": 14474460,
  "ghostwhite": 16316671,
  "gold": 16766720,
  "goldenrod": 14329120,
  "gray": 8421504,
  "green": 32768,
  "greenyellow": 11403055,
  "grey": 8421504,
  "honeydew": 15794160,
  "hotpink": 16738740,
  "indianred": 13458524,
  "indigo": 4915330,
  "ivory": 16777200,
  "khaki": 15787660,
  "lavender": 15132410,
  "lavenderblush": 16773365,
  "lawngreen": 8190976,
  "lemonchiffon": 16775885,
  "lightblue": 11393254,
  "lightcoral": 15761536,
  "lightcyan": 14745599,
  "lightgoldenrodyellow": 16448210,
  "lightgray": 13882323,
  "lightgreen": 9498256,
  "lightgrey": 13882323,
  "lightpink": 16758465,
  "lightsalmon": 16752762,
  "lightseagreen": 2142890,
  "lightskyblue": 8900346,
  "lightslategray": 7833753,
  "lightslategrey": 7833753,
  "lightsteelblue": 11584734,
  "lightyellow": 16777184,
  "lime": 65280,
  "limegreen": 3329330,
  "linen": 16445670,
  "magenta": 16711935,
  "maroon": 8388608,
  "mediumaquamarine": 6737322,
  "mediumblue": 205,
  "mediumorchid": 12211667,
  "mediumpurple": 9662683,
  "mediumseagreen": 3978097,
  "mediumslateblue": 8087790,
  "mediumspringgreen": 64154,
  "mediumturquoise": 4772300,
  "mediumvioletred": 13047173,
  "midnightblue": 1644912,
  "mintcream": 16121850,
  "mistyrose": 16770273,
  "moccasin": 16770229,
  "navajowhite": 16768685,
  "navy": 128,
  "oldlace": 16643558,
  "olive": 8421376,
  "olivedrab": 7048739,
  "orange": 16753920,
  "orangered": 16729344,
  "orchid": 14315734,
  "palegoldenrod": 15657130,
  "palegreen": 10025880,
  "paleturquoise": 11529966,
  "palevioletred": 14381203,
  "papayawhip": 16773077,
  "peachpuff": 16767673,
  "peru": 13468991,
  "pink": 16761035,
  "plum": 14524637,
  "powderblue": 11591910,
  "purple": 8388736,
  "rebeccapurple": 6697881,
  "red": 16711680,
  "rosybrown": 12357519,
  "royalblue": 4286945,
  "saddlebrown": 9127187,
  "salmon": 16416882,
  "sandybrown": 16032864,
  "seagreen": 3050327,
  "seashell": 16774638,
  "sienna": 10506797,
  "silver": 12632256,
  "skyblue": 8900331,
  "slateblue": 6970061,
  "slategray": 7372944,
  "slategrey": 7372944,
  "snow": 16775930,
  "springgreen": 65407,
  "steelblue": 4620980,
  "tan": 13808780,
  "teal": 32896,
  "thistle": 14204888,
  "tomato": 16737095,
  "turquoise": 4251856,
  "violet": 15631086,
  "wheat": 16113331,
  "white": 16777215,
  "whitesmoke": 16119285,
  "yellow": 16776960,
  "yellowgreen": 10145074
};
var _hslA = { h: 0, s: 0, l: 0 };
var _hslB = { h: 0, s: 0, l: 0 };
function hue2rgb(p2, q2, t2) {
  if (t2 < 0) t2 += 1;
  if (t2 > 1) t2 -= 1;
  if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
  if (t2 < 1 / 2) return q2;
  if (t2 < 2 / 3) return p2 + (q2 - p2) * 6 * (2 / 3 - t2);
  return p2;
}
var Color = class {
  /**
   * Constructs a new color.
   *
   * Note that standard method of specifying color in three.js is with a hexadecimal triplet,
   * and that method is used throughout the rest of the documentation.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   */
  constructor(r2, g2, b2) {
    this.isColor = true;
    this.r = 1;
    this.g = 1;
    this.b = 1;
    return this.set(r2, g2, b2);
  }
  /**
   * Sets the colors's components from the given values.
   *
   * @param {(number|string|Color)} [r] - The red component of the color. If `g` and `b` are
   * not provided, it can be hexadecimal triplet, a CSS-style string or another `Color` instance.
   * @param {number} [g] - The green component.
   * @param {number} [b] - The blue component.
   * @return {Color} A reference to this color.
   */
  set(r2, g2, b2) {
    if (g2 === void 0 && b2 === void 0) {
      const value = r2;
      if (value && value.isColor) {
        this.copy(value);
      } else if (typeof value === "number") {
        this.setHex(value);
      } else if (typeof value === "string") {
        this.setStyle(value);
      }
    } else {
      this.setRGB(r2, g2, b2);
    }
    return this;
  }
  /**
   * Sets the colors's components to the given scalar value.
   *
   * @param {number} scalar - The scalar value.
   * @return {Color} A reference to this color.
   */
  setScalar(scalar) {
    this.r = scalar;
    this.g = scalar;
    this.b = scalar;
    return this;
  }
  /**
   * Sets this color from a hexadecimal value.
   *
   * @param {number} hex - The hexadecimal value.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex);
    this.r = (hex >> 16 & 255) / 255;
    this.g = (hex >> 8 & 255) / 255;
    this.b = (hex & 255) / 255;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} r - Red channel value between `0.0` and `1.0`.
   * @param {number} g - Green channel value between `0.0` and `1.0`.
   * @param {number} b - Blue channel value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setRGB(r2, g2, b2, colorSpace = ColorManagement.workingColorSpace) {
    this.r = r2;
    this.g = g2;
    this.b = b2;
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from RGB values.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setHSL(h2, s2, l2, colorSpace = ColorManagement.workingColorSpace) {
    h2 = euclideanModulo(h2, 1);
    s2 = clamp(s2, 0, 1);
    l2 = clamp(l2, 0, 1);
    if (s2 === 0) {
      this.r = this.g = this.b = l2;
    } else {
      const p2 = l2 <= 0.5 ? l2 * (1 + s2) : l2 + s2 - l2 * s2;
      const q2 = 2 * l2 - p2;
      this.r = hue2rgb(q2, p2, h2 + 1 / 3);
      this.g = hue2rgb(q2, p2, h2);
      this.b = hue2rgb(q2, p2, h2 - 1 / 3);
    }
    ColorManagement.colorSpaceToWorking(this, colorSpace);
    return this;
  }
  /**
   * Sets this color from a CSS-style string. For example, `rgb(250, 0,0)`,
   * `rgb(100%, 0%, 0%)`, `hsl(0, 100%, 50%)`, `#ff0000`, `#f00`, or `red` ( or
   * any [X11 color name](https://en.wikipedia.org/wiki/X11_color_names#Color_name_chart) -
   * all 140 color names are supported).
   *
   * @param {string} style - Color as a CSS-style string.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return;
      if (parseFloat(string) < 1) {
        warn("Color: Alpha component of " + style + " will be ignored.");
      }
    }
    let m2;
    if (m2 = /^(\w+)\(([^\)]*)\)/.exec(style)) {
      let color;
      const name = m2[1];
      const components = m2[2];
      switch (name) {
        case "rgb":
        case "rgba":
          if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(255, parseInt(color[1], 10)) / 255,
              Math.min(255, parseInt(color[2], 10)) / 255,
              Math.min(255, parseInt(color[3], 10)) / 255,
              colorSpace
            );
          }
          if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setRGB(
              Math.min(100, parseInt(color[1], 10)) / 100,
              Math.min(100, parseInt(color[2], 10)) / 100,
              Math.min(100, parseInt(color[3], 10)) / 100,
              colorSpace
            );
          }
          break;
        case "hsl":
        case "hsla":
          if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
            handleAlpha(color[4]);
            return this.setHSL(
              parseFloat(color[1]) / 360,
              parseFloat(color[2]) / 100,
              parseFloat(color[3]) / 100,
              colorSpace
            );
          }
          break;
        default:
          warn("Color: Unknown color model " + style);
      }
    } else if (m2 = /^\#([A-Fa-f\d]+)$/.exec(style)) {
      const hex = m2[1];
      const size = hex.length;
      if (size === 3) {
        return this.setRGB(
          parseInt(hex.charAt(0), 16) / 15,
          parseInt(hex.charAt(1), 16) / 15,
          parseInt(hex.charAt(2), 16) / 15,
          colorSpace
        );
      } else if (size === 6) {
        return this.setHex(parseInt(hex, 16), colorSpace);
      } else {
        warn("Color: Invalid hex color " + style);
      }
    } else if (style && style.length > 0) {
      return this.setColorName(style, colorSpace);
    }
    return this;
  }
  /**
   * Sets this color from a color name. Faster than {@link Color#setStyle} if
   * you don't need the other CSS-style formats.
   *
   * For convenience, the list of names is exposed in `Color.NAMES` as a hash.
   * ```js
   * Color.NAMES.aliceblue // returns 0xF0F8FF
   * ```
   *
   * @param {string} style - The color name.
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {Color} A reference to this color.
   */
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()];
    if (hex !== void 0) {
      this.setHex(hex, colorSpace);
    } else {
      warn("Color: Unknown color " + style);
    }
    return this;
  }
  /**
   * Returns a new color with copied values from this instance.
   *
   * @return {Color} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  /**
   * Copies the values of the given color to this instance.
   *
   * @param {Color} color - The color to copy.
   * @return {Color} A reference to this color.
   */
  copy(color) {
    this.r = color.r;
    this.g = color.g;
    this.b = color.b;
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r);
    this.g = SRGBToLinear(color.g);
    this.b = SRGBToLinear(color.b);
    return this;
  }
  /**
   * Copies the given color into this color, and then converts this color from
   * `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @param {Color} color - The color to copy/convert.
   * @return {Color} A reference to this color.
   */
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r);
    this.g = LinearToSRGB(color.g);
    this.b = LinearToSRGB(color.b);
    return this;
  }
  /**
   * Converts this color from `SRGBColorSpace` to `LinearSRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertSRGBToLinear() {
    this.copySRGBToLinear(this);
    return this;
  }
  /**
   * Converts this color from `LinearSRGBColorSpace` to `SRGBColorSpace`.
   *
   * @return {Color} A reference to this color.
   */
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this);
    return this;
  }
  /**
   * Returns the hexadecimal value of this color.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {number} The hexadecimal value.
   */
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));
  }
  /**
   * Returns the hexadecimal value of this color as a string (for example, 'FFFFFF').
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The hexadecimal value as a string.
   */
  getHexString(colorSpace = SRGBColorSpace) {
    return ("000000" + this.getHex(colorSpace).toString(16)).slice(-6);
  }
  /**
   * Converts the colors RGB values into the HSL format and stores them into the
   * given target object.
   *
   * @param {{h:number,s:number,l:number}} target - The target object that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {{h:number,s:number,l:number}} The HSL representation of this color.
   */
  getHSL(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g2 = _color.g, b2 = _color.b;
    const max = Math.max(r2, g2, b2);
    const min = Math.min(r2, g2, b2);
    let hue, saturation;
    const lightness = (min + max) / 2;
    if (min === max) {
      hue = 0;
      saturation = 0;
    } else {
      const delta = max - min;
      saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
      switch (max) {
        case r2:
          hue = (g2 - b2) / delta + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          hue = (b2 - r2) / delta + 2;
          break;
        case b2:
          hue = (r2 - g2) / delta + 4;
          break;
      }
      hue /= 6;
    }
    target.h = hue;
    target.s = saturation;
    target.l = lightness;
    return target;
  }
  /**
   * Returns the RGB values of this color and stores them into the given target object.
   *
   * @param {Color} target - The target color that is used to store the method's result.
   * @param {string} [colorSpace=ColorManagement.workingColorSpace] - The color space.
   * @return {Color} The RGB representation of this color.
   */
  getRGB(target, colorSpace = ColorManagement.workingColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    target.r = _color.r;
    target.g = _color.g;
    target.b = _color.b;
    return target;
  }
  /**
   * Returns the value of this color as a CSS style string. Example: `rgb(255,0,0)`.
   *
   * @param {string} [colorSpace=SRGBColorSpace] - The color space.
   * @return {string} The CSS representation of this color.
   */
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.workingToColorSpace(_color.copy(this), colorSpace);
    const r2 = _color.r, g2 = _color.g, b2 = _color.b;
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${r2.toFixed(3)} ${g2.toFixed(3)} ${b2.toFixed(3)})`;
    }
    return `rgb(${Math.round(r2 * 255)},${Math.round(g2 * 255)},${Math.round(b2 * 255)})`;
  }
  /**
   * Adds the given HSL values to this color's values.
   * Internally, this converts the color's RGB values to HSL, adds HSL
   * and then converts the color back to RGB.
   *
   * @param {number} h - Hue value between `0.0` and `1.0`.
   * @param {number} s - Saturation value between `0.0` and `1.0`.
   * @param {number} l - Lightness value between `0.0` and `1.0`.
   * @return {Color} A reference to this color.
   */
  offsetHSL(h2, s2, l2) {
    this.getHSL(_hslA);
    return this.setHSL(_hslA.h + h2, _hslA.s + s2, _hslA.l + l2);
  }
  /**
   * Adds the RGB values of the given color to the RGB values of this color.
   *
   * @param {Color} color - The color to add.
   * @return {Color} A reference to this color.
   */
  add(color) {
    this.r += color.r;
    this.g += color.g;
    this.b += color.b;
    return this;
  }
  /**
   * Adds the RGB values of the given colors and stores the result in this instance.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @return {Color} A reference to this color.
   */
  addColors(color1, color2) {
    this.r = color1.r + color2.r;
    this.g = color1.g + color2.g;
    this.b = color1.b + color2.b;
    return this;
  }
  /**
   * Adds the given scalar value to the RGB values of this color.
   *
   * @param {number} s - The scalar to add.
   * @return {Color} A reference to this color.
   */
  addScalar(s2) {
    this.r += s2;
    this.g += s2;
    this.b += s2;
    return this;
  }
  /**
   * Subtracts the RGB values of the given color from the RGB values of this color.
   *
   * @param {Color} color - The color to subtract.
   * @return {Color} A reference to this color.
   */
  sub(color) {
    this.r = Math.max(0, this.r - color.r);
    this.g = Math.max(0, this.g - color.g);
    this.b = Math.max(0, this.b - color.b);
    return this;
  }
  /**
   * Multiplies the RGB values of the given color with the RGB values of this color.
   *
   * @param {Color} color - The color to multiply.
   * @return {Color} A reference to this color.
   */
  multiply(color) {
    this.r *= color.r;
    this.g *= color.g;
    this.b *= color.b;
    return this;
  }
  /**
   * Multiplies the given scalar value with the RGB values of this color.
   *
   * @param {number} s - The scalar to multiply.
   * @return {Color} A reference to this color.
   */
  multiplyScalar(s2) {
    this.r *= s2;
    this.g *= s2;
    this.b *= s2;
    return this;
  }
  /**
   * Linearly interpolates this color's RGB values toward the RGB values of the
   * given color. The alpha argument can be thought of as the ratio between
   * the two colors, where `0.0` is this color and `1.0` is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha;
    this.g += (color.g - this.g) * alpha;
    this.b += (color.b - this.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates between the given colors and stores the result in this instance.
   * The alpha argument can be thought of as the ratio between the two colors, where `0.0`
   * is the first and `1.0` is the second color.
   *
   * @param {Color} color1 - The first color.
   * @param {Color} color2 - The second color.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha;
    this.g = color1.g + (color2.g - color1.g) * alpha;
    this.b = color1.b + (color2.b - color1.b) * alpha;
    return this;
  }
  /**
   * Linearly interpolates this color's HSL values toward the HSL values of the
   * given color. It differs from {@link Color#lerp} by not interpolating straight
   * from one color to the other, but instead going through all the hues in between
   * those two colors. The alpha argument can be thought of as the ratio between
   * the two colors, where 0.0 is this color and 1.0 is the first argument.
   *
   * @param {Color} color - The color to converge on.
   * @param {number} alpha - The interpolation factor in the closed interval `[0,1]`.
   * @return {Color} A reference to this color.
   */
  lerpHSL(color, alpha) {
    this.getHSL(_hslA);
    color.getHSL(_hslB);
    const h2 = lerp(_hslA.h, _hslB.h, alpha);
    const s2 = lerp(_hslA.s, _hslB.s, alpha);
    const l2 = lerp(_hslA.l, _hslB.l, alpha);
    this.setHSL(h2, s2, l2);
    return this;
  }
  /**
   * Sets the color's RGB components from the given 3D vector.
   *
   * @param {Vector3} v - The vector to set.
   * @return {Color} A reference to this color.
   */
  setFromVector3(v2) {
    this.r = v2.x;
    this.g = v2.y;
    this.b = v2.z;
    return this;
  }
  /**
   * Transforms this color with the given 3x3 matrix.
   *
   * @param {Matrix3} m - The matrix.
   * @return {Color} A reference to this color.
   */
  applyMatrix3(m2) {
    const r2 = this.r, g2 = this.g, b2 = this.b;
    const e2 = m2.elements;
    this.r = e2[0] * r2 + e2[3] * g2 + e2[6] * b2;
    this.g = e2[1] * r2 + e2[4] * g2 + e2[7] * b2;
    this.b = e2[2] * r2 + e2[5] * g2 + e2[8] * b2;
    return this;
  }
  /**
   * Returns `true` if this color is equal with the given one.
   *
   * @param {Color} c - The color to test for equality.
   * @return {boolean} Whether this bounding color is equal with the given one.
   */
  equals(c2) {
    return c2.r === this.r && c2.g === this.g && c2.b === this.b;
  }
  /**
   * Sets this color's RGB components from the given array.
   *
   * @param {Array<number>} array - An array holding the RGB values.
   * @param {number} [offset=0] - The offset into the array.
   * @return {Color} A reference to this color.
   */
  fromArray(array, offset = 0) {
    this.r = array[offset];
    this.g = array[offset + 1];
    this.b = array[offset + 2];
    return this;
  }
  /**
   * Writes the RGB components of this color to the given array. If no array is provided,
   * the method returns a new instance.
   *
   * @param {Array<number>} [array=[]] - The target array holding the color components.
   * @param {number} [offset=0] - Index of the first element in the array.
   * @return {Array<number>} The color components.
   */
  toArray(array = [], offset = 0) {
    array[offset] = this.r;
    array[offset + 1] = this.g;
    array[offset + 2] = this.b;
    return array;
  }
  /**
   * Sets the components of this color from the given buffer attribute.
   *
   * @param {BufferAttribute} attribute - The buffer attribute holding color data.
   * @param {number} index - The index into the attribute.
   * @return {Color} A reference to this color.
   */
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index);
    this.g = attribute.getY(index);
    this.b = attribute.getZ(index);
    return this;
  }
  /**
   * This methods defines the serialization result of this class. Returns the color
   * as a hexadecimal value.
   *
   * @return {number} The hexadecimal value.
   */
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r;
    yield this.g;
    yield this.b;
  }
};
var _color = /* @__PURE__ */ new Color();
Color.NAMES = _colorKeywords;
var _materialId = 0;
var Material = class extends EventDispatcher {
  /**
   * Constructs a new material.
   */
  constructor() {
    super();
    this.isMaterial = true;
    Object.defineProperty(this, "id", { value: _materialId++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "Material";
    this.blending = NormalBlending;
    this.side = FrontSide;
    this.vertexColors = false;
    this.opacity = 1;
    this.transparent = false;
    this.alphaHash = false;
    this.blendSrc = SrcAlphaFactor;
    this.blendDst = OneMinusSrcAlphaFactor;
    this.blendEquation = AddEquation;
    this.blendSrcAlpha = null;
    this.blendDstAlpha = null;
    this.blendEquationAlpha = null;
    this.blendColor = new Color(0, 0, 0);
    this.blendAlpha = 0;
    this.depthFunc = LessEqualDepth;
    this.depthTest = true;
    this.depthWrite = true;
    this.stencilWriteMask = 255;
    this.stencilFunc = AlwaysStencilFunc;
    this.stencilRef = 0;
    this.stencilFuncMask = 255;
    this.stencilFail = KeepStencilOp;
    this.stencilZFail = KeepStencilOp;
    this.stencilZPass = KeepStencilOp;
    this.stencilWrite = false;
    this.clippingPlanes = null;
    this.clipIntersection = false;
    this.clipShadows = false;
    this.shadowSide = null;
    this.colorWrite = true;
    this.precision = null;
    this.polygonOffset = false;
    this.polygonOffsetFactor = 0;
    this.polygonOffsetUnits = 0;
    this.dithering = false;
    this.alphaToCoverage = false;
    this.premultipliedAlpha = false;
    this.forceSinglePass = false;
    this.allowOverride = true;
    this.visible = true;
    this.toneMapped = true;
    this.userData = {};
    this.version = 0;
    this._alphaTest = 0;
  }
  /**
   * Sets the alpha value to be used when running an alpha test. The material
   * will not be rendered if the opacity is lower than this value.
   *
   * @type {number}
   * @readonly
   * @default 0
   */
  get alphaTest() {
    return this._alphaTest;
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++;
    }
    this._alphaTest = value;
  }
  /**
   * An optional callback that is executed immediately before the material is used to render a 3D object.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Camera} camera - The camera that is used to render the scene.
   * @param {BufferGeometry} geometry - The 3D object's geometry.
   * @param {Object3D} object - The 3D object.
   * @param {Object} group - The geometry group data.
   */
  onBeforeRender() {
  }
  /**
   * An optional callback that is executed immediately before the shader
   * program is compiled. This function is called with the shader source code
   * as a parameter. Useful for the modification of built-in materials.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}. The
   * recommended approach when customizing materials is to use `WebGPURenderer` with the new
   * Node Material system and [TSL](https://github.com/mrdoob/three.js/wiki/Three.js-Shading-Language).
   *
   * @param {{vertexShader:string,fragmentShader:string,uniforms:Object}} shaderobject - The object holds the uniforms and the vertex and fragment shader source.
   * @param {WebGLRenderer} renderer - A reference to the renderer.
   */
  onBeforeCompile() {
  }
  /**
   * In case {@link Material#onBeforeCompile} is used, this callback can be used to identify
   * values of settings used in `onBeforeCompile()`, so three.js can reuse a cached
   * shader or recompile the shader for this material as needed.
   *
   * This method can only be used when rendering with {@link WebGLRenderer}.
   *
   * @return {string} The custom program cache key.
   */
  customProgramCacheKey() {
    return this.onBeforeCompile.toString();
  }
  /**
   * This method can be used to set default values from parameter objects.
   * It is a generic implementation so it can be used with different types
   * of materials.
   *
   * @param {Object} [values] - The material values to set.
   */
  setValues(values) {
    if (values === void 0) return;
    for (const key in values) {
      const newValue = values[key];
      if (newValue === void 0) {
        warn(`Material: parameter '${key}' has value of undefined.`);
        continue;
      }
      const currentValue = this[key];
      if (currentValue === void 0) {
        warn(`Material: '${key}' is not a property of THREE.${this.type}.`);
        continue;
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue);
      } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {
        currentValue.copy(newValue);
      } else {
        this[key] = newValue;
      }
    }
  }
  /**
   * Serializes the material into JSON.
   *
   * @param {?(Object|string)} meta - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized material.
   * @see {@link ObjectLoader#parse}
   */
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === "string";
    if (isRootObject) {
      meta = {
        textures: {},
        images: {}
      };
    }
    const data2 = {
      metadata: {
        version: 4.7,
        type: "Material",
        generator: "Material.toJSON"
      }
    };
    data2.uuid = this.uuid;
    data2.type = this.type;
    if (this.name !== "") data2.name = this.name;
    if (this.color && this.color.isColor) data2.color = this.color.getHex();
    if (this.roughness !== void 0) data2.roughness = this.roughness;
    if (this.metalness !== void 0) data2.metalness = this.metalness;
    if (this.sheen !== void 0) data2.sheen = this.sheen;
    if (this.sheenColor && this.sheenColor.isColor) data2.sheenColor = this.sheenColor.getHex();
    if (this.sheenRoughness !== void 0) data2.sheenRoughness = this.sheenRoughness;
    if (this.emissive && this.emissive.isColor) data2.emissive = this.emissive.getHex();
    if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data2.emissiveIntensity = this.emissiveIntensity;
    if (this.specular && this.specular.isColor) data2.specular = this.specular.getHex();
    if (this.specularIntensity !== void 0) data2.specularIntensity = this.specularIntensity;
    if (this.specularColor && this.specularColor.isColor) data2.specularColor = this.specularColor.getHex();
    if (this.shininess !== void 0) data2.shininess = this.shininess;
    if (this.clearcoat !== void 0) data2.clearcoat = this.clearcoat;
    if (this.clearcoatRoughness !== void 0) data2.clearcoatRoughness = this.clearcoatRoughness;
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data2.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data2.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data2.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
      data2.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
    }
    if (this.sheenColorMap && this.sheenColorMap.isTexture) {
      data2.sheenColorMap = this.sheenColorMap.toJSON(meta).uuid;
    }
    if (this.sheenRoughnessMap && this.sheenRoughnessMap.isTexture) {
      data2.sheenRoughnessMap = this.sheenRoughnessMap.toJSON(meta).uuid;
    }
    if (this.dispersion !== void 0) data2.dispersion = this.dispersion;
    if (this.iridescence !== void 0) data2.iridescence = this.iridescence;
    if (this.iridescenceIOR !== void 0) data2.iridescenceIOR = this.iridescenceIOR;
    if (this.iridescenceThicknessRange !== void 0) data2.iridescenceThicknessRange = this.iridescenceThicknessRange;
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data2.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
    }
    if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
      data2.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
    }
    if (this.anisotropy !== void 0) data2.anisotropy = this.anisotropy;
    if (this.anisotropyRotation !== void 0) data2.anisotropyRotation = this.anisotropyRotation;
    if (this.anisotropyMap && this.anisotropyMap.isTexture) {
      data2.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
    }
    if (this.map && this.map.isTexture) data2.map = this.map.toJSON(meta).uuid;
    if (this.matcap && this.matcap.isTexture) data2.matcap = this.matcap.toJSON(meta).uuid;
    if (this.alphaMap && this.alphaMap.isTexture) data2.alphaMap = this.alphaMap.toJSON(meta).uuid;
    if (this.lightMap && this.lightMap.isTexture) {
      data2.lightMap = this.lightMap.toJSON(meta).uuid;
      data2.lightMapIntensity = this.lightMapIntensity;
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data2.aoMap = this.aoMap.toJSON(meta).uuid;
      data2.aoMapIntensity = this.aoMapIntensity;
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data2.bumpMap = this.bumpMap.toJSON(meta).uuid;
      data2.bumpScale = this.bumpScale;
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data2.normalMap = this.normalMap.toJSON(meta).uuid;
      data2.normalMapType = this.normalMapType;
      data2.normalScale = this.normalScale.toArray();
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data2.displacementMap = this.displacementMap.toJSON(meta).uuid;
      data2.displacementScale = this.displacementScale;
      data2.displacementBias = this.displacementBias;
    }
    if (this.roughnessMap && this.roughnessMap.isTexture) data2.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
    if (this.metalnessMap && this.metalnessMap.isTexture) data2.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
    if (this.emissiveMap && this.emissiveMap.isTexture) data2.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
    if (this.specularMap && this.specularMap.isTexture) data2.specularMap = this.specularMap.toJSON(meta).uuid;
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data2.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
    if (this.specularColorMap && this.specularColorMap.isTexture) data2.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
    if (this.envMap && this.envMap.isTexture) {
      data2.envMap = this.envMap.toJSON(meta).uuid;
      if (this.combine !== void 0) data2.combine = this.combine;
    }
    if (this.envMapRotation !== void 0) data2.envMapRotation = this.envMapRotation.toArray();
    if (this.envMapIntensity !== void 0) data2.envMapIntensity = this.envMapIntensity;
    if (this.reflectivity !== void 0) data2.reflectivity = this.reflectivity;
    if (this.refractionRatio !== void 0) data2.refractionRatio = this.refractionRatio;
    if (this.gradientMap && this.gradientMap.isTexture) {
      data2.gradientMap = this.gradientMap.toJSON(meta).uuid;
    }
    if (this.transmission !== void 0) data2.transmission = this.transmission;
    if (this.transmissionMap && this.transmissionMap.isTexture) data2.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
    if (this.thickness !== void 0) data2.thickness = this.thickness;
    if (this.thicknessMap && this.thicknessMap.isTexture) data2.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
    if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data2.attenuationDistance = this.attenuationDistance;
    if (this.attenuationColor !== void 0) data2.attenuationColor = this.attenuationColor.getHex();
    if (this.size !== void 0) data2.size = this.size;
    if (this.shadowSide !== null) data2.shadowSide = this.shadowSide;
    if (this.sizeAttenuation !== void 0) data2.sizeAttenuation = this.sizeAttenuation;
    if (this.blending !== NormalBlending) data2.blending = this.blending;
    if (this.side !== FrontSide) data2.side = this.side;
    if (this.vertexColors === true) data2.vertexColors = true;
    if (this.opacity < 1) data2.opacity = this.opacity;
    if (this.transparent === true) data2.transparent = true;
    if (this.blendSrc !== SrcAlphaFactor) data2.blendSrc = this.blendSrc;
    if (this.blendDst !== OneMinusSrcAlphaFactor) data2.blendDst = this.blendDst;
    if (this.blendEquation !== AddEquation) data2.blendEquation = this.blendEquation;
    if (this.blendSrcAlpha !== null) data2.blendSrcAlpha = this.blendSrcAlpha;
    if (this.blendDstAlpha !== null) data2.blendDstAlpha = this.blendDstAlpha;
    if (this.blendEquationAlpha !== null) data2.blendEquationAlpha = this.blendEquationAlpha;
    if (this.blendColor && this.blendColor.isColor) data2.blendColor = this.blendColor.getHex();
    if (this.blendAlpha !== 0) data2.blendAlpha = this.blendAlpha;
    if (this.depthFunc !== LessEqualDepth) data2.depthFunc = this.depthFunc;
    if (this.depthTest === false) data2.depthTest = this.depthTest;
    if (this.depthWrite === false) data2.depthWrite = this.depthWrite;
    if (this.colorWrite === false) data2.colorWrite = this.colorWrite;
    if (this.stencilWriteMask !== 255) data2.stencilWriteMask = this.stencilWriteMask;
    if (this.stencilFunc !== AlwaysStencilFunc) data2.stencilFunc = this.stencilFunc;
    if (this.stencilRef !== 0) data2.stencilRef = this.stencilRef;
    if (this.stencilFuncMask !== 255) data2.stencilFuncMask = this.stencilFuncMask;
    if (this.stencilFail !== KeepStencilOp) data2.stencilFail = this.stencilFail;
    if (this.stencilZFail !== KeepStencilOp) data2.stencilZFail = this.stencilZFail;
    if (this.stencilZPass !== KeepStencilOp) data2.stencilZPass = this.stencilZPass;
    if (this.stencilWrite === true) data2.stencilWrite = this.stencilWrite;
    if (this.rotation !== void 0 && this.rotation !== 0) data2.rotation = this.rotation;
    if (this.polygonOffset === true) data2.polygonOffset = true;
    if (this.polygonOffsetFactor !== 0) data2.polygonOffsetFactor = this.polygonOffsetFactor;
    if (this.polygonOffsetUnits !== 0) data2.polygonOffsetUnits = this.polygonOffsetUnits;
    if (this.linewidth !== void 0 && this.linewidth !== 1) data2.linewidth = this.linewidth;
    if (this.dashSize !== void 0) data2.dashSize = this.dashSize;
    if (this.gapSize !== void 0) data2.gapSize = this.gapSize;
    if (this.scale !== void 0) data2.scale = this.scale;
    if (this.dithering === true) data2.dithering = true;
    if (this.alphaTest > 0) data2.alphaTest = this.alphaTest;
    if (this.alphaHash === true) data2.alphaHash = true;
    if (this.alphaToCoverage === true) data2.alphaToCoverage = true;
    if (this.premultipliedAlpha === true) data2.premultipliedAlpha = true;
    if (this.forceSinglePass === true) data2.forceSinglePass = true;
    if (this.allowOverride === false) data2.allowOverride = false;
    if (this.wireframe === true) data2.wireframe = true;
    if (this.wireframeLinewidth > 1) data2.wireframeLinewidth = this.wireframeLinewidth;
    if (this.wireframeLinecap !== "round") data2.wireframeLinecap = this.wireframeLinecap;
    if (this.wireframeLinejoin !== "round") data2.wireframeLinejoin = this.wireframeLinejoin;
    if (this.flatShading === true) data2.flatShading = true;
    if (this.visible === false) data2.visible = false;
    if (this.toneMapped === false) data2.toneMapped = false;
    if (this.fog === false) data2.fog = false;
    if (Object.keys(this.userData).length > 0) data2.userData = this.userData;
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data3 = cache[key];
        delete data3.metadata;
        values.push(data3);
      }
      return values;
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      if (textures.length > 0) data2.textures = textures;
      if (images.length > 0) data2.images = images;
    }
    return data2;
  }
  /**
   * Returns a new material with copied values from this instance.
   *
   * @return {Material} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given material to this instance.
   *
   * @param {Material} source - The material to copy.
   * @return {Material} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.blending = source.blending;
    this.side = source.side;
    this.vertexColors = source.vertexColors;
    this.opacity = source.opacity;
    this.transparent = source.transparent;
    this.blendSrc = source.blendSrc;
    this.blendDst = source.blendDst;
    this.blendEquation = source.blendEquation;
    this.blendSrcAlpha = source.blendSrcAlpha;
    this.blendDstAlpha = source.blendDstAlpha;
    this.blendEquationAlpha = source.blendEquationAlpha;
    this.blendColor.copy(source.blendColor);
    this.blendAlpha = source.blendAlpha;
    this.depthFunc = source.depthFunc;
    this.depthTest = source.depthTest;
    this.depthWrite = source.depthWrite;
    this.stencilWriteMask = source.stencilWriteMask;
    this.stencilFunc = source.stencilFunc;
    this.stencilRef = source.stencilRef;
    this.stencilFuncMask = source.stencilFuncMask;
    this.stencilFail = source.stencilFail;
    this.stencilZFail = source.stencilZFail;
    this.stencilZPass = source.stencilZPass;
    this.stencilWrite = source.stencilWrite;
    const srcPlanes = source.clippingPlanes;
    let dstPlanes = null;
    if (srcPlanes !== null) {
      const n2 = srcPlanes.length;
      dstPlanes = new Array(n2);
      for (let i2 = 0; i2 !== n2; ++i2) {
        dstPlanes[i2] = srcPlanes[i2].clone();
      }
    }
    this.clippingPlanes = dstPlanes;
    this.clipIntersection = source.clipIntersection;
    this.clipShadows = source.clipShadows;
    this.shadowSide = source.shadowSide;
    this.colorWrite = source.colorWrite;
    this.precision = source.precision;
    this.polygonOffset = source.polygonOffset;
    this.polygonOffsetFactor = source.polygonOffsetFactor;
    this.polygonOffsetUnits = source.polygonOffsetUnits;
    this.dithering = source.dithering;
    this.alphaTest = source.alphaTest;
    this.alphaHash = source.alphaHash;
    this.alphaToCoverage = source.alphaToCoverage;
    this.premultipliedAlpha = source.premultipliedAlpha;
    this.forceSinglePass = source.forceSinglePass;
    this.allowOverride = source.allowOverride;
    this.visible = source.visible;
    this.toneMapped = source.toneMapped;
    this.userData = JSON.parse(JSON.stringify(source.userData));
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires Material#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  /**
   * Setting this property to `true` indicates the engine the material
   * needs to be recompiled.
   *
   * @type {boolean}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
};
var MeshBasicMaterial = class extends Material {
  /**
   * Constructs a new mesh basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshBasicMaterial = true;
    this.type = "MeshBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.specularMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.combine = MultiplyOperation;
    this.reflectivity = 1;
    this.refractionRatio = 0.98;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.specularMap = source.specularMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.combine = source.combine;
    this.reflectivity = source.reflectivity;
    this.refractionRatio = source.refractionRatio;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.fog = source.fog;
    return this;
  }
};
var _vector$9 = /* @__PURE__ */ new Vector3();
var _vector2$1 = /* @__PURE__ */ new Vector2();
var _id$2 = 0;
var BufferAttribute = class {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array, itemSize, normalized = false) {
    if (Array.isArray(array)) {
      throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
    }
    this.isBufferAttribute = true;
    Object.defineProperty(this, "id", { value: _id$2++ });
    this.name = "";
    this.array = array;
    this.itemSize = itemSize;
    this.count = array !== void 0 ? array.length / itemSize : 0;
    this.normalized = normalized;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.gpuType = FloatType;
    this.version = 0;
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute
   * array data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this buffer attribute.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {BufferAttribute} A reference to this buffer attribute.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given buffer attribute to this instance.
   *
   * @param {BufferAttribute} source - The buffer attribute to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copy(source) {
    this.name = source.name;
    this.array = new source.array.constructor(source.array);
    this.itemSize = source.itemSize;
    this.count = source.count;
    this.normalized = source.normalized;
    this.usage = source.usage;
    this.gpuType = source.gpuType;
    return this;
  }
  /**
   * Copies a vector from the given buffer attribute to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this buffer attribute.
   * @param {BufferAttribute} attribute - The buffer attribute to copy from.
   * @param {number} index2 - The source index into the given buffer attribute.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize;
    index2 *= attribute.itemSize;
    for (let i2 = 0, l2 = this.itemSize; i2 < l2; i2++) {
      this.array[index1 + i2] = attribute.array[index2 + i2];
    }
    return this;
  }
  /**
   * Copies the given array data into this buffer attribute.
   *
   * @param {(TypedArray|Array)} array - The array to copy.
   * @return {BufferAttribute} A reference to this instance.
   */
  copyArray(array) {
    this.array.set(array);
    return this;
  }
  /**
   * Applies the given 3x3 matrix to the given attribute. Works with
   * item size `2` and `3`.
   *
   * @param {Matrix3} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix3(m2) {
    if (this.itemSize === 2) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector2$1.fromBufferAttribute(this, i2);
        _vector2$1.applyMatrix3(m2);
        this.setXY(i2, _vector2$1.x, _vector2$1.y);
      }
    } else if (this.itemSize === 3) {
      for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
        _vector$9.fromBufferAttribute(this, i2);
        _vector$9.applyMatrix3(m2);
        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
      }
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyMatrix4(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {BufferAttribute} A reference to this instance.
   */
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$9.fromBufferAttribute(this, i2);
      _vector$9.transformDirection(m2);
      this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);
    }
    return this;
  }
  /**
   * Sets the given array data in the buffer attribute.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this buffer attribute's array.
   * @return {BufferAttribute} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.itemSize + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.array[index * this.itemSize + component] = value;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x2 = this.array[index * this.itemSize];
    if (this.normalized) x2 = denormalize(x2, this.array);
    return x2;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setX(index, x2) {
    if (this.normalized) x2 = normalize(x2, this.array);
    this.array[index * this.itemSize] = x2;
    return this;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y2 = this.array[index * this.itemSize + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.array[index * this.itemSize + 1] = y2;
    return this;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z2 = this.array[index * this.itemSize + 2];
    if (this.normalized) z2 = denormalize(z2, this.array);
    return z2;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setZ(index, z2) {
    if (this.normalized) z2 = normalize(z2, this.array);
    this.array[index * this.itemSize + 2] = z2;
    return this;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w2 = this.array[index * this.itemSize + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setW(index, w2) {
    if (this.normalized) w2 = normalize(w2, this.array);
    this.array[index * this.itemSize + 3] = w2;
    return this;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXY(index, x2, y2) {
    index *= this.itemSize;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
    }
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZ(index, x2, y2, z2) {
    index *= this.itemSize;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
      z2 = normalize(z2, this.array);
    }
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setXYZW(index, x2, y2, z2, w2) {
    index *= this.itemSize;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
      z2 = normalize(z2, this.array);
      w2 = normalize(w2, this.array);
    }
    this.array[index + 0] = x2;
    this.array[index + 1] = y2;
    this.array[index + 2] = z2;
    this.array[index + 3] = w2;
    return this;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the attribute array data to the GPU. Can be used to perform clean-up operations after
   * the upload when attribute data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {BufferAttribute} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * @return {BufferAttribute} A clone of this instance.
   */
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON() {
    const data2 = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized
    };
    if (this.name !== "") data2.name = this.name;
    if (this.usage !== StaticDrawUsage) data2.usage = this.usage;
    return data2;
  }
};
var Uint16BufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint16Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized);
  }
};
var Uint32BufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Uint32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized);
  }
};
var Float32BufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new buffer attribute.
   *
   * @param {(Array<number>|Float32Array)} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized);
  }
};
var _id$1 = 0;
var _m1 = /* @__PURE__ */ new Matrix4();
var _obj = /* @__PURE__ */ new Object3D();
var _offset = /* @__PURE__ */ new Vector3();
var _box$2 = /* @__PURE__ */ new Box3();
var _boxMorphTargets = /* @__PURE__ */ new Box3();
var _vector$8 = /* @__PURE__ */ new Vector3();
var BufferGeometry = class _BufferGeometry extends EventDispatcher {
  /**
   * Constructs a new geometry.
   */
  constructor() {
    super();
    this.isBufferGeometry = true;
    Object.defineProperty(this, "id", { value: _id$1++ });
    this.uuid = generateUUID();
    this.name = "";
    this.type = "BufferGeometry";
    this.index = null;
    this.indirect = null;
    this.indirectOffset = 0;
    this.attributes = {};
    this.morphAttributes = {};
    this.morphTargetsRelative = false;
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    this.drawRange = { start: 0, count: Infinity };
    this.userData = {};
  }
  /**
   * Returns the index of this geometry.
   *
   * @return {?BufferAttribute} The index. Returns `null` if no index is defined.
   */
  getIndex() {
    return this.index;
  }
  /**
   * Sets the given index to this geometry.
   *
   * @param {Array<number>|BufferAttribute} index - The index to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
    } else {
      this.index = index;
    }
    return this;
  }
  /**
   * Sets the given indirect attribute to this geometry.
   *
   * @param {BufferAttribute} indirect - The attribute holding indirect draw calls.
   * @param {number|Array<number>} [indirectOffset=0] - The offset, in bytes, into the indirect drawing buffer where the value data begins. If an array is provided, multiple indirect draw calls will be made for each offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  setIndirect(indirect, indirectOffset = 0) {
    this.indirect = indirect;
    this.indirectOffset = indirectOffset;
    return this;
  }
  /**
   * Returns the indirect attribute of this geometry.
   *
   * @return {?BufferAttribute} The indirect attribute. Returns `null` if no indirect attribute is defined.
   */
  getIndirect() {
    return this.indirect;
  }
  /**
   * Returns the buffer attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {BufferAttribute|InterleavedBufferAttribute|undefined} The buffer attribute.
   * Returns `undefined` if not attribute has been found.
   */
  getAttribute(name) {
    return this.attributes[name];
  }
  /**
   * Sets the given attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @param {BufferAttribute|InterleavedBufferAttribute} attribute - The attribute to set.
   * @return {BufferGeometry} A reference to this instance.
   */
  setAttribute(name, attribute) {
    this.attributes[name] = attribute;
    return this;
  }
  /**
   * Deletes the attribute for the given name.
   *
   * @param {string} name - The attribute name to delete.
   * @return {BufferGeometry} A reference to this instance.
   */
  deleteAttribute(name) {
    delete this.attributes[name];
    return this;
  }
  /**
   * Returns `true` if this geometry has an attribute for the given name.
   *
   * @param {string} name - The attribute name.
   * @return {boolean} Whether this geometry has an attribute for the given name or not.
   */
  hasAttribute(name) {
    return this.attributes[name] !== void 0;
  }
  /**
   * Adds a group to this geometry.
   *
   * @param {number} start - The first element in this draw call. That is the first
   * vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - Specifies how many vertices (or indices) are part of this group.
   * @param {number} [materialIndex=0] - The material array index to use.
   */
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex
    });
  }
  /**
   * Clears all groups.
   */
  clearGroups() {
    this.groups = [];
  }
  /**
   * Sets the draw range for this geometry.
   *
   * @param {number} start - The first vertex for non-indexed geometry, otherwise the first triangle index.
   * @param {number} count - For non-indexed BufferGeometry, `count` is the number of vertices to render.
   * For indexed BufferGeometry, `count` is the number of indices to render.
   */
  setDrawRange(start, count) {
    this.drawRange.start = start;
    this.drawRange.count = count;
  }
  /**
   * Applies the given 4x4 transformation matrix to the geometry.
   *
   * @param {Matrix4} matrix - The matrix to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyMatrix4(matrix) {
    const position = this.attributes.position;
    if (position !== void 0) {
      position.applyMatrix4(matrix);
      position.needsUpdate = true;
    }
    const normal = this.attributes.normal;
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix);
      normal.applyNormalMatrix(normalMatrix);
      normal.needsUpdate = true;
    }
    const tangent = this.attributes.tangent;
    if (tangent !== void 0) {
      tangent.transformDirection(matrix);
      tangent.needsUpdate = true;
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox();
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere();
    }
    return this;
  }
  /**
   * Applies the rotation represented by the Quaternion to the geometry.
   *
   * @param {Quaternion} q - The Quaternion to apply.
   * @return {BufferGeometry} A reference to this instance.
   */
  applyQuaternion(q2) {
    _m1.makeRotationFromQuaternion(q2);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Rotates the geometry about the X axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateX(angle) {
    _m1.makeRotationX(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Rotates the geometry about the Y axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateY(angle) {
    _m1.makeRotationY(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Rotates the geometry about the Z axis. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#rotation} for typical
   * real-time mesh rotation.
   *
   * @param {number} angle - The angle in radians.
   * @return {BufferGeometry} A reference to this instance.
   */
  rotateZ(angle) {
    _m1.makeRotationZ(angle);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Translates the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#position} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x offset.
   * @param {number} y - The y offset.
   * @param {number} z - The z offset.
   * @return {BufferGeometry} A reference to this instance.
   */
  translate(x2, y2, z2) {
    _m1.makeTranslation(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Scales the geometry. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#scale} for typical
   * real-time mesh rotation.
   *
   * @param {number} x - The x scale.
   * @param {number} y - The y scale.
   * @param {number} z - The z scale.
   * @return {BufferGeometry} A reference to this instance.
   */
  scale(x2, y2, z2) {
    _m1.makeScale(x2, y2, z2);
    this.applyMatrix4(_m1);
    return this;
  }
  /**
   * Rotates the geometry to face a point in 3D space. This is typically done as a one time
   * operation, and not during a loop. Use {@link Object3D#lookAt} for typical
   * real-time mesh rotation.
   *
   * @param {Vector3} vector - The target point.
   * @return {BufferGeometry} A reference to this instance.
   */
  lookAt(vector) {
    _obj.lookAt(vector);
    _obj.updateMatrix();
    this.applyMatrix4(_obj.matrix);
    return this;
  }
  /**
   * Center the geometry based on its bounding box.
   *
   * @return {BufferGeometry} A reference to this instance.
   */
  center() {
    this.computeBoundingBox();
    this.boundingBox.getCenter(_offset).negate();
    this.translate(_offset.x, _offset.y, _offset.z);
    return this;
  }
  /**
   * Defines a geometry by creating a `position` attribute based on the given array of points. The array
   * can hold 2D or 3D vectors. When using two-dimensional data, the `z` coordinate for all vertices is
   * set to `0`.
   *
   * If the method is used with an existing `position` attribute, the vertex data are overwritten with the
   * data from the array. The length of the array must match the vertex count.
   *
   * @param {Array<Vector2>|Array<Vector3>} points - The points.
   * @return {BufferGeometry} A reference to this instance.
   */
  setFromPoints(points) {
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute === void 0) {
      const position = [];
      for (let i2 = 0, l2 = points.length; i2 < l2; i2++) {
        const point = points[i2];
        position.push(point.x, point.y, point.z || 0);
      }
      this.setAttribute("position", new Float32BufferAttribute(position, 3));
    } else {
      const l2 = Math.min(points.length, positionAttribute.count);
      for (let i2 = 0; i2 < l2; i2++) {
        const point = points[i2];
        positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);
      }
      if (points.length > positionAttribute.count) {
        warn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.");
      }
      positionAttribute.needsUpdate = true;
    }
    return this;
  }
  /**
   * Computes the bounding box of the geometry, and updates the `boundingBox` member.
   * The bounding box is not computed by the engine; it must be computed by your app.
   * You may need to recompute the bounding box if the geometry vertices are modified.
   */
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      error("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this);
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity)
      );
      return;
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _box$2.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(this.boundingBox.min, _box$2.min);
            this.boundingBox.expandByPoint(_vector$8);
            _vector$8.addVectors(this.boundingBox.max, _box$2.max);
            this.boundingBox.expandByPoint(_vector$8);
          } else {
            this.boundingBox.expandByPoint(_box$2.min);
            this.boundingBox.expandByPoint(_box$2.max);
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty();
    }
    if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
      error('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
    }
  }
  /**
   * Computes the bounding sphere of the geometry, and updates the `boundingSphere` member.
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if the geometry vertices are modified.
   */
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    const position = this.attributes.position;
    const morphAttributesPosition = this.morphAttributes.position;
    if (position && position.isGLBufferAttribute) {
      error("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this);
      this.boundingSphere.set(new Vector3(), Infinity);
      return;
    }
    if (position) {
      const center = this.boundingSphere.center;
      _box$2.setFromBufferAttribute(position);
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          _boxMorphTargets.setFromBufferAttribute(morphAttribute);
          if (this.morphTargetsRelative) {
            _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
            _box$2.expandByPoint(_vector$8);
            _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
            _box$2.expandByPoint(_vector$8);
          } else {
            _box$2.expandByPoint(_boxMorphTargets.min);
            _box$2.expandByPoint(_boxMorphTargets.max);
          }
        }
      }
      _box$2.getCenter(center);
      let maxRadiusSq = 0;
      for (let i2 = 0, il = position.count; i2 < il; i2++) {
        _vector$8.fromBufferAttribute(position, i2);
        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
      }
      if (morphAttributesPosition) {
        for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {
          const morphAttribute = morphAttributesPosition[i2];
          const morphTargetsRelative = this.morphTargetsRelative;
          for (let j2 = 0, jl = morphAttribute.count; j2 < jl; j2++) {
            _vector$8.fromBufferAttribute(morphAttribute, j2);
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j2);
              _vector$8.add(_offset);
            }
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
      if (isNaN(this.boundingSphere.radius)) {
        error('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
      }
    }
  }
  /**
   * Calculates and adds a tangent attribute to this geometry.
   *
   * The computation is only supported for indexed geometries and if position, normal, and uv attributes
   * are defined. When using a tangent space normal map, prefer the MikkTSpace algorithm provided by
   * {@link BufferGeometryUtils#computeMikkTSpaceTangents} instead.
   */
  computeTangents() {
    const index = this.index;
    const attributes = this.attributes;
    if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {
      error("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
      return;
    }
    const positionAttribute = attributes.position;
    const normalAttribute = attributes.normal;
    const uvAttribute = attributes.uv;
    if (this.hasAttribute("tangent") === false) {
      this.setAttribute("tangent", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
    }
    const tangentAttribute = this.getAttribute("tangent");
    const tan1 = [], tan2 = [];
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      tan1[i2] = new Vector3();
      tan2[i2] = new Vector3();
    }
    const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();
    function handleTriangle(a2, b2, c2) {
      vA.fromBufferAttribute(positionAttribute, a2);
      vB.fromBufferAttribute(positionAttribute, b2);
      vC.fromBufferAttribute(positionAttribute, c2);
      uvA.fromBufferAttribute(uvAttribute, a2);
      uvB.fromBufferAttribute(uvAttribute, b2);
      uvC.fromBufferAttribute(uvAttribute, c2);
      vB.sub(vA);
      vC.sub(vA);
      uvB.sub(uvA);
      uvC.sub(uvA);
      const r2 = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);
      if (!isFinite(r2)) return;
      sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r2);
      tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r2);
      tan1[a2].add(sdir);
      tan1[b2].add(sdir);
      tan1[c2].add(sdir);
      tan2[a2].add(tdir);
      tan2[b2].add(tdir);
      tan2[c2].add(tdir);
    }
    let groups = this.groups;
    if (groups.length === 0) {
      groups = [{
        start: 0,
        count: index.count
      }];
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleTriangle(
          index.getX(j2 + 0),
          index.getX(j2 + 1),
          index.getX(j2 + 2)
        );
      }
    }
    const tmp = new Vector3(), tmp2 = new Vector3();
    const n2 = new Vector3(), n22 = new Vector3();
    function handleVertex(v2) {
      n2.fromBufferAttribute(normalAttribute, v2);
      n22.copy(n2);
      const t2 = tan1[v2];
      tmp.copy(t2);
      tmp.sub(n2.multiplyScalar(n2.dot(t2))).normalize();
      tmp2.crossVectors(n22, t2);
      const test2 = tmp2.dot(tan2[v2]);
      const w2 = test2 < 0 ? -1 : 1;
      tangentAttribute.setXYZW(v2, tmp.x, tmp.y, tmp.z, w2);
    }
    for (let i2 = 0, il = groups.length; i2 < il; ++i2) {
      const group = groups[i2];
      const start = group.start;
      const count = group.count;
      for (let j2 = start, jl = start + count; j2 < jl; j2 += 3) {
        handleVertex(index.getX(j2 + 0));
        handleVertex(index.getX(j2 + 1));
        handleVertex(index.getX(j2 + 2));
      }
    }
  }
  /**
   * Computes vertex normals for the given vertex data. For indexed geometries, the method sets
   * each vertex normal to be the average of the face normals of the faces that share that vertex.
   * For non-indexed geometries, vertices are not shared, and the method sets each vertex normal
   * to be the same as the face normal.
   */
  computeVertexNormals() {
    const index = this.index;
    const positionAttribute = this.getAttribute("position");
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute("normal");
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
        this.setAttribute("normal", normalAttribute);
      } else {
        for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {
          normalAttribute.setXYZ(i2, 0, 0, 0);
        }
      }
      const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
      const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();
      const cb = new Vector3(), ab = new Vector3();
      if (index) {
        for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {
          const vA = index.getX(i2 + 0);
          const vB = index.getX(i2 + 1);
          const vC = index.getX(i2 + 2);
          pA.fromBufferAttribute(positionAttribute, vA);
          pB.fromBufferAttribute(positionAttribute, vB);
          pC.fromBufferAttribute(positionAttribute, vC);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          nA.fromBufferAttribute(normalAttribute, vA);
          nB.fromBufferAttribute(normalAttribute, vB);
          nC.fromBufferAttribute(normalAttribute, vC);
          nA.add(cb);
          nB.add(cb);
          nC.add(cb);
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
        }
      } else {
        for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {
          pA.fromBufferAttribute(positionAttribute, i2 + 0);
          pB.fromBufferAttribute(positionAttribute, i2 + 1);
          pC.fromBufferAttribute(positionAttribute, i2 + 2);
          cb.subVectors(pC, pB);
          ab.subVectors(pA, pB);
          cb.cross(ab);
          normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);
          normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);
        }
      }
      this.normalizeNormals();
      normalAttribute.needsUpdate = true;
    }
  }
  /**
   * Ensures every normal vector in a geometry will have a magnitude of `1`. This will
   * correct lighting on the geometry surfaces.
   */
  normalizeNormals() {
    const normals = this.attributes.normal;
    for (let i2 = 0, il = normals.count; i2 < il; i2++) {
      _vector$8.fromBufferAttribute(normals, i2);
      _vector$8.normalize();
      normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);
    }
  }
  /**
   * Return a new non-index version of this indexed geometry. If the geometry
   * is already non-indexed, the method is a NOOP.
   *
   * @return {BufferGeometry} The non-indexed version of this indexed geometry.
   */
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array;
      const itemSize = attribute.itemSize;
      const normalized = attribute.normalized;
      const array2 = new array.constructor(indices2.length * itemSize);
      let index = 0, index2 = 0;
      for (let i2 = 0, l2 = indices2.length; i2 < l2; i2++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i2] * attribute.data.stride + attribute.offset;
        } else {
          index = indices2[i2] * itemSize;
        }
        for (let j2 = 0; j2 < itemSize; j2++) {
          array2[index2++] = array[index++];
        }
      }
      return new BufferAttribute(array2, itemSize, normalized);
    }
    if (this.index === null) {
      warn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.");
      return this;
    }
    const geometry2 = new _BufferGeometry();
    const indices = this.index.array;
    const attributes = this.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      const newAttribute = convertBufferAttribute(attribute, indices);
      geometry2.setAttribute(name, newAttribute);
    }
    const morphAttributes = this.morphAttributes;
    for (const name in morphAttributes) {
      const morphArray = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {
        const attribute = morphAttribute[i2];
        const newAttribute = convertBufferAttribute(attribute, indices);
        morphArray.push(newAttribute);
      }
      geometry2.morphAttributes[name] = morphArray;
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative;
    const groups = this.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      geometry2.addGroup(group.start, group.count, group.materialIndex);
    }
    return geometry2;
  }
  /**
   * Serializes the geometry into JSON.
   *
   * @return {Object} A JSON object representing the serialized geometry.
   */
  toJSON() {
    const data2 = {
      metadata: {
        version: 4.7,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON"
      }
    };
    data2.uuid = this.uuid;
    data2.type = this.type;
    if (this.name !== "") data2.name = this.name;
    if (Object.keys(this.userData).length > 0) data2.userData = this.userData;
    if (this.parameters !== void 0) {
      const parameters = this.parameters;
      for (const key in parameters) {
        if (parameters[key] !== void 0) data2[key] = parameters[key];
      }
      return data2;
    }
    data2.data = { attributes: {} };
    const index = this.index;
    if (index !== null) {
      data2.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array)
      };
    }
    const attributes = this.attributes;
    for (const key in attributes) {
      const attribute = attributes[key];
      data2.data.attributes[key] = attribute.toJSON(data2.data);
    }
    const morphAttributes = {};
    let hasMorphAttributes = false;
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key];
      const array = [];
      for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {
        const attribute = attributeArray[i2];
        array.push(attribute.toJSON(data2.data));
      }
      if (array.length > 0) {
        morphAttributes[key] = array;
        hasMorphAttributes = true;
      }
    }
    if (hasMorphAttributes) {
      data2.data.morphAttributes = morphAttributes;
      data2.data.morphTargetsRelative = this.morphTargetsRelative;
    }
    const groups = this.groups;
    if (groups.length > 0) {
      data2.data.groups = JSON.parse(JSON.stringify(groups));
    }
    const boundingSphere = this.boundingSphere;
    if (boundingSphere !== null) {
      data2.data.boundingSphere = boundingSphere.toJSON();
    }
    return data2;
  }
  /**
   * Returns a new geometry with copied values from this instance.
   *
   * @return {BufferGeometry} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Copies the values of the given geometry to this instance.
   *
   * @param {BufferGeometry} source - The geometry to copy.
   * @return {BufferGeometry} A reference to this instance.
   */
  copy(source) {
    this.index = null;
    this.attributes = {};
    this.morphAttributes = {};
    this.groups = [];
    this.boundingBox = null;
    this.boundingSphere = null;
    const data2 = {};
    this.name = source.name;
    const index = source.index;
    if (index !== null) {
      this.setIndex(index.clone());
    }
    const attributes = source.attributes;
    for (const name in attributes) {
      const attribute = attributes[name];
      this.setAttribute(name, attribute.clone(data2));
    }
    const morphAttributes = source.morphAttributes;
    for (const name in morphAttributes) {
      const array = [];
      const morphAttribute = morphAttributes[name];
      for (let i2 = 0, l2 = morphAttribute.length; i2 < l2; i2++) {
        array.push(morphAttribute[i2].clone(data2));
      }
      this.morphAttributes[name] = array;
    }
    this.morphTargetsRelative = source.morphTargetsRelative;
    const groups = source.groups;
    for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
      const group = groups[i2];
      this.addGroup(group.start, group.count, group.materialIndex);
    }
    const boundingBox = source.boundingBox;
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone();
    }
    const boundingSphere = source.boundingSphere;
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone();
    }
    this.drawRange.start = source.drawRange.start;
    this.drawRange.count = source.drawRange.count;
    this.userData = source.userData;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   *
   * @fires BufferGeometry#dispose
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
};
var _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();
var _ray$3 = /* @__PURE__ */ new Ray();
var _sphere$6 = /* @__PURE__ */ new Sphere();
var _sphereHitAt = /* @__PURE__ */ new Vector3();
var _vA$1 = /* @__PURE__ */ new Vector3();
var _vB$1 = /* @__PURE__ */ new Vector3();
var _vC$1 = /* @__PURE__ */ new Vector3();
var _tempA = /* @__PURE__ */ new Vector3();
var _morphA = /* @__PURE__ */ new Vector3();
var _intersectionPoint = /* @__PURE__ */ new Vector3();
var _intersectionPointWorld = /* @__PURE__ */ new Vector3();
var Mesh = class extends Object3D {
  /**
   * Constructs a new mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {
    super();
    this.isMesh = true;
    this.type = "Mesh";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.count = 1;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice();
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
    }
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Sets the values of {@link Mesh#morphTargetDictionary} and {@link Mesh#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
  /**
   * Returns the local-space position of the vertex at the given index, taking into
   * account the current animation state of both morph targets and skinning.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * @return {Vector3} The vertex position in local space.
   */
  getVertexPosition(index, target) {
    const geometry = this.geometry;
    const position = geometry.attributes.position;
    const morphPosition = geometry.morphAttributes.position;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    target.fromBufferAttribute(position, index);
    const morphInfluences = this.morphTargetInfluences;
    if (morphPosition && morphInfluences) {
      _morphA.set(0, 0, 0);
      for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {
        const influence = morphInfluences[i2];
        const morphAttribute = morphPosition[i2];
        if (influence === 0) continue;
        _tempA.fromBufferAttribute(morphAttribute, index);
        if (morphTargetsRelative) {
          _morphA.addScaledVector(_tempA, influence);
        } else {
          _morphA.addScaledVector(_tempA.sub(target), influence);
        }
      }
      target.add(_morphA);
    }
    return target;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$6.copy(geometry.boundingSphere);
    _sphere$6.applyMatrix4(matrixWorld);
    _ray$3.copy(raycaster.ray).recast(raycaster.near);
    if (_sphere$6.containsPoint(_ray$3.origin) === false) {
      if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
      if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
    }
    _inverseMatrix$3.copy(matrixWorld).invert();
    _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);
    if (geometry.boundingBox !== null) {
      if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects, _ray$3);
  }
  _computeIntersections(raycaster, intersects, rayLocalSpace) {
    let intersection;
    const geometry = this.geometry;
    const material = this.material;
    const index = geometry.index;
    const position = geometry.attributes.position;
    const uv = geometry.attributes.uv;
    const uv1 = geometry.attributes.uv1;
    const normal = geometry.attributes.normal;
    const groups = geometry.groups;
    const drawRange = geometry.drawRange;
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
            const a2 = index.getX(j2);
            const b2 = index.getX(j2 + 1);
            const c2 = index.getX(j2 + 2);
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(j2 / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(index.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = index.getX(i2);
          const b2 = index.getX(i2 + 1);
          const c2 = index.getX(i2 + 2);
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i2 = 0, il = groups.length; i2 < il; i2++) {
          const group = groups[i2];
          const groupMaterial = material[group.materialIndex];
          const start = Math.max(group.start, drawRange.start);
          const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
          for (let j2 = start, jl = end; j2 < jl; j2 += 3) {
            const a2 = j2;
            const b2 = j2 + 1;
            const c2 = j2 + 2;
            intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
            if (intersection) {
              intersection.faceIndex = Math.floor(j2 / 3);
              intersection.face.materialIndex = group.materialIndex;
              intersects.push(intersection);
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start);
        const end = Math.min(position.count, drawRange.start + drawRange.count);
        for (let i2 = start, il = end; i2 < il; i2 += 3) {
          const a2 = i2;
          const b2 = i2 + 1;
          const c2 = i2 + 2;
          intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a2, b2, c2);
          if (intersection) {
            intersection.faceIndex = Math.floor(i2 / 3);
            intersects.push(intersection);
          }
        }
      }
    }
  }
};
function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
  let intersect;
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point);
  } else {
    intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
  }
  if (intersect === null) return null;
  _intersectionPointWorld.copy(point);
  _intersectionPointWorld.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
  if (distance < raycaster.near || distance > raycaster.far) return null;
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object
  };
}
function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a2, b2, c2) {
  object.getVertexPosition(a2, _vA$1);
  object.getVertexPosition(b2, _vB$1);
  object.getVertexPosition(c2, _vC$1);
  const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
  if (intersection) {
    const barycoord = new Vector3();
    Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
    if (uv) {
      intersection.uv = Triangle.getInterpolatedAttribute(uv, a2, b2, c2, barycoord, new Vector2());
    }
    if (uv1) {
      intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a2, b2, c2, barycoord, new Vector2());
    }
    if (normal) {
      intersection.normal = Triangle.getInterpolatedAttribute(normal, a2, b2, c2, barycoord, new Vector3());
      if (intersection.normal.dot(ray.direction) > 0) {
        intersection.normal.multiplyScalar(-1);
      }
    }
    const face = {
      a: a2,
      b: b2,
      c: c2,
      normal: new Vector3(),
      materialIndex: 0
    };
    Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
    intersection.face = face;
    intersection.barycoord = barycoord;
  }
  return intersection;
}
var BoxGeometry = class _BoxGeometry extends BufferGeometry {
  /**
   * Constructs a new box geometry.
   *
   * @param {number} [width=1] - The width. That is, the length of the edges parallel to the X axis.
   * @param {number} [height=1] - The height. That is, the length of the edges parallel to the Y axis.
   * @param {number} [depth=1] - The depth. That is, the length of the edges parallel to the Z axis.
   * @param {number} [widthSegments=1] - Number of segmented rectangular faces along the width of the sides.
   * @param {number} [heightSegments=1] - Number of segmented rectangular faces along the height of the sides.
   * @param {number} [depthSegments=1] - Number of segmented rectangular faces along the depth of the sides.
   */
  constructor(width = 1, height = 1, depth = 1, widthSegments = 1, heightSegments = 1, depthSegments = 1) {
    super();
    this.type = "BoxGeometry";
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments
    };
    const scope = this;
    widthSegments = Math.floor(widthSegments);
    heightSegments = Math.floor(heightSegments);
    depthSegments = Math.floor(depthSegments);
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    let numberOfVertices = 0;
    let groupStart = 0;
    buildPlane("z", "y", "x", -1, -1, depth, height, width, depthSegments, heightSegments, 0);
    buildPlane("z", "y", "x", 1, -1, depth, height, -width, depthSegments, heightSegments, 1);
    buildPlane("x", "z", "y", 1, 1, width, depth, height, widthSegments, depthSegments, 2);
    buildPlane("x", "z", "y", 1, -1, width, depth, -height, widthSegments, depthSegments, 3);
    buildPlane("x", "y", "z", 1, -1, width, height, depth, widthSegments, heightSegments, 4);
    buildPlane("x", "y", "z", -1, -1, width, height, -depth, widthSegments, heightSegments, 5);
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
    function buildPlane(u2, v2, w2, udir, vdir, width2, height2, depth2, gridX, gridY, materialIndex) {
      const segmentWidth = width2 / gridX;
      const segmentHeight = height2 / gridY;
      const widthHalf = width2 / 2;
      const heightHalf = height2 / 2;
      const depthHalf = depth2 / 2;
      const gridX1 = gridX + 1;
      const gridY1 = gridY + 1;
      let vertexCounter = 0;
      let groupCount = 0;
      const vector = new Vector3();
      for (let iy = 0; iy < gridY1; iy++) {
        const y2 = iy * segmentHeight - heightHalf;
        for (let ix = 0; ix < gridX1; ix++) {
          const x2 = ix * segmentWidth - widthHalf;
          vector[u2] = x2 * udir;
          vector[v2] = y2 * vdir;
          vector[w2] = depthHalf;
          vertices.push(vector.x, vector.y, vector.z);
          vector[u2] = 0;
          vector[v2] = 0;
          vector[w2] = depth2 > 0 ? 1 : -1;
          normals.push(vector.x, vector.y, vector.z);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
          vertexCounter += 1;
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a2 = numberOfVertices + ix + gridX1 * iy;
          const b2 = numberOfVertices + ix + gridX1 * (iy + 1);
          const c2 = numberOfVertices + (ix + 1) + gridX1 * (iy + 1);
          const d2 = numberOfVertices + (ix + 1) + gridX1 * iy;
          indices.push(a2, b2, d2);
          indices.push(b2, c2, d2);
          groupCount += 6;
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex);
      groupStart += groupCount;
      numberOfVertices += vertexCounter;
    }
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {BoxGeometry} A new instance.
   */
  static fromJSON(data2) {
    return new _BoxGeometry(data2.width, data2.height, data2.depth, data2.widthSegments, data2.heightSegments, data2.depthSegments);
  }
};
function cloneUniforms(src) {
  const dst = {};
  for (const u2 in src) {
    dst[u2] = {};
    for (const p2 in src[u2]) {
      const property = src[u2][p2];
      if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
        if (property.isRenderTargetTexture) {
          warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().");
          dst[u2][p2] = null;
        } else {
          dst[u2][p2] = property.clone();
        }
      } else if (Array.isArray(property)) {
        dst[u2][p2] = property.slice();
      } else {
        dst[u2][p2] = property;
      }
    }
  }
  return dst;
}
function mergeUniforms(uniforms) {
  const merged = {};
  for (let u2 = 0; u2 < uniforms.length; u2++) {
    const tmp = cloneUniforms(uniforms[u2]);
    for (const p2 in tmp) {
      merged[p2] = tmp[p2];
    }
  }
  return merged;
}
function cloneUniformsGroups(src) {
  const dst = [];
  for (let u2 = 0; u2 < src.length; u2++) {
    dst.push(src[u2].clone());
  }
  return dst;
}
function getUnlitUniformColorSpace(renderer) {
  const currentRenderTarget = renderer.getRenderTarget();
  if (currentRenderTarget === null) {
    return renderer.outputColorSpace;
  }
  if (currentRenderTarget.isXRRenderTarget === true) {
    return currentRenderTarget.texture.colorSpace;
  }
  return ColorManagement.workingColorSpace;
}
var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
var default_vertex = "void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
var default_fragment = "void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
var ShaderMaterial = class extends Material {
  /**
   * Constructs a new shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isShaderMaterial = true;
    this.type = "ShaderMaterial";
    this.defines = {};
    this.uniforms = {};
    this.uniformsGroups = [];
    this.vertexShader = default_vertex;
    this.fragmentShader = default_fragment;
    this.linewidth = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.fog = false;
    this.lights = false;
    this.clipping = false;
    this.forceSinglePass = true;
    this.extensions = {
      clipCullDistance: false,
      // set to use vertex shader clipping
      multiDraw: false
      // set to use vertex shader multi_draw / enable gl_DrawID
    };
    this.defaultAttributeValues = {
      "color": [1, 1, 1],
      "uv": [0, 0],
      "uv1": [0, 0]
    };
    this.index0AttributeName = void 0;
    this.uniformsNeedUpdate = false;
    this.glslVersion = null;
    if (parameters !== void 0) {
      this.setValues(parameters);
    }
  }
  copy(source) {
    super.copy(source);
    this.fragmentShader = source.fragmentShader;
    this.vertexShader = source.vertexShader;
    this.uniforms = cloneUniforms(source.uniforms);
    this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
    this.defines = Object.assign({}, source.defines);
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.fog = source.fog;
    this.lights = source.lights;
    this.clipping = source.clipping;
    this.extensions = Object.assign({}, source.extensions);
    this.glslVersion = source.glslVersion;
    this.defaultAttributeValues = Object.assign({}, source.defaultAttributeValues);
    this.index0AttributeName = source.index0AttributeName;
    this.uniformsNeedUpdate = source.uniformsNeedUpdate;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.glslVersion = this.glslVersion;
    data2.uniforms = {};
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name];
      const value = uniform.value;
      if (value && value.isTexture) {
        data2.uniforms[name] = {
          type: "t",
          value: value.toJSON(meta).uuid
        };
      } else if (value && value.isColor) {
        data2.uniforms[name] = {
          type: "c",
          value: value.getHex()
        };
      } else if (value && value.isVector2) {
        data2.uniforms[name] = {
          type: "v2",
          value: value.toArray()
        };
      } else if (value && value.isVector3) {
        data2.uniforms[name] = {
          type: "v3",
          value: value.toArray()
        };
      } else if (value && value.isVector4) {
        data2.uniforms[name] = {
          type: "v4",
          value: value.toArray()
        };
      } else if (value && value.isMatrix3) {
        data2.uniforms[name] = {
          type: "m3",
          value: value.toArray()
        };
      } else if (value && value.isMatrix4) {
        data2.uniforms[name] = {
          type: "m4",
          value: value.toArray()
        };
      } else {
        data2.uniforms[name] = {
          value
        };
      }
    }
    if (Object.keys(this.defines).length > 0) data2.defines = this.defines;
    data2.vertexShader = this.vertexShader;
    data2.fragmentShader = this.fragmentShader;
    data2.lights = this.lights;
    data2.clipping = this.clipping;
    const extensions = {};
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true;
    }
    if (Object.keys(extensions).length > 0) data2.extensions = extensions;
    return data2;
  }
};
var Camera = class extends Object3D {
  /**
   * Constructs a new camera.
   */
  constructor() {
    super();
    this.isCamera = true;
    this.type = "Camera";
    this.matrixWorldInverse = new Matrix4();
    this.projectionMatrix = new Matrix4();
    this.projectionMatrixInverse = new Matrix4();
    this.coordinateSystem = WebGLCoordinateSystem;
    this._reversedDepth = false;
  }
  /**
   * The flag that indicates whether the camera uses a reversed depth buffer.
   *
   * @type {boolean}
   * @default false
   */
  get reversedDepth() {
    return this._reversedDepth;
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.matrixWorldInverse.copy(source.matrixWorldInverse);
    this.projectionMatrix.copy(source.projectionMatrix);
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
    this.coordinateSystem = source.coordinateSystem;
    return this;
  }
  /**
   * Returns a vector representing the ("look") direction of the 3D object in world space.
   *
   * This method is overwritten since cameras have a different forward vector compared to other
   * 3D objects. A camera looks down its local, negative z-axis by default.
   *
   * @param {Vector3} target - The target vector the result is stored to.
   * @return {Vector3} The 3D object's direction in world space.
   */
  getWorldDirection(target) {
    return super.getWorldDirection(target).negate();
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
};
var _v3$1 = /* @__PURE__ */ new Vector3();
var _minTarget = /* @__PURE__ */ new Vector2();
var _maxTarget = /* @__PURE__ */ new Vector2();
var PerspectiveCamera = class extends Camera {
  /**
   * Constructs a new perspective camera.
   *
   * @param {number} [fov=50] - The vertical field of view.
   * @param {number} [aspect=1] - The aspect ratio.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super();
    this.isPerspectiveCamera = true;
    this.type = "PerspectiveCamera";
    this.fov = fov2;
    this.zoom = 1;
    this.near = near;
    this.far = far;
    this.focus = 10;
    this.aspect = aspect2;
    this.view = null;
    this.filmGauge = 35;
    this.filmOffset = 0;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.fov = source.fov;
    this.zoom = source.zoom;
    this.near = source.near;
    this.far = source.far;
    this.focus = source.focus;
    this.aspect = source.aspect;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    this.filmGauge = source.filmGauge;
    this.filmOffset = source.filmOffset;
    return this;
  }
  /**
   * Sets the FOV by focal length in respect to the current {@link PerspectiveCamera#filmGauge}.
   *
   * The default film gauge is 35, so that the focal length can be specified for
   * a 35mm (full frame) camera.
   *
   * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
   */
  setFocalLength(focalLength) {
    const vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
    this.updateProjectionMatrix();
  }
  /**
   * Returns the focal length from the current {@link PerspectiveCamera#fov} and
   * {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The computed focal length.
   */
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
    return 0.5 * this.getFilmHeight() / vExtentSlope;
  }
  /**
   * Returns the current vertical field of view angle in degrees considering {@link PerspectiveCamera#zoom}.
   *
   * @return {number} The effective FOV.
   */
  getEffectiveFOV() {
    return RAD2DEG * 2 * Math.atan(
      Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom
    );
  }
  /**
   * Returns the width of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  /**
   * Returns the height of the image on the film. If {@link PerspectiveCamera#aspect} is greater than or
   * equal to one (landscape format), the result equals {@link PerspectiveCamera#filmGauge}.
   *
   * @return {number} The film width.
   */
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  /**
   * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
   * Sets `minTarget` and `maxTarget` to the coordinates of the lower-left and upper-right corners of the view rectangle.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} minTarget - The lower-left corner of the view rectangle is written into this vector.
   * @param {Vector2} maxTarget - The upper-right corner of the view rectangle is written into this vector.
   */
  getViewBounds(distance, minTarget, maxTarget) {
    _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
    _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
    maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
  }
  /**
   * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
   *
   * @param {number} distance - The viewing distance.
   * @param {Vector2} target - The target vector that is used to store result where x is width and y is height.
   * @returns {Vector2} The view size.
   */
  getViewSize(distance, target) {
    this.getViewBounds(distance, _minTarget, _maxTarget);
    return target.subVectors(_maxTarget, _minTarget);
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
   * the monitors are in grid like this
   *```
   *   +---+---+---+
   *   | A | B | C |
   *   +---+---+---+
   *   | D | E | F |
   *   +---+---+---+
   *```
   * then for each monitor you would call it like this:
   *```js
   * const w = 1920;
   * const h = 1080;
   * const fullWidth = w * 3;
   * const fullHeight = h * 2;
   *
   * // --A--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
   * // --B--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
   * // --C--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
   * // --D--
   * camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
   * // --E--
   * camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
   * // --F--
   * camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
   * ```
   *
   * Note there is no reason monitors have to be the same size or in a grid.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   */
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    this.aspect = fullWidth / fullHeight;
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const near = this.near;
    let top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
    let height = 2 * top;
    let width = this.aspect * height;
    let left = -0.5 * width;
    const view = this.view;
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth, fullHeight = view.fullHeight;
      left += view.offsetX * width / fullWidth;
      top -= view.offsetY * height / fullHeight;
      width *= view.width / fullWidth;
      height *= view.height / fullHeight;
    }
    const skew = this.filmOffset;
    if (skew !== 0) left += near * skew / this.getFilmWidth();
    this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem, this.reversedDepth);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.fov = this.fov;
    data2.object.zoom = this.zoom;
    data2.object.near = this.near;
    data2.object.far = this.far;
    data2.object.focus = this.focus;
    data2.object.aspect = this.aspect;
    if (this.view !== null) data2.object.view = Object.assign({}, this.view);
    data2.object.filmGauge = this.filmGauge;
    data2.object.filmOffset = this.filmOffset;
    return data2;
  }
};
var fov = -90;
var aspect = 1;
var CubeCamera = class extends Object3D {
  /**
   * Constructs a new cube camera.
   *
   * @param {number} near - The camera's near plane.
   * @param {number} far - The camera's far plane.
   * @param {WebGLCubeRenderTarget} renderTarget - The cube render target.
   */
  constructor(near, far, renderTarget) {
    super();
    this.type = "CubeCamera";
    this.renderTarget = renderTarget;
    this.coordinateSystem = null;
    this.activeMipmapLevel = 0;
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far);
    cameraPX.layers = this.layers;
    this.add(cameraPX);
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far);
    cameraNX.layers = this.layers;
    this.add(cameraNX);
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far);
    cameraPY.layers = this.layers;
    this.add(cameraPY);
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far);
    cameraNY.layers = this.layers;
    this.add(cameraNY);
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraPZ.layers = this.layers;
    this.add(cameraPZ);
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
    cameraNZ.layers = this.layers;
    this.add(cameraNZ);
  }
  /**
   * Must be called when the coordinate system of the cube camera is changed.
   */
  updateCoordinateSystem() {
    const coordinateSystem = this.coordinateSystem;
    const cameras = this.children.concat();
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = cameras;
    for (const camera of cameras) this.remove(camera);
    if (coordinateSystem === WebGLCoordinateSystem) {
      cameraPX.up.set(0, 1, 0);
      cameraPX.lookAt(1, 0, 0);
      cameraNX.up.set(0, 1, 0);
      cameraNX.lookAt(-1, 0, 0);
      cameraPY.up.set(0, 0, -1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, 1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, 1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, 1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else if (coordinateSystem === WebGPUCoordinateSystem) {
      cameraPX.up.set(0, -1, 0);
      cameraPX.lookAt(-1, 0, 0);
      cameraNX.up.set(0, -1, 0);
      cameraNX.lookAt(1, 0, 0);
      cameraPY.up.set(0, 0, 1);
      cameraPY.lookAt(0, 1, 0);
      cameraNY.up.set(0, 0, -1);
      cameraNY.lookAt(0, -1, 0);
      cameraPZ.up.set(0, -1, 0);
      cameraPZ.lookAt(0, 0, 1);
      cameraNZ.up.set(0, -1, 0);
      cameraNZ.lookAt(0, 0, -1);
    } else {
      throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + coordinateSystem);
    }
    for (const camera of cameras) {
      this.add(camera);
      camera.updateMatrixWorld();
    }
  }
  /**
   * Calling this method will render the given scene with the given renderer
   * into the cube render target of the camera.
   *
   * @param {(Renderer|WebGLRenderer)} renderer - The renderer.
   * @param {Scene} scene - The scene to render.
   */
  update(renderer, scene) {
    if (this.parent === null) this.updateMatrixWorld();
    const { renderTarget, activeMipmapLevel } = this;
    if (this.coordinateSystem !== renderer.coordinateSystem) {
      this.coordinateSystem = renderer.coordinateSystem;
      this.updateCoordinateSystem();
    }
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] = this.children;
    const currentRenderTarget = renderer.getRenderTarget();
    const currentActiveCubeFace = renderer.getActiveCubeFace();
    const currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
    const currentXrEnabled = renderer.xr.enabled;
    renderer.xr.enabled = false;
    const generateMipmaps = renderTarget.texture.generateMipmaps;
    renderTarget.texture.generateMipmaps = false;
    renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
    renderer.render(scene, cameraPX);
    renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
    renderer.render(scene, cameraNX);
    renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
    renderer.render(scene, cameraPY);
    renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
    renderer.render(scene, cameraNY);
    renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
    renderer.render(scene, cameraPZ);
    renderTarget.texture.generateMipmaps = generateMipmaps;
    renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
    renderer.render(scene, cameraNZ);
    renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
    renderer.xr.enabled = currentXrEnabled;
    renderTarget.texture.needsPMREMUpdate = true;
  }
};
var CubeTexture = class extends Texture {
  /**
   * Constructs a new cube texture.
   *
   * @param {Array<Image>} [images=[]] - An array holding a image for each side of a cube.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearMipmapLinearFilter] - The min filter value.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space value.
   */
  constructor(images = [], mapping = CubeReflectionMapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
    super(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isCubeTexture = true;
    this.flipY = false;
  }
  /**
   * Alias for {@link CubeTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var WebGLCubeRenderTarget = class extends WebGLRenderTarget {
  /**
   * Constructs a new cube render target.
   *
   * @param {number} [size=1] - The size of the render target.
   * @param {RenderTarget~Options} [options] - The configuration object.
   */
  constructor(size = 1, options = {}) {
    super(size, size, options);
    this.isWebGLCubeRenderTarget = true;
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    this.texture = new CubeTexture(images);
    this._setTextureOptions(options);
    this.texture.isRenderTargetTexture = true;
  }
  /**
   * Converts the given equirectangular texture to a cube map.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {Texture} texture - The equirectangular texture.
   * @return {WebGLCubeRenderTarget} A reference to this cube render target.
   */
  fromEquirectangularTexture(renderer, texture) {
    this.texture.type = texture.type;
    this.texture.colorSpace = texture.colorSpace;
    this.texture.generateMipmaps = texture.generateMipmaps;
    this.texture.minFilter = texture.minFilter;
    this.texture.magFilter = texture.magFilter;
    const shader = {
      uniforms: {
        tEquirect: { value: null }
      },
      vertexShader: (
        /* glsl */
        `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`
      ),
      fragmentShader: (
        /* glsl */
        `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
      )
    };
    const geometry = new BoxGeometry(5, 5, 5);
    const material = new ShaderMaterial({
      name: "CubemapFromEquirect",
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending
    });
    material.uniforms.tEquirect.value = texture;
    const mesh = new Mesh(geometry, material);
    const currentMinFilter = texture.minFilter;
    if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
    const camera = new CubeCamera(1, 10, this);
    camera.update(renderer, mesh);
    texture.minFilter = currentMinFilter;
    mesh.geometry.dispose();
    mesh.material.dispose();
    return this;
  }
  /**
   * Clears this cube render target.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {boolean} [color=true] - Whether the color buffer should be cleared or not.
   * @param {boolean} [depth=true] - Whether the depth buffer should be cleared or not.
   * @param {boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
   */
  clear(renderer, color = true, depth = true, stencil = true) {
    const currentRenderTarget = renderer.getRenderTarget();
    for (let i2 = 0; i2 < 6; i2++) {
      renderer.setRenderTarget(this, i2);
      renderer.clear(color, depth, stencil);
    }
    renderer.setRenderTarget(currentRenderTarget);
  }
};
var Group = class extends Object3D {
  constructor() {
    super();
    this.isGroup = true;
    this.type = "Group";
  }
};
var _moveEvent = { type: "move" };
var WebXRController = class {
  /**
   * Constructs a new XR controller.
   */
  constructor() {
    this._targetRay = null;
    this._grip = null;
    this._hand = null;
  }
  /**
   * Returns a group representing the hand space of the XR controller.
   *
   * @return {Group} A group representing the hand space of the XR controller.
   */
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group();
      this._hand.matrixAutoUpdate = false;
      this._hand.visible = false;
      this._hand.joints = {};
      this._hand.inputState = { pinching: false };
    }
    return this._hand;
  }
  /**
   * Returns a group representing the target ray space of the XR controller.
   *
   * @return {Group} A group representing the target ray space of the XR controller.
   */
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group();
      this._targetRay.matrixAutoUpdate = false;
      this._targetRay.visible = false;
      this._targetRay.hasLinearVelocity = false;
      this._targetRay.linearVelocity = new Vector3();
      this._targetRay.hasAngularVelocity = false;
      this._targetRay.angularVelocity = new Vector3();
    }
    return this._targetRay;
  }
  /**
   * Returns a group representing the grip space of the XR controller.
   *
   * @return {Group} A group representing the grip space of the XR controller.
   */
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group();
      this._grip.matrixAutoUpdate = false;
      this._grip.visible = false;
      this._grip.hasLinearVelocity = false;
      this._grip.linearVelocity = new Vector3();
      this._grip.hasAngularVelocity = false;
      this._grip.angularVelocity = new Vector3();
    }
    return this._grip;
  }
  /**
   * Dispatches the given event to the groups representing
   * the different coordinate spaces of the XR controller.
   *
   * @param {Object} event - The event to dispatch.
   * @return {WebXRController} A reference to this instance.
   */
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event);
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event);
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event);
    }
    return this;
  }
  /**
   * Connects the controller with the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  connect(inputSource) {
    if (inputSource && inputSource.hand) {
      const hand = this._hand;
      if (hand) {
        for (const inputjoint of inputSource.hand.values()) {
          this._getHandJoint(hand, inputjoint);
        }
      }
    }
    this.dispatchEvent({ type: "connected", data: inputSource });
    return this;
  }
  /**
   * Disconnects the controller from the given XR input source.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @return {WebXRController} A reference to this instance.
   */
  disconnect(inputSource) {
    this.dispatchEvent({ type: "disconnected", data: inputSource });
    if (this._targetRay !== null) {
      this._targetRay.visible = false;
    }
    if (this._grip !== null) {
      this._grip.visible = false;
    }
    if (this._hand !== null) {
      this._hand.visible = false;
    }
    return this;
  }
  /**
   * Updates the controller with the given input source, XR frame and reference space.
   * This updates the transformations of the groups that represent the different
   * coordinate systems of the controller.
   *
   * @param {XRInputSource} inputSource - The input source.
   * @param {XRFrame} frame - The XR frame.
   * @param {XRReferenceSpace} referenceSpace - The reference space.
   * @return {WebXRController} A reference to this instance.
   */
  update(inputSource, frame, referenceSpace) {
    let inputPose = null;
    let gripPose = null;
    let handPose = null;
    const targetRay = this._targetRay;
    const grip = this._grip;
    const hand = this._hand;
    if (inputSource && frame.session.visibilityState !== "visible-blurred") {
      if (hand && inputSource.hand) {
        handPose = true;
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace);
          const joint = this._getHandJoint(hand, inputjoint);
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix);
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale);
            joint.matrixWorldNeedsUpdate = true;
            joint.jointRadius = jointPose.radius;
          }
          joint.visible = jointPose !== null;
        }
        const indexTip = hand.joints["index-finger-tip"];
        const thumbTip = hand.joints["thumb-tip"];
        const distance = indexTip.position.distanceTo(thumbTip.position);
        const distanceToPinch = 0.02;
        const threshold = 5e-3;
        if (hand.inputState.pinching && distance > distanceToPinch + threshold) {
          hand.inputState.pinching = false;
          this.dispatchEvent({
            type: "pinchend",
            handedness: inputSource.handedness,
            target: this
          });
        } else if (!hand.inputState.pinching && distance <= distanceToPinch - threshold) {
          hand.inputState.pinching = true;
          this.dispatchEvent({
            type: "pinchstart",
            handedness: inputSource.handedness,
            target: this
          });
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace);
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix);
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale);
            grip.matrixWorldNeedsUpdate = true;
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true;
              grip.linearVelocity.copy(gripPose.linearVelocity);
            } else {
              grip.hasLinearVelocity = false;
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true;
              grip.angularVelocity.copy(gripPose.angularVelocity);
            } else {
              grip.hasAngularVelocity = false;
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace);
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose;
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix);
          targetRay.matrix.decompose(targetRay.position, targetRay.rotation, targetRay.scale);
          targetRay.matrixWorldNeedsUpdate = true;
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true;
            targetRay.linearVelocity.copy(inputPose.linearVelocity);
          } else {
            targetRay.hasLinearVelocity = false;
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true;
            targetRay.angularVelocity.copy(inputPose.angularVelocity);
          } else {
            targetRay.hasAngularVelocity = false;
          }
          this.dispatchEvent(_moveEvent);
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null;
    }
    if (grip !== null) {
      grip.visible = gripPose !== null;
    }
    if (hand !== null) {
      hand.visible = handPose !== null;
    }
    return this;
  }
  /**
   * Returns a group representing the hand joint for the given input joint.
   *
   * @private
   * @param {Group} hand - The group representing the hand space.
   * @param {XRJointSpace} inputjoint - The hand joint data.
   * @return {Group} A group representing the hand joint for the given input joint.
   */
  _getHandJoint(hand, inputjoint) {
    if (hand.joints[inputjoint.jointName] === void 0) {
      const joint = new Group();
      joint.matrixAutoUpdate = false;
      joint.visible = false;
      hand.joints[inputjoint.jointName] = joint;
      hand.add(joint);
    }
    return hand.joints[inputjoint.jointName];
  }
};
var Scene = class extends Object3D {
  /**
   * Constructs a new scene.
   */
  constructor() {
    super();
    this.isScene = true;
    this.type = "Scene";
    this.background = null;
    this.environment = null;
    this.fog = null;
    this.backgroundBlurriness = 0;
    this.backgroundIntensity = 1;
    this.backgroundRotation = new Euler();
    this.environmentIntensity = 1;
    this.environmentRotation = new Euler();
    this.overrideMaterial = null;
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    if (source.background !== null) this.background = source.background.clone();
    if (source.environment !== null) this.environment = source.environment.clone();
    if (source.fog !== null) this.fog = source.fog.clone();
    this.backgroundBlurriness = source.backgroundBlurriness;
    this.backgroundIntensity = source.backgroundIntensity;
    this.backgroundRotation.copy(source.backgroundRotation);
    this.environmentIntensity = source.environmentIntensity;
    this.environmentRotation.copy(source.environmentRotation);
    if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
    this.matrixAutoUpdate = source.matrixAutoUpdate;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    if (this.fog !== null) data2.object.fog = this.fog.toJSON();
    if (this.backgroundBlurriness > 0) data2.object.backgroundBlurriness = this.backgroundBlurriness;
    if (this.backgroundIntensity !== 1) data2.object.backgroundIntensity = this.backgroundIntensity;
    data2.object.backgroundRotation = this.backgroundRotation.toArray();
    if (this.environmentIntensity !== 1) data2.object.environmentIntensity = this.environmentIntensity;
    data2.object.environmentRotation = this.environmentRotation.toArray();
    return data2;
  }
};
var InterleavedBuffer = class {
  /**
   * Constructs a new interleaved buffer.
   *
   * @param {TypedArray} array - A typed array with a shared buffer storing attribute data.
   * @param {number} stride - The number of typed-array elements per vertex.
   */
  constructor(array, stride) {
    this.isInterleavedBuffer = true;
    this.array = array;
    this.stride = stride;
    this.count = array !== void 0 ? array.length / stride : 0;
    this.usage = StaticDrawUsage;
    this.updateRanges = [];
    this.version = 0;
    this.uuid = generateUUID();
  }
  /**
   * A callback function that is executed after the renderer has transferred the attribute array
   * data to the GPU.
   */
  onUploadCallback() {
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the usage of this interleaved buffer.
   *
   * @param {(StaticDrawUsage|DynamicDrawUsage|StreamDrawUsage|StaticReadUsage|DynamicReadUsage|StreamReadUsage|StaticCopyUsage|DynamicCopyUsage|StreamCopyUsage)} value - The usage to set.
   * @return {InterleavedBuffer} A reference to this interleaved buffer.
   */
  setUsage(value) {
    this.usage = value;
    return this;
  }
  /**
   * Adds a range of data in the data array to be updated on the GPU.
   *
   * @param {number} start - Position at which to start update.
   * @param {number} count - The number of components to update.
   */
  addUpdateRange(start, count) {
    this.updateRanges.push({ start, count });
  }
  /**
   * Clears the update ranges.
   */
  clearUpdateRanges() {
    this.updateRanges.length = 0;
  }
  /**
   * Copies the values of the given interleaved buffer to this instance.
   *
   * @param {InterleavedBuffer} source - The interleaved buffer to copy.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copy(source) {
    this.array = new source.array.constructor(source.array);
    this.count = source.count;
    this.stride = source.stride;
    this.usage = source.usage;
    return this;
  }
  /**
   * Copies a vector from the given interleaved buffer to this one. The start
   * and destination position in the attribute buffers are represented by the
   * given indices.
   *
   * @param {number} index1 - The destination index into this interleaved buffer.
   * @param {InterleavedBuffer} interleavedBuffer - The interleaved buffer to copy from.
   * @param {number} index2 - The source index into the given interleaved buffer.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  copyAt(index1, interleavedBuffer, index2) {
    index1 *= this.stride;
    index2 *= interleavedBuffer.stride;
    for (let i2 = 0, l2 = this.stride; i2 < l2; i2++) {
      this.array[index1 + i2] = interleavedBuffer.array[index2 + i2];
    }
    return this;
  }
  /**
   * Sets the given array data in the interleaved buffer.
   *
   * @param {(TypedArray|Array)} value - The array data to set.
   * @param {number} [offset=0] - The offset in this interleaved buffer's array.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  set(value, offset = 0) {
    this.array.set(value, offset);
    return this;
  }
  /**
   * Returns a new interleaved buffer with copied values from this instance.
   *
   * @param {Object} [data] - An object with shared array buffers that allows to retain shared structures.
   * @return {InterleavedBuffer} A clone of this instance.
   */
  clone(data2) {
    if (data2.arrayBuffers === void 0) {
      data2.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data2.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data2.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
    }
    const array = new this.array.constructor(data2.arrayBuffers[this.array.buffer._uuid]);
    const ib = new this.constructor(array, this.stride);
    ib.setUsage(this.usage);
    return ib;
  }
  /**
   * Sets the given callback function that is executed after the Renderer has transferred
   * the array data to the GPU. Can be used to perform clean-up operations after
   * the upload when data are not needed anymore on the CPU side.
   *
   * @param {Function} callback - The `onUpload()` callback.
   * @return {InterleavedBuffer} A reference to this instance.
   */
  onUpload(callback) {
    this.onUploadCallback = callback;
    return this;
  }
  /**
   * Serializes the interleaved buffer into JSON.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized interleaved buffer.
   */
  toJSON(data2) {
    if (data2.arrayBuffers === void 0) {
      data2.arrayBuffers = {};
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID();
    }
    if (data2.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data2.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride
    };
  }
};
var _vector$7 = /* @__PURE__ */ new Vector3();
var InterleavedBufferAttribute = class _InterleavedBufferAttribute {
  /**
   * Constructs a new interleaved buffer attribute.
   *
   * @param {InterleavedBuffer} interleavedBuffer - The buffer holding the interleaved data.
   * @param {number} itemSize - The item size.
   * @param {number} offset - The attribute offset into the buffer.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true;
    this.name = "";
    this.data = interleavedBuffer;
    this.itemSize = itemSize;
    this.offset = offset;
    this.normalized = normalized;
  }
  /**
   * The item count of this buffer attribute.
   *
   * @type {number}
   * @readonly
   */
  get count() {
    return this.data.count;
  }
  /**
   * The array holding the interleaved buffer attribute data.
   *
   * @type {TypedArray}
   */
  get array() {
    return this.data.array;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    this.data.needsUpdate = value;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyMatrix4(m2) {
    for (let i2 = 0, l2 = this.data.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.applyMatrix4(m2);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 3x3 normal matrix to the given attribute. Only works with
   * item size `3`.
   *
   * @param {Matrix3} m - The normal matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  applyNormalMatrix(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.applyNormalMatrix(m2);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Applies the given 4x4 matrix to the given attribute. Only works with
   * item size `3` and with direction vectors.
   *
   * @param {Matrix4} m - The matrix to apply.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  transformDirection(m2) {
    for (let i2 = 0, l2 = this.count; i2 < l2; i2++) {
      _vector$7.fromBufferAttribute(this, i2);
      _vector$7.transformDirection(m2);
      this.setXYZ(i2, _vector$7.x, _vector$7.y, _vector$7.z);
    }
    return this;
  }
  /**
   * Returns the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @return {number} The returned value.
   */
  getComponent(index, component) {
    let value = this.array[index * this.data.stride + this.offset + component];
    if (this.normalized) value = denormalize(value, this.array);
    return value;
  }
  /**
   * Sets the given value to the given component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} component - The component index.
   * @param {number} value - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setComponent(index, component, value) {
    if (this.normalized) value = normalize(value, this.array);
    this.data.array[index * this.data.stride + this.offset + component] = value;
    return this;
  }
  /**
   * Sets the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setX(index, x2) {
    if (this.normalized) x2 = normalize(x2, this.array);
    this.data.array[index * this.data.stride + this.offset] = x2;
    return this;
  }
  /**
   * Sets the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} y - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setY(index, y2) {
    if (this.normalized) y2 = normalize(y2, this.array);
    this.data.array[index * this.data.stride + this.offset + 1] = y2;
    return this;
  }
  /**
   * Sets the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} z - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setZ(index, z2) {
    if (this.normalized) z2 = normalize(z2, this.array);
    this.data.array[index * this.data.stride + this.offset + 2] = z2;
    return this;
  }
  /**
   * Sets the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} w - The value to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setW(index, w2) {
    if (this.normalized) w2 = normalize(w2, this.array);
    this.data.array[index * this.data.stride + this.offset + 3] = w2;
    return this;
  }
  /**
   * Returns the x component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The x component.
   */
  getX(index) {
    let x2 = this.data.array[index * this.data.stride + this.offset];
    if (this.normalized) x2 = denormalize(x2, this.array);
    return x2;
  }
  /**
   * Returns the y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The y component.
   */
  getY(index) {
    let y2 = this.data.array[index * this.data.stride + this.offset + 1];
    if (this.normalized) y2 = denormalize(y2, this.array);
    return y2;
  }
  /**
   * Returns the z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The z component.
   */
  getZ(index) {
    let z2 = this.data.array[index * this.data.stride + this.offset + 2];
    if (this.normalized) z2 = denormalize(z2, this.array);
    return z2;
  }
  /**
   * Returns the w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @return {number} The w component.
   */
  getW(index) {
    let w2 = this.data.array[index * this.data.stride + this.offset + 3];
    if (this.normalized) w2 = denormalize(w2, this.array);
    return w2;
  }
  /**
   * Sets the x and y component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXY(index, x2, y2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
    }
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    return this;
  }
  /**
   * Sets the x, y and z component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZ(index, x2, y2, z2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
      z2 = normalize(z2, this.array);
    }
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    return this;
  }
  /**
   * Sets the x, y, z and w component of the vector at the given index.
   *
   * @param {number} index - The index into the buffer attribute.
   * @param {number} x - The value for the x component to set.
   * @param {number} y - The value for the y component to set.
   * @param {number} z - The value for the z component to set.
   * @param {number} w - The value for the w component to set.
   * @return {InterleavedBufferAttribute} A reference to this instance.
   */
  setXYZW(index, x2, y2, z2, w2) {
    index = index * this.data.stride + this.offset;
    if (this.normalized) {
      x2 = normalize(x2, this.array);
      y2 = normalize(y2, this.array);
      z2 = normalize(z2, this.array);
      w2 = normalize(w2, this.array);
    }
    this.data.array[index + 0] = x2;
    this.data.array[index + 1] = y2;
    this.data.array[index + 2] = z2;
    this.data.array[index + 3] = w2;
    return this;
  }
  /**
   * Returns a new buffer attribute with copied values from this instance.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An object with interleaved buffers that allows to retain the interleaved property.
   * @return {BufferAttribute|InterleavedBufferAttribute} A clone of this instance.
   */
  clone(data2) {
    if (data2 === void 0) {
      log("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
    } else {
      if (data2.interleavedBuffers === void 0) {
        data2.interleavedBuffers = {};
      }
      if (data2.interleavedBuffers[this.data.uuid] === void 0) {
        data2.interleavedBuffers[this.data.uuid] = this.data.clone(data2);
      }
      return new _InterleavedBufferAttribute(data2.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
    }
  }
  /**
   * Serializes the buffer attribute into JSON.
   *
   * If no parameter is provided, cloning an interleaved buffer attribute will de-interleave buffer data.
   *
   * @param {Object} [data] - An optional value holding meta information about the serialization.
   * @return {Object} A JSON object representing the serialized buffer attribute.
   */
  toJSON(data2) {
    if (data2 === void 0) {
      log("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
      const array = [];
      for (let i2 = 0; i2 < this.count; i2++) {
        const index = i2 * this.data.stride + this.offset;
        for (let j2 = 0; j2 < this.itemSize; j2++) {
          array.push(this.data.array[index + j2]);
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized
      };
    } else {
      if (data2.interleavedBuffers === void 0) {
        data2.interleavedBuffers = {};
      }
      if (data2.interleavedBuffers[this.data.uuid] === void 0) {
        data2.interleavedBuffers[this.data.uuid] = this.data.toJSON(data2);
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized
      };
    }
  }
};
var _basePosition = /* @__PURE__ */ new Vector3();
var _skinIndex = /* @__PURE__ */ new Vector4();
var _skinWeight = /* @__PURE__ */ new Vector4();
var _vector3 = /* @__PURE__ */ new Vector3();
var _matrix4 = /* @__PURE__ */ new Matrix4();
var _vertex = /* @__PURE__ */ new Vector3();
var _sphere$5 = /* @__PURE__ */ new Sphere();
var _inverseMatrix$2 = /* @__PURE__ */ new Matrix4();
var _ray$2 = /* @__PURE__ */ new Ray();
var SkinnedMesh = class extends Mesh {
  /**
   * Constructs a new skinned mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   */
  constructor(geometry, material) {
    super(geometry, material);
    this.isSkinnedMesh = true;
    this.type = "SkinnedMesh";
    this.bindMode = AttachedBindMode;
    this.bindMatrix = new Matrix4();
    this.bindMatrixInverse = new Matrix4();
    this.boundingBox = null;
    this.boundingSphere = null;
  }
  /**
   * Computes the bounding box of the skinned mesh, and updates {@link SkinnedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * If the skinned mesh is animated, the bounding box should be recomputed per frame in order to reflect
   * the current animation state.
   */
  computeBoundingBox() {
    const geometry = this.geometry;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    this.boundingBox.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      this.getVertexPosition(i2, _vertex);
      this.boundingBox.expandByPoint(_vertex);
    }
  }
  /**
   * Computes the bounding sphere of the skinned mesh, and updates {@link SkinnedMesh#boundingSphere}.
   * The bounding sphere is automatically computed by the engine once when it is needed, e.g., for ray casting
   * and view frustum culling. If the skinned mesh is animated, the bounding sphere should be recomputed
   * per frame in order to reflect the current animation state.
   */
  computeBoundingSphere() {
    const geometry = this.geometry;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    this.boundingSphere.makeEmpty();
    const positionAttribute = geometry.getAttribute("position");
    for (let i2 = 0; i2 < positionAttribute.count; i2++) {
      this.getVertexPosition(i2, _vertex);
      this.boundingSphere.expandByPoint(_vertex);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.bindMode = source.bindMode;
    this.bindMatrix.copy(source.bindMatrix);
    this.bindMatrixInverse.copy(source.bindMatrixInverse);
    this.skeleton = source.skeleton;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  raycast(raycaster, intersects) {
    const material = this.material;
    const matrixWorld = this.matrixWorld;
    if (material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$5.copy(this.boundingSphere);
    _sphere$5.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$5) === false) return;
    _inverseMatrix$2.copy(matrixWorld).invert();
    _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);
    if (this.boundingBox !== null) {
      if (_ray$2.intersectsBox(this.boundingBox) === false) return;
    }
    this._computeIntersections(raycaster, intersects, _ray$2);
  }
  getVertexPosition(index, target) {
    super.getVertexPosition(index, target);
    this.applyBoneTransform(index, target);
    return target;
  }
  /**
   * Binds the given skeleton to the skinned mesh.
   *
   * @param {Skeleton} skeleton - The skeleton to bind.
   * @param {Matrix4} [bindMatrix] - The bind matrix. If no bind matrix is provided,
   * the skinned mesh's world matrix will be used instead.
   */
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton;
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true);
      this.skeleton.calculateInverses();
      bindMatrix = this.matrixWorld;
    }
    this.bindMatrix.copy(bindMatrix);
    this.bindMatrixInverse.copy(bindMatrix).invert();
  }
  /**
   * This method sets the skinned mesh in the rest pose).
   */
  pose() {
    this.skeleton.pose();
  }
  /**
   * Normalizes the skin weights which are defined as a buffer attribute
   * in the skinned mesh's geometry.
   */
  normalizeSkinWeights() {
    const vector = new Vector4();
    const skinWeight = this.geometry.attributes.skinWeight;
    for (let i2 = 0, l2 = skinWeight.count; i2 < l2; i2++) {
      vector.fromBufferAttribute(skinWeight, i2);
      const scale = 1 / vector.manhattanLength();
      if (scale !== Infinity) {
        vector.multiplyScalar(scale);
      } else {
        vector.set(1, 0, 0, 0);
      }
      skinWeight.setXYZW(i2, vector.x, vector.y, vector.z, vector.w);
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force);
    if (this.bindMode === AttachedBindMode) {
      this.bindMatrixInverse.copy(this.matrixWorld).invert();
    } else if (this.bindMode === DetachedBindMode) {
      this.bindMatrixInverse.copy(this.bindMatrix).invert();
    } else {
      warn("SkinnedMesh: Unrecognized bindMode: " + this.bindMode);
    }
  }
  /**
   * Applies the bone transform associated with the given index to the given
   * vertex position. Returns the updated vector.
   *
   * @param {number} index - The vertex index.
   * @param {Vector3} target - The target object that is used to store the method's result.
   * the skinned mesh's world matrix will be used instead.
   * @return {Vector3} The updated vertex position.
   */
  applyBoneTransform(index, target) {
    const skeleton = this.skeleton;
    const geometry = this.geometry;
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
    _basePosition.copy(target).applyMatrix4(this.bindMatrix);
    target.set(0, 0, 0);
    for (let i2 = 0; i2 < 4; i2++) {
      const weight = _skinWeight.getComponent(i2);
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i2);
        _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
        target.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse);
  }
};
var Bone = class extends Object3D {
  /**
   * Constructs a new bone.
   */
  constructor() {
    super();
    this.isBone = true;
    this.type = "Bone";
  }
};
var DataTexture = class extends Texture {
  /**
   * Constructs a new data texture.
   *
   * @param {?TypedArray} [data=null] - The buffer data.
   * @param {number} [width=1] - The width of the texture.
   * @param {number} [height=1] - The height of the texture.
   * @param {number} [format=RGBAFormat] - The texture format.
   * @param {number} [type=UnsignedByteType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {string} [colorSpace=NoColorSpace] - The color space.
   */
  constructor(data2 = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {
    super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);
    this.isDataTexture = true;
    this.image = { data: data2, width, height };
    this.generateMipmaps = false;
    this.flipY = false;
    this.unpackAlignment = 1;
  }
};
var _offsetMatrix = /* @__PURE__ */ new Matrix4();
var _identityMatrix = /* @__PURE__ */ new Matrix4();
var Skeleton = class _Skeleton {
  /**
   * Constructs a new skeleton.
   *
   * @param {Array<Bone>} [bones] - An array of bones.
   * @param {Array<Matrix4>} [boneInverses] - An array of bone inverse matrices.
   * If not provided, these matrices will be computed automatically via {@link Skeleton#calculateInverses}.
   */
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID();
    this.bones = bones.slice(0);
    this.boneInverses = boneInverses;
    this.boneMatrices = null;
    this.previousBoneMatrices = null;
    this.boneTexture = null;
    this.init();
  }
  /**
   * Initializes the skeleton. This method gets automatically called by the constructor
   * but depending on how the skeleton is created it might be necessary to call this method
   * manually.
   */
  init() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    this.boneMatrices = new Float32Array(bones.length * 16);
    if (boneInverses.length === 0) {
      this.calculateInverses();
    } else {
      if (bones.length !== boneInverses.length) {
        warn("Skeleton: Number of inverse bone matrices does not match amount of bones.");
        this.boneInverses = [];
        for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
          this.boneInverses.push(new Matrix4());
        }
      }
    }
  }
  /**
   * Computes the bone inverse matrices. This method resets {@link Skeleton#boneInverses}
   * and fills it with new matrices.
   */
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const inverse = new Matrix4();
      if (this.bones[i2]) {
        inverse.copy(this.bones[i2].matrixWorld).invert();
      }
      this.boneInverses.push(inverse);
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  pose() {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i2]).invert();
      }
    }
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert();
          bone.matrix.multiply(bone.matrixWorld);
        } else {
          bone.matrix.copy(bone.matrixWorld);
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      }
    }
  }
  /**
   * Resets the skeleton to the base pose.
   */
  update() {
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    const boneMatrices = this.boneMatrices;
    const boneTexture = this.boneTexture;
    for (let i2 = 0, il = bones.length; i2 < il; i2++) {
      const matrix = bones[i2] ? bones[i2].matrixWorld : _identityMatrix;
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i2]);
      _offsetMatrix.toArray(boneMatrices, i2 * 16);
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true;
    }
  }
  /**
   * Returns a new skeleton with copied values from this instance.
   *
   * @return {Skeleton} A clone of this instance.
   */
  clone() {
    return new _Skeleton(this.bones, this.boneInverses);
  }
  /**
   * Computes a data texture for passing bone data to the vertex shader.
   *
   * @return {Skeleton} A reference of this instance.
   */
  computeBoneTexture() {
    let size = Math.sqrt(this.bones.length * 4);
    size = Math.ceil(size / 4) * 4;
    size = Math.max(size, 4);
    const boneMatrices = new Float32Array(size * size * 4);
    boneMatrices.set(this.boneMatrices);
    const boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
    boneTexture.needsUpdate = true;
    this.boneMatrices = boneMatrices;
    this.boneTexture = boneTexture;
    return this;
  }
  /**
   * Searches through the skeleton's bone array and returns the first with a
   * matching name.
   *
   * @param {string} name - The name of the bone.
   * @return {Bone|undefined} The found bone. `undefined` if no bone has been found.
   */
  getBoneByName(name) {
    for (let i2 = 0, il = this.bones.length; i2 < il; i2++) {
      const bone = this.bones[i2];
      if (bone.name === name) {
        return bone;
      }
    }
    return void 0;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose();
      this.boneTexture = null;
    }
  }
  /**
   * Setups the skeleton by the given JSON and bones.
   *
   * @param {Object} json - The skeleton as serialized JSON.
   * @param {Object<string, Bone>} bones - An array of bones.
   * @return {Skeleton} A reference of this instance.
   */
  fromJSON(json, bones) {
    this.uuid = json.uuid;
    for (let i2 = 0, l2 = json.bones.length; i2 < l2; i2++) {
      const uuid = json.bones[i2];
      let bone = bones[uuid];
      if (bone === void 0) {
        warn("Skeleton: No bone found with UUID:", uuid);
        bone = new Bone();
      }
      this.bones.push(bone);
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i2]));
    }
    this.init();
    return this;
  }
  /**
   * Serializes the skeleton into JSON.
   *
   * @return {Object} A JSON object representing the serialized skeleton.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const data2 = {
      metadata: {
        version: 4.7,
        type: "Skeleton",
        generator: "Skeleton.toJSON"
      },
      bones: [],
      boneInverses: []
    };
    data2.uuid = this.uuid;
    const bones = this.bones;
    const boneInverses = this.boneInverses;
    for (let i2 = 0, l2 = bones.length; i2 < l2; i2++) {
      const bone = bones[i2];
      data2.bones.push(bone.uuid);
      const boneInverse = boneInverses[i2];
      data2.boneInverses.push(boneInverse.toArray());
    }
    return data2;
  }
};
var InstancedBufferAttribute = class extends BufferAttribute {
  /**
   * Constructs a new instanced buffer attribute.
   *
   * @param {TypedArray} array - The array holding the attribute data.
   * @param {number} itemSize - The item size.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   * @param {number} [meshPerAttribute=1] - How often a value of this buffer attribute should be repeated.
   */
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    super(array, itemSize, normalized);
    this.isInstancedBufferAttribute = true;
    this.meshPerAttribute = meshPerAttribute;
  }
  copy(source) {
    super.copy(source);
    this.meshPerAttribute = source.meshPerAttribute;
    return this;
  }
  toJSON() {
    const data2 = super.toJSON();
    data2.meshPerAttribute = this.meshPerAttribute;
    data2.isInstancedBufferAttribute = true;
    return data2;
  }
};
var _instanceLocalMatrix = /* @__PURE__ */ new Matrix4();
var _instanceWorldMatrix = /* @__PURE__ */ new Matrix4();
var _instanceIntersects = [];
var _box3 = /* @__PURE__ */ new Box3();
var _identity = /* @__PURE__ */ new Matrix4();
var _mesh$1 = /* @__PURE__ */ new Mesh();
var _sphere$4 = /* @__PURE__ */ new Sphere();
var InstancedMesh = class extends Mesh {
  /**
   * Constructs a new instanced mesh.
   *
   * @param {BufferGeometry} [geometry] - The mesh geometry.
   * @param {Material|Array<Material>} [material] - The mesh material.
   * @param {number} count - The number of instances.
   */
  constructor(geometry, material, count) {
    super(geometry, material);
    this.isInstancedMesh = true;
    this.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
    this.instanceColor = null;
    this.morphTexture = null;
    this.count = count;
    this.boundingBox = null;
    this.boundingSphere = null;
    for (let i2 = 0; i2 < count; i2++) {
      this.setMatrixAt(i2, _identity);
    }
  }
  /**
   * Computes the bounding box of the instanced mesh, and updates {@link InstancedMesh#boundingBox}.
   * The bounding box is not automatically computed by the engine; this method must be called by your app.
   * You may need to recompute the bounding box if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingBox() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingBox === null) {
      this.boundingBox = new Box3();
    }
    if (geometry.boundingBox === null) {
      geometry.computeBoundingBox();
    }
    this.boundingBox.makeEmpty();
    for (let i2 = 0; i2 < count; i2++) {
      this.getMatrixAt(i2, _instanceLocalMatrix);
      _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
      this.boundingBox.union(_box3);
    }
  }
  /**
   * Computes the bounding sphere of the instanced mesh, and updates {@link InstancedMesh#boundingSphere}
   * The engine automatically computes the bounding sphere when it is needed, e.g., for ray casting or view frustum culling.
   * You may need to recompute the bounding sphere if an instance is transformed via {@link InstancedMesh#setMatrixAt}.
   */
  computeBoundingSphere() {
    const geometry = this.geometry;
    const count = this.count;
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere();
    }
    if (geometry.boundingSphere === null) {
      geometry.computeBoundingSphere();
    }
    this.boundingSphere.makeEmpty();
    for (let i2 = 0; i2 < count; i2++) {
      this.getMatrixAt(i2, _instanceLocalMatrix);
      _sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
      this.boundingSphere.union(_sphere$4);
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.instanceMatrix.copy(source.instanceMatrix);
    if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
    if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
    this.count = source.count;
    if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
    if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
    return this;
  }
  /**
   * Gets the color of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The target object that is used to store the method's result.
   */
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3);
  }
  /**
   * Gets the local transformation matrix of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The target object that is used to store the method's result.
   */
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16);
  }
  /**
   * Gets the morph target weights of the defined instance.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object - The target object that is used to store the method's result.
   */
  getMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const array = this.morphTexture.source.data.data;
    const len = objectInfluences.length + 1;
    const dataIndex = index * len + 1;
    for (let i2 = 0; i2 < objectInfluences.length; i2++) {
      objectInfluences[i2] = array[dataIndex + i2];
    }
  }
  raycast(raycaster, intersects) {
    const matrixWorld = this.matrixWorld;
    const raycastTimes = this.count;
    _mesh$1.geometry = this.geometry;
    _mesh$1.material = this.material;
    if (_mesh$1.material === void 0) return;
    if (this.boundingSphere === null) this.computeBoundingSphere();
    _sphere$4.copy(this.boundingSphere);
    _sphere$4.applyMatrix4(matrixWorld);
    if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix);
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);
      _mesh$1.matrixWorld = _instanceWorldMatrix;
      _mesh$1.raycast(raycaster, _instanceIntersects);
      for (let i2 = 0, l2 = _instanceIntersects.length; i2 < l2; i2++) {
        const intersect = _instanceIntersects[i2];
        intersect.instanceId = instanceId;
        intersect.object = this;
        intersects.push(intersect);
      }
      _instanceIntersects.length = 0;
    }
  }
  /**
   * Sets the given color to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceColor} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Color} color - The instance color.
   */
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
    }
    color.toArray(this.instanceColor.array, index * 3);
  }
  /**
   * Sets the given local transformation matrix to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#instanceMatrix} to `true` after updating all the colors.
   *
   * @param {number} index - The instance index.
   * @param {Matrix4} matrix - The local transformation.
   */
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16);
  }
  /**
   * Sets the morph target weights to the defined instance. Make sure you set the `needsUpdate` flag of
   * {@link InstancedMesh#morphTexture} to `true` after updating all the influences.
   *
   * @param {number} index - The instance index.
   * @param {Mesh} object -  A mesh which `morphTargetInfluences` property containing the morph target weights
   * of a single instance.
   */
  setMorphAt(index, object) {
    const objectInfluences = object.morphTargetInfluences;
    const len = objectInfluences.length + 1;
    if (this.morphTexture === null) {
      this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
    }
    const array = this.morphTexture.source.data.data;
    let morphInfluencesSum = 0;
    for (let i2 = 0; i2 < objectInfluences.length; i2++) {
      morphInfluencesSum += objectInfluences[i2];
    }
    const morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
    const dataIndex = len * index;
    array[dataIndex] = morphBaseInfluence;
    array.set(objectInfluences, dataIndex + 1);
  }
  updateMorphTargets() {
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
    if (this.morphTexture !== null) {
      this.morphTexture.dispose();
      this.morphTexture = null;
    }
  }
};
var _vector1 = /* @__PURE__ */ new Vector3();
var _vector2 = /* @__PURE__ */ new Vector3();
var _normalMatrix = /* @__PURE__ */ new Matrix3();
var Plane = class {
  /**
   * Constructs a new plane.
   *
   * @param {Vector3} [normal=(1,0,0)] - A unit length vector defining the normal of the plane.
   * @param {number} [constant=0] - The signed distance from the origin to the plane.
   */
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true;
    this.normal = normal;
    this.constant = constant;
  }
  /**
   * Sets the plane components by copying the given values.
   *
   * @param {Vector3} normal - The normal.
   * @param {number} constant - The constant.
   * @return {Plane} A reference to this plane.
   */
  set(normal, constant) {
    this.normal.copy(normal);
    this.constant = constant;
    return this;
  }
  /**
   * Sets the plane components by defining `x`, `y`, `z` as the
   * plane normal and `w` as the constant.
   *
   * @param {number} x - The value for the normal's x component.
   * @param {number} y - The value for the normal's y component.
   * @param {number} z - The value for the normal's z component.
   * @param {number} w - The constant value.
   * @return {Plane} A reference to this plane.
   */
  setComponents(x2, y2, z2, w2) {
    this.normal.set(x2, y2, z2);
    this.constant = w2;
    return this;
  }
  /**
   * Sets the plane from the given normal and coplanar point (that is a point
   * that lies onto the plane).
   *
   * @param {Vector3} normal - The normal.
   * @param {Vector3} point - A coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal);
    this.constant = -point.dot(this.normal);
    return this;
  }
  /**
   * Sets the plane from three coplanar points. The winding order is
   * assumed to be counter-clockwise, and determines the direction of
   * the plane normal.
   *
   * @param {Vector3} a - The first coplanar point.
   * @param {Vector3} b - The second coplanar point.
   * @param {Vector3} c - The third coplanar point.
   * @return {Plane} A reference to this plane.
   */
  setFromCoplanarPoints(a2, b2, c2) {
    const normal = _vector1.subVectors(c2, b2).cross(_vector2.subVectors(a2, b2)).normalize();
    this.setFromNormalAndCoplanarPoint(normal, a2);
    return this;
  }
  /**
   * Copies the values of the given plane to this instance.
   *
   * @param {Plane} plane - The plane to copy.
   * @return {Plane} A reference to this plane.
   */
  copy(plane) {
    this.normal.copy(plane.normal);
    this.constant = plane.constant;
    return this;
  }
  /**
   * Normalizes the plane normal and adjusts the constant accordingly.
   *
   * @return {Plane} A reference to this plane.
   */
  normalize() {
    const inverseNormalLength = 1 / this.normal.length();
    this.normal.multiplyScalar(inverseNormalLength);
    this.constant *= inverseNormalLength;
    return this;
  }
  /**
   * Negates both the plane normal and the constant.
   *
   * @return {Plane} A reference to this plane.
   */
  negate() {
    this.constant *= -1;
    this.normal.negate();
    return this;
  }
  /**
   * Returns the signed distance from the given point to this plane.
   *
   * @param {Vector3} point - The point to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant;
  }
  /**
   * Returns the signed distance from the given sphere to this plane.
   *
   * @param {Sphere} sphere - The sphere to compute the distance for.
   * @return {number} The signed distance.
   */
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius;
  }
  /**
   * Projects a the given point onto the plane.
   *
   * @param {Vector3} point - The point to project.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The projected point on the plane.
   */
  projectPoint(point, target) {
    return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
  }
  /**
   * Returns the intersection point of the passed line and the plane. Returns
   * `null` if the line does not intersect. Returns the line's starting point if
   * the line is coplanar with the plane.
   *
   * @param {Line3} line - The line to compute the intersection for.
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {?Vector3} The intersection point.
   */
  intersectLine(line, target) {
    const direction = line.delta(_vector1);
    const denominator = this.normal.dot(direction);
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start);
      }
      return null;
    }
    const t2 = -(line.start.dot(this.normal) + this.constant) / denominator;
    if (t2 < 0 || t2 > 1) {
      return null;
    }
    return target.copy(line.start).addScaledVector(direction, t2);
  }
  /**
   * Returns `true` if the given line segment intersects with (passes through) the plane.
   *
   * @param {Line3} line - The line to test.
   * @return {boolean} Whether the given line segment intersects with the plane or not.
   */
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start);
    const endSign = this.distanceToPoint(line.end);
    return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
  }
  /**
   * Returns `true` if the given bounding box intersects with the plane.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the given bounding box intersects with the plane or not.
   */
  intersectsBox(box) {
    return box.intersectsPlane(this);
  }
  /**
   * Returns `true` if the given bounding sphere intersects with the plane.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the given bounding sphere intersects with the plane or not.
   */
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this);
  }
  /**
   * Returns a coplanar vector to the plane, by calculating the
   * projection of the normal at the origin onto the plane.
   *
   * @param {Vector3} target - The target vector that is used to store the method's result.
   * @return {Vector3} The coplanar point.
   */
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant);
  }
  /**
   * Apply a 4x4 matrix to the plane. The matrix must be an affine, homogeneous transform.
   *
   * The optional normal matrix can be pre-computed like so:
   * ```js
   * const optionalNormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );
   * ```
   *
   * @param {Matrix4} matrix - The transformation matrix.
   * @param {Matrix4} [optionalNormalMatrix] - A pre-computed normal matrix.
   * @return {Plane} A reference to this plane.
   */
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
    const normal = this.normal.applyMatrix3(normalMatrix).normalize();
    this.constant = -referencePoint.dot(normal);
    return this;
  }
  /**
   * Translates the plane by the distance defined by the given offset vector.
   * Note that this only affects the plane constant and will not affect the normal vector.
   *
   * @param {Vector3} offset - The offset vector.
   * @return {Plane} A reference to this plane.
   */
  translate(offset) {
    this.constant -= offset.dot(this.normal);
    return this;
  }
  /**
   * Returns `true` if this plane is equal with the given one.
   *
   * @param {Plane} plane - The plane to test for equality.
   * @return {boolean} Whether this plane is equal with the given one.
   */
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant;
  }
  /**
   * Returns a new plane with copied values from this instance.
   *
   * @return {Plane} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
};
var _sphere$3 = /* @__PURE__ */ new Sphere();
var _defaultSpriteCenter = /* @__PURE__ */ new Vector2(0.5, 0.5);
var _vector$6 = /* @__PURE__ */ new Vector3();
var Frustum = class {
  /**
   * Constructs a new frustum.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   */
  constructor(p0 = new Plane(), p1 = new Plane(), p2 = new Plane(), p3 = new Plane(), p4 = new Plane(), p5 = new Plane()) {
    this.planes = [p0, p1, p2, p3, p4, p5];
  }
  /**
   * Sets the frustum planes by copying the given planes.
   *
   * @param {Plane} [p0] - The first plane that encloses the frustum.
   * @param {Plane} [p1] - The second plane that encloses the frustum.
   * @param {Plane} [p2] - The third plane that encloses the frustum.
   * @param {Plane} [p3] - The fourth plane that encloses the frustum.
   * @param {Plane} [p4] - The fifth plane that encloses the frustum.
   * @param {Plane} [p5] - The sixth plane that encloses the frustum.
   * @return {Frustum} A reference to this frustum.
   */
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes;
    planes[0].copy(p0);
    planes[1].copy(p1);
    planes[2].copy(p2);
    planes[3].copy(p3);
    planes[4].copy(p4);
    planes[5].copy(p5);
    return this;
  }
  /**
   * Copies the values of the given frustum to this instance.
   *
   * @param {Frustum} frustum - The frustum to copy.
   * @return {Frustum} A reference to this frustum.
   */
  copy(frustum) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      planes[i2].copy(frustum.planes[i2]);
    }
    return this;
  }
  /**
   * Sets the frustum planes from the given projection matrix.
   *
   * @param {Matrix4} m - The projection matrix.
   * @param {(WebGLCoordinateSystem|WebGPUCoordinateSystem)} coordinateSystem - The coordinate system.
   * @param {boolean} [reversedDepth=false] - Whether to use a reversed depth.
   * @return {Frustum} A reference to this frustum.
   */
  setFromProjectionMatrix(m2, coordinateSystem = WebGLCoordinateSystem, reversedDepth = false) {
    const planes = this.planes;
    const me2 = m2.elements;
    const me0 = me2[0], me1 = me2[1], me22 = me2[2], me3 = me2[3];
    const me4 = me2[4], me5 = me2[5], me6 = me2[6], me7 = me2[7];
    const me8 = me2[8], me9 = me2[9], me10 = me2[10], me11 = me2[11];
    const me12 = me2[12], me13 = me2[13], me14 = me2[14], me15 = me2[15];
    planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
    planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
    planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
    planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
    if (reversedDepth) {
      planes[4].setComponents(me22, me6, me10, me14).normalize();
      planes[5].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
    } else {
      planes[4].setComponents(me3 - me22, me7 - me6, me11 - me10, me15 - me14).normalize();
      if (coordinateSystem === WebGLCoordinateSystem) {
        planes[5].setComponents(me3 + me22, me7 + me6, me11 + me10, me15 + me14).normalize();
      } else if (coordinateSystem === WebGPUCoordinateSystem) {
        planes[5].setComponents(me22, me6, me10, me14).normalize();
      } else {
        throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + coordinateSystem);
      }
    }
    return this;
  }
  /**
   * Returns `true` if the 3D object's bounding sphere is intersecting this frustum.
   *
   * Note that the 3D object must have a geometry so that the bounding sphere can be calculated.
   *
   * @param {Object3D} object - The 3D object to test.
   * @return {boolean} Whether the 3D object's bounding sphere is intersecting this frustum or not.
   */
  intersectsObject(object) {
    if (object.boundingSphere !== void 0) {
      if (object.boundingSphere === null) object.computeBoundingSphere();
      _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
    } else {
      const geometry = object.geometry;
      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
      _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
    }
    return this.intersectsSphere(_sphere$3);
  }
  /**
   * Returns `true` if the given sprite is intersecting this frustum.
   *
   * @param {Sprite} sprite - The sprite to test.
   * @return {boolean} Whether the sprite is intersecting this frustum or not.
   */
  intersectsSprite(sprite) {
    _sphere$3.center.set(0, 0, 0);
    const offset = _defaultSpriteCenter.distanceTo(sprite.center);
    _sphere$3.radius = 0.7071067811865476 + offset;
    _sphere$3.applyMatrix4(sprite.matrixWorld);
    return this.intersectsSphere(_sphere$3);
  }
  /**
   * Returns `true` if the given bounding sphere is intersecting this frustum.
   *
   * @param {Sphere} sphere - The bounding sphere to test.
   * @return {boolean} Whether the bounding sphere is intersecting this frustum or not.
   */
  intersectsSphere(sphere) {
    const planes = this.planes;
    const center = sphere.center;
    const negRadius = -sphere.radius;
    for (let i2 = 0; i2 < 6; i2++) {
      const distance = planes[i2].distanceToPoint(center);
      if (distance < negRadius) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns `true` if the given bounding box is intersecting this frustum.
   *
   * @param {Box3} box - The bounding box to test.
   * @return {boolean} Whether the bounding box is intersecting this frustum or not.
   */
  intersectsBox(box) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      const plane = planes[i2];
      _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
      _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
      _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
      if (plane.distanceToPoint(_vector$6) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns `true` if the given point lies within the frustum.
   *
   * @param {Vector3} point - The point to test.
   * @return {boolean} Whether the point lies within this frustum or not.
   */
  containsPoint(point) {
    const planes = this.planes;
    for (let i2 = 0; i2 < 6; i2++) {
      if (planes[i2].distanceToPoint(point) < 0) {
        return false;
      }
    }
    return true;
  }
  /**
   * Returns a new frustum with copied values from this instance.
   *
   * @return {Frustum} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
};
var LineBasicMaterial = class extends Material {
  /**
   * Constructs a new line basic material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isLineBasicMaterial = true;
    this.type = "LineBasicMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.linewidth = 1;
    this.linecap = "round";
    this.linejoin = "round";
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.linewidth = source.linewidth;
    this.linecap = source.linecap;
    this.linejoin = source.linejoin;
    this.fog = source.fog;
    return this;
  }
};
var _vStart = /* @__PURE__ */ new Vector3();
var _vEnd = /* @__PURE__ */ new Vector3();
var _inverseMatrix$1 = /* @__PURE__ */ new Matrix4();
var _ray$1 = /* @__PURE__ */ new Ray();
var _sphere$1 = /* @__PURE__ */ new Sphere();
var _intersectPointOnRay = /* @__PURE__ */ new Vector3();
var _intersectPointOnSegment = /* @__PURE__ */ new Vector3();
var Line = class extends Object3D {
  /**
   * Constructs a new line.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(geometry = new BufferGeometry(), material = new LineBasicMaterial()) {
    super();
    this.isLine = true;
    this.type = "Line";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Computes an array of distance values which are necessary for rendering dashed lines.
   * For each vertex in the geometry, the method calculates the cumulative length from the
   * current point to the very beginning of the line.
   *
   * @return {Line} A reference to this line.
   */
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [0];
      for (let i2 = 1, l2 = positionAttribute.count; i2 < l2; i2++) {
        _vStart.fromBufferAttribute(positionAttribute, i2 - 1);
        _vEnd.fromBufferAttribute(positionAttribute, i2);
        lineDistances[i2] = lineDistances[i2 - 1];
        lineDistances[i2] += _vStart.distanceTo(_vEnd);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      warn("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this line.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Line.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere$1.copy(geometry.boundingSphere);
    _sphere$1.applyMatrix4(matrixWorld);
    _sphere$1.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;
    _inverseMatrix$1.copy(matrixWorld).invert();
    _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const step = this.isLineSegments ? 2 : 1;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
        const a2 = index.getX(i2);
        const b2 = index.getX(i2 + 1);
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a2, b2, i2);
        if (intersect) {
          intersects.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const a2 = index.getX(end - 1);
        const b2 = index.getX(start);
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a2, b2, end - 1);
        if (intersect) {
          intersects.push(intersect);
        }
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end - 1; i2 < l2; i2 += step) {
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, i2, i2 + 1, i2);
        if (intersect) {
          intersects.push(intersect);
        }
      }
      if (this.isLineLoop) {
        const intersect = checkIntersection(this, raycaster, _ray$1, localThresholdSq, end - 1, start, end - 1);
        if (intersect) {
          intersects.push(intersect);
        }
      }
    }
  }
  /**
   * Sets the values of {@link Line#morphTargetDictionary} and {@link Line#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
};
function checkIntersection(object, raycaster, ray, thresholdSq, a2, b2, i2) {
  const positionAttribute = object.geometry.attributes.position;
  _vStart.fromBufferAttribute(positionAttribute, a2);
  _vEnd.fromBufferAttribute(positionAttribute, b2);
  const distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
  if (distSq > thresholdSq) return;
  _intersectPointOnRay.applyMatrix4(object.matrixWorld);
  const distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
  if (distance < raycaster.near || distance > raycaster.far) return;
  return {
    distance,
    // What do we want? intersection point on the ray or on the segment??
    // point: raycaster.ray.at( distance ),
    point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
    index: i2,
    face: null,
    faceIndex: null,
    barycoord: null,
    object
  };
}
var _start = /* @__PURE__ */ new Vector3();
var _end = /* @__PURE__ */ new Vector3();
var LineSegments = class extends Line {
  /**
   * Constructs a new line segments.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineSegments = true;
    this.type = "LineSegments";
  }
  computeLineDistances() {
    const geometry = this.geometry;
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position;
      const lineDistances = [];
      for (let i2 = 0, l2 = positionAttribute.count; i2 < l2; i2 += 2) {
        _start.fromBufferAttribute(positionAttribute, i2);
        _end.fromBufferAttribute(positionAttribute, i2 + 1);
        lineDistances[i2] = i2 === 0 ? 0 : lineDistances[i2 - 1];
        lineDistances[i2 + 1] = lineDistances[i2] + _start.distanceTo(_end);
      }
      geometry.setAttribute("lineDistance", new Float32BufferAttribute(lineDistances, 1));
    } else {
      warn("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
    }
    return this;
  }
};
var LineLoop = class extends Line {
  /**
   * Constructs a new line loop.
   *
   * @param {BufferGeometry} [geometry] - The line geometry.
   * @param {Material|Array<Material>} [material] - The line material.
   */
  constructor(geometry, material) {
    super(geometry, material);
    this.isLineLoop = true;
    this.type = "LineLoop";
  }
};
var PointsMaterial = class extends Material {
  /**
   * Constructs a new points material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isPointsMaterial = true;
    this.type = "PointsMaterial";
    this.color = new Color(16777215);
    this.map = null;
    this.alphaMap = null;
    this.size = 1;
    this.sizeAttenuation = true;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.color.copy(source.color);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.size = source.size;
    this.sizeAttenuation = source.sizeAttenuation;
    this.fog = source.fog;
    return this;
  }
};
var _inverseMatrix = /* @__PURE__ */ new Matrix4();
var _ray = /* @__PURE__ */ new Ray();
var _sphere = /* @__PURE__ */ new Sphere();
var _position$2 = /* @__PURE__ */ new Vector3();
var Points = class extends Object3D {
  /**
   * Constructs a new point cloud.
   *
   * @param {BufferGeometry} [geometry] - The points geometry.
   * @param {Material|Array<Material>} [material] - The points material.
   */
  constructor(geometry = new BufferGeometry(), material = new PointsMaterial()) {
    super();
    this.isPoints = true;
    this.type = "Points";
    this.geometry = geometry;
    this.material = material;
    this.morphTargetDictionary = void 0;
    this.morphTargetInfluences = void 0;
    this.updateMorphTargets();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
    this.geometry = source.geometry;
    return this;
  }
  /**
   * Computes intersection points between a casted ray and this point cloud.
   *
   * @param {Raycaster} raycaster - The raycaster.
   * @param {Array<Object>} intersects - The target array that holds the intersection points.
   */
  raycast(raycaster, intersects) {
    const geometry = this.geometry;
    const matrixWorld = this.matrixWorld;
    const threshold = raycaster.params.Points.threshold;
    const drawRange = geometry.drawRange;
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
    _sphere.copy(geometry.boundingSphere);
    _sphere.applyMatrix4(matrixWorld);
    _sphere.radius += threshold;
    if (raycaster.ray.intersectsSphere(_sphere) === false) return;
    _inverseMatrix.copy(matrixWorld).invert();
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
    const localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
    const localThresholdSq = localThreshold * localThreshold;
    const index = geometry.index;
    const attributes = geometry.attributes;
    const positionAttribute = attributes.position;
    if (index !== null) {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(index.count, drawRange.start + drawRange.count);
      for (let i2 = start, il = end; i2 < il; i2++) {
        const a2 = index.getX(i2);
        _position$2.fromBufferAttribute(positionAttribute, a2);
        testPoint(_position$2, a2, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    } else {
      const start = Math.max(0, drawRange.start);
      const end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
      for (let i2 = start, l2 = end; i2 < l2; i2++) {
        _position$2.fromBufferAttribute(positionAttribute, i2);
        testPoint(_position$2, i2, localThresholdSq, matrixWorld, raycaster, intersects, this);
      }
    }
  }
  /**
   * Sets the values of {@link Points#morphTargetDictionary} and {@link Points#morphTargetInfluences}
   * to make sure existing morph targets can influence this 3D object.
   */
  updateMorphTargets() {
    const geometry = this.geometry;
    const morphAttributes = geometry.morphAttributes;
    const keys = Object.keys(morphAttributes);
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]];
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = [];
        this.morphTargetDictionary = {};
        for (let m2 = 0, ml = morphAttribute.length; m2 < ml; m2++) {
          const name = morphAttribute[m2].name || String(m2);
          this.morphTargetInfluences.push(0);
          this.morphTargetDictionary[name] = m2;
        }
      }
    }
  }
};
function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point);
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3();
    _ray.closestPointToPoint(point, intersectPoint);
    intersectPoint.applyMatrix4(matrixWorld);
    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    if (distance < raycaster.near || distance > raycaster.far) return;
    intersects.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      faceIndex: null,
      barycoord: null,
      object
    });
  }
}
var DepthTexture = class extends Texture {
  /**
   * Constructs a new depth texture.
   *
   * @param {number} width - The width of the texture.
   * @param {number} height - The height of the texture.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=Texture.DEFAULT_MAPPING] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=LinearFilter] - The mag filter value.
   * @param {number} [minFilter=LinearFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   * @param {number} [depth=1] - The depth of the texture.
   */
  constructor(width, height, type = UnsignedIntType, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat, depth = 1) {
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
    }
    const image = { width, height, depth };
    super(image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy);
    this.isDepthTexture = true;
    this.flipY = false;
    this.generateMipmaps = false;
    this.compareFunction = null;
  }
  copy(source) {
    super.copy(source);
    this.source = new Source(Object.assign({}, source.image));
    this.compareFunction = source.compareFunction;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    if (this.compareFunction !== null) data2.compareFunction = this.compareFunction;
    return data2;
  }
};
var CubeDepthTexture = class extends DepthTexture {
  /**
   * Constructs a new cube depth texture.
   *
   * @param {number} size - The size (width and height) of each cube face.
   * @param {number} [type=UnsignedIntType] - The texture type.
   * @param {number} [mapping=CubeReflectionMapping] - The texture mapping.
   * @param {number} [wrapS=ClampToEdgeWrapping] - The wrapS value.
   * @param {number} [wrapT=ClampToEdgeWrapping] - The wrapT value.
   * @param {number} [magFilter=NearestFilter] - The mag filter value.
   * @param {number} [minFilter=NearestFilter] - The min filter value.
   * @param {number} [anisotropy=Texture.DEFAULT_ANISOTROPY] - The anisotropy value.
   * @param {number} [format=DepthFormat] - The texture format.
   */
  constructor(size, type = UnsignedIntType, mapping = CubeReflectionMapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, format = DepthFormat) {
    const image = { width: size, height: size, depth: 1 };
    const images = [image, image, image, image, image, image];
    super(size, size, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format);
    this.image = images;
    this.isCubeDepthTexture = true;
    this.isCubeTexture = true;
  }
  /**
   * Alias for {@link CubeDepthTexture#image}.
   *
   * @type {Array<Image>}
   */
  get images() {
    return this.image;
  }
  set images(value) {
    this.image = value;
  }
};
var ExternalTexture = class extends Texture {
  /**
   * Creates a new raw texture.
   *
   * @param {?(WebGLTexture|GPUTexture)} [sourceTexture=null] - The external texture.
   */
  constructor(sourceTexture = null) {
    super();
    this.sourceTexture = sourceTexture;
    this.isExternalTexture = true;
  }
  copy(source) {
    super.copy(source);
    this.sourceTexture = source.sourceTexture;
    return this;
  }
};
var PlaneGeometry = class _PlaneGeometry extends BufferGeometry {
  /**
   * Constructs a new plane geometry.
   *
   * @param {number} [width=1] - The width along the X axis.
   * @param {number} [height=1] - The height along the Y axis
   * @param {number} [widthSegments=1] - The number of segments along the X axis.
   * @param {number} [heightSegments=1] - The number of segments along the Y axis.
   */
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super();
    this.type = "PlaneGeometry";
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments
    };
    const width_half = width / 2;
    const height_half = height / 2;
    const gridX = Math.floor(widthSegments);
    const gridY = Math.floor(heightSegments);
    const gridX1 = gridX + 1;
    const gridY1 = gridY + 1;
    const segment_width = width / gridX;
    const segment_height = height / gridY;
    const indices = [];
    const vertices = [];
    const normals = [];
    const uvs = [];
    for (let iy = 0; iy < gridY1; iy++) {
      const y2 = iy * segment_height - height_half;
      for (let ix = 0; ix < gridX1; ix++) {
        const x2 = ix * segment_width - width_half;
        vertices.push(x2, -y2, 0);
        normals.push(0, 0, 1);
        uvs.push(ix / gridX);
        uvs.push(1 - iy / gridY);
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a2 = ix + gridX1 * iy;
        const b2 = ix + gridX1 * (iy + 1);
        const c2 = ix + 1 + gridX1 * (iy + 1);
        const d2 = ix + 1 + gridX1 * iy;
        indices.push(a2, b2, d2);
        indices.push(b2, c2, d2);
      }
    }
    this.setIndex(indices);
    this.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    this.setAttribute("normal", new Float32BufferAttribute(normals, 3));
    this.setAttribute("uv", new Float32BufferAttribute(uvs, 2));
  }
  copy(source) {
    super.copy(source);
    this.parameters = Object.assign({}, source.parameters);
    return this;
  }
  /**
   * Factory method for creating an instance of this class from the given
   * JSON object.
   *
   * @param {Object} data - A JSON object representing the serialized geometry.
   * @return {PlaneGeometry} A new instance.
   */
  static fromJSON(data2) {
    return new _PlaneGeometry(data2.width, data2.height, data2.widthSegments, data2.heightSegments);
  }
};
var RawShaderMaterial = class extends ShaderMaterial {
  /**
   * Constructs a new raw shader material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super(parameters);
    this.isRawShaderMaterial = true;
    this.type = "RawShaderMaterial";
  }
};
var MeshStandardMaterial = class extends Material {
  /**
   * Constructs a new mesh standard material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshStandardMaterial = true;
    this.type = "MeshStandardMaterial";
    this.defines = { "STANDARD": "" };
    this.color = new Color(16777215);
    this.roughness = 1;
    this.metalness = 0;
    this.map = null;
    this.lightMap = null;
    this.lightMapIntensity = 1;
    this.aoMap = null;
    this.aoMapIntensity = 1;
    this.emissive = new Color(0);
    this.emissiveIntensity = 1;
    this.emissiveMap = null;
    this.bumpMap = null;
    this.bumpScale = 1;
    this.normalMap = null;
    this.normalMapType = TangentSpaceNormalMap;
    this.normalScale = new Vector2(1, 1);
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.roughnessMap = null;
    this.metalnessMap = null;
    this.alphaMap = null;
    this.envMap = null;
    this.envMapRotation = new Euler();
    this.envMapIntensity = 1;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.wireframeLinecap = "round";
    this.wireframeLinejoin = "round";
    this.flatShading = false;
    this.fog = true;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.defines = { "STANDARD": "" };
    this.color.copy(source.color);
    this.roughness = source.roughness;
    this.metalness = source.metalness;
    this.map = source.map;
    this.lightMap = source.lightMap;
    this.lightMapIntensity = source.lightMapIntensity;
    this.aoMap = source.aoMap;
    this.aoMapIntensity = source.aoMapIntensity;
    this.emissive.copy(source.emissive);
    this.emissiveMap = source.emissiveMap;
    this.emissiveIntensity = source.emissiveIntensity;
    this.bumpMap = source.bumpMap;
    this.bumpScale = source.bumpScale;
    this.normalMap = source.normalMap;
    this.normalMapType = source.normalMapType;
    this.normalScale.copy(source.normalScale);
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.roughnessMap = source.roughnessMap;
    this.metalnessMap = source.metalnessMap;
    this.alphaMap = source.alphaMap;
    this.envMap = source.envMap;
    this.envMapRotation.copy(source.envMapRotation);
    this.envMapIntensity = source.envMapIntensity;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    this.wireframeLinecap = source.wireframeLinecap;
    this.wireframeLinejoin = source.wireframeLinejoin;
    this.flatShading = source.flatShading;
    this.fog = source.fog;
    return this;
  }
};
var MeshPhysicalMaterial = class extends MeshStandardMaterial {
  /**
   * Constructs a new mesh physical material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshPhysicalMaterial = true;
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.type = "MeshPhysicalMaterial";
    this.anisotropyRotation = 0;
    this.anisotropyMap = null;
    this.clearcoatMap = null;
    this.clearcoatRoughness = 0;
    this.clearcoatRoughnessMap = null;
    this.clearcoatNormalScale = new Vector2(1, 1);
    this.clearcoatNormalMap = null;
    this.ior = 1.5;
    Object.defineProperty(this, "reflectivity", {
      get: function() {
        return clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
      },
      set: function(reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
      }
    });
    this.iridescenceMap = null;
    this.iridescenceIOR = 1.3;
    this.iridescenceThicknessRange = [100, 400];
    this.iridescenceThicknessMap = null;
    this.sheenColor = new Color(0);
    this.sheenColorMap = null;
    this.sheenRoughness = 1;
    this.sheenRoughnessMap = null;
    this.transmissionMap = null;
    this.thickness = 0;
    this.thicknessMap = null;
    this.attenuationDistance = Infinity;
    this.attenuationColor = new Color(1, 1, 1);
    this.specularIntensity = 1;
    this.specularIntensityMap = null;
    this.specularColor = new Color(1, 1, 1);
    this.specularColorMap = null;
    this._anisotropy = 0;
    this._clearcoat = 0;
    this._dispersion = 0;
    this._iridescence = 0;
    this._sheen = 0;
    this._transmission = 0;
    this.setValues(parameters);
  }
  /**
   * The anisotropy strength, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(value) {
    if (this._anisotropy > 0 !== value > 0) {
      this.version++;
    }
    this._anisotropy = value;
  }
  /**
   * Represents the intensity of the clear coat layer, from `0.0` to `1.0`. Use
   * clear coat related properties to enable multilayer materials that have a
   * thin translucent layer over the base layer.
   *
   * @type {number}
   * @default 0
   */
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++;
    }
    this._clearcoat = value;
  }
  /**
   * The intensity of the iridescence layer, simulating RGB color shift based on the angle between
   * the surface and the viewer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++;
    }
    this._iridescence = value;
  }
  /**
   * Defines the strength of the angular separation of colors (chromatic aberration) transmitting
   * through a relatively clear volume. Any value zero or larger is valid, the typical range of
   * realistic values is `[0, 1]`. This property can be only be used with transmissive objects.
   *
   * @type {number}
   * @default 0
   */
  get dispersion() {
    return this._dispersion;
  }
  set dispersion(value) {
    if (this._dispersion > 0 !== value > 0) {
      this.version++;
    }
    this._dispersion = value;
  }
  /**
   * The intensity of the sheen layer, from `0.0` to `1.0`.
   *
   * @type {number}
   * @default 0
   */
  get sheen() {
    return this._sheen;
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++;
    }
    this._sheen = value;
  }
  /**
   * Degree of transmission (or optical transparency), from `0.0` to `1.0`.
   *
   * Thin, transparent or semitransparent, plastic or glass materials remain
   * largely reflective even if they are fully transmissive. The transmission
   * property can be used to model these materials.
   *
   * When transmission is non-zero, `opacity` should be  set to `1`.
   *
   * @type {number}
   * @default 0
   */
  get transmission() {
    return this._transmission;
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++;
    }
    this._transmission = value;
  }
  copy(source) {
    super.copy(source);
    this.defines = {
      "STANDARD": "",
      "PHYSICAL": ""
    };
    this.anisotropy = source.anisotropy;
    this.anisotropyRotation = source.anisotropyRotation;
    this.anisotropyMap = source.anisotropyMap;
    this.clearcoat = source.clearcoat;
    this.clearcoatMap = source.clearcoatMap;
    this.clearcoatRoughness = source.clearcoatRoughness;
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
    this.clearcoatNormalMap = source.clearcoatNormalMap;
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
    this.dispersion = source.dispersion;
    this.ior = source.ior;
    this.iridescence = source.iridescence;
    this.iridescenceMap = source.iridescenceMap;
    this.iridescenceIOR = source.iridescenceIOR;
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange];
    this.iridescenceThicknessMap = source.iridescenceThicknessMap;
    this.sheen = source.sheen;
    this.sheenColor.copy(source.sheenColor);
    this.sheenColorMap = source.sheenColorMap;
    this.sheenRoughness = source.sheenRoughness;
    this.sheenRoughnessMap = source.sheenRoughnessMap;
    this.transmission = source.transmission;
    this.transmissionMap = source.transmissionMap;
    this.thickness = source.thickness;
    this.thicknessMap = source.thicknessMap;
    this.attenuationDistance = source.attenuationDistance;
    this.attenuationColor.copy(source.attenuationColor);
    this.specularIntensity = source.specularIntensity;
    this.specularIntensityMap = source.specularIntensityMap;
    this.specularColor.copy(source.specularColor);
    this.specularColorMap = source.specularColorMap;
    return this;
  }
};
var MeshDepthMaterial = class extends Material {
  /**
   * Constructs a new mesh depth material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshDepthMaterial = true;
    this.type = "MeshDepthMaterial";
    this.depthPacking = BasicDepthPacking;
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.wireframe = false;
    this.wireframeLinewidth = 1;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.depthPacking = source.depthPacking;
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    this.wireframe = source.wireframe;
    this.wireframeLinewidth = source.wireframeLinewidth;
    return this;
  }
};
var MeshDistanceMaterial = class extends Material {
  /**
   * Constructs a new mesh distance material.
   *
   * @param {Object} [parameters] - An object with one or more properties
   * defining the material's appearance. Any property of the material
   * (including any property from inherited materials) can be passed
   * in here. Color values can be passed any type of value accepted
   * by {@link Color#set}.
   */
  constructor(parameters) {
    super();
    this.isMeshDistanceMaterial = true;
    this.type = "MeshDistanceMaterial";
    this.map = null;
    this.alphaMap = null;
    this.displacementMap = null;
    this.displacementScale = 1;
    this.displacementBias = 0;
    this.setValues(parameters);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.alphaMap = source.alphaMap;
    this.displacementMap = source.displacementMap;
    this.displacementScale = source.displacementScale;
    this.displacementBias = source.displacementBias;
    return this;
  }
};
function convertArray(array, type) {
  if (!array || array.constructor === type) return array;
  if (typeof type.BYTES_PER_ELEMENT === "number") {
    return new type(array);
  }
  return Array.prototype.slice.call(array);
}
function getKeyframeOrder(times) {
  function compareTime(i2, j2) {
    return times[i2] - times[j2];
  }
  const n2 = times.length;
  const result = new Array(n2);
  for (let i2 = 0; i2 !== n2; ++i2) result[i2] = i2;
  result.sort(compareTime);
  return result;
}
function sortedArray(values, stride, order) {
  const nValues = values.length;
  const result = new values.constructor(nValues);
  for (let i2 = 0, dstOffset = 0; dstOffset !== nValues; ++i2) {
    const srcOffset = order[i2] * stride;
    for (let j2 = 0; j2 !== stride; ++j2) {
      result[dstOffset++] = values[srcOffset + j2];
    }
  }
  return result;
}
function flattenJSON(jsonKeys, times, values, valuePropertyName) {
  let i2 = 1, key = jsonKeys[0];
  while (key !== void 0 && key[valuePropertyName] === void 0) {
    key = jsonKeys[i2++];
  }
  if (key === void 0) return;
  let value = key[valuePropertyName];
  if (value === void 0) return;
  if (Array.isArray(value)) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(...value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else if (value.toArray !== void 0) {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        value.toArray(values, values.length);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  } else {
    do {
      value = key[valuePropertyName];
      if (value !== void 0) {
        times.push(key.time);
        values.push(value);
      }
      key = jsonKeys[i2++];
    } while (key !== void 0);
  }
}
var Interpolant = class {
  /**
   * Constructs a new interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions;
    this._cachedIndex = 0;
    this.resultBuffer = resultBuffer !== void 0 ? resultBuffer : new sampleValues.constructor(sampleSize);
    this.sampleValues = sampleValues;
    this.valueSize = sampleSize;
    this.settings = null;
    this.DefaultSettings_ = {};
  }
  /**
   * Evaluate the interpolant at position `t`.
   *
   * @param {number} t - The interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  evaluate(t2) {
    const pp = this.parameterPositions;
    let i1 = this._cachedIndex, t1 = pp[i1], t0 = pp[i1 - 1];
    validate_interval: {
      seek: {
        let right;
        linear_scan: {
          forward_scan: if (!(t2 < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t2 < t0) break forward_scan;
                i1 = pp.length;
                this._cachedIndex = i1;
                return this.copySampleValue_(i1 - 1);
              }
              if (i1 === giveUpAt) break;
              t0 = t1;
              t1 = pp[++i1];
              if (t2 < t1) {
                break seek;
              }
            }
            right = pp.length;
            break linear_scan;
          }
          if (!(t2 >= t0)) {
            const t1global = pp[1];
            if (t2 < t1global) {
              i1 = 2;
              t0 = t1global;
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0;
                return this.copySampleValue_(0);
              }
              if (i1 === giveUpAt) break;
              t1 = t0;
              t0 = pp[--i1 - 1];
              if (t2 >= t0) {
                break seek;
              }
            }
            right = i1;
            i1 = 0;
            break linear_scan;
          }
          break validate_interval;
        }
        while (i1 < right) {
          const mid = i1 + right >>> 1;
          if (t2 < pp[mid]) {
            right = mid;
          } else {
            i1 = mid + 1;
          }
        }
        t1 = pp[i1];
        t0 = pp[i1 - 1];
        if (t0 === void 0) {
          this._cachedIndex = 0;
          return this.copySampleValue_(0);
        }
        if (t1 === void 0) {
          i1 = pp.length;
          this._cachedIndex = i1;
          return this.copySampleValue_(i1 - 1);
        }
      }
      this._cachedIndex = i1;
      this.intervalChanged_(i1, t0, t1);
    }
    return this.interpolate_(i1, t0, t2, t1);
  }
  /**
   * Returns the interpolation settings.
   *
   * @return {Object} The interpolation settings.
   */
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @param {number} index - An index into the sample value buffer.
   * @return {TypedArray} The result buffer.
   */
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset = index * stride;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  /**
   * Copies a sample value to the result buffer.
   *
   * @abstract
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   * @param {number} t1 - The next interpolation factor.
   * @return {TypedArray} The result buffer.
   */
  interpolate_() {
    throw new Error("call to abstract method");
  }
  /**
   * Optional method that is executed when the interval has changed.
   *
   * @param {number} i1 - An index into the sample value buffer.
   * @param {number} t0 - The previous interpolation factor.
   * @param {number} t - The current interpolation factor.
   */
  intervalChanged_() {
  }
};
var CubicInterpolant = class extends Interpolant {
  /**
   * Constructs a new cubic interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
    this._weightPrev = -0;
    this._offsetPrev = -0;
    this._weightNext = -0;
    this._offsetNext = -0;
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding
    };
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions;
    let iPrev = i1 - 2, iNext = i1 + 1, tPrev = pp[iPrev], tNext = pp[iNext];
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1;
          tPrev = 2 * t0 - t1;
          break;
        case WrapAroundEnding:
          iPrev = pp.length - 2;
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
          break;
        default:
          iPrev = i1;
          tPrev = t1;
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1;
          tNext = 2 * t1 - t0;
          break;
        case WrapAroundEnding:
          iNext = 1;
          tNext = t1 + pp[1] - pp[0];
          break;
        default:
          iNext = i1 - 1;
          tNext = t0;
      }
    }
    const halfDt = (t1 - t0) * 0.5, stride = this.valueSize;
    this._weightPrev = halfDt / (t0 - tPrev);
    this._weightNext = halfDt / (tNext - t1);
    this._offsetPrev = iPrev * stride;
    this._offsetNext = iNext * stride;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, o1 = i1 * stride, o0 = o1 - stride, oP = this._offsetPrev, oN = this._offsetNext, wP = this._weightPrev, wN = this._weightNext, p2 = (t2 - t0) / (t1 - t0), pp = p2 * p2, ppp = pp * p2;
    const sP = -wP * ppp + 2 * wP * pp - wP * p2;
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1;
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2;
    const sN = wN * ppp - wN * pp;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = sP * values[oP + i2] + s0 * values[o0 + i2] + s1 * values[o1 + i2] + sN * values[oN + i2];
    }
    return result;
  }
};
var LinearInterpolant = class extends Interpolant {
  /**
   * Constructs a new linear interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, offset1 = i1 * stride, offset0 = offset1 - stride, weight1 = (t2 - t0) / (t1 - t0), weight0 = 1 - weight1;
    for (let i2 = 0; i2 !== stride; ++i2) {
      result[i2] = values[offset0 + i2] * weight0 + values[offset1 + i2] * weight1;
    }
    return result;
  }
};
var DiscreteInterpolant = class extends Interpolant {
  /**
   * Constructs a new discrete interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1);
  }
};
var KeyframeTrack = class {
  /**
   * Constructs a new keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number|string|boolean>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(name, times, values, interpolation) {
    if (name === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (times === void 0 || times.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + name);
    this.name = name;
    this.times = convertArray(times, this.TimeBufferType);
    this.values = convertArray(values, this.ValueBufferType);
    this.setInterpolation(interpolation || this.DefaultInterpolation);
  }
  /**
   * Converts the keyframe track to JSON.
   *
   * @static
   * @param {KeyframeTrack} track - The keyframe track to serialize.
   * @return {Object} The serialized keyframe track as JSON.
   */
  static toJSON(track) {
    const trackType = track.constructor;
    let json;
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track);
    } else {
      json = {
        "name": track.name,
        "times": convertArray(track.times, Array),
        "values": convertArray(track.values, Array)
      };
      const interpolation = track.getInterpolation();
      if (interpolation !== track.DefaultInterpolation) {
        json.interpolation = interpolation;
      }
    }
    json.type = track.ValueTypeName;
    return json;
  }
  /**
   * Factory method for creating a new discrete interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {DiscreteInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodDiscrete(result) {
    return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  /**
   * Factory method for creating a new linear interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {LinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(result) {
    return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  /**
   * Factory method for creating a new smooth interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {CubicInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodSmooth(result) {
    return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
  }
  /**
   * Defines the interpolation factor method for this keyframe track.
   *
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} interpolation - The interpolation type.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  setInterpolation(interpolation) {
    let factoryMethod;
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete;
        break;
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear;
        break;
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth;
        break;
    }
    if (factoryMethod === void 0) {
      const message = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation);
        } else {
          throw new Error(message);
        }
      }
      warn("KeyframeTrack:", message);
      return this;
    }
    this.createInterpolant = factoryMethod;
    return this;
  }
  /**
   * Returns the current interpolation type.
   *
   * @return {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} The interpolation type.
   */
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete;
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear;
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth;
    }
  }
  /**
   * Returns the value size.
   *
   * @return {number} The value size.
   */
  getValueSize() {
    return this.values.length / this.times.length;
  }
  /**
   * Moves all keyframes either forward or backward in time.
   *
   * @param {number} timeOffset - The offset to move the time values.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] += timeOffset;
      }
    }
    return this;
  }
  /**
   * Scale all keyframe times by a factor (useful for frame - seconds conversions).
   *
   * @param {number} timeScale - The time scale.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times;
      for (let i2 = 0, n2 = times.length; i2 !== n2; ++i2) {
        times[i2] *= timeScale;
      }
    }
    return this;
  }
  /**
   * Removes keyframes before and after animation without changing any values within the defined time range.
   *
   * Note: The method does not shift around keys to the start of the track time, because for interpolated
   * keys this will change their values
   *
   * @param {number} startTime - The start time.
   * @param {number} endTime - The end time.
   * @return {KeyframeTrack} A reference to this keyframe track.
   */
  trim(startTime, endTime) {
    const times = this.times, nKeys = times.length;
    let from = 0, to2 = nKeys - 1;
    while (from !== nKeys && times[from] < startTime) {
      ++from;
    }
    while (to2 !== -1 && times[to2] > endTime) {
      --to2;
    }
    ++to2;
    if (from !== 0 || to2 !== nKeys) {
      if (from >= to2) {
        to2 = Math.max(to2, 1);
        from = to2 - 1;
      }
      const stride = this.getValueSize();
      this.times = times.slice(from, to2);
      this.values = this.values.slice(from * stride, to2 * stride);
    }
    return this;
  }
  /**
   * Performs minimal validation on the keyframe track. Returns `true` if the values
   * are valid.
   *
   * @return {boolean} Whether the keyframes are valid or not.
   */
  validate() {
    let valid = true;
    const valueSize = this.getValueSize();
    if (valueSize - Math.floor(valueSize) !== 0) {
      error("KeyframeTrack: Invalid value size in track.", this);
      valid = false;
    }
    const times = this.times, values = this.values, nKeys = times.length;
    if (nKeys === 0) {
      error("KeyframeTrack: Track is empty.", this);
      valid = false;
    }
    let prevTime = null;
    for (let i2 = 0; i2 !== nKeys; i2++) {
      const currTime = times[i2];
      if (typeof currTime === "number" && isNaN(currTime)) {
        error("KeyframeTrack: Time is not a valid number.", this, i2, currTime);
        valid = false;
        break;
      }
      if (prevTime !== null && prevTime > currTime) {
        error("KeyframeTrack: Out of order keys.", this, i2, currTime, prevTime);
        valid = false;
        break;
      }
      prevTime = currTime;
    }
    if (values !== void 0) {
      if (isTypedArray2(values)) {
        for (let i2 = 0, n2 = values.length; i2 !== n2; ++i2) {
          const value = values[i2];
          if (isNaN(value)) {
            error("KeyframeTrack: Value is not a valid number.", this, i2, value);
            valid = false;
            break;
          }
        }
      }
    }
    return valid;
  }
  /**
   * Optimizes this keyframe track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    const times = this.times.slice(), values = this.values.slice(), stride = this.getValueSize(), smoothInterpolation = this.getInterpolation() === InterpolateSmooth, lastIndex = times.length - 1;
    let writeIndex = 1;
    for (let i2 = 1; i2 < lastIndex; ++i2) {
      let keep = false;
      const time = times[i2];
      const timeNext = times[i2 + 1];
      if (time !== timeNext && (i2 !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i2 * stride, offsetP = offset - stride, offsetN = offset + stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            const value = values[offset + j2];
            if (value !== values[offsetP + j2] || value !== values[offsetN + j2]) {
              keep = true;
              break;
            }
          }
        } else {
          keep = true;
        }
      }
      if (keep) {
        if (i2 !== writeIndex) {
          times[writeIndex] = times[i2];
          const readOffset = i2 * stride, writeOffset = writeIndex * stride;
          for (let j2 = 0; j2 !== stride; ++j2) {
            values[writeOffset + j2] = values[readOffset + j2];
          }
        }
        ++writeIndex;
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex];
      for (let readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j2 = 0; j2 !== stride; ++j2) {
        values[writeOffset + j2] = values[readOffset + j2];
      }
      ++writeIndex;
    }
    if (writeIndex !== times.length) {
      this.times = times.slice(0, writeIndex);
      this.values = values.slice(0, writeIndex * stride);
    } else {
      this.times = times;
      this.values = values;
    }
    return this;
  }
  /**
   * Returns a new keyframe track with copied values from this instance.
   *
   * @return {KeyframeTrack} A clone of this instance.
   */
  clone() {
    const times = this.times.slice();
    const values = this.values.slice();
    const TypedKeyframeTrack = this.constructor;
    const track = new TypedKeyframeTrack(this.name, times, values);
    track.createInterpolant = this.createInterpolant;
    return track;
  }
};
KeyframeTrack.prototype.ValueTypeName = "";
KeyframeTrack.prototype.TimeBufferType = Float32Array;
KeyframeTrack.prototype.ValueBufferType = Float32Array;
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;
var BooleanKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new boolean keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<boolean>} values - A list of keyframe values.
   */
  constructor(name, times, values) {
    super(name, times, values);
  }
};
BooleanKeyframeTrack.prototype.ValueTypeName = "bool";
BooleanKeyframeTrack.prototype.ValueBufferType = Array;
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var ColorKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new color keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(name, times, values, interpolation) {
    super(name, times, values, interpolation);
  }
};
ColorKeyframeTrack.prototype.ValueTypeName = "color";
var NumberKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new number keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(name, times, values, interpolation) {
    super(name, times, values, interpolation);
  }
};
NumberKeyframeTrack.prototype.ValueTypeName = "number";
var QuaternionLinearInterpolant = class extends Interpolant {
  /**
   * Constructs a new SLERP interpolant.
   *
   * @param {TypedArray} parameterPositions - The parameter positions hold the interpolation factors.
   * @param {TypedArray} sampleValues - The sample values.
   * @param {number} sampleSize - The sample size
   * @param {TypedArray} [resultBuffer] - The result buffer.
   */
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer, values = this.sampleValues, stride = this.valueSize, alpha = (t2 - t0) / (t1 - t0);
    let offset = i1 * stride;
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
    }
    return result;
  }
};
var QuaternionKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new Quaternion keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(name, times, values, interpolation) {
    super(name, times, values, interpolation);
  }
  /**
   * Overwritten so the method returns Quaternion based interpolant.
   *
   * @static
   * @param {TypedArray} [result] - The result buffer.
   * @return {QuaternionLinearInterpolant} The new interpolant.
   */
  InterpolantFactoryMethodLinear(result) {
    return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
  }
};
QuaternionKeyframeTrack.prototype.ValueTypeName = "quaternion";
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var StringKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new string keyframe track.
   *
   * This keyframe track type has no `interpolation` parameter because the
   * interpolation is always discrete.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<string>} values - A list of keyframe values.
   */
  constructor(name, times, values) {
    super(name, times, values);
  }
};
StringKeyframeTrack.prototype.ValueTypeName = "string";
StringKeyframeTrack.prototype.ValueBufferType = Array;
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0;
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0;
var VectorKeyframeTrack = class extends KeyframeTrack {
  /**
   * Constructs a new vector keyframe track.
   *
   * @param {string} name - The keyframe track's name.
   * @param {Array<number>} times - A list of keyframe times.
   * @param {Array<number>} values - A list of keyframe values.
   * @param {(InterpolateLinear|InterpolateDiscrete|InterpolateSmooth)} [interpolation] - The interpolation type.
   */
  constructor(name, times, values, interpolation) {
    super(name, times, values, interpolation);
  }
};
VectorKeyframeTrack.prototype.ValueTypeName = "vector";
var AnimationClip = class {
  /**
   * Constructs a new animation clip.
   *
   * Note: Instead of instantiating an AnimationClip directly with the constructor, you can
   * use the static interface of this class for creating clips. In most cases though, animation clips
   * will automatically be created by loaders when importing animated 3D assets.
   *
   * @param {string} [name=''] - The clip's name.
   * @param {number} [duration=-1] - The clip's duration in seconds. If a negative value is passed,
   * the duration will be calculated from the passed keyframes.
   * @param {Array<KeyframeTrack>} tracks - An array of keyframe tracks.
   * @param {(NormalAnimationBlendMode|AdditiveAnimationBlendMode)} [blendMode=NormalAnimationBlendMode] - Defines how the animation
   * is blended/combined when two or more animations are simultaneously played.
   */
  constructor(name = "", duration = -1, tracks = [], blendMode = NormalAnimationBlendMode) {
    this.name = name;
    this.tracks = tracks;
    this.duration = duration;
    this.blendMode = blendMode;
    this.uuid = generateUUID();
    this.userData = {};
    if (this.duration < 0) {
      this.resetDuration();
    }
  }
  /**
   * Factory method for creating an animation clip from the given JSON.
   *
   * @static
   * @param {Object} json - The serialized animation clip.
   * @return {AnimationClip} The new animation clip.
   */
  static parse(json) {
    const tracks = [], jsonTracks = json.tracks, frameTime = 1 / (json.fps || 1);
    for (let i2 = 0, n2 = jsonTracks.length; i2 !== n2; ++i2) {
      tracks.push(parseKeyframeTrack(jsonTracks[i2]).scale(frameTime));
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode);
    clip.uuid = json.uuid;
    clip.userData = JSON.parse(json.userData || "{}");
    return clip;
  }
  /**
   * Serializes the given animation clip into JSON.
   *
   * @static
   * @param {AnimationClip} clip - The animation clip to serialize.
   * @return {Object} The JSON object.
   */
  static toJSON(clip) {
    const tracks = [], clipTracks = clip.tracks;
    const json = {
      "name": clip.name,
      "duration": clip.duration,
      "tracks": tracks,
      "uuid": clip.uuid,
      "blendMode": clip.blendMode,
      "userData": JSON.stringify(clip.userData)
    };
    for (let i2 = 0, n2 = clipTracks.length; i2 !== n2; ++i2) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i2]));
    }
    return json;
  }
  /**
   * Returns a new animation clip from the passed morph targets array of a
   * geometry, taking a name and the number of frames per second.
   *
   * Note: The fps parameter is required, but the animation speed can be
   * overridden via {@link AnimationAction#setDuration}.
   *
   * @static
   * @param {string} name - The name of the animation clip.
   * @param {Array<Object>} morphTargetSequence - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {AnimationClip} The new animation clip.
   */
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length;
    const tracks = [];
    for (let i2 = 0; i2 < numMorphTargets; i2++) {
      let times = [];
      let values = [];
      times.push(
        (i2 + numMorphTargets - 1) % numMorphTargets,
        i2,
        (i2 + 1) % numMorphTargets
      );
      values.push(0, 1, 0);
      const order = getKeyframeOrder(times);
      times = sortedArray(times, 1, order);
      values = sortedArray(values, 1, order);
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets);
        values.push(values[0]);
      }
      tracks.push(
        new NumberKeyframeTrack(
          ".morphTargetInfluences[" + morphTargetSequence[i2].name + "]",
          times,
          values
        ).scale(1 / fps)
      );
    }
    return new this(name, -1, tracks);
  }
  /**
   * Searches for an animation clip by name, taking as its first parameter
   * either an array of clips, or a mesh or geometry that contains an
   * array named "animations" property.
   *
   * @static
   * @param {(Array<AnimationClip>|Object3D)} objectOrClipArray - The array or object to search through.
   * @param {string} name - The name to search for.
   * @return {?AnimationClip} The found animation clip. Returns `null` if no clip has been found.
   */
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray;
    if (!Array.isArray(objectOrClipArray)) {
      const o2 = objectOrClipArray;
      clipArray = o2.geometry && o2.geometry.animations || o2.animations;
    }
    for (let i2 = 0; i2 < clipArray.length; i2++) {
      if (clipArray[i2].name === name) {
        return clipArray[i2];
      }
    }
    return null;
  }
  /**
   * Returns an array of new AnimationClips created from the morph target
   * sequences of a geometry, trying to sort morph target names into
   * animation-group-based patterns like "Walk_001, Walk_002, Run_001, Run_002...".
   *
   * See {@link MD2Loader#parse} as an example for how the method should be used.
   *
   * @static
   * @param {Array<Object>} morphTargets - A sequence of morph targets.
   * @param {number} fps - The Frames-Per-Second value.
   * @param {boolean} noLoop - Whether the clip should be no loop or not.
   * @return {Array<AnimationClip>} An array of new animation clips.
   */
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {};
    const pattern = /^([\w-]*?)([\d]+)$/;
    for (let i2 = 0, il = morphTargets.length; i2 < il; i2++) {
      const morphTarget = morphTargets[i2];
      const parts = morphTarget.name.match(pattern);
      if (parts && parts.length > 1) {
        const name = parts[1];
        let animationMorphTargets = animationToMorphTargets[name];
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = [];
        }
        animationMorphTargets.push(morphTarget);
      }
    }
    const clips = [];
    for (const name in animationToMorphTargets) {
      clips.push(this.CreateFromMorphTargetSequence(name, animationToMorphTargets[name], fps, noLoop));
    }
    return clips;
  }
  /**
   * Parses the `animation.hierarchy` format and returns a new animation clip.
   *
   * @static
   * @deprecated since r175.
   * @param {Object} animation - A serialized animation clip as JSON.
   * @param {Array<Bones>} bones - An array of bones.
   * @return {?AnimationClip} The new animation clip.
   */
  static parseAnimation(animation, bones) {
    warn("AnimationClip: parseAnimation() is deprecated and will be removed with r185");
    if (!animation) {
      error("AnimationClip: No animation in JSONLoader data.");
      return null;
    }
    const addNonemptyTrack = function(trackType, trackName, animationKeys, propertyName, destTracks) {
      if (animationKeys.length !== 0) {
        const times = [];
        const values = [];
        flattenJSON(animationKeys, times, values, propertyName);
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values));
        }
      }
    };
    const tracks = [];
    const clipName = animation.name || "default";
    const fps = animation.fps || 30;
    const blendMode = animation.blendMode;
    let duration = animation.length || -1;
    const hierarchyTracks = animation.hierarchy || [];
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys;
      if (!animationKeys || animationKeys.length === 0) continue;
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {};
        let k2;
        for (k2 = 0; k2 < animationKeys.length; k2++) {
          if (animationKeys[k2].morphTargets) {
            for (let m2 = 0; m2 < animationKeys[k2].morphTargets.length; m2++) {
              morphTargetNames[animationKeys[k2].morphTargets[m2]] = -1;
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = [];
          const values = [];
          for (let m2 = 0; m2 !== animationKeys[k2].morphTargets.length; ++m2) {
            const animationKey = animationKeys[k2];
            times.push(animationKey.time);
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
          }
          tracks.push(new NumberKeyframeTrack(".morphTargetInfluence[" + morphTargetName + "]", times, values));
        }
        duration = morphTargetNames.length * fps;
      } else {
        const boneName = ".bones[" + bones[h2].name + "]";
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".position",
          animationKeys,
          "pos",
          tracks
        );
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + ".quaternion",
          animationKeys,
          "rot",
          tracks
        );
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + ".scale",
          animationKeys,
          "scl",
          tracks
        );
      }
    }
    if (tracks.length === 0) {
      return null;
    }
    const clip = new this(clipName, duration, tracks, blendMode);
    return clip;
  }
  /**
   * Sets the duration of this clip to the duration of its longest keyframe track.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  resetDuration() {
    const tracks = this.tracks;
    let duration = 0;
    for (let i2 = 0, n2 = tracks.length; i2 !== n2; ++i2) {
      const track = this.tracks[i2];
      duration = Math.max(duration, track.times[track.times.length - 1]);
    }
    this.duration = duration;
    return this;
  }
  /**
   * Trims all tracks to the clip's duration.
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  trim() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].trim(0, this.duration);
    }
    return this;
  }
  /**
   * Performs minimal validation on each track in the clip. Returns `true` if all
   * tracks are valid.
   *
   * @return {boolean} Whether the clip's keyframes are valid or not.
   */
  validate() {
    let valid = true;
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      valid = valid && this.tracks[i2].validate();
    }
    return valid;
  }
  /**
   * Optimizes each track by removing equivalent sequential keys (which are
   * common in morph target sequences).
   *
   * @return {AnimationClip} A reference to this animation clip.
   */
  optimize() {
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      this.tracks[i2].optimize();
    }
    return this;
  }
  /**
   * Returns a new animation clip with copied values from this instance.
   *
   * @return {AnimationClip} A clone of this instance.
   */
  clone() {
    const tracks = [];
    for (let i2 = 0; i2 < this.tracks.length; i2++) {
      tracks.push(this.tracks[i2].clone());
    }
    const clip = new this.constructor(this.name, this.duration, tracks, this.blendMode);
    clip.userData = JSON.parse(JSON.stringify(this.userData));
    return clip;
  }
  /**
   * Serializes this animation clip into JSON.
   *
   * @return {Object} The JSON object.
   */
  toJSON() {
    return this.constructor.toJSON(this);
  }
};
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
      return NumberKeyframeTrack;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
      return VectorKeyframeTrack;
    case "color":
      return ColorKeyframeTrack;
    case "quaternion":
      return QuaternionKeyframeTrack;
    case "bool":
    case "boolean":
      return BooleanKeyframeTrack;
    case "string":
      return StringKeyframeTrack;
  }
  throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + typeName);
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  }
  const trackType = getTrackTypeForValueTypeName(json.type);
  if (json.times === void 0) {
    const times = [], values = [];
    flattenJSON(json.keys, times, values, "value");
    json.times = times;
    json.values = values;
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json);
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation);
  }
}
var Cache = {
  /**
   * Whether caching is enabled or not.
   *
   * @static
   * @type {boolean}
   * @default false
   */
  enabled: false,
  /**
   * A dictionary that holds cached files.
   *
   * @static
   * @type {Object<string,Object>}
   */
  files: {},
  /**
   * Adds a cache entry with a key to reference the file. If this key already
   * holds a file, it is overwritten.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @param {Object} file -  The file to be cached.
   */
  add: function(key, file) {
    if (this.enabled === false) return;
    this.files[key] = file;
  },
  /**
   * Gets the cached value for the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   * @return {Object|undefined} The cached file. If the key does not exist `undefined` is returned.
   */
  get: function(key) {
    if (this.enabled === false) return;
    return this.files[key];
  },
  /**
   * Removes the cached file associated with the given key.
   *
   * @static
   * @param {string} key - The key to reference the cached file.
   */
  remove: function(key) {
    delete this.files[key];
  },
  /**
   * Remove all values from the cache.
   *
   * @static
   */
  clear: function() {
    this.files = {};
  }
};
var LoadingManager = class {
  /**
   * Constructs a new loading manager.
   *
   * @param {Function} [onLoad] - Executes when all items have been loaded.
   * @param {Function} [onProgress] - Executes when single items have been loaded.
   * @param {Function} [onError] - Executes when an error occurs.
   */
  constructor(onLoad, onProgress, onError) {
    const scope = this;
    let isLoading = false;
    let itemsLoaded = 0;
    let itemsTotal = 0;
    let urlModifier = void 0;
    const handlers = [];
    this.onStart = void 0;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this._abortController = null;
    this.itemStart = function(url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function(url) {
      itemsLoaded++;
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== void 0) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function(url) {
      if (scope.onError !== void 0) {
        scope.onError(url);
      }
    };
    this.resolveURL = function(url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function(transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function(regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function(regex) {
      const index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function(file) {
      for (let i2 = 0, l2 = handlers.length; i2 < l2; i2 += 2) {
        const regex = handlers[i2];
        const loader = handlers[i2 + 1];
        if (regex.global) regex.lastIndex = 0;
        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
    this.abort = function() {
      this.abortController.abort();
      this._abortController = null;
      return this;
    };
  }
  // TODO: Revert this back to a single member variable once this issue has been fixed
  // https://github.com/cloudflare/workerd/issues/3657
  /**
   * Used for aborting ongoing requests in loaders using this manager.
   *
   * @type {AbortController}
   */
  get abortController() {
    if (!this._abortController) {
      this._abortController = new AbortController();
    }
    return this._abortController;
  }
};
var DefaultLoadingManager = /* @__PURE__ */ new LoadingManager();
var Loader = class {
  /**
   * Constructs a new loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager;
    this.crossOrigin = "anonymous";
    this.withCredentials = false;
    this.path = "";
    this.resourcePath = "";
    this.requestHeader = {};
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for loading assets from the backend.
   *
   * @abstract
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {Function} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   */
  load() {
  }
  /**
   * A async version of {@link Loader#load}.
   *
   * @param {string} url - The path/URL of the file to be loaded.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @return {Promise} A Promise that resolves when the asset has been loaded.
   */
  loadAsync(url, onProgress) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.load(url, resolve, onProgress, reject);
    });
  }
  /**
   * This method needs to be implemented by all concrete loaders. It holds the
   * logic for parsing the asset into three.js entities.
   *
   * @abstract
   * @param {any} data - The data to parse.
   */
  parse() {
  }
  /**
   * Sets the `crossOrigin` String to implement CORS for loading the URL
   * from a different domain that allows CORS.
   *
   * @param {string} crossOrigin - The `crossOrigin` value.
   * @return {Loader} A reference to this instance.
   */
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin;
    return this;
  }
  /**
   * Whether the XMLHttpRequest uses credentials such as cookies, authorization
   * headers or TLS client certificates, see [XMLHttpRequest.withCredentials](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/withCredentials).
   *
   * Note: This setting has no effect if you are loading files locally or from the same domain.
   *
   * @param {boolean} value - The `withCredentials` value.
   * @return {Loader} A reference to this instance.
   */
  setWithCredentials(value) {
    this.withCredentials = value;
    return this;
  }
  /**
   * Sets the base path for the asset.
   *
   * @param {string} path - The base path.
   * @return {Loader} A reference to this instance.
   */
  setPath(path) {
    this.path = path;
    return this;
  }
  /**
   * Sets the base path for dependent resources like textures.
   *
   * @param {string} resourcePath - The resource path.
   * @return {Loader} A reference to this instance.
   */
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath;
    return this;
  }
  /**
   * Sets the given request header.
   *
   * @param {Object} requestHeader - A [request header](https://developer.mozilla.org/en-US/docs/Glossary/Request_header)
   * for configuring the HTTP request.
   * @return {Loader} A reference to this instance.
   */
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader;
    return this;
  }
  /**
   * This method can be implemented in loaders for aborting ongoing requests.
   *
   * @abstract
   * @return {Loader} A reference to this instance.
   */
  abort() {
    return this;
  }
};
Loader.DEFAULT_MATERIAL_NAME = "__DEFAULT";
var loading = {};
var HttpError = class extends Error {
  constructor(message, response) {
    super(message);
    this.response = response;
  }
};
var FileLoader = class extends Loader {
  /**
   * Constructs a new file loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
    this.mimeType = "";
    this.responseType = "";
    this._abortController = new AbortController();
  }
  /**
   * Starts loading from the given URL and pass the loaded response to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(any)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} [onProgress] - Executed while the loading is in progress.
   * @param {onErrorCallback} [onError] - Executed when errors occur.
   * @return {any|undefined} The cached resource if available.
   */
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const cached = Cache.get(`file:${url}`);
    if (cached !== void 0) {
      this.manager.itemStart(url);
      setTimeout(() => {
        if (onLoad) onLoad(cached);
        this.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError
      });
      return;
    }
    loading[url] = [];
    loading[url].push({
      onLoad,
      onProgress,
      onError
    });
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? "include" : "same-origin",
      signal: typeof AbortSignal.any === "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal
    });
    const mimeType = this.mimeType;
    const responseType = this.responseType;
    fetch(req).then((response) => {
      if (response.status === 200 || response.status === 0) {
        if (response.status === 0) {
          warn("FileLoader: HTTP Status 0 received.");
        }
        if (typeof ReadableStream === "undefined" || response.body === void 0 || response.body.getReader === void 0) {
          return response;
        }
        const callbacks = loading[url];
        const reader = response.body.getReader();
        const contentLength = response.headers.get("X-File-Size") || response.headers.get("Content-Length");
        const total = contentLength ? parseInt(contentLength) : 0;
        const lengthComputable = total !== 0;
        let loaded = 0;
        const stream = new ReadableStream({
          start(controller) {
            readData();
            function readData() {
              reader.read().then(({ done, value }) => {
                if (done) {
                  controller.close();
                } else {
                  loaded += value.byteLength;
                  const event = new ProgressEvent("progress", { lengthComputable, loaded, total });
                  for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
                    const callback = callbacks[i2];
                    if (callback.onProgress) callback.onProgress(event);
                  }
                  controller.enqueue(value);
                  readData();
                }
              }, (e2) => {
                controller.error(e2);
              });
            }
          }
        });
        return new Response(stream);
      } else {
        throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
      }
    }).then((response) => {
      switch (responseType) {
        case "arraybuffer":
          return response.arrayBuffer();
        case "blob":
          return response.blob();
        case "document":
          return response.text().then((text) => {
            const parser = new DOMParser();
            return parser.parseFromString(text, mimeType);
          });
        case "json":
          return response.json();
        default:
          if (mimeType === "") {
            return response.text();
          } else {
            const re2 = /charset="?([^;"\s]*)"?/i;
            const exec = re2.exec(mimeType);
            const label = exec && exec[1] ? exec[1].toLowerCase() : void 0;
            const decoder = new TextDecoder(label);
            return response.arrayBuffer().then((ab) => decoder.decode(ab));
          }
      }
    }).then((data2) => {
      Cache.add(`file:${url}`, data2);
      const callbacks = loading[url];
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad) callback.onLoad(data2);
      }
    }).catch((err) => {
      const callbacks = loading[url];
      if (callbacks === void 0) {
        this.manager.itemError(url);
        throw err;
      }
      delete loading[url];
      for (let i2 = 0, il = callbacks.length; i2 < il; i2++) {
        const callback = callbacks[i2];
        if (callback.onError) callback.onError(err);
      }
      this.manager.itemError(url);
    }).finally(() => {
      this.manager.itemEnd(url);
    });
    this.manager.itemStart(url);
  }
  /**
   * Sets the expected response type.
   *
   * @param {('arraybuffer'|'blob'|'document'|'json'|'')} value - The response type.
   * @return {FileLoader} A reference to this file loader.
   */
  setResponseType(value) {
    this.responseType = value;
    return this;
  }
  /**
   * Sets the expected mime type of the loaded file.
   *
   * @param {string} value - The mime type.
   * @return {FileLoader} A reference to this file loader.
   */
  setMimeType(value) {
    this.mimeType = value;
    return this;
  }
  /**
   * Aborts ongoing fetch requests.
   *
   * @return {FileLoader} A reference to this instance.
   */
  abort() {
    this._abortController.abort();
    this._abortController = new AbortController();
    return this;
  }
};
var _loading = /* @__PURE__ */ new WeakMap();
var ImageLoader = class extends Loader {
  /**
   * Constructs a new image loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
  }
  /**
   * Starts loading from the given URL and passes the loaded image
   * to the `onLoad()` callback. The method also returns a new `Image` object which can
   * directly be used for texture creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Image)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Image} The image.
   */
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(`image:${url}`);
    if (cached !== void 0) {
      if (cached.complete === true) {
        scope.manager.itemStart(url);
        setTimeout(function() {
          if (onLoad) onLoad(cached);
          scope.manager.itemEnd(url);
        }, 0);
      } else {
        let arr = _loading.get(cached);
        if (arr === void 0) {
          arr = [];
          _loading.set(cached, arr);
        }
        arr.push({ onLoad, onError });
      }
      return cached;
    }
    const image = createElementNS("img");
    function onImageLoad() {
      removeEventListeners();
      if (onLoad) onLoad(this);
      const callbacks = _loading.get(this) || [];
      for (let i2 = 0; i2 < callbacks.length; i2++) {
        const callback = callbacks[i2];
        if (callback.onLoad) callback.onLoad(this);
      }
      _loading.delete(this);
      scope.manager.itemEnd(url);
    }
    function onImageError(event) {
      removeEventListeners();
      if (onError) onError(event);
      Cache.remove(`image:${url}`);
      const callbacks = _loading.get(this) || [];
      for (let i2 = 0; i2 < callbacks.length; i2++) {
        const callback = callbacks[i2];
        if (callback.onError) callback.onError(event);
      }
      _loading.delete(this);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    }
    function removeEventListeners() {
      image.removeEventListener("load", onImageLoad, false);
      image.removeEventListener("error", onImageError, false);
    }
    image.addEventListener("load", onImageLoad, false);
    image.addEventListener("error", onImageError, false);
    if (url.slice(0, 5) !== "data:") {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin;
    }
    Cache.add(`image:${url}`, image);
    scope.manager.itemStart(url);
    image.src = url;
    return image;
  }
};
var TextureLoader = class extends Loader {
  /**
   * Constructs a new texture loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
  }
  /**
   * Starts loading from the given URL and pass the fully loaded texture
   * to the `onLoad()` callback. The method also returns a new texture object which can
   * directly be used for material creation. If you do it this way, the texture
   * may pop up in your scene once the respective loading process is finished.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(Texture)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {Texture} The texture.
   */
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture();
    const loader = new ImageLoader(this.manager);
    loader.setCrossOrigin(this.crossOrigin);
    loader.setPath(this.path);
    loader.load(url, function(image) {
      texture.image = image;
      texture.needsUpdate = true;
      if (onLoad !== void 0) {
        onLoad(texture);
      }
    }, onProgress, onError);
    return texture;
  }
};
var Light = class extends Object3D {
  /**
   * Constructs a new light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color, intensity = 1) {
    super();
    this.isLight = true;
    this.type = "Light";
    this.color = new Color(color);
    this.intensity = intensity;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.color.copy(source.color);
    this.intensity = source.intensity;
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.color = this.color.getHex();
    data2.object.intensity = this.intensity;
    return data2;
  }
};
var _projScreenMatrix = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld = /* @__PURE__ */ new Vector3();
var _lookTarget = /* @__PURE__ */ new Vector3();
var LightShadow = class {
  /**
   * Constructs a new light shadow.
   *
   * @param {Camera} camera - The light's view of the world.
   */
  constructor(camera) {
    this.camera = camera;
    this.intensity = 1;
    this.bias = 0;
    this.normalBias = 0;
    this.radius = 1;
    this.blurSamples = 8;
    this.mapSize = new Vector2(512, 512);
    this.mapType = UnsignedByteType;
    this.map = null;
    this.mapPass = null;
    this.matrix = new Matrix4();
    this.autoUpdate = true;
    this.needsUpdate = false;
    this._frustum = new Frustum();
    this._frameExtents = new Vector2(1, 1);
    this._viewportCount = 1;
    this._viewports = [
      new Vector4(0, 0, 1, 1)
    ];
  }
  /**
   * Used internally by the renderer to get the number of viewports that need
   * to be rendered for this shadow.
   *
   * @return {number} The viewport count.
   */
  getViewportCount() {
    return this._viewportCount;
  }
  /**
   * Gets the shadow cameras frustum. Used internally by the renderer to cull objects.
   *
   * @return {Frustum} The shadow camera frustum.
   */
  getFrustum() {
    return this._frustum;
  }
  /**
   * Update the matrices for the camera and shadow, used internally by the renderer.
   *
   * @param {Light} light - The light for which the shadow is being rendered.
   */
  updateMatrices(light) {
    const shadowCamera = this.camera;
    const shadowMatrix = this.matrix;
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
    shadowCamera.position.copy(_lightPositionWorld);
    _lookTarget.setFromMatrixPosition(light.target.matrixWorld);
    shadowCamera.lookAt(_lookTarget);
    shadowCamera.updateMatrixWorld();
    _projScreenMatrix.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
    this._frustum.setFromProjectionMatrix(_projScreenMatrix, shadowCamera.coordinateSystem, shadowCamera.reversedDepth);
    if (shadowCamera.reversedDepth) {
      shadowMatrix.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
      );
    } else {
      shadowMatrix.set(
        0.5,
        0,
        0,
        0.5,
        0,
        0.5,
        0,
        0.5,
        0,
        0,
        0.5,
        0.5,
        0,
        0,
        0,
        1
      );
    }
    shadowMatrix.multiply(_projScreenMatrix);
  }
  /**
   * Returns a viewport definition for the given viewport index.
   *
   * @param {number} viewportIndex - The viewport index.
   * @return {Vector4} The viewport.
   */
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex];
  }
  /**
   * Returns the frame extends.
   *
   * @return {Vector2} The frame extends.
   */
  getFrameExtents() {
    return this._frameExtents;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    if (this.map) {
      this.map.dispose();
    }
    if (this.mapPass) {
      this.mapPass.dispose();
    }
  }
  /**
   * Copies the values of the given light shadow instance to this instance.
   *
   * @param {LightShadow} source - The light shadow to copy.
   * @return {LightShadow} A reference to this light shadow instance.
   */
  copy(source) {
    this.camera = source.camera.clone();
    this.intensity = source.intensity;
    this.bias = source.bias;
    this.radius = source.radius;
    this.autoUpdate = source.autoUpdate;
    this.needsUpdate = source.needsUpdate;
    this.normalBias = source.normalBias;
    this.blurSamples = source.blurSamples;
    this.mapSize.copy(source.mapSize);
    return this;
  }
  /**
   * Returns a new light shadow instance with copied values from this instance.
   *
   * @return {LightShadow} A clone of this instance.
   */
  clone() {
    return new this.constructor().copy(this);
  }
  /**
   * Serializes the light shadow into JSON.
   *
   * @return {Object} A JSON object representing the serialized light shadow.
   * @see {@link ObjectLoader#parse}
   */
  toJSON() {
    const object = {};
    if (this.intensity !== 1) object.intensity = this.intensity;
    if (this.bias !== 0) object.bias = this.bias;
    if (this.normalBias !== 0) object.normalBias = this.normalBias;
    if (this.radius !== 1) object.radius = this.radius;
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
    object.camera = this.camera.toJSON(false).object;
    delete object.camera.matrix;
    return object;
  }
};
var SpotLightShadow = class extends LightShadow {
  /**
   * Constructs a new spot light shadow.
   */
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500));
    this.isSpotLightShadow = true;
    this.focus = 1;
    this.aspect = 1;
  }
  updateMatrices(light) {
    const camera = this.camera;
    const fov2 = RAD2DEG * 2 * light.angle * this.focus;
    const aspect2 = this.mapSize.width / this.mapSize.height * this.aspect;
    const far = light.distance || camera.far;
    if (fov2 !== camera.fov || aspect2 !== camera.aspect || far !== camera.far) {
      camera.fov = fov2;
      camera.aspect = aspect2;
      camera.far = far;
      camera.updateProjectionMatrix();
    }
    super.updateMatrices(light);
  }
  copy(source) {
    super.copy(source);
    this.focus = source.focus;
    return this;
  }
};
var SpotLight = class extends Light {
  /**
   * Constructs a new spot light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [angle=Math.PI/3] - Maximum angle of light dispersion from its direction whose upper bound is `Math.PI/2`.
   * @param {number} [penumbra=0] - Percent of the spotlight cone that is attenuated due to penumbra. Value range is `[0,1]`.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color, intensity, distance = 0, angle = Math.PI / 3, penumbra = 0, decay = 2) {
    super(color, intensity);
    this.isSpotLight = true;
    this.type = "SpotLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.distance = distance;
    this.angle = angle;
    this.penumbra = penumbra;
    this.decay = decay;
    this.map = null;
    this.shadow = new SpotLightShadow();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   *  Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * Math.PI;
  }
  set power(power) {
    this.intensity = power / Math.PI;
  }
  dispose() {
    super.dispose();
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.angle = source.angle;
    this.penumbra = source.penumbra;
    this.decay = source.decay;
    this.target = source.target.clone();
    this.map = source.map;
    this.shadow = source.shadow.clone();
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.distance = this.distance;
    data2.object.angle = this.angle;
    data2.object.decay = this.decay;
    data2.object.penumbra = this.penumbra;
    data2.object.target = this.target.uuid;
    if (this.map && this.map.isTexture) data2.object.map = this.map.toJSON(meta).uuid;
    data2.object.shadow = this.shadow.toJSON();
    return data2;
  }
};
var PointLightShadow = class extends LightShadow {
  /**
   * Constructs a new point light shadow.
   */
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500));
    this.isPointLightShadow = true;
  }
};
var PointLight = class extends Light {
  /**
   * Constructs a new point light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity measured in candela (cd).
   * @param {number} [distance=0] - Maximum range of the light. `0` means no limit.
   * @param {number} [decay=2] - The amount the light dims along the distance of the light.
   */
  constructor(color, intensity, distance = 0, decay = 2) {
    super(color, intensity);
    this.isPointLight = true;
    this.type = "PointLight";
    this.distance = distance;
    this.decay = decay;
    this.shadow = new PointLightShadow();
  }
  /**
   * The light's power. Power is the luminous power of the light measured in lumens (lm).
   * Changing the power will also change the light's intensity.
   *
   * @type {number}
   */
  get power() {
    return this.intensity * 4 * Math.PI;
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI);
  }
  dispose() {
    super.dispose();
    this.shadow.dispose();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.distance = source.distance;
    this.decay = source.decay;
    this.shadow = source.shadow.clone();
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.distance = this.distance;
    data2.object.decay = this.decay;
    data2.object.shadow = this.shadow.toJSON();
    return data2;
  }
};
var OrthographicCamera = class extends Camera {
  /**
   * Constructs a new orthographic camera.
   *
   * @param {number} [left=-1] - The left plane of the camera's frustum.
   * @param {number} [right=1] - The right plane of the camera's frustum.
   * @param {number} [top=1] - The top plane of the camera's frustum.
   * @param {number} [bottom=-1] - The bottom plane of the camera's frustum.
   * @param {number} [near=0.1] - The camera's near plane.
   * @param {number} [far=2000] - The camera's far plane.
   */
  constructor(left = -1, right = 1, top = 1, bottom = -1, near = 0.1, far = 2e3) {
    super();
    this.isOrthographicCamera = true;
    this.type = "OrthographicCamera";
    this.zoom = 1;
    this.view = null;
    this.left = left;
    this.right = right;
    this.top = top;
    this.bottom = bottom;
    this.near = near;
    this.far = far;
    this.updateProjectionMatrix();
  }
  copy(source, recursive) {
    super.copy(source, recursive);
    this.left = source.left;
    this.right = source.right;
    this.top = source.top;
    this.bottom = source.bottom;
    this.near = source.near;
    this.far = source.far;
    this.zoom = source.zoom;
    this.view = source.view === null ? null : Object.assign({}, source.view);
    return this;
  }
  /**
   * Sets an offset in a larger frustum. This is useful for multi-window or
   * multi-monitor/multi-machine setups.
   *
   * @param {number} fullWidth - The full width of multiview setup.
   * @param {number} fullHeight - The full height of multiview setup.
   * @param {number} x - The horizontal offset of the subcamera.
   * @param {number} y - The vertical offset of the subcamera.
   * @param {number} width - The width of subcamera.
   * @param {number} height - The height of subcamera.
   * @see {@link PerspectiveCamera#setViewOffset}
   */
  setViewOffset(fullWidth, fullHeight, x2, y2, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1
      };
    }
    this.view.enabled = true;
    this.view.fullWidth = fullWidth;
    this.view.fullHeight = fullHeight;
    this.view.offsetX = x2;
    this.view.offsetY = y2;
    this.view.width = width;
    this.view.height = height;
    this.updateProjectionMatrix();
  }
  /**
   * Removes the view offset from the projection matrix.
   */
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false;
    }
    this.updateProjectionMatrix();
  }
  /**
   * Updates the camera's projection matrix. Must be called after any change of
   * camera properties.
   */
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom);
    const dy = (this.top - this.bottom) / (2 * this.zoom);
    const cx = (this.right + this.left) / 2;
    const cy = (this.top + this.bottom) / 2;
    let left = cx - dx;
    let right = cx + dx;
    let top = cy + dy;
    let bottom = cy - dy;
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      left += scaleW * this.view.offsetX;
      right = left + scaleW * this.view.width;
      top -= scaleH * this.view.offsetY;
      bottom = top - scaleH * this.view.height;
    }
    this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem, this.reversedDepth);
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.zoom = this.zoom;
    data2.object.left = this.left;
    data2.object.right = this.right;
    data2.object.top = this.top;
    data2.object.bottom = this.bottom;
    data2.object.near = this.near;
    data2.object.far = this.far;
    if (this.view !== null) data2.object.view = Object.assign({}, this.view);
    return data2;
  }
};
var DirectionalLightShadow = class extends LightShadow {
  /**
   * Constructs a new directional light shadow.
   */
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500));
    this.isDirectionalLightShadow = true;
  }
};
var DirectionalLight = class extends Light {
  /**
   * Constructs a new directional light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color, intensity) {
    super(color, intensity);
    this.isDirectionalLight = true;
    this.type = "DirectionalLight";
    this.position.copy(Object3D.DEFAULT_UP);
    this.updateMatrix();
    this.target = new Object3D();
    this.shadow = new DirectionalLightShadow();
  }
  dispose() {
    super.dispose();
    this.shadow.dispose();
  }
  copy(source) {
    super.copy(source);
    this.target = source.target.clone();
    this.shadow = source.shadow.clone();
    return this;
  }
  toJSON(meta) {
    const data2 = super.toJSON(meta);
    data2.object.shadow = this.shadow.toJSON();
    data2.object.target = this.target.uuid;
    return data2;
  }
};
var AmbientLight = class extends Light {
  /**
   * Constructs a new ambient light.
   *
   * @param {(number|Color|string)} [color=0xffffff] - The light's color.
   * @param {number} [intensity=1] - The light's strength/intensity.
   */
  constructor(color, intensity) {
    super(color, intensity);
    this.isAmbientLight = true;
    this.type = "AmbientLight";
  }
};
var LoaderUtils = class {
  /**
   * Extracts the base URL from the given URL.
   *
   * @param {string} url -The URL to extract the base URL from.
   * @return {string} The extracted base URL.
   */
  static extractUrlBase(url) {
    const index = url.lastIndexOf("/");
    if (index === -1) return "./";
    return url.slice(0, index + 1);
  }
  /**
   * Resolves relative URLs against the given path. Absolute paths, data urls,
   * and blob URLs will be returned as is. Invalid URLs will return an empty
   * string.
   *
   * @param {string} url -The URL to resolve.
   * @param {string} path - The base path for relative URLs to be resolved against.
   * @return {string} The resolved URL.
   */
  static resolveURL(url, path) {
    if (typeof url !== "string" || url === "") return "";
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, "$1");
    }
    if (/^(https?:)?\/\//i.test(url)) return url;
    if (/^data:.*,.*$/i.test(url)) return url;
    if (/^blob:.*$/i.test(url)) return url;
    return path + url;
  }
};
var _errorMap = /* @__PURE__ */ new WeakMap();
var ImageBitmapLoader = class extends Loader {
  /**
   * Constructs a new image bitmap loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
    this.isImageBitmapLoader = true;
    if (typeof createImageBitmap === "undefined") {
      warn("ImageBitmapLoader: createImageBitmap() not supported.");
    }
    if (typeof fetch === "undefined") {
      warn("ImageBitmapLoader: fetch() not supported.");
    }
    this.options = { premultiplyAlpha: "none" };
    this._abortController = new AbortController();
  }
  /**
   * Sets the given loader options. The structure of the object must match the `options` parameter of
   * [createImageBitmap](https://developer.mozilla.org/en-US/docs/Web/API/Window/createImageBitmap).
   *
   * @param {Object} options - The loader options to set.
   * @return {ImageBitmapLoader} A reference to this image bitmap loader.
   */
  setOptions(options) {
    this.options = options;
    return this;
  }
  /**
   * Starts loading from the given URL and pass the loaded image bitmap to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(ImageBitmap)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Unsupported in this loader.
   * @param {onErrorCallback} onError - Executed when errors occur.
   * @return {ImageBitmap|undefined} The image bitmap.
   */
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = "";
    if (this.path !== void 0) url = this.path + url;
    url = this.manager.resolveURL(url);
    const scope = this;
    const cached = Cache.get(`image-bitmap:${url}`);
    if (cached !== void 0) {
      scope.manager.itemStart(url);
      if (cached.then) {
        cached.then((imageBitmap) => {
          if (_errorMap.has(cached) === true) {
            if (onError) onError(_errorMap.get(cached));
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          } else {
            if (onLoad) onLoad(imageBitmap);
            scope.manager.itemEnd(url);
            return imageBitmap;
          }
        });
        return;
      }
      setTimeout(function() {
        if (onLoad) onLoad(cached);
        scope.manager.itemEnd(url);
      }, 0);
      return cached;
    }
    const fetchOptions = {};
    fetchOptions.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include";
    fetchOptions.headers = this.requestHeader;
    fetchOptions.signal = typeof AbortSignal.any === "function" ? AbortSignal.any([this._abortController.signal, this.manager.abortController.signal]) : this._abortController.signal;
    const promise = fetch(url, fetchOptions).then(function(res) {
      return res.blob();
    }).then(function(blob) {
      return createImageBitmap(blob, Object.assign(scope.options, { colorSpaceConversion: "none" }));
    }).then(function(imageBitmap) {
      Cache.add(`image-bitmap:${url}`, imageBitmap);
      if (onLoad) onLoad(imageBitmap);
      scope.manager.itemEnd(url);
      return imageBitmap;
    }).catch(function(e2) {
      if (onError) onError(e2);
      _errorMap.set(promise, e2);
      Cache.remove(`image-bitmap:${url}`);
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    });
    Cache.add(`image-bitmap:${url}`, promise);
    scope.manager.itemStart(url);
  }
  /**
   * Aborts ongoing fetch requests.
   *
   * @return {ImageBitmapLoader} A reference to this instance.
   */
  abort() {
    this._abortController.abort();
    this._abortController = new AbortController();
    return this;
  }
};
var ArrayCamera = class extends PerspectiveCamera {
  /**
   * Constructs a new array camera.
   *
   * @param {Array<PerspectiveCamera>} [array=[]] - An array of perspective sub cameras.
   */
  constructor(array = []) {
    super();
    this.isArrayCamera = true;
    this.isMultiViewCamera = false;
    this.cameras = array;
  }
};
var Clock = class {
  /**
   * Constructs a new clock.
   *
   * @param {boolean} [autoStart=true] - Whether to automatically start the clock when
   * `getDelta()` is called for the first time.
   */
  constructor(autoStart = true) {
    this.autoStart = autoStart;
    this.startTime = 0;
    this.oldTime = 0;
    this.elapsedTime = 0;
    this.running = false;
  }
  /**
   * Starts the clock. When `autoStart` is set to `true`, the method is automatically
   * called by the class.
   */
  start() {
    this.startTime = performance.now();
    this.oldTime = this.startTime;
    this.elapsedTime = 0;
    this.running = true;
  }
  /**
   * Stops the clock.
   */
  stop() {
    this.getElapsedTime();
    this.running = false;
    this.autoStart = false;
  }
  /**
   * Returns the elapsed time in seconds.
   *
   * @return {number} The elapsed time.
   */
  getElapsedTime() {
    this.getDelta();
    return this.elapsedTime;
  }
  /**
   * Returns the delta time in seconds.
   *
   * @return {number} The delta time.
   */
  getDelta() {
    let diff = 0;
    if (this.autoStart && !this.running) {
      this.start();
      return 0;
    }
    if (this.running) {
      const newTime = performance.now();
      diff = (newTime - this.oldTime) / 1e3;
      this.oldTime = newTime;
      this.elapsedTime += diff;
    }
    return diff;
  }
};
var _RESERVED_CHARS_RE = "\\[\\]\\.:\\/";
var _reservedRe = new RegExp("[" + _RESERVED_CHARS_RE + "]", "g");
var _wordChar = "[^" + _RESERVED_CHARS_RE + "]";
var _wordCharOrDot = "[^" + _RESERVED_CHARS_RE.replace("\\.", "") + "]";
var _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace("WC", _wordChar);
var _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace("WCOD", _wordCharOrDot);
var _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", _wordChar);
var _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", _wordChar);
var _trackRe = new RegExp(
  "^" + _directoryRe + _nodeRe + _objectRe + _propertyRe + "$"
);
var _supportedObjectNames = ["material", "materials", "bones", "map"];
var Composite = class {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
    this._targetGroup = targetGroup;
    this._bindings = targetGroup.subscribe_(path, parsedPath);
  }
  getValue(array, offset) {
    this.bind();
    const firstValidIndex = this._targetGroup.nCachedObjects_, binding = this._bindings[firstValidIndex];
    if (binding !== void 0) binding.getValue(array, offset);
  }
  setValue(array, offset) {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].setValue(array, offset);
    }
  }
  bind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].bind();
    }
  }
  unbind() {
    const bindings = this._bindings;
    for (let i2 = this._targetGroup.nCachedObjects_, n2 = bindings.length; i2 !== n2; ++i2) {
      bindings[i2].unbind();
    }
  }
};
var PropertyBinding = class _PropertyBinding {
  /**
   * Constructs a new property binding.
   *
   * @param {Object} rootNode - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   */
  constructor(rootNode, path, parsedPath) {
    this.path = path;
    this.parsedPath = parsedPath || _PropertyBinding.parseTrackName(path);
    this.node = _PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
    this.rootNode = rootNode;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
  /**
   * Factory method for creating a property binding from the given parameters.
   *
   * @static
   * @param {Object} root - The root node.
   * @param {string} path - The path.
   * @param {?Object} [parsedPath] - The parsed path.
   * @return {PropertyBinding|Composite} The created property binding or composite.
   */
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new _PropertyBinding(root, path, parsedPath);
    } else {
      return new _PropertyBinding.Composite(root, path, parsedPath);
    }
  }
  /**
   * Replaces spaces with underscores and removes unsupported characters from
   * node names, to ensure compatibility with parseTrackName().
   *
   * @param {string} name - Node name to be sanitized.
   * @return {string} The sanitized node name.
   */
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, "_").replace(_reservedRe, "");
  }
  /**
   * Parses the given track name (an object path to an animated property) and
   * returns an object with information about the path. Matches strings in the following forms:
   *
   * - nodeName.property
   * - nodeName.property[accessor]
   * - nodeName.material.property[accessor]
   * - uuid.property[accessor]
   * - uuid.objectName[objectIndex].propertyName[propertyIndex]
   * - parentName/nodeName.property
   * - parentName/parentName/nodeName.property[index]
   * - .bone[Armature.DEF_cog].position
   * - scene:helium_balloon_model:helium_balloon_model.position
   *
   * @static
   * @param {string} trackName - The track name to parse.
   * @return {Object} The parsed track name as an object.
   */
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName);
    if (matches === null) {
      throw new Error("PropertyBinding: Cannot parse trackName: " + trackName);
    }
    const results = {
      // directoryName: matches[ 1 ], // (tschw) currently unused
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      // required
      propertyIndex: matches[6]
    };
    const lastDot = results.nodeName && results.nodeName.lastIndexOf(".");
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1);
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot);
        results.objectName = objectName;
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error("PropertyBinding: can not parse propertyName from trackName: " + trackName);
    }
    return results;
  }
  /**
   * Searches for a node in the hierarchy of the given root object by the given
   * node name.
   *
   * @static
   * @param {Object} root - The root object.
   * @param {string|number} nodeName - The name of the node.
   * @return {?Object} The found node. Returns `null` if no object was found.
   */
  static findNode(root, nodeName) {
    if (nodeName === void 0 || nodeName === "" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
      return root;
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName);
      if (bone !== void 0) {
        return bone;
      }
    }
    if (root.children) {
      const searchNodeSubtree = function(children) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const childNode = children[i2];
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode;
          }
          const result = searchNodeSubtree(childNode.children);
          if (result) return result;
        }
        return null;
      };
      const subTreeNode = searchNodeSubtree(root.children);
      if (subTreeNode) {
        return subTreeNode;
      }
    }
    return null;
  }
  // these are used to "bind" a nonexistent property
  _getValue_unavailable() {
  }
  _setValue_unavailable() {
  }
  // Getters
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName];
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty;
    for (let i2 = 0, n2 = source.length; i2 !== n2; ++i2) {
      buffer[offset++] = source[i2];
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset);
  }
  // Direct
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // EntireArray
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.needsUpdate = true;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty;
    for (let i2 = 0, n2 = dest.length; i2 !== n2; ++i2) {
      dest[i2] = buffer[offset++];
    }
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // ArrayElement
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.needsUpdate = true;
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset];
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  // HasToFromArray
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.needsUpdate = true;
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset);
    this.targetObject.matrixWorldNeedsUpdate = true;
  }
  _getValue_unbound(targetArray, offset) {
    this.bind();
    this.getValue(targetArray, offset);
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind();
    this.setValue(sourceArray, offset);
  }
  /**
   * Creates a getter / setter pair for the property tracked by this binding.
   */
  bind() {
    let targetObject = this.node;
    const parsedPath = this.parsedPath;
    const objectName = parsedPath.objectName;
    const propertyName = parsedPath.propertyName;
    let propertyIndex = parsedPath.propertyIndex;
    if (!targetObject) {
      targetObject = _PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
      this.node = targetObject;
    }
    this.getValue = this._getValue_unavailable;
    this.setValue = this._setValue_unavailable;
    if (!targetObject) {
      warn("PropertyBinding: No target node found for track: " + this.path + ".");
      return;
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex;
      switch (objectName) {
        case "materials":
          if (!targetObject.material) {
            error("PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.materials) {
            error("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
            return;
          }
          targetObject = targetObject.material.materials;
          break;
        case "bones":
          if (!targetObject.skeleton) {
            error("PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
            return;
          }
          targetObject = targetObject.skeleton.bones;
          for (let i2 = 0; i2 < targetObject.length; i2++) {
            if (targetObject[i2].name === objectIndex) {
              objectIndex = i2;
              break;
            }
          }
          break;
        case "map":
          if ("map" in targetObject) {
            targetObject = targetObject.map;
            break;
          }
          if (!targetObject.material) {
            error("PropertyBinding: Can not bind to material as node does not have a material.", this);
            return;
          }
          if (!targetObject.material.map) {
            error("PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
            return;
          }
          targetObject = targetObject.material.map;
          break;
        default:
          if (targetObject[objectName] === void 0) {
            error("PropertyBinding: Can not bind to objectName of node undefined.", this);
            return;
          }
          targetObject = targetObject[objectName];
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          error("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, targetObject);
          return;
        }
        targetObject = targetObject[objectIndex];
      }
    }
    const nodeProperty = targetObject[propertyName];
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName;
      error("PropertyBinding: Trying to update property for track: " + nodeName + "." + propertyName + " but it wasn't found.", targetObject);
      return;
    }
    let versioning = this.Versioning.None;
    this.targetObject = targetObject;
    if (targetObject.isMaterial === true) {
      versioning = this.Versioning.NeedsUpdate;
    } else if (targetObject.isObject3D === true) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate;
    }
    let bindingType = this.BindingType.Direct;
    if (propertyIndex !== void 0) {
      if (propertyName === "morphTargetInfluences") {
        if (!targetObject.geometry) {
          error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
          return;
        }
        if (!targetObject.geometry.morphAttributes) {
          error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
          return;
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
        }
      }
      bindingType = this.BindingType.ArrayElement;
      this.resolvedProperty = nodeProperty;
      this.propertyIndex = propertyIndex;
    } else if (nodeProperty.fromArray !== void 0 && nodeProperty.toArray !== void 0) {
      bindingType = this.BindingType.HasFromToArray;
      this.resolvedProperty = nodeProperty;
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray;
      this.resolvedProperty = nodeProperty;
    } else {
      this.propertyName = propertyName;
    }
    this.getValue = this.GetterByBindingType[bindingType];
    this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
  }
  /**
   * Unbinds the property.
   */
  unbind() {
    this.node = null;
    this.getValue = this._getValue_unbound;
    this.setValue = this._setValue_unbound;
  }
};
PropertyBinding.Composite = Composite;
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3
};
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2
};
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray
];
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    // Direct
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate
  ],
  [
    // EntireArray
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate
  ],
  [
    // ArrayElement
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate
  ],
  [
    // HasToFromArray
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate
  ]
];
var _controlInterpolantsResultBuffer = new Float32Array(1);
var GLBufferAttribute = class {
  /**
   * Constructs a new GL buffer attribute.
   *
   * @param {WebGLBuffer} buffer - The native WebGL buffer.
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} itemSize - The item size.
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @param {number} count - The expected number of vertices in VBO.
   * @param {boolean} [normalized=false] - Whether the data are normalized or not.
   */
  constructor(buffer, type, itemSize, elementSize, count, normalized = false) {
    this.isGLBufferAttribute = true;
    this.name = "";
    this.buffer = buffer;
    this.type = type;
    this.itemSize = itemSize;
    this.elementSize = elementSize;
    this.count = count;
    this.normalized = normalized;
    this.version = 0;
  }
  /**
   * Flag to indicate that this attribute has changed and should be re-sent to
   * the GPU. Set this to `true` when you modify the value of the array.
   *
   * @type {number}
   * @default false
   * @param {boolean} value
   */
  set needsUpdate(value) {
    if (value === true) this.version++;
  }
  /**
   * Sets the given native WebGL buffer.
   *
   * @param {WebGLBuffer} buffer - The buffer to set.
   * @return {BufferAttribute} A reference to this instance.
   */
  setBuffer(buffer) {
    this.buffer = buffer;
    return this;
  }
  /**
   * Sets the given native data type and element size.
   *
   * @param {number} type - The native data type (e.g. `gl.FLOAT`).
   * @param {number} elementSize - The corresponding size (in bytes) for the given `type` parameter.
   * @return {BufferAttribute} A reference to this instance.
   */
  setType(type, elementSize) {
    this.type = type;
    this.elementSize = elementSize;
    return this;
  }
  /**
   * Sets the item size.
   *
   * @param {number} itemSize - The item size.
   * @return {BufferAttribute} A reference to this instance.
   */
  setItemSize(itemSize) {
    this.itemSize = itemSize;
    return this;
  }
  /**
   * Sets the count (the expected number of vertices in VBO).
   *
   * @param {number} count - The count.
   * @return {BufferAttribute} A reference to this instance.
   */
  setCount(count) {
    this.count = count;
    return this;
  }
};
var AxesHelper = class extends LineSegments {
  /**
   * Constructs a new axes helper.
   *
   * @param {number} [size=1] - Size of the lines representing the axes.
   */
  constructor(size = 1) {
    const vertices = [
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size,
      0,
      0,
      0,
      0,
      0,
      0,
      size
    ];
    const colors = [
      1,
      0,
      0,
      1,
      0.6,
      0,
      0,
      1,
      0,
      0.6,
      1,
      0,
      0,
      0,
      1,
      0,
      0.6,
      1
    ];
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", new Float32BufferAttribute(vertices, 3));
    geometry.setAttribute("color", new Float32BufferAttribute(colors, 3));
    const material = new LineBasicMaterial({ vertexColors: true, toneMapped: false });
    super(geometry, material);
    this.type = "AxesHelper";
  }
  /**
   * Defines the colors of the axes helper.
   *
   * @param {number|Color|string} xAxisColor - The color for the x axis.
   * @param {number|Color|string} yAxisColor - The color for the y axis.
   * @param {number|Color|string} zAxisColor - The color for the z axis.
   * @return {AxesHelper} A reference to this axes helper.
   */
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color();
    const array = this.geometry.attributes.color.array;
    color.set(xAxisColor);
    color.toArray(array, 0);
    color.toArray(array, 3);
    color.set(yAxisColor);
    color.toArray(array, 6);
    color.toArray(array, 9);
    color.set(zAxisColor);
    color.toArray(array, 12);
    color.toArray(array, 15);
    this.geometry.attributes.color.needsUpdate = true;
    return this;
  }
  /**
   * Frees the GPU-related resources allocated by this instance. Call this
   * method whenever this instance is no longer used in your app.
   */
  dispose() {
    this.geometry.dispose();
    this.material.dispose();
  }
};
function getByteLength(width, height, format, type) {
  const typeByteLength = getTextureTypeByteLength(type);
  switch (format) {
    // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
    case AlphaFormat:
      return width * height;
    case RedFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RedIntegerFormat:
      return width * height / typeByteLength.components * typeByteLength.byteLength;
    case RGFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGIntegerFormat:
      return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
    case RGBFormat:
      return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    case RGBAIntegerFormat:
      return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
    case RGB_S3TC_DXT1_Format:
    case RGBA_S3TC_DXT1_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_S3TC_DXT3_Format:
    case RGBA_S3TC_DXT5_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
    case RGB_PVRTC_2BPPV1_Format:
    case RGBA_PVRTC_2BPPV1_Format:
      return Math.max(width, 16) * Math.max(height, 8) / 4;
    case RGB_PVRTC_4BPPV1_Format:
    case RGBA_PVRTC_4BPPV1_Format:
      return Math.max(width, 8) * Math.max(height, 8) / 2;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
    case RGB_ETC1_Format:
    case RGB_ETC2_Format:
    case R11_EAC_Format:
    case SIGNED_R11_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
    case RGBA_ETC2_EAC_Format:
    case RG11_EAC_Format:
    case SIGNED_RG11_EAC_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
    case RGBA_ASTC_4x4_Format:
      return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x4_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
    case RGBA_ASTC_5x5_Format:
      return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x5_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_6x6_Format:
      return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x5_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_8x6_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_8x8_Format:
      return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x5_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
    case RGBA_ASTC_10x6_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
    case RGBA_ASTC_10x8_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
    case RGBA_ASTC_10x10_Format:
      return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x10_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
    case RGBA_ASTC_12x12_Format:
      return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
    case RGBA_BPTC_Format:
    case RGB_BPTC_SIGNED_Format:
    case RGB_BPTC_UNSIGNED_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
    case RED_RGTC1_Format:
    case SIGNED_RED_RGTC1_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
    case RED_GREEN_RGTC2_Format:
    case SIGNED_RED_GREEN_RGTC2_Format:
      return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
  }
  throw new Error(
    `Unable to determine texture byte length for ${format} format.`
  );
}
function getTextureTypeByteLength(type) {
  switch (type) {
    case UnsignedByteType:
    case ByteType:
      return { byteLength: 1, components: 1 };
    case UnsignedShortType:
    case ShortType:
    case HalfFloatType:
      return { byteLength: 2, components: 1 };
    case UnsignedShort4444Type:
    case UnsignedShort5551Type:
      return { byteLength: 2, components: 4 };
    case UnsignedIntType:
    case IntType:
    case FloatType:
      return { byteLength: 4, components: 1 };
    case UnsignedInt5999Type:
    case UnsignedInt101111Type:
      return { byteLength: 4, components: 3 };
  }
  throw new Error(`Unknown texture type ${type}.`);
}
if (typeof __THREE_DEVTOOLS__ !== "undefined") {
  __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", { detail: {
    revision: REVISION
  } }));
}
if (typeof window !== "undefined") {
  if (window.__THREE__) {
    warn("WARNING: Multiple instances of Three.js being imported.");
  } else {
    window.__THREE__ = REVISION;
  }
}

// node_modules/three/build/three.module.js
function WebGLAnimation() {
  let context = null;
  let isAnimating = false;
  let animationLoop = null;
  let requestId = null;
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame);
    requestId = context.requestAnimationFrame(onAnimationFrame);
  }
  return {
    start: function() {
      if (isAnimating === true) return;
      if (animationLoop === null) return;
      requestId = context.requestAnimationFrame(onAnimationFrame);
      isAnimating = true;
    },
    stop: function() {
      context.cancelAnimationFrame(requestId);
      isAnimating = false;
    },
    setAnimationLoop: function(callback) {
      animationLoop = callback;
    },
    setContext: function(value) {
      context = value;
    }
  };
}
function WebGLAttributes(gl) {
  const buffers = /* @__PURE__ */ new WeakMap();
  function createBuffer(attribute, bufferType) {
    const array = attribute.array;
    const usage = attribute.usage;
    const size = array.byteLength;
    const buffer = gl.createBuffer();
    gl.bindBuffer(bufferType, buffer);
    gl.bufferData(bufferType, array, usage);
    attribute.onUploadCallback();
    let type;
    if (array instanceof Float32Array) {
      type = gl.FLOAT;
    } else if (typeof Float16Array !== "undefined" && array instanceof Float16Array) {
      type = gl.HALF_FLOAT;
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        type = gl.HALF_FLOAT;
      } else {
        type = gl.UNSIGNED_SHORT;
      }
    } else if (array instanceof Int16Array) {
      type = gl.SHORT;
    } else if (array instanceof Uint32Array) {
      type = gl.UNSIGNED_INT;
    } else if (array instanceof Int32Array) {
      type = gl.INT;
    } else if (array instanceof Int8Array) {
      type = gl.BYTE;
    } else if (array instanceof Uint8Array) {
      type = gl.UNSIGNED_BYTE;
    } else if (array instanceof Uint8ClampedArray) {
      type = gl.UNSIGNED_BYTE;
    } else {
      throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + array);
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
      size
    };
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array;
    const updateRanges = attribute.updateRanges;
    gl.bindBuffer(bufferType, buffer);
    if (updateRanges.length === 0) {
      gl.bufferSubData(bufferType, 0, array);
    } else {
      updateRanges.sort((a2, b2) => a2.start - b2.start);
      let mergeIndex = 0;
      for (let i2 = 1; i2 < updateRanges.length; i2++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i2];
        if (range.start <= previousRange.start + previousRange.count + 1) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range = updateRanges[i2];
        gl.bufferSubData(
          bufferType,
          range.start * array.BYTES_PER_ELEMENT,
          array,
          range.start,
          range.count
        );
      }
      attribute.clearUpdateRanges();
    }
    attribute.onUploadCallback();
  }
  function get(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    return buffers.get(attribute);
  }
  function remove(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    const data2 = buffers.get(attribute);
    if (data2) {
      gl.deleteBuffer(data2.buffer);
      buffers.delete(attribute);
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute);
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version
        });
      }
      return;
    }
    const data2 = buffers.get(attribute);
    if (data2 === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType));
    } else if (data2.version < attribute.version) {
      if (data2.size !== attribute.array.byteLength) {
        throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
      }
      updateBuffer(data2.buffer, attribute, bufferType);
      data2.version = attribute.version;
    }
  }
  return {
    get,
    remove,
    update
  };
}
var alphahash_fragment = "#ifdef USE_ALPHAHASH\n	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif";
var alphahash_pars_fragment = "#ifdef USE_ALPHAHASH\n	const float ALPHA_HASH_SCALE = 0.05;\n	float hash2D( vec2 value ) {\n		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n	}\n	float hash3D( vec3 value ) {\n		return hash2D( vec2( hash2D( value.xy ), value.z ) );\n	}\n	float getAlphaHashThreshold( vec3 position ) {\n		float maxDeriv = max(\n			length( dFdx( position.xyz ) ),\n			length( dFdy( position.xyz ) )\n		);\n		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n		vec2 pixScales = vec2(\n			exp2( floor( log2( pixScale ) ) ),\n			exp2( ceil( log2( pixScale ) ) )\n		);\n		vec2 alpha = vec2(\n			hash3D( floor( pixScales.x * position.xyz ) ),\n			hash3D( floor( pixScales.y * position.xyz ) )\n		);\n		float lerpFactor = fract( log2( pixScale ) );\n		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n		float a = min( lerpFactor, 1.0 - lerpFactor );\n		vec3 cases = vec3(\n			x * x / ( 2.0 * a * ( 1.0 - a ) ),\n			( x - 0.5 * a ) / ( 1.0 - a ),\n			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n		);\n		float threshold = ( x < ( 1.0 - a ) )\n			? ( ( x < a ) ? cases.x : cases.y )\n			: cases.z;\n		return clamp( threshold , 1.0e-6, 1.0 );\n	}\n#endif";
var alphamap_fragment = "#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif";
var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var alphatest_fragment = "#ifdef USE_ALPHATEST\n	#ifdef ALPHA_TO_COVERAGE\n	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );\n	if ( diffuseColor.a == 0.0 ) discard;\n	#else\n	if ( diffuseColor.a < alphaTest ) discard;\n	#endif\n#endif";
var alphatest_pars_fragment = "#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif";
var aomap_fragment = "#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_CLEARCOAT ) \n		clearcoatSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_SHEEN ) \n		sheenSpecularIndirect *= ambientOcclusion;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif";
var aomap_pars_fragment = "#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif";
var batching_pars_vertex = "#ifdef USE_BATCHING\n	#if ! defined( GL_ANGLE_multi_draw )\n	#define gl_DrawID _gl_DrawID\n	uniform int _gl_DrawID;\n	#endif\n	uniform highp sampler2D batchingTexture;\n	uniform highp usampler2D batchingIdTexture;\n	mat4 getBatchingMatrix( const in float i ) {\n		int size = textureSize( batchingTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n	float getIndirectIndex( const in int i ) {\n		int size = textureSize( batchingIdTexture, 0 ).x;\n		int x = i % size;\n		int y = i / size;\n		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );\n	}\n#endif\n#ifdef USE_BATCHING_COLOR\n	uniform sampler2D batchingColorTexture;\n	vec3 getBatchingColor( const in float i ) {\n		int size = textureSize( batchingColorTexture, 0 ).x;\n		int j = int( i );\n		int x = j % size;\n		int y = j / size;\n		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;\n	}\n#endif";
var batching_vertex = "#ifdef USE_BATCHING\n	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );\n#endif";
var begin_vertex = "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n	vPosition = vec3( position );\n#endif";
var beginnormal_vertex = "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif";
var bsdfs = "float G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n} // validated";
var iridescence_fragment = "#ifdef USE_IRIDESCENCE\n	const mat3 XYZ_TO_REC709 = mat3(\n		 3.2404542, -0.9692660,  0.0556434,\n		-1.5371385,  1.8760108, -0.2040259,\n		-0.4985314,  0.0415560,  1.0572252\n	);\n	vec3 Fresnel0ToIor( vec3 fresnel0 ) {\n		vec3 sqrtF0 = sqrt( fresnel0 );\n		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n	}\n	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n	}\n	float IorToFresnel0( float transmittedIor, float incidentIor ) {\n		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n	}\n	vec3 evalSensitivity( float OPD, vec3 shift ) {\n		float phase = 2.0 * PI * OPD * 1.0e-9;\n		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n		xyz /= 1.0685e-7;\n		vec3 rgb = XYZ_TO_REC709 * xyz;\n		return rgb;\n	}\n	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n		vec3 I;\n		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n		float cosTheta2Sq = 1.0 - sinTheta2Sq;\n		if ( cosTheta2Sq < 0.0 ) {\n			return vec3( 1.0 );\n		}\n		float cosTheta2 = sqrt( cosTheta2Sq );\n		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n		float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n		float T121 = 1.0 - R12;\n		float phi12 = 0.0;\n		if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n		float phi21 = PI - phi12;\n		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n		vec3 phi23 = vec3( 0.0 );\n		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n		vec3 phi = vec3( phi21 ) + phi23;\n		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n		vec3 r123 = sqrt( R123 );\n		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n		vec3 C0 = R12 + Rs;\n		I = C0;\n		vec3 Cm = Rs - T121;\n		for ( int m = 1; m <= 2; ++ m ) {\n			Cm *= r123;\n			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n			I += Cm * Sm;\n		}\n		return max( I, vec3( 0.0 ) );\n	}\n#endif";
var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vBumpMapUv );\n		vec2 dSTdy = dFdy( vBumpMapUv );\n		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );\n		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif";
var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#ifdef ALPHA_TO_COVERAGE\n		float distanceToPlane, distanceGradient;\n		float clipOpacity = 1.0;\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n			distanceGradient = fwidth( distanceToPlane ) / 2.0;\n			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			if ( clipOpacity == 0.0 ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			float unionClipOpacity = 1.0;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;\n				distanceGradient = fwidth( distanceToPlane ) / 2.0;\n				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );\n			}\n			#pragma unroll_loop_end\n			clipOpacity *= 1.0 - unionClipOpacity;\n		#endif\n		diffuseColor.a *= clipOpacity;\n		if ( diffuseColor.a == 0.0 ) discard;\n	#else\n		#pragma unroll_loop_start\n		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n		}\n		#pragma unroll_loop_end\n		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n			bool clipped = true;\n			#pragma unroll_loop_start\n			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n				plane = clippingPlanes[ i ];\n				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n			}\n			#pragma unroll_loop_end\n			if ( clipped ) discard;\n		#endif\n	#endif\n#endif";
var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif";
var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif";
var color_fragment = "#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif";
var color_pars_fragment = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif";
var color_pars_vertex = "#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	varying vec3 vColor;\n#endif";
var color_vertex = "#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif\n#ifdef USE_BATCHING_COLOR\n	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );\n	vColor.xyz *= batchingColor.xyz;\n#endif";
var common = "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\n#ifdef USE_ALPHAHASH\n	varying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated";
var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define cubeUV_r0 1.0\n	#define cubeUV_m0 - 2.0\n	#define cubeUV_r1 0.8\n	#define cubeUV_m1 - 1.0\n	#define cubeUV_r4 0.4\n	#define cubeUV_m4 2.0\n	#define cubeUV_r5 0.305\n	#define cubeUV_m5 3.0\n	#define cubeUV_r6 0.21\n	#define cubeUV_m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= cubeUV_r1 ) {\n			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n		} else if ( roughness >= cubeUV_r4 ) {\n			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n		} else if ( roughness >= cubeUV_r5 ) {\n			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n		} else if ( roughness >= cubeUV_r6 ) {\n			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif";
var defaultnormal_vertex = "vec3 transformedNormal = objectNormal;\n#ifdef USE_TANGENT\n	vec3 transformedTangent = objectTangent;\n#endif\n#ifdef USE_BATCHING\n	mat3 bm = mat3( batchingMatrix );\n	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );\n	transformedNormal = bm * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = bm * transformedTangent;\n	#endif\n#endif\n#ifdef USE_INSTANCING\n	mat3 im = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );\n	transformedNormal = im * transformedNormal;\n	#ifdef USE_TANGENT\n		transformedTangent = im * transformedTangent;\n	#endif\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif";
var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif";
var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif";
var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE\n		emissiveColor = sRGBTransferEOTF( emissiveColor );\n	#endif\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif";
var colorspace_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
var colorspace_pars_fragment = "vec4 LinearTransferOETF( in vec4 value ) {\n	return value;\n}\nvec4 sRGBTransferEOTF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 sRGBTransferOETF( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}";
var envmap_fragment = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif";
var envmap_common_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	uniform mat3 envMapRotation;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n#endif";
var envmap_pars_fragment = "#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif";
var envmap_pars_vertex = "#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif";
var envmap_vertex = "#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif";
var fog_vertex = "#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif";
var fog_pars_vertex = "#ifdef USE_FOG\n	varying float vFogDepth;\n#endif";
var fog_fragment = "#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
var fog_pars_fragment = "#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif";
var gradientmap_pars_fragment = "#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		vec2 fw = fwidth( coord ) * 0.5;\n		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n	#endif\n}";
var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif";
var lights_lambert_fragment = "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;";
var lights_lambert_pars_fragment = "varying vec3 vViewPosition;\nstruct LambertMaterial {\n	vec3 diffuseColor;\n	float specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Lambert\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert";
var lights_pars_begin = "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\n#if defined( USE_LIGHT_PROBES )\n	uniform vec3 lightProbe[ 9 ];\n#endif\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n	if ( cutoffDistance > 0.0 ) {\n		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n	}\n	return distanceFalloff;\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometryPosition;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif";
var envmap_physical_pars_fragment = "#ifdef USE_ENVMAP\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#ifdef ENVMAP_TYPE_CUBE_UV\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, pow4( roughness ) ) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	#ifdef USE_ANISOTROPY\n		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n			#ifdef ENVMAP_TYPE_CUBE_UV\n				vec3 bentNormal = cross( bitangent, viewDir );\n				bentNormal = normalize( cross( bentNormal, bitangent ) );\n				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n				return getIBLRadiance( viewDir, bentNormal, roughness );\n			#else\n				return vec3( 0.0 );\n			#endif\n		}\n	#endif\n#endif";
var lights_toon_fragment = "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;";
var lights_toon_pars_fragment = "varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon";
var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
var lights_phong_pars_fragment = "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong";
var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.diffuseContribution = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.metalness = metalnessFactor;\nvec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	material.ior = ior;\n	#ifdef USE_SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULAR_COLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n		#endif\n		#ifdef USE_SPECULAR_INTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor;\n	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = vec3( 0.04 );\n	material.specularColorBlended = mix( material.specularColor, diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_DISPERSION\n	material.dispersion = dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEEN_COLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.0001, 1.0 );\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	#ifdef USE_ANISOTROPYMAP\n		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n	#else\n		vec2 anisotropyV = anisotropyVector;\n	#endif\n	material.anisotropy = length( anisotropyV );\n	if( material.anisotropy == 0.0 ) {\n		anisotropyV = vec2( 1.0, 0.0 );\n	} else {\n		anisotropyV /= material.anisotropy;\n		material.anisotropy = saturate( material.anisotropy );\n	}\n	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;\n	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;\n#endif";
var lights_physical_pars_fragment = "uniform sampler2D dfgLUT;\nstruct PhysicalMaterial {\n	vec3 diffuseColor;\n	vec3 diffuseContribution;\n	vec3 specularColor;\n	vec3 specularColorBlended;\n	float roughness;\n	float metalness;\n	float specularF90;\n	float dispersion;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n		vec3 iridescenceFresnelDielectric;\n		vec3 iridescenceFresnelMetallic;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n	#ifdef IOR\n		float ior;\n	#endif\n	#ifdef USE_TRANSMISSION\n		float transmission;\n		float transmissionAlpha;\n		float thickness;\n		float attenuationDistance;\n		vec3 attenuationColor;\n	#endif\n	#ifdef USE_ANISOTROPY\n		float anisotropy;\n		float alphaT;\n		vec3 anisotropyT;\n		vec3 anisotropyB;\n	#endif\n};\nvec3 clearcoatSpecularDirect = vec3( 0.0 );\nvec3 clearcoatSpecularIndirect = vec3( 0.0 );\nvec3 sheenSpecularDirect = vec3( 0.0 );\nvec3 sheenSpecularIndirect = vec3(0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n		float v = 0.5 / ( gv + gl );\n		return v;\n	}\n	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n		float a2 = alphaT * alphaB;\n		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n		highp float v2 = dot( v, v );\n		float w2 = a2 / v2;\n		return RECIPROCAL_PI * a2 * pow2 ( w2 );\n	}\n#endif\n#ifdef USE_CLEARCOAT\n	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n		vec3 f0 = material.clearcoatF0;\n		float f90 = material.clearcoatF90;\n		float roughness = material.clearcoatRoughness;\n		float alpha = pow2( roughness );\n		vec3 halfDir = normalize( lightDir + viewDir );\n		float dotNL = saturate( dot( normal, lightDir ) );\n		float dotNV = saturate( dot( normal, viewDir ) );\n		float dotNH = saturate( dot( normal, halfDir ) );\n		float dotVH = saturate( dot( viewDir, halfDir ) );\n		vec3 F = F_Schlick( f0, f90, dotVH );\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n		return F * ( V * D );\n	}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 f0 = material.specularColorBlended;\n	float f90 = material.specularF90;\n	float roughness = material.roughness;\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	#ifdef USE_IRIDESCENCE\n		F = mix( F, material.iridescenceFresnel, material.iridescence );\n	#endif\n	#ifdef USE_ANISOTROPY\n		float dotTL = dot( material.anisotropyT, lightDir );\n		float dotTV = dot( material.anisotropyT, viewDir );\n		float dotTH = dot( material.anisotropyT, halfDir );\n		float dotBL = dot( material.anisotropyB, lightDir );\n		float dotBV = dot( material.anisotropyB, viewDir );\n		float dotBH = dot( material.anisotropyB, halfDir );\n		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n	#else\n		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n		float D = D_GGX( alpha, dotNH );\n	#endif\n	return F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transpose( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float rInv = 1.0 / ( roughness + 0.1 );\n	float a = -1.9362 + 1.0678 * roughness + 0.4573 * r2 - 0.8469 * rInv;\n	float b = -0.6014 + 0.5538 * roughness - 0.4670 * r2 - 0.1255 * rInv;\n	float DG = exp( a * dotNV + b );\n	return saturate( DG );\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 fab = texture2D( dfgLUT, vec2( roughness, dotNV ) ).rg;\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\nvec3 BRDF_GGX_Multiscatter( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n	vec3 singleScatter = BRDF_GGX( lightDir, viewDir, normal, material );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	vec2 dfgV = texture2D( dfgLUT, vec2( material.roughness, dotNV ) ).rg;\n	vec2 dfgL = texture2D( dfgLUT, vec2( material.roughness, dotNL ) ).rg;\n	vec3 FssEss_V = material.specularColorBlended * dfgV.x + material.specularF90 * dfgV.y;\n	vec3 FssEss_L = material.specularColorBlended * dfgL.x + material.specularF90 * dfgL.y;\n	float Ess_V = dfgV.x + dfgV.y;\n	float Ess_L = dfgL.x + dfgL.y;\n	float Ems_V = 1.0 - Ess_V;\n	float Ems_L = 1.0 - Ess_L;\n	vec3 Favg = material.specularColorBlended + ( 1.0 - material.specularColorBlended ) * 0.047619;\n	vec3 Fms = FssEss_V * FssEss_L * Favg / ( 1.0 - Ems_V * Ems_L * Favg + EPSILON );\n	float compensationFactor = Ems_V * Ems_L;\n	vec3 multiScatter = Fms * compensationFactor;\n	return singleScatter + multiScatter;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometryNormal;\n		vec3 viewDir = geometryViewDir;\n		vec3 position = geometryPosition;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColorBlended * t2.x + ( vec3( 1.0 ) - material.specularColorBlended ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseContribution * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );\n	#endif\n	#ifdef USE_SHEEN\n \n 		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );\n \n 		float sheenAlbedoV = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n 		float sheenAlbedoL = IBLSheenBRDF( geometryNormal, directLight.direction, material.sheenRoughness );\n \n 		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * max( sheenAlbedoV, sheenAlbedoL );\n \n 		irradiance *= sheenEnergyComp;\n \n 	#endif\n	reflectedLight.directSpecular += irradiance * BRDF_GGX_Multiscatter( directLight.direction, geometryViewDir, geometryNormal, material );\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseContribution );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 diffuse = irradiance * BRDF_Lambert( material.diffuseContribution );\n	#ifdef USE_SHEEN\n		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;\n		diffuse *= sheenEnergyComp;\n	#endif\n	reflectedLight.indirectDiffuse += diffuse;\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness ) * RECIPROCAL_PI;\n 	#endif\n	vec3 singleScatteringDielectric = vec3( 0.0 );\n	vec3 multiScatteringDielectric = vec3( 0.0 );\n	vec3 singleScatteringMetallic = vec3( 0.0 );\n	vec3 multiScatteringMetallic = vec3( 0.0 );\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnelDielectric, material.roughness, singleScatteringDielectric, multiScatteringDielectric );\n		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.iridescence, material.iridescenceFresnelMetallic, material.roughness, singleScatteringMetallic, multiScatteringMetallic );\n	#else\n		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScatteringDielectric, multiScatteringDielectric );\n		computeMultiscattering( geometryNormal, geometryViewDir, material.diffuseColor, material.specularF90, material.roughness, singleScatteringMetallic, multiScatteringMetallic );\n	#endif\n	vec3 singleScattering = mix( singleScatteringDielectric, singleScatteringMetallic, material.metalness );\n	vec3 multiScattering = mix( multiScatteringDielectric, multiScatteringMetallic, material.metalness );\n	vec3 totalScatteringDielectric = singleScatteringDielectric + multiScatteringDielectric;\n	vec3 diffuse = material.diffuseContribution * ( 1.0 - totalScatteringDielectric );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	vec3 indirectSpecular = radiance * singleScattering;\n	indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	vec3 indirectDiffuse = diffuse * cosineWeightedIrradiance;\n	#ifdef USE_SHEEN\n		float sheenAlbedo = IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );\n		float sheenEnergyComp = 1.0 - max3( material.sheenColor ) * sheenAlbedo;\n		indirectSpecular *= sheenEnergyComp;\n		indirectDiffuse *= sheenEnergyComp;\n	#endif\n	reflectedLight.indirectSpecular += indirectSpecular;\n	reflectedLight.indirectDiffuse += indirectDiffuse;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
var lights_fragment_begin = "\nvec3 geometryPosition = - vViewPosition;\nvec3 geometryNormal = normal;\nvec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\nvec3 geometryClearcoatNormal = vec3( 0.0 );\n#ifdef USE_CLEARCOAT\n	geometryClearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n	float dotNVi = saturate( dot( normal, geometryViewDir ) );\n	if ( material.iridescenceThickness == 0.0 ) {\n		material.iridescence = 0.0;\n	} else {\n		material.iridescence = saturate( material.iridescence );\n	}\n	if ( material.iridescence > 0.0 ) {\n		material.iridescenceFresnelDielectric = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n		material.iridescenceFresnelMetallic = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.diffuseColor );\n		material.iridescenceFresnel = mix( material.iridescenceFresnelDielectric, material.iridescenceFresnelMetallic, material.metalness );\n		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n	}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometryPosition, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS ) && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	vec4 spotColor;\n	vec3 spotLightCoord;\n	bool inSpotLightMap;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometryPosition, directLight );\n		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n		#else\n		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n		#endif\n		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n		#endif\n		#undef SPOT_LIGHT_MAP_INDEX\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	#if defined( USE_LIGHT_PROBES )\n		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n	#endif\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif";
var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometryNormal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	#ifdef USE_ANISOTROPY\n		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );\n	#else\n		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );\n	#endif\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif";
var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );\n#endif";
var logdepthbuf_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
var logdepthbuf_pars_fragment = "#if defined( USE_LOGARITHMIC_DEPTH_BUFFER )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_pars_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif";
var logdepthbuf_vertex = "#ifdef USE_LOGARITHMIC_DEPTH_BUFFER\n	vFragDepth = 1.0 + gl_Position.w;\n	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n#endif";
var map_fragment = "#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vMapUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif";
var map_pars_fragment = "#ifdef USE_MAP\n	uniform sampler2D map;\n#endif";
var map_particle_fragment = "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	#if defined( USE_POINTS_UV )\n		vec2 uv = vUv;\n	#else\n		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n	#endif\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif";
var map_particle_pars_fragment = "#if defined( USE_POINTS_UV )\n	varying vec2 vUv;\n#else\n	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n		uniform mat3 uvTransform;\n	#endif\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif";
var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n	metalnessFactor *= texelMetalness.b;\n#endif";
var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif";
var morphinstance_vertex = "#ifdef USE_INSTANCING_MORPH\n	float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;\n	}\n#endif";
var morphcolor_vertex = "#if defined( USE_MORPHCOLORS )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif";
var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n	#ifndef USE_INSTANCING_MORPH\n		uniform float morphTargetBaseInfluence;\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n	#endif\n	uniform sampler2DArray morphTargetsTexture;\n	uniform ivec2 morphTargetsTextureSize;\n	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n		int y = texelIndex / morphTargetsTextureSize.x;\n		int x = texelIndex - y * morphTargetsTextureSize.x;\n		ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n		return texelFetch( morphTargetsTexture, morphUV, 0 );\n	}\n#endif";
var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n	}\n#endif";
var normal_fragment_begin = "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = dFdx( vViewPosition );\n	vec3 fdy = dFdy( vViewPosition );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal *= faceDirection;\n	#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n	#ifdef USE_TANGENT\n		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn = getTangentFrame( - vViewPosition, normal,\n		#if defined( USE_NORMALMAP )\n			vNormalMapUv\n		#elif defined( USE_CLEARCOAT_NORMALMAP )\n			vClearcoatNormalMapUv\n		#else\n			vUv\n		#endif\n		);\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn[0] *= faceDirection;\n		tbn[1] *= faceDirection;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	#ifdef USE_TANGENT\n		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n	#else\n		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n	#endif\n	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n		tbn2[0] *= faceDirection;\n		tbn2[1] *= faceDirection;\n	#endif\n#endif\nvec3 nonPerturbedNormal = normal;";
var normal_fragment_maps = "#ifdef USE_NORMALMAP_OBJECTSPACE\n	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	normal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif";
var normal_pars_fragment = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_pars_vertex = "#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif";
var normal_vertex = "#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif";
var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n		vec3 q0 = dFdx( eye_pos.xyz );\n		vec3 q1 = dFdy( eye_pos.xyz );\n		vec2 st0 = dFdx( uv.st );\n		vec2 st1 = dFdy( uv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n		return mat3( T * scale, B * scale, N );\n	}\n#endif";
var clearcoat_normal_fragment_begin = "#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = nonPerturbedNormal;\n#endif";
var clearcoat_normal_fragment_maps = "#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	clearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif";
var clearcoat_pars_fragment = "#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif";
var iridescence_pars_fragment = "#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif";
var opaque_fragment = "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );";
var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;\nconst float Inv255 = 1. / 255.;\nconst vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );\nconst vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );\nconst vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );\nconst vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );\nvec4 packDepthToRGBA( const in float v ) {\n	if( v <= 0.0 )\n		return vec4( 0., 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec4( 1., 1., 1., 1. );\n	float vuf;\n	float af = modf( v * PackFactors.a, vuf );\n	float bf = modf( vuf * ShiftRight8, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );\n}\nvec3 packDepthToRGB( const in float v ) {\n	if( v <= 0.0 )\n		return vec3( 0., 0., 0. );\n	if( v >= 1.0 )\n		return vec3( 1., 1., 1. );\n	float vuf;\n	float bf = modf( v * PackFactors.b, vuf );\n	float gf = modf( vuf * ShiftRight8, vuf );\n	return vec3( vuf * Inv255, gf * PackUpscale, bf );\n}\nvec2 packDepthToRG( const in float v ) {\n	if( v <= 0.0 )\n		return vec2( 0., 0. );\n	if( v >= 1.0 )\n		return vec2( 1., 1. );\n	float vuf;\n	float gf = modf( v * 256., vuf );\n	return vec2( vuf * Inv255, gf );\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors4 );\n}\nfloat unpackRGBToDepth( const in vec3 v ) {\n	return dot( v, UnpackFactors3 );\n}\nfloat unpackRGToDepth( const in vec2 v ) {\n	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;\n}\nvec4 pack2HalfToRGBA( const in vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( const in vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * depth - far );\n}";
var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif";
var project_vertex = "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_BATCHING\n	mvPosition = batchingMatrix * mvPosition;\n#endif\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;";
var dithering_fragment = "#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
var dithering_pars_fragment = "#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif";
var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n	roughnessFactor *= texelRoughness.g;\n#endif";
var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif";
var shadowmap_pars_fragment = "#if NUM_SPOT_LIGHT_COORDS > 0\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#if defined( SHADOWMAP_TYPE_PCF )\n			uniform sampler2DShadow directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		#else\n			uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		#endif\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		#if defined( SHADOWMAP_TYPE_PCF )\n			uniform sampler2DShadow spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		#else\n			uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		#endif\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#if defined( SHADOWMAP_TYPE_PCF )\n			uniform samplerCubeShadow pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		#elif defined( SHADOWMAP_TYPE_BASIC )\n			uniform samplerCube pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		#endif\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	#if defined( SHADOWMAP_TYPE_PCF )\n		float interleavedGradientNoise( vec2 position ) {\n			return fract( 52.9829189 * fract( dot( position, vec2( 0.06711056, 0.00583715 ) ) ) );\n		}\n		vec2 vogelDiskSample( int sampleIndex, int samplesCount, float phi ) {\n			const float goldenAngle = 2.399963229728653;\n			float r = sqrt( ( float( sampleIndex ) + 0.5 ) / float( samplesCount ) );\n			float theta = float( sampleIndex ) * goldenAngle + phi;\n			return vec2( cos( theta ), sin( theta ) ) * r;\n		}\n	#endif\n	#if defined( SHADOWMAP_TYPE_PCF )\n		float getShadow( sampler2DShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n			float shadow = 1.0;\n			shadowCoord.xyz /= shadowCoord.w;\n			shadowCoord.z += shadowBias;\n			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n			if ( frustumTest ) {\n				vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n				float radius = shadowRadius * texelSize.x;\n				float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;\n				shadow = (\n					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 0, 5, phi ) * radius, shadowCoord.z ) ) +\n					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 1, 5, phi ) * radius, shadowCoord.z ) ) +\n					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 2, 5, phi ) * radius, shadowCoord.z ) ) +\n					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 3, 5, phi ) * radius, shadowCoord.z ) ) +\n					texture( shadowMap, vec3( shadowCoord.xy + vogelDiskSample( 4, 5, phi ) * radius, shadowCoord.z ) )\n				) * 0.2;\n			}\n			return mix( 1.0, shadow, shadowIntensity );\n		}\n	#elif defined( SHADOWMAP_TYPE_VSM )\n		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n			float shadow = 1.0;\n			shadowCoord.xyz /= shadowCoord.w;\n			shadowCoord.z += shadowBias;\n			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n			if ( frustumTest ) {\n				vec2 distribution = texture2D( shadowMap, shadowCoord.xy ).rg;\n				float mean = distribution.x;\n				float variance = distribution.y * distribution.y;\n				#ifdef USE_REVERSED_DEPTH_BUFFER\n					float hard_shadow = step( mean, shadowCoord.z );\n				#else\n					float hard_shadow = step( shadowCoord.z, mean );\n				#endif\n				if ( hard_shadow == 1.0 ) {\n					shadow = 1.0;\n				} else {\n					variance = max( variance, 0.0000001 );\n					float d = shadowCoord.z - mean;\n					float p_max = variance / ( variance + d * d );\n					p_max = clamp( ( p_max - 0.3 ) / 0.65, 0.0, 1.0 );\n					shadow = max( hard_shadow, p_max );\n				}\n			}\n			return mix( 1.0, shadow, shadowIntensity );\n		}\n	#else\n		float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n			float shadow = 1.0;\n			shadowCoord.xyz /= shadowCoord.w;\n			shadowCoord.z += shadowBias;\n			bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n			bool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n			if ( frustumTest ) {\n				float depth = texture2D( shadowMap, shadowCoord.xy ).r;\n				#ifdef USE_REVERSED_DEPTH_BUFFER\n					shadow = step( depth, shadowCoord.z );\n				#else\n					shadow = step( shadowCoord.z, depth );\n				#endif\n			}\n			return mix( 1.0, shadow, shadowIntensity );\n		}\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#if defined( SHADOWMAP_TYPE_PCF )\n	float getPointShadow( samplerCubeShadow shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		vec3 absVec = abs( lightToPosition );\n		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );\n		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {\n			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );\n			dp += shadowBias;\n			float texelSize = shadowRadius / shadowMapSize.x;\n			vec3 absDir = abs( bd3D );\n			vec3 tangent = absDir.x > absDir.z ? vec3( 0.0, 1.0, 0.0 ) : vec3( 1.0, 0.0, 0.0 );\n			tangent = normalize( cross( bd3D, tangent ) );\n			vec3 bitangent = cross( bd3D, tangent );\n			float phi = interleavedGradientNoise( gl_FragCoord.xy ) * 6.28318530718;\n			shadow = (\n				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 0, 5, phi ).x + bitangent * vogelDiskSample( 0, 5, phi ).y ) * texelSize, dp ) ) +\n				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 1, 5, phi ).x + bitangent * vogelDiskSample( 1, 5, phi ).y ) * texelSize, dp ) ) +\n				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 2, 5, phi ).x + bitangent * vogelDiskSample( 2, 5, phi ).y ) * texelSize, dp ) ) +\n				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 3, 5, phi ).x + bitangent * vogelDiskSample( 3, 5, phi ).y ) * texelSize, dp ) ) +\n				texture( shadowMap, vec4( bd3D + ( tangent * vogelDiskSample( 4, 5, phi ).x + bitangent * vogelDiskSample( 4, 5, phi ).y ) * texelSize, dp ) )\n			) * 0.2;\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	#elif defined( SHADOWMAP_TYPE_BASIC )\n	float getPointShadow( samplerCube shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		float shadow = 1.0;\n		vec3 lightToPosition = shadowCoord.xyz;\n		vec3 bd3D = normalize( lightToPosition );\n		vec3 absVec = abs( lightToPosition );\n		float viewSpaceZ = max( max( absVec.x, absVec.y ), absVec.z );\n		if ( viewSpaceZ - shadowCameraFar <= 0.0 && viewSpaceZ - shadowCameraNear >= 0.0 ) {\n			float dp = ( shadowCameraFar * ( viewSpaceZ - shadowCameraNear ) ) / ( viewSpaceZ * ( shadowCameraFar - shadowCameraNear ) );\n			dp += shadowBias;\n			float depth = textureCube( shadowMap, bd3D ).r;\n			#ifdef USE_REVERSED_DEPTH_BUFFER\n				shadow = step( depth, dp );\n			#else\n				shadow = step( dp, depth );\n			#endif\n		}\n		return mix( 1.0, shadow, shadowIntensity );\n	}\n	#endif\n	#endif\n#endif";
var shadowmap_pars_vertex = "#if NUM_SPOT_LIGHT_COORDS > 0\n	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		struct SpotLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowIntensity;\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif";
var shadowmap_vertex = "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n	vec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n		shadowWorldPosition = worldPosition;\n		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n		#endif\n		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n#endif";
var shadowmask_pars_fragment = "float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0 && ( defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_BASIC ) )\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}";
var skinbase_vertex = "#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
var skinning_pars_vertex = "#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	mat4 getBoneMatrix( const in float i ) {\n		int size = textureSize( boneTexture, 0 ).x;\n		int j = int( i ) * 4;\n		int x = j % size;\n		int y = j / size;\n		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );\n		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );\n		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );\n		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );\n		return mat4( v1, v2, v3, v4 );\n	}\n#endif";
var skinning_vertex = "#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
var skinnormal_vertex = "#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif";
var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif";
var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif";
var tonemapping_fragment = "#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
var tonemapping_pars_fragment = "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 CineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nconst mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(\n	vec3( 1.6605, - 0.1246, - 0.0182 ),\n	vec3( - 0.5876, 1.1329, - 0.1006 ),\n	vec3( - 0.0728, - 0.0083, 1.1187 )\n);\nconst mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(\n	vec3( 0.6274, 0.0691, 0.0164 ),\n	vec3( 0.3293, 0.9195, 0.0880 ),\n	vec3( 0.0433, 0.0113, 0.8956 )\n);\nvec3 agxDefaultContrastApprox( vec3 x ) {\n	vec3 x2 = x * x;\n	vec3 x4 = x2 * x2;\n	return + 15.5 * x4 * x2\n		- 40.14 * x4 * x\n		+ 31.96 * x4\n		- 6.868 * x2 * x\n		+ 0.4298 * x2\n		+ 0.1191 * x\n		- 0.00232;\n}\nvec3 AgXToneMapping( vec3 color ) {\n	const mat3 AgXInsetMatrix = mat3(\n		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),\n		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),\n		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )\n	);\n	const mat3 AgXOutsetMatrix = mat3(\n		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),\n		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),\n		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )\n	);\n	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;\n	color *= toneMappingExposure;\n	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;\n	color = AgXInsetMatrix * color;\n	color = max( color, 1e-10 );	color = log2( color );\n	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );\n	color = clamp( color, 0.0, 1.0 );\n	color = agxDefaultContrastApprox( color );\n	color = AgXOutsetMatrix * color;\n	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );\n	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;\n	color = clamp( color, 0.0, 1.0 );\n	return color;\n}\nvec3 NeutralToneMapping( vec3 color ) {\n	const float StartCompression = 0.8 - 0.04;\n	const float Desaturation = 0.15;\n	color *= toneMappingExposure;\n	float x = min( color.r, min( color.g, color.b ) );\n	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;\n	color -= offset;\n	float peak = max( color.r, max( color.g, color.b ) );\n	if ( peak < StartCompression ) return color;\n	float d = 1. - StartCompression;\n	float newPeak = 1. - d * d / ( peak + d - StartCompression );\n	color *= newPeak / peak;\n	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );\n	return mix( color, vec3( newPeak ), g );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }";
var transmission_fragment = "#ifdef USE_TRANSMISSION\n	material.transmission = transmission;\n	material.transmissionAlpha = 1.0;\n	material.thickness = thickness;\n	material.attenuationDistance = attenuationDistance;\n	material.attenuationColor = attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmitted = getIBLVolumeRefraction(\n		n, v, material.roughness, material.diffuseContribution, material.specularColorBlended, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,\n		material.attenuationColor, material.attenuationDistance );\n	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif";
var transmission_pars_fragment = "#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	float w0( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n	}\n	float w1( float a ) {\n		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n	}\n	float w2( float a ){\n		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n	}\n	float w3( float a ) {\n		return ( 1.0 / 6.0 ) * ( a * a * a );\n	}\n	float g0( float a ) {\n		return w0( a ) + w1( a );\n	}\n	float g1( float a ) {\n		return w2( a ) + w3( a );\n	}\n	float h0( float a ) {\n		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n	}\n	float h1( float a ) {\n		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n	}\n	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n		uv = uv * texelSize.zw + 0.5;\n		vec2 iuv = floor( uv );\n		vec2 fuv = fract( uv );\n		float g0x = g0( fuv.x );\n		float g1x = g1( fuv.x );\n		float h0x = h0( fuv.x );\n		float h1x = h1( fuv.x );\n		float h0y = h0( fuv.y );\n		float h1y = h1( fuv.y );\n		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n	}\n	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n		vec2 fLodSizeInv = 1.0 / fLodSize;\n		vec2 cLodSizeInv = 1.0 / cLodSize;\n		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n		return mix( fSample, cSample, fract( lod ) );\n	}\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n	}\n	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( isinf( attenuationDistance ) ) {\n			return vec3( 1.0 );\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec4 transmittedLight;\n		vec3 transmittance;\n		#ifdef USE_DISPERSION\n			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;\n			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );\n			for ( int i = 0; i < 3; i ++ ) {\n				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );\n				vec3 refractedRayExit = position + transmissionRay;\n				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n				vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n				refractionCoords += 1.0;\n				refractionCoords /= 2.0;\n				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );\n				transmittedLight[ i ] = transmissionSample[ i ];\n				transmittedLight.a += transmissionSample.a;\n				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];\n			}\n			transmittedLight.a /= 3.0;\n		#else\n			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n			vec3 refractedRayExit = position + transmissionRay;\n			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n			vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n			refractionCoords += 1.0;\n			refractionCoords /= 2.0;\n			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n		#endif\n		vec3 attenuatedColor = transmittance * transmittedLight.rgb;\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n	}\n#endif";
var uv_pars_fragment = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_pars_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	varying vec2 vUv;\n#endif\n#ifdef USE_MAP\n	uniform mat3 mapTransform;\n	varying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform mat3 alphaMapTransform;\n	varying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n	uniform mat3 lightMapTransform;\n	varying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n	uniform mat3 aoMapTransform;\n	varying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n	uniform mat3 bumpMapTransform;\n	varying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n	uniform mat3 normalMapTransform;\n	varying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	uniform mat3 displacementMapTransform;\n	varying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n	uniform mat3 emissiveMapTransform;\n	varying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n	uniform mat3 metalnessMapTransform;\n	varying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	uniform mat3 roughnessMapTransform;\n	varying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	uniform mat3 anisotropyMapTransform;\n	varying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n	uniform mat3 clearcoatMapTransform;\n	varying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform mat3 clearcoatNormalMapTransform;\n	varying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform mat3 clearcoatRoughnessMapTransform;\n	varying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	uniform mat3 sheenColorMapTransform;\n	varying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	uniform mat3 sheenRoughnessMapTransform;\n	varying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	uniform mat3 iridescenceMapTransform;\n	varying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform mat3 iridescenceThicknessMapTransform;\n	varying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n	uniform mat3 specularMapTransform;\n	varying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	uniform mat3 specularColorMapTransform;\n	varying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	uniform mat3 specularIntensityMapTransform;\n	varying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	uniform mat3 transmissionMapTransform;\n	varying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n	uniform mat3 thicknessMapTransform;\n	varying vec2 vThicknessMapUv;\n#endif";
var uv_vertex = "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n	vUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif";
var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_BATCHING\n		worldPosition = batchingMatrix * worldPosition;\n	#endif\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif";
var vertex$h = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
var fragment$h = "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n	vec4 texColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$g = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$g = "#ifdef ENVMAP_TYPE_CUBE\n	uniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n	uniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nuniform mat3 backgroundRotation;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );\n	#else\n		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n	#endif\n	texColor.rgb *= backgroundIntensity;\n	gl_FragColor = texColor;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$f = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}";
var fragment$f = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n	gl_FragColor = texColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$e = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}";
var fragment$e = "#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <logdepthbuf_fragment>\n	#ifdef USE_REVERSED_DEPTH_BUFFER\n		float fragCoordZ = vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ];\n	#else\n		float fragCoordZ = 0.5 * vHighPrecisionZW[ 0 ] / vHighPrecisionZW[ 1 ] + 0.5;\n	#endif\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#elif DEPTH_PACKING == 3202\n		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );\n	#elif DEPTH_PACKING == 3203\n		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );\n	#endif\n}";
var vertex$d = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <skinbase_vertex>\n	#include <morphinstance_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}";
var fragment$d = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <clipping_planes_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = vec4( dist, 0.0, 0.0, 1.0 );\n}";
var vertex$c = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}";
var fragment$c = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n}";
var vertex$b = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$b = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$a = "#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$a = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$9 = "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$9 = "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_lambert_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$8 = "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}";
var fragment$8 = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$7 = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}";
var fragment$7 = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n	varying vec3 vViewPosition;\n#endif\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( normalize( normal ) * 0.5 + 0.5, diffuseColor.a );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}";
var vertex$6 = "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$6 = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$5 = "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}";
var fragment$5 = "#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef USE_SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULAR_COLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n	#ifdef USE_SPECULAR_INTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_DISPERSION\n	uniform float dispersion;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEEN_COLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEEN_ROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\n#ifdef USE_ANISOTROPY\n	uniform vec2 anisotropyVector;\n	#ifdef USE_ANISOTROPYMAP\n		uniform sampler2D anisotropyMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n \n		outgoingLight = outgoingLight + sheenSpecularDirect + sheenSpecularIndirect;\n \n 	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;\n	#endif\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$4 = "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <batching_pars_vertex>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$4 = "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}";
var vertex$3 = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n	varying vec2 vUv;\n	uniform mat3 uvTransform;\n#endif\nvoid main() {\n	#ifdef USE_POINTS_UV\n		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	#endif\n	#include <color_vertex>\n	#include <morphinstance_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}";
var fragment$3 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}";
var vertex$2 = "#include <common>\n#include <batching_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <batching_vertex>\n	#include <beginnormal_vertex>\n	#include <morphinstance_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}";
var fragment$2 = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	#include <logdepthbuf_fragment>\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var vertex$1 = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix[ 3 ];\n	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}";
var fragment$1 = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <alphahash_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <opaque_fragment>\n	#include <tonemapping_fragment>\n	#include <colorspace_fragment>\n	#include <fog_fragment>\n}";
var ShaderChunk = {
  alphahash_fragment,
  alphahash_pars_fragment,
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  batching_pars_vertex,
  batching_vertex,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  colorspace_fragment,
  colorspace_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_pars_fragment,
  lights_lambert_fragment,
  lights_lambert_pars_fragment,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphinstance_vertex,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  opaque_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  worldpos_vertex,
  background_vert: vertex$h,
  background_frag: fragment$h,
  backgroundCube_vert: vertex$g,
  backgroundCube_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distance_vert: vertex$d,
  distance_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex$9,
  meshlambert_frag: fragment$9,
  meshmatcap_vert: vertex$8,
  meshmatcap_frag: fragment$8,
  meshnormal_vert: vertex$7,
  meshnormal_frag: fragment$7,
  meshphong_vert: vertex$6,
  meshphong_frag: fragment$6,
  meshphysical_vert: vertex$5,
  meshphysical_frag: fragment$5,
  meshtoon_vert: vertex$4,
  meshtoon_frag: fragment$4,
  points_vert: vertex$3,
  points_frag: fragment$3,
  shadow_vert: vertex$2,
  shadow_frag: fragment$2,
  sprite_vert: vertex$1,
  sprite_frag: fragment$1
};
var UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  },
  specularmap: {
    specularMap: { value: null },
    specularMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  envmap: {
    envMap: { value: null },
    envMapRotation: { value: /* @__PURE__ */ new Matrix3() },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    // basic, lambert, phong
    ior: { value: 1.5 },
    // physical
    refractionRatio: { value: 0.98 },
    // basic, lambert, phong
    dfgLUT: { value: null }
    // DFG LUT for physically-based rendering
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
    aoMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
    lightMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    bumpScale: { value: 1 }
  },
  normalmap: {
    normalMap: { value: null },
    normalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) }
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 }
  },
  emissivemap: {
    emissiveMap: { value: null },
    emissiveMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  metalnessmap: {
    metalnessMap: { value: null },
    metalnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  roughnessmap: {
    roughnessMap: { value: null },
    roughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  gradientmap: {
    gradientMap: { value: null }
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color(16777215) }
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: { value: [], properties: {
      direction: {},
      color: {}
    } },
    directionalLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: { value: [], properties: {
      color: {},
      position: {},
      direction: {},
      distance: {},
      coneCos: {},
      penumbraCos: {},
      decay: {}
    } },
    spotLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {}
    } },
    spotLightMap: { value: [] },
    spotShadowMap: { value: [] },
    spotLightMatrix: { value: [] },
    pointLights: { value: [], properties: {
      color: {},
      position: {},
      decay: {},
      distance: {}
    } },
    pointLightShadows: { value: [], properties: {
      shadowIntensity: 1,
      shadowBias: {},
      shadowNormalBias: {},
      shadowRadius: {},
      shadowMapSize: {},
      shadowCameraNear: {},
      shadowCameraFar: {}
    } },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: { value: [], properties: {
      direction: {},
      skyColor: {},
      groundColor: {}
    } },
    // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
    rectAreaLights: { value: [], properties: {
      color: {},
      position: {},
      width: {},
      height: {}
    } },
    ltc_1: { value: null },
    ltc_2: { value: null }
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() }
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    mapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaMapTransform: { value: /* @__PURE__ */ new Matrix3() },
    alphaTest: { value: 0 }
  }
};
var ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        specular: { value: /* @__PURE__ */ new Color(1118481) },
        shininess: { value: 30 }
      }
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color(0) }
      }
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null }
      }
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 }
      }
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
      backgroundIntensity: { value: 1 }
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag
  },
  backgroundCube: {
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      backgroundBlurriness: { value: 0 },
      backgroundIntensity: { value: 1 },
      backgroundRotation: { value: /* @__PURE__ */ new Matrix3() }
    },
    vertexShader: ShaderChunk.backgroundCube_vert,
    fragmentShader: ShaderChunk.backgroundCube_frag
  },
  cube: {
    uniforms: {
      tCube: { value: null },
      tFlip: { value: -1 },
      opacity: { value: 1 }
    },
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null }
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag
  },
  distance: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 }
      }
    ]),
    vertexShader: ShaderChunk.distance_vert,
    fragmentShader: ShaderChunk.distance_frag
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color(0) },
        opacity: { value: 1 }
      }
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag
  }
};
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      dispersion: { value: 0 },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color(0) },
      specularColor: { value: /* @__PURE__ */ new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: /* @__PURE__ */ new Matrix3() },
      anisotropyVector: { value: /* @__PURE__ */ new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: /* @__PURE__ */ new Matrix3() }
    }
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag
};
var _rgb = { r: 0, b: 0, g: 0 };
var _e1$1 = /* @__PURE__ */ new Euler();
var _m1$12 = /* @__PURE__ */ new Matrix4();
function WebGLBackground(renderer, cubemaps, cubeuvmaps, state, objects, alpha, premultipliedAlpha) {
  const clearColor = new Color(0);
  let clearAlpha = alpha === true ? 0 : 1;
  let planeMesh;
  let boxMesh;
  let currentBackground = null;
  let currentBackgroundVersion = 0;
  let currentTonemapping = null;
  function getBackground(scene) {
    let background = scene.isScene === true ? scene.background : null;
    if (background && background.isTexture) {
      const usePMREM = scene.backgroundBlurriness > 0;
      background = (usePMREM ? cubeuvmaps : cubemaps).get(background);
    }
    return background;
  }
  function render(scene) {
    let forceClear = false;
    const background = getBackground(scene);
    if (background === null) {
      setClear(clearColor, clearAlpha);
    } else if (background && background.isColor) {
      setClear(background, 1);
      forceClear = true;
    }
    const environmentBlendMode = renderer.xr.getEnvironmentBlendMode();
    if (environmentBlendMode === "additive") {
      state.buffers.color.setClear(0, 0, 0, 1, premultipliedAlpha);
    } else if (environmentBlendMode === "alpha-blend") {
      state.buffers.color.setClear(0, 0, 0, 0, premultipliedAlpha);
    }
    if (renderer.autoClear || forceClear) {
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
    }
  }
  function addToRenderList(renderList, scene) {
    const background = getBackground(scene);
    if (background && (background.isCubeTexture || background.mapping === CubeUVReflectionMapping)) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: "BackgroundCubeMaterial",
            uniforms: cloneUniforms(ShaderLib.backgroundCube.uniforms),
            vertexShader: ShaderLib.backgroundCube.vertexShader,
            fragmentShader: ShaderLib.backgroundCube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })
        );
        boxMesh.geometry.deleteAttribute("normal");
        boxMesh.geometry.deleteAttribute("uv");
        boxMesh.onBeforeRender = function(renderer2, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld);
        };
        Object.defineProperty(boxMesh.material, "envMap", {
          get: function() {
            return this.uniforms.envMap.value;
          }
        });
        objects.update(boxMesh);
      }
      _e1$1.copy(scene.backgroundRotation);
      _e1$1.x *= -1;
      _e1$1.y *= -1;
      _e1$1.z *= -1;
      if (background.isCubeTexture && background.isRenderTargetTexture === false) {
        _e1$1.y *= -1;
        _e1$1.z *= -1;
      }
      boxMesh.material.uniforms.envMap.value = background;
      boxMesh.material.uniforms.flipEnvMap.value = background.isCubeTexture && background.isRenderTargetTexture === false ? -1 : 1;
      boxMesh.material.uniforms.backgroundBlurriness.value = scene.backgroundBlurriness;
      boxMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      boxMesh.material.uniforms.backgroundRotation.value.setFromMatrix4(_m1$12.makeRotationFromEuler(_e1$1));
      boxMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        boxMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      boxMesh.layers.enableAll();
      renderList.unshift(boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null);
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: "BackgroundMaterial",
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
            allowOverride: false
          })
        );
        planeMesh.geometry.deleteAttribute("normal");
        Object.defineProperty(planeMesh.material, "map", {
          get: function() {
            return this.uniforms.t2D.value;
          }
        });
        objects.update(planeMesh);
      }
      planeMesh.material.uniforms.t2D.value = background;
      planeMesh.material.uniforms.backgroundIntensity.value = scene.backgroundIntensity;
      planeMesh.material.toneMapped = ColorManagement.getTransfer(background.colorSpace) !== SRGBTransfer;
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix();
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);
      if (currentBackground !== background || currentBackgroundVersion !== background.version || currentTonemapping !== renderer.toneMapping) {
        planeMesh.material.needsUpdate = true;
        currentBackground = background;
        currentBackgroundVersion = background.version;
        currentTonemapping = renderer.toneMapping;
      }
      planeMesh.layers.enableAll();
      renderList.unshift(planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null);
    }
  }
  function setClear(color, alpha2) {
    color.getRGB(_rgb, getUnlitUniformColorSpace(renderer));
    state.buffers.color.setClear(_rgb.r, _rgb.g, _rgb.b, alpha2, premultipliedAlpha);
  }
  function dispose2() {
    if (boxMesh !== void 0) {
      boxMesh.geometry.dispose();
      boxMesh.material.dispose();
      boxMesh = void 0;
    }
    if (planeMesh !== void 0) {
      planeMesh.geometry.dispose();
      planeMesh.material.dispose();
      planeMesh = void 0;
    }
  }
  return {
    getClearColor: function() {
      return clearColor;
    },
    setClearColor: function(color, alpha2 = 1) {
      clearColor.set(color);
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    getClearAlpha: function() {
      return clearAlpha;
    },
    setClearAlpha: function(alpha2) {
      clearAlpha = alpha2;
      setClear(clearColor, clearAlpha);
    },
    render,
    addToRenderList,
    dispose: dispose2
  };
}
function WebGLBindingStates(gl, attributes) {
  const maxVertexAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const bindingStates = {};
  const defaultState = createBindingState(null);
  let currentState = defaultState;
  let forceUpdate = false;
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false;
    const state = getBindingState(geometry, program, material);
    if (currentState !== state) {
      currentState = state;
      bindVertexArrayObject(currentState.object);
    }
    updateBuffers = needsUpdate(object, geometry, program, index);
    if (updateBuffers) saveCache(object, geometry, program, index);
    if (index !== null) {
      attributes.update(index, gl.ELEMENT_ARRAY_BUFFER);
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false;
      setupVertexAttributes(object, material, program, geometry);
      if (index !== null) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, attributes.get(index).buffer);
      }
    }
  }
  function createVertexArrayObject() {
    return gl.createVertexArray();
  }
  function bindVertexArrayObject(vao) {
    return gl.bindVertexArray(vao);
  }
  function deleteVertexArrayObject(vao) {
    return gl.deleteVertexArray(vao);
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true;
    let programMap = bindingStates[geometry.id];
    if (programMap === void 0) {
      programMap = {};
      bindingStates[geometry.id] = programMap;
    }
    let stateMap = programMap[program.id];
    if (stateMap === void 0) {
      stateMap = {};
      programMap[program.id] = stateMap;
    }
    let state = stateMap[wireframe];
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject());
      stateMap[wireframe] = state;
    }
    return state;
  }
  function createBindingState(vao) {
    const newAttributes = [];
    const enabledAttributes = [];
    const attributeDivisors = [];
    for (let i2 = 0; i2 < maxVertexAttributes; i2++) {
      newAttributes[i2] = 0;
      enabledAttributes[i2] = 0;
      attributeDivisors[i2] = 0;
    }
    return {
      // for backward compatibility on non-VAO support browser
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null
    };
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes;
    const geometryAttributes = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name];
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (cachedAttribute === void 0) return true;
        if (cachedAttribute.attribute !== geometryAttribute) return true;
        if (geometryAttribute && cachedAttribute.data !== geometryAttribute.data) return true;
        attributesNum++;
      }
    }
    if (currentState.attributesNum !== attributesNum) return true;
    if (currentState.index !== index) return true;
    return false;
  }
  function saveCache(object, geometry, program, index) {
    const cache = {};
    const attributes2 = geometry.attributes;
    let attributesNum = 0;
    const programAttributes = program.getAttributes();
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name];
        if (attribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) attribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) attribute = object.instanceColor;
        }
        const data2 = {};
        data2.attribute = attribute;
        if (attribute && attribute.data) {
          data2.data = attribute.data;
        }
        cache[name] = data2;
        attributesNum++;
      }
    }
    currentState.attributes = cache;
    currentState.attributesNum = attributesNum;
    currentState.index = index;
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes;
    for (let i2 = 0, il = newAttributes.length; i2 < il; i2++) {
      newAttributes[i2] = 0;
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0);
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    const attributeDivisors = currentState.attributeDivisors;
    newAttributes[attribute] = 1;
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute);
      enabledAttributes[attribute] = 1;
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      gl.vertexAttribDivisor(attribute, meshPerAttribute);
      attributeDivisors[attribute] = meshPerAttribute;
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes;
    const enabledAttributes = currentState.enabledAttributes;
    for (let i2 = 0, il = enabledAttributes.length; i2 < il; i2++) {
      if (enabledAttributes[i2] !== newAttributes[i2]) {
        gl.disableVertexAttribArray(i2);
        enabledAttributes[i2] = 0;
      }
    }
  }
  function vertexAttribPointer(index, size, type, normalized, stride, offset, integer) {
    if (integer === true) {
      gl.vertexAttribIPointer(index, size, type, stride, offset);
    } else {
      gl.vertexAttribPointer(index, size, type, normalized, stride, offset);
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    initAttributes();
    const geometryAttributes = geometry.attributes;
    const programAttributes = program.getAttributes();
    const materialDefaultAttributeValues = material.defaultAttributeValues;
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name];
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name];
        if (geometryAttribute === void 0) {
          if (name === "instanceMatrix" && object.instanceMatrix) geometryAttribute = object.instanceMatrix;
          if (name === "instanceColor" && object.instanceColor) geometryAttribute = object.instanceColor;
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized;
          const size = geometryAttribute.itemSize;
          const attribute = attributes.get(geometryAttribute);
          if (attribute === void 0) continue;
          const buffer = attribute.buffer;
          const type = attribute.type;
          const bytesPerElement = attribute.bytesPerElement;
          const integer = type === gl.INT || type === gl.UNSIGNED_INT || geometryAttribute.gpuType === IntType;
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data2 = geometryAttribute.data;
            const stride = data2.stride;
            const offset = geometryAttribute.offset;
            if (data2.isInstancedInterleavedBuffer) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, data2.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = data2.meshPerAttribute * data2.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + size / programAttribute.locationSize * i2) * bytesPerElement,
                integer
              );
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttributeAndDivisor(programAttribute.location + i2, geometryAttribute.meshPerAttribute);
              }
              if (object.isInstancedMesh !== true && geometry._maxInstanceCount === void 0) {
                geometry._maxInstanceCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
              }
            } else {
              for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
                enableAttribute(programAttribute.location + i2);
              }
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
            for (let i2 = 0; i2 < programAttribute.locationSize; i2++) {
              vertexAttribPointer(
                programAttribute.location + i2,
                size / programAttribute.locationSize,
                type,
                normalized,
                size * bytesPerElement,
                size / programAttribute.locationSize * i2 * bytesPerElement,
                integer
              );
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name];
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value);
                break;
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value);
                break;
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value);
                break;
              default:
                gl.vertexAttrib1fv(programAttribute.location, value);
            }
          }
        }
      }
    }
    disableUnusedAttributes();
  }
  function dispose2() {
    reset();
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      for (const programId in programMap) {
        const stateMap = programMap[programId];
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object);
          delete stateMap[wireframe];
        }
        delete programMap[programId];
      }
      delete bindingStates[geometryId];
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return;
    const programMap = bindingStates[geometry.id];
    for (const programId in programMap) {
      const stateMap = programMap[programId];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[programId];
    }
    delete bindingStates[geometry.id];
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId];
      if (programMap[program.id] === void 0) continue;
      const stateMap = programMap[program.id];
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object);
        delete stateMap[wireframe];
      }
      delete programMap[program.id];
    }
  }
  function reset() {
    resetDefaultState();
    forceUpdate = true;
    if (currentState === defaultState) return;
    currentState = defaultState;
    bindVertexArrayObject(currentState.object);
  }
  function resetDefaultState() {
    defaultState.geometry = null;
    defaultState.program = null;
    defaultState.wireframe = false;
  }
  return {
    setup,
    reset,
    resetDefaultState,
    dispose: dispose2,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes
  };
}
function WebGLBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  function render(start, count) {
    gl.drawArrays(mode, start, count);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawArraysInstanced(mode, start, count, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
    let elementCount = 0;
    for (let i2 = 0; i2 < drawCount; i2++) {
      elementCount += counts[i2];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < starts.length; i2++) {
        renderInstances(starts[i2], counts[i2], primcount[i2]);
      }
    } else {
      extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2] * primcount[i2];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLCapabilities(gl, extensions, parameters, utils) {
  let maxAnisotropy;
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy;
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      const extension = extensions.get("EXT_texture_filter_anisotropic");
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
    } else {
      maxAnisotropy = 0;
    }
    return maxAnisotropy;
  }
  function textureFormatReadable(textureFormat) {
    if (textureFormat !== RGBAFormat && utils.convert(textureFormat) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_FORMAT)) {
      return false;
    }
    return true;
  }
  function textureTypeReadable(textureType) {
    const halfFloatSupportedByExt = textureType === HalfFloatType && (extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float"));
    if (textureType !== UnsignedByteType && utils.convert(textureType) !== gl.getParameter(gl.IMPLEMENTATION_COLOR_READ_TYPE) && // Edge and Chrome Mac < 52 (#9513)
    textureType !== FloatType && !halfFloatSupportedByExt) {
      return false;
    }
    return true;
  }
  function getMaxPrecision(precision2) {
    if (precision2 === "highp") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.HIGH_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT).precision > 0) {
        return "highp";
      }
      precision2 = "mediump";
    }
    if (precision2 === "mediump") {
      if (gl.getShaderPrecisionFormat(gl.VERTEX_SHADER, gl.MEDIUM_FLOAT).precision > 0 && gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT).precision > 0) {
        return "mediump";
      }
    }
    return "lowp";
  }
  let precision = parameters.precision !== void 0 ? parameters.precision : "highp";
  const maxPrecision = getMaxPrecision(precision);
  if (maxPrecision !== precision) {
    warn("WebGLRenderer:", precision, "not supported, using", maxPrecision, "instead.");
    precision = maxPrecision;
  }
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
  const reversedDepthBuffer = parameters.reversedDepthBuffer === true && extensions.has("EXT_clip_control");
  const maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
  const maxVertexTextures = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
  const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
  const maxCubemapSize = gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE);
  const maxAttributes = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
  const maxVertexUniforms = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
  const maxVaryings = gl.getParameter(gl.MAX_VARYING_VECTORS);
  const maxFragmentUniforms = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
  const maxSamples = gl.getParameter(gl.MAX_SAMPLES);
  const samples = gl.getParameter(gl.SAMPLES);
  return {
    isWebGL2: true,
    // keeping this for backwards compatibility
    getMaxAnisotropy,
    getMaxPrecision,
    textureFormatReadable,
    textureTypeReadable,
    precision,
    logarithmicDepthBuffer,
    reversedDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    maxSamples,
    samples
  };
}
function WebGLClipping(properties) {
  const scope = this;
  let globalState = null, numGlobalPlanes = 0, localClippingEnabled = false, renderingShadows = false;
  const plane = new Plane(), viewNormalMatrix = new Matrix3(), uniform = { value: null, needsUpdate: false };
  this.uniform = uniform;
  this.numPlanes = 0;
  this.numIntersection = 0;
  this.init = function(planes, enableLocalClipping) {
    const enabled = planes.length !== 0 || enableLocalClipping || // enable state of previous frame - the clipping code has to
    // run another frame in order to reset the state:
    numGlobalPlanes !== 0 || localClippingEnabled;
    localClippingEnabled = enableLocalClipping;
    numGlobalPlanes = planes.length;
    return enabled;
  };
  this.beginShadows = function() {
    renderingShadows = true;
    projectPlanes(null);
  };
  this.endShadows = function() {
    renderingShadows = false;
  };
  this.setGlobalState = function(planes, camera) {
    globalState = projectPlanes(planes, camera, 0);
  };
  this.setState = function(material, camera, useCache) {
    const planes = material.clippingPlanes, clipIntersection = material.clipIntersection, clipShadows = material.clipShadows;
    const materialProperties = properties.get(material);
    if (!localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && !clipShadows) {
      if (renderingShadows) {
        projectPlanes(null);
      } else {
        resetGlobalState();
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes, lGlobal = nGlobal * 4;
      let dstArray = materialProperties.clippingState || null;
      uniform.value = dstArray;
      dstArray = projectPlanes(planes, camera, lGlobal, useCache);
      for (let i2 = 0; i2 !== lGlobal; ++i2) {
        dstArray[i2] = globalState[i2];
      }
      materialProperties.clippingState = dstArray;
      this.numIntersection = clipIntersection ? this.numPlanes : 0;
      this.numPlanes += nGlobal;
    }
  };
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState;
      uniform.needsUpdate = numGlobalPlanes > 0;
    }
    scope.numPlanes = numGlobalPlanes;
    scope.numIntersection = 0;
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0;
    let dstArray = null;
    if (nPlanes !== 0) {
      dstArray = uniform.value;
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4, viewMatrix = camera.matrixWorldInverse;
        viewNormalMatrix.getNormalMatrix(viewMatrix);
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize);
        }
        for (let i2 = 0, i4 = dstOffset; i2 !== nPlanes; ++i2, i4 += 4) {
          plane.copy(planes[i2]).applyMatrix4(viewMatrix, viewNormalMatrix);
          plane.normal.toArray(dstArray, i4);
          dstArray[i4 + 3] = plane.constant;
        }
      }
      uniform.value = dstArray;
      uniform.needsUpdate = true;
    }
    scope.numPlanes = nPlanes;
    scope.numIntersection = 0;
    return dstArray;
  }
}
function WebGLCubeMaps(renderer) {
  let cubemaps = /* @__PURE__ */ new WeakMap();
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping;
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping;
    }
    return texture;
  }
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      if (mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture;
          return mapTextureMapping(cubemap, texture.mapping);
        } else {
          const image = texture.image;
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            cubemaps.set(texture, renderTarget);
            texture.addEventListener("dispose", onTextureDispose);
            return mapTextureMapping(renderTarget.texture, texture.mapping);
          } else {
            return null;
          }
        }
      }
    }
    return texture;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemap = cubemaps.get(texture);
    if (cubemap !== void 0) {
      cubemaps.delete(texture);
      cubemap.dispose();
    }
  }
  function dispose2() {
    cubemaps = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
var LOD_MIN = 4;
var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];
var MAX_SAMPLES = 20;
var GGX_SAMPLES = 256;
var _flatCamera = /* @__PURE__ */ new OrthographicCamera();
var _clearColor = /* @__PURE__ */ new Color();
var _oldTarget = null;
var _oldActiveCubeFace = 0;
var _oldActiveMipmapLevel = 0;
var _oldXrEnabled = false;
var _origin = /* @__PURE__ */ new Vector3();
var PMREMGenerator = class {
  /**
   * Constructs a new PMREM generator.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   */
  constructor(renderer) {
    this._renderer = renderer;
    this._pingPongRenderTarget = null;
    this._lodMax = 0;
    this._cubeSize = 0;
    this._sizeLods = [];
    this._sigmas = [];
    this._lodMeshes = [];
    this._backgroundBox = null;
    this._cubemapMaterial = null;
    this._equirectMaterial = null;
    this._blurMaterial = null;
    this._ggxMaterial = null;
  }
  /**
   * Generates a PMREM from a supplied Scene, which can be faster than using an
   * image if networking bandwidth is low. Optional sigma specifies a blur radius
   * in radians to be applied to the scene before PMREM generation. Optional near
   * and far planes ensure the scene is rendered in its entirety.
   *
   * @param {Scene} scene - The scene to be captured.
   * @param {number} [sigma=0] - The blur radius in radians.
   * @param {number} [near=0.1] - The near plane distance.
   * @param {number} [far=100] - The far plane distance.
   * @param {Object} [options={}] - The configuration options.
   * @param {number} [options.size=256] - The texture size of the PMREM.
   * @param {Vector3} [options.position=origin] - The position of the internal cube camera that renders the scene.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromScene(scene, sigma = 0, near = 0.1, far = 100, options = {}) {
    const {
      size = 256,
      position = _origin
    } = options;
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    this._setSize(size);
    const cubeUVRenderTarget = this._allocateTargets();
    cubeUVRenderTarget.depthBuffer = true;
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position);
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma);
    }
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  /**
   * Generates a PMREM from an equirectangular texture, which can be either LDR
   * or HDR. The ideal input image size is 1k (1024 x 512),
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} equirectangular - The equirectangular texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget);
  }
  /**
   * Generates a PMREM from an cubemap texture, which can be either LDR
   * or HDR. The ideal input cube size is 256 x 256,
   * as this matches best with the 256 x 256 cubemap output.
   *
   * @param {Texture} cubemap - The cubemap texture to be converted.
   * @param {?WebGLRenderTarget} [renderTarget=null] - The render target to use.
   * @return {WebGLRenderTarget} The resulting PMREM.
   */
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget);
  }
  /**
   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial();
      this._compileMaterial(this._cubemapMaterial);
    }
  }
  /**
   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
   * your texture's network fetch for increased concurrency.
   */
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial();
      this._compileMaterial(this._equirectMaterial);
    }
  }
  /**
   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
   * one of them will cause any others to also become unusable.
   */
  dispose() {
    this._dispose();
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
    if (this._backgroundBox !== null) {
      this._backgroundBox.geometry.dispose();
      this._backgroundBox.material.dispose();
    }
  }
  // private interface
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize));
    this._cubeSize = Math.pow(2, this._lodMax);
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose();
    if (this._ggxMaterial !== null) this._ggxMaterial.dispose();
    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
    for (let i2 = 0; i2 < this._lodMeshes.length; i2++) {
      this._lodMeshes[i2].geometry.dispose();
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
    this._renderer.xr.enabled = _oldXrEnabled;
    outputTarget.scissorTest = false;
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
  }
  _fromTexture(texture, renderTarget) {
    if (texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping) {
      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
    } else {
      this._setSize(texture.image.width / 4);
    }
    _oldTarget = this._renderer.getRenderTarget();
    _oldActiveCubeFace = this._renderer.getActiveCubeFace();
    _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
    _oldXrEnabled = this._renderer.xr.enabled;
    this._renderer.xr.enabled = false;
    const cubeUVRenderTarget = renderTarget || this._allocateTargets();
    this._textureToCubeUV(texture, cubeUVRenderTarget);
    this._applyPMREM(cubeUVRenderTarget);
    this._cleanup(cubeUVRenderTarget);
    return cubeUVRenderTarget;
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7);
    const height = 4 * this._cubeSize;
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      colorSpace: LinearSRGBColorSpace,
      depthBuffer: false
    };
    const cubeUVRenderTarget = _createRenderTarget(width, height, params);
    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose();
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params);
      const { _lodMax } = this;
      ({ lodMeshes: this._lodMeshes, sizeLods: this._sizeLods, sigmas: this._sigmas } = _createPlanes(_lodMax));
      this._blurMaterial = _getBlurShader(_lodMax, width, height);
      this._ggxMaterial = _getGGXShader(_lodMax, width, height);
    }
    return cubeUVRenderTarget;
  }
  _compileMaterial(material) {
    const mesh = new Mesh(new BufferGeometry(), material);
    this._renderer.compile(mesh, _flatCamera);
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget, position) {
    const fov2 = 90;
    const aspect2 = 1;
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far);
    const upSign = [1, -1, 1, 1, 1, 1];
    const forwardSign = [1, 1, 1, -1, -1, -1];
    const renderer = this._renderer;
    const originalAutoClear = renderer.autoClear;
    const toneMapping = renderer.toneMapping;
    renderer.getClearColor(_clearColor);
    renderer.toneMapping = NoToneMapping;
    renderer.autoClear = false;
    const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();
    if (reversedDepthBuffer) {
      renderer.setRenderTarget(cubeUVRenderTarget);
      renderer.clearDepth();
      renderer.setRenderTarget(null);
    }
    if (this._backgroundBox === null) {
      this._backgroundBox = new Mesh(
        new BoxGeometry(),
        new MeshBasicMaterial({
          name: "PMREM.Background",
          side: BackSide,
          depthWrite: false,
          depthTest: false
        })
      );
    }
    const backgroundBox = this._backgroundBox;
    const backgroundMaterial = backgroundBox.material;
    let useSolidColor = false;
    const background = scene.background;
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background);
        scene.background = null;
        useSolidColor = true;
      }
    } else {
      backgroundMaterial.color.copy(_clearColor);
      useSolidColor = true;
    }
    for (let i2 = 0; i2 < 6; i2++) {
      const col = i2 % 3;
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x + forwardSign[i2], position.y, position.z);
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i2]);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y + forwardSign[i2], position.z);
      } else {
        cubeCamera.up.set(0, upSign[i2], 0);
        cubeCamera.position.set(position.x, position.y, position.z);
        cubeCamera.lookAt(position.x, position.y, position.z + forwardSign[i2]);
      }
      const size = this._cubeSize;
      _setViewport(cubeUVRenderTarget, col * size, i2 > 2 ? size : 0, size, size);
      renderer.setRenderTarget(cubeUVRenderTarget);
      if (useSolidColor) {
        renderer.render(backgroundBox, cubeCamera);
      }
      renderer.render(scene, cubeCamera);
    }
    renderer.toneMapping = toneMapping;
    renderer.autoClear = originalAutoClear;
    scene.background = background;
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer = this._renderer;
    const isCubeTexture = texture.mapping === CubeReflectionMapping || texture.mapping === CubeRefractionMapping;
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial();
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial();
      }
    }
    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
    const mesh = this._lodMeshes[0];
    mesh.material = material;
    const uniforms = material.uniforms;
    uniforms["envMap"].value = texture;
    const size = this._cubeSize;
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(mesh, _flatCamera);
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer = this._renderer;
    const autoClear = renderer.autoClear;
    renderer.autoClear = false;
    const n2 = this._lodMeshes.length;
    for (let i2 = 1; i2 < n2; i2++) {
      this._applyGGXFilter(cubeUVRenderTarget, i2 - 1, i2);
    }
    renderer.autoClear = autoClear;
  }
  /**
   * Applies GGX VNDF importance sampling filter to generate a prefiltered environment map.
   * Uses Monte Carlo integration with VNDF importance sampling to accurately represent the
   * GGX BRDF for physically-based rendering. Reads from the previous LOD level and
   * applies incremental roughness filtering to avoid over-blurring.
   *
   * @private
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn - Source LOD level to read from
   * @param {number} lodOut - Target LOD level to write to
   */
  _applyGGXFilter(cubeUVRenderTarget, lodIn, lodOut) {
    const renderer = this._renderer;
    const pingPongRenderTarget = this._pingPongRenderTarget;
    const ggxMaterial = this._ggxMaterial;
    const ggxMesh = this._lodMeshes[lodOut];
    ggxMesh.material = ggxMaterial;
    const ggxUniforms = ggxMaterial.uniforms;
    const targetRoughness = lodOut / (this._lodMeshes.length - 1);
    const sourceRoughness = lodIn / (this._lodMeshes.length - 1);
    const incrementalRoughness = Math.sqrt(targetRoughness * targetRoughness - sourceRoughness * sourceRoughness);
    const blurStrength = 0 + targetRoughness * 1.25;
    const adjustedRoughness = incrementalRoughness * blurStrength;
    const { _lodMax } = this;
    const outputSize = this._sizeLods[lodOut];
    const x2 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    ggxUniforms["envMap"].value = cubeUVRenderTarget.texture;
    ggxUniforms["roughness"].value = adjustedRoughness;
    ggxUniforms["mipInt"].value = _lodMax - lodIn;
    _setViewport(pingPongRenderTarget, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(pingPongRenderTarget);
    renderer.render(ggxMesh, _flatCamera);
    ggxUniforms["envMap"].value = pingPongRenderTarget.texture;
    ggxUniforms["roughness"].value = 0;
    ggxUniforms["mipInt"].value = _lodMax - lodOut;
    _setViewport(cubeUVRenderTarget, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(cubeUVRenderTarget);
    renderer.render(ggxMesh, _flatCamera);
  }
  /**
   * This is a two-pass Gaussian blur for a cubemap. Normally this is done
   * vertically and horizontally, but this breaks down on a cube. Here we apply
   * the blur latitudinally (around the poles), and then longitudinally (towards
   * the poles) to approximate the orthogonally-separable blur. It is least
   * accurate at the poles, but still does a decent job.
   *
   * Used for initial scene blur in fromScene() method when sigma > 0.
   *
   * @private
   * @param {WebGLRenderTarget} cubeUVRenderTarget
   * @param {number} lodIn
   * @param {number} lodOut
   * @param {number} sigma
   * @param {Vector3} [poleAxis]
   */
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget;
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      "latitudinal",
      poleAxis
    );
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      "longitudinal",
      poleAxis
    );
  }
  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
    const renderer = this._renderer;
    const blurMaterial = this._blurMaterial;
    if (direction !== "latitudinal" && direction !== "longitudinal") {
      error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    }
    const STANDARD_DEVIATIONS = 3;
    const blurMesh = this._lodMeshes[lodOut];
    blurMesh.material = blurMaterial;
    const blurUniforms = blurMaterial.uniforms;
    const pixels = this._sizeLods[lodIn] - 1;
    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
    const sigmaPixels = sigmaRadians / radiansPerPixel;
    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
    if (samples > MAX_SAMPLES) {
      warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
    }
    const weights = [];
    let sum = 0;
    for (let i2 = 0; i2 < MAX_SAMPLES; ++i2) {
      const x3 = i2 / sigmaPixels;
      const weight = Math.exp(-x3 * x3 / 2);
      weights.push(weight);
      if (i2 === 0) {
        sum += weight;
      } else if (i2 < samples) {
        sum += 2 * weight;
      }
    }
    for (let i2 = 0; i2 < weights.length; i2++) {
      weights[i2] = weights[i2] / sum;
    }
    blurUniforms["envMap"].value = targetIn.texture;
    blurUniforms["samples"].value = samples;
    blurUniforms["weights"].value = weights;
    blurUniforms["latitudinal"].value = direction === "latitudinal";
    if (poleAxis) {
      blurUniforms["poleAxis"].value = poleAxis;
    }
    const { _lodMax } = this;
    blurUniforms["dTheta"].value = radiansPerPixel;
    blurUniforms["mipInt"].value = _lodMax - lodIn;
    const outputSize = this._sizeLods[lodOut];
    const x2 = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
    const y2 = 4 * (this._cubeSize - outputSize);
    _setViewport(targetOut, x2, y2, 3 * outputSize, 2 * outputSize);
    renderer.setRenderTarget(targetOut);
    renderer.render(blurMesh, _flatCamera);
  }
};
function _createPlanes(lodMax) {
  const sizeLods = [];
  const sigmas = [];
  const lodMeshes = [];
  let lod = lodMax;
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
  for (let i2 = 0; i2 < totalLods; i2++) {
    const sizeLod = Math.pow(2, lod);
    sizeLods.push(sizeLod);
    let sigma = 1 / sizeLod;
    if (i2 > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i2 - lodMax + LOD_MIN - 1];
    } else if (i2 === 0) {
      sigma = 0;
    }
    sigmas.push(sigma);
    const texelSize = 1 / (sizeLod - 2);
    const min = -texelSize;
    const max = 1 + texelSize;
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];
    const cubeFaces = 6;
    const vertices = 6;
    const positionSize = 3;
    const uvSize = 2;
    const faceIndexSize = 1;
    const position = new Float32Array(positionSize * vertices * cubeFaces);
    const uv = new Float32Array(uvSize * vertices * cubeFaces);
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
    for (let face = 0; face < cubeFaces; face++) {
      const x2 = face % 3 * 2 / 3 - 1;
      const y2 = face > 2 ? 0 : -1;
      const coordinates = [
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2,
        0,
        x2 + 2 / 3,
        y2 + 1,
        0,
        x2,
        y2 + 1,
        0
      ];
      position.set(coordinates, positionSize * vertices * face);
      uv.set(uv1, uvSize * vertices * face);
      const fill = [face, face, face, face, face, face];
      faceIndex.set(fill, faceIndexSize * vertices * face);
    }
    const planes = new BufferGeometry();
    planes.setAttribute("position", new BufferAttribute(position, positionSize));
    planes.setAttribute("uv", new BufferAttribute(uv, uvSize));
    planes.setAttribute("faceIndex", new BufferAttribute(faceIndex, faceIndexSize));
    lodMeshes.push(new Mesh(planes, null));
    if (lod > LOD_MIN) {
      lod--;
    }
  }
  return { lodMeshes, sizeLods, sigmas };
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params);
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping;
  cubeUVRenderTarget.texture.name = "PMREM.cubeUv";
  cubeUVRenderTarget.scissorTest = true;
  return cubeUVRenderTarget;
}
function _setViewport(target, x2, y2, width, height) {
  target.viewport.set(x2, y2, width, height);
  target.scissor.set(x2, y2, width, height);
}
function _getGGXShader(lodMax, width, height) {
  const shaderMaterial = new ShaderMaterial({
    name: "PMREMGGXConvolution",
    defines: {
      "GGX_SAMPLES": GGX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "roughness": { value: 0 },
      "mipInt": { value: 0 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision highp float;
			precision highp int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform float roughness;
			uniform float mipInt;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			#define PI 3.14159265359

			// Van der Corput radical inverse
			float radicalInverse_VdC(uint bits) {
				bits = (bits << 16u) | (bits >> 16u);
				bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
				bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
				bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
				bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
				return float(bits) * 2.3283064365386963e-10; // / 0x100000000
			}

			// Hammersley sequence
			vec2 hammersley(uint i, uint N) {
				return vec2(float(i) / float(N), radicalInverse_VdC(i));
			}

			// GGX VNDF importance sampling (Eric Heitz 2018)
			// "Sampling the GGX Distribution of Visible Normals"
			// https://jcgt.org/published/0007/04/01/
			vec3 importanceSampleGGX_VNDF(vec2 Xi, vec3 V, float roughness) {
				float alpha = roughness * roughness;

				// Section 3.2: Transform view direction to hemisphere configuration
				vec3 Vh = normalize(vec3(alpha * V.x, alpha * V.y, V.z));

				// Section 4.1: Orthonormal basis
				float lensq = Vh.x * Vh.x + Vh.y * Vh.y;
				vec3 T1 = lensq > 0.0 ? vec3(-Vh.y, Vh.x, 0.0) / sqrt(lensq) : vec3(1.0, 0.0, 0.0);
				vec3 T2 = cross(Vh, T1);

				// Section 4.2: Parameterization of projected area
				float r = sqrt(Xi.x);
				float phi = 2.0 * PI * Xi.y;
				float t1 = r * cos(phi);
				float t2 = r * sin(phi);
				float s = 0.5 * (1.0 + Vh.z);
				t2 = (1.0 - s) * sqrt(1.0 - t1 * t1) + s * t2;

				// Section 4.3: Reprojection onto hemisphere
				vec3 Nh = t1 * T1 + t2 * T2 + sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh;

				// Section 3.4: Transform back to ellipsoid configuration
				return normalize(vec3(alpha * Nh.x, alpha * Nh.y, max(0.0, Nh.z)));
			}

			void main() {
				vec3 N = normalize(vOutputDirection);
				vec3 V = N; // Assume view direction equals normal for pre-filtering

				vec3 prefilteredColor = vec3(0.0);
				float totalWeight = 0.0;

				// For very low roughness, just sample the environment directly
				if (roughness < 0.001) {
					gl_FragColor = vec4(bilinearCubeUV(envMap, N, mipInt), 1.0);
					return;
				}

				// Tangent space basis for VNDF sampling
				vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
				vec3 tangent = normalize(cross(up, N));
				vec3 bitangent = cross(N, tangent);

				for(uint i = 0u; i < uint(GGX_SAMPLES); i++) {
					vec2 Xi = hammersley(i, uint(GGX_SAMPLES));

					// For PMREM, V = N, so in tangent space V is always (0, 0, 1)
					vec3 H_tangent = importanceSampleGGX_VNDF(Xi, vec3(0.0, 0.0, 1.0), roughness);

					// Transform H back to world space
					vec3 H = normalize(tangent * H_tangent.x + bitangent * H_tangent.y + N * H_tangent.z);
					vec3 L = normalize(2.0 * dot(V, H) * H - V);

					float NdotL = max(dot(N, L), 0.0);

					if(NdotL > 0.0) {
						// Sample environment at fixed mip level
						// VNDF importance sampling handles the distribution filtering
						vec3 sampleColor = bilinearCubeUV(envMap, L, mipInt);

						// Weight by NdotL for the split-sum approximation
						// VNDF PDF naturally accounts for the visible microfacet distribution
						prefilteredColor += sampleColor * NdotL;
						totalWeight += NdotL;
					}
				}

				if (totalWeight > 0.0) {
					prefilteredColor = prefilteredColor / totalWeight;
				}

				gl_FragColor = vec4(prefilteredColor, 1.0);
			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES);
  const poleAxis = new Vector3(0, 1, 0);
  const shaderMaterial = new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      "n": MAX_SAMPLES,
      "CUBEUV_TEXEL_WIDTH": 1 / width,
      "CUBEUV_TEXEL_HEIGHT": 1 / height,
      "CUBEUV_MAX_MIP": `${lodMax}.0`
    },
    uniforms: {
      "envMap": { value: null },
      "samples": { value: 1 },
      "weights": { value: weights },
      "latitudinal": { value: false },
      "dTheta": { value: 0 },
      "mipInt": { value: 0 },
      "poleAxis": { value: poleAxis }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
  return shaderMaterial;
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: {
      "envMap": { value: null }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: {
      "envMap": { value: null },
      "flipEnvMap": { value: -1 }
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: (
      /* glsl */
      `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`
    ),
    blending: NoBlending,
    depthTest: false,
    depthWrite: false
  });
}
function _getCommonVertexShader() {
  return (
    /* glsl */
    `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
  );
}
function WebGLCubeUVMaps(renderer) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap();
  let pmremGenerator = null;
  function get(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping;
      const isEquirectMap = mapping === EquirectangularReflectionMapping || mapping === EquirectangularRefractionMapping;
      const isCubeMap = mapping === CubeReflectionMapping || mapping === CubeRefractionMapping;
      if (isEquirectMap || isCubeMap) {
        let renderTarget = cubeUVmaps.get(texture);
        const currentPMREMVersion = renderTarget !== void 0 ? renderTarget.texture.pmremVersion : 0;
        if (texture.isRenderTargetTexture && texture.pmremVersion !== currentPMREMVersion) {
          if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
          renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture, renderTarget) : pmremGenerator.fromCubemap(texture, renderTarget);
          renderTarget.texture.pmremVersion = texture.pmremVersion;
          cubeUVmaps.set(texture, renderTarget);
          return renderTarget.texture;
        } else {
          if (renderTarget !== void 0) {
            return renderTarget.texture;
          } else {
            const image = texture.image;
            if (isEquirectMap && image && image.height > 0 || isCubeMap && image && isCubeTextureComplete(image)) {
              if (pmremGenerator === null) pmremGenerator = new PMREMGenerator(renderer);
              renderTarget = isEquirectMap ? pmremGenerator.fromEquirectangular(texture) : pmremGenerator.fromCubemap(texture);
              renderTarget.texture.pmremVersion = texture.pmremVersion;
              cubeUVmaps.set(texture, renderTarget);
              texture.addEventListener("dispose", onTextureDispose);
              return renderTarget.texture;
            } else {
              return null;
            }
          }
        }
      }
    }
    return texture;
  }
  function isCubeTextureComplete(image) {
    let count = 0;
    const length = 6;
    for (let i2 = 0; i2 < length; i2++) {
      if (image[i2] !== void 0) count++;
    }
    return count === length;
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    const cubemapUV = cubeUVmaps.get(texture);
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture);
      cubemapUV.dispose();
    }
  }
  function dispose2() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap();
    if (pmremGenerator !== null) {
      pmremGenerator.dispose();
      pmremGenerator = null;
    }
  }
  return {
    get,
    dispose: dispose2
  };
}
function WebGLExtensions(gl) {
  const extensions = {};
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name];
    }
    const extension = gl.getExtension(name);
    extensions[name] = extension;
    return extension;
  }
  return {
    has: function(name) {
      return getExtension(name) !== null;
    },
    init: function() {
      getExtension("EXT_color_buffer_float");
      getExtension("WEBGL_clip_cull_distance");
      getExtension("OES_texture_float_linear");
      getExtension("EXT_color_buffer_half_float");
      getExtension("WEBGL_multisampled_render_to_texture");
      getExtension("WEBGL_render_shared_exponent");
    },
    get: function(name) {
      const extension = getExtension(name);
      if (extension === null) {
        warnOnce("WebGLRenderer: " + name + " extension not supported.");
      }
      return extension;
    }
  };
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {};
  const wireframeAttributes = /* @__PURE__ */ new WeakMap();
  function onGeometryDispose(event) {
    const geometry = event.target;
    if (geometry.index !== null) {
      attributes.remove(geometry.index);
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name]);
    }
    geometry.removeEventListener("dispose", onGeometryDispose);
    delete geometries[geometry.id];
    const attribute = wireframeAttributes.get(geometry);
    if (attribute) {
      attributes.remove(attribute);
      wireframeAttributes.delete(geometry);
    }
    bindingStates.releaseStatesOfGeometry(geometry);
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount;
    }
    info.memory.geometries--;
  }
  function get(object, geometry) {
    if (geometries[geometry.id] === true) return geometry;
    geometry.addEventListener("dispose", onGeometryDispose);
    geometries[geometry.id] = true;
    info.memory.geometries++;
    return geometry;
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes;
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], gl.ARRAY_BUFFER);
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = [];
    const geometryIndex = geometry.index;
    const geometryPosition = geometry.attributes.position;
    let version = 0;
    if (geometryIndex !== null) {
      const array = geometryIndex.array;
      version = geometryIndex.version;
      for (let i2 = 0, l2 = array.length; i2 < l2; i2 += 3) {
        const a2 = array[i2 + 0];
        const b2 = array[i2 + 1];
        const c2 = array[i2 + 2];
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else if (geometryPosition !== void 0) {
      const array = geometryPosition.array;
      version = geometryPosition.version;
      for (let i2 = 0, l2 = array.length / 3 - 1; i2 < l2; i2 += 3) {
        const a2 = i2 + 0;
        const b2 = i2 + 1;
        const c2 = i2 + 2;
        indices.push(a2, b2, b2, c2, c2, a2);
      }
    } else {
      return;
    }
    const attribute = new (arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute)(indices, 1);
    attribute.version = version;
    const previousAttribute = wireframeAttributes.get(geometry);
    if (previousAttribute) attributes.remove(previousAttribute);
    wireframeAttributes.set(geometry, attribute);
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry);
    if (currentAttribute) {
      const geometryIndex = geometry.index;
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry);
        }
      }
    } else {
      updateWireframeAttribute(geometry);
    }
    return wireframeAttributes.get(geometry);
  }
  return {
    get,
    update,
    getWireframeAttribute
  };
}
function WebGLIndexedBufferRenderer(gl, extensions, info) {
  let mode;
  function setMode(value) {
    mode = value;
  }
  let type, bytesPerElement;
  function setIndex(value) {
    type = value.type;
    bytesPerElement = value.bytesPerElement;
  }
  function render(start, count) {
    gl.drawElements(mode, count, type, start * bytesPerElement);
    info.update(count, mode, 1);
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return;
    gl.drawElementsInstanced(mode, count, type, start * bytesPerElement, primcount);
    info.update(count, mode, primcount);
  }
  function renderMultiDraw(starts, counts, drawCount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    extension.multiDrawElementsWEBGL(mode, counts, 0, type, starts, 0, drawCount);
    let elementCount = 0;
    for (let i2 = 0; i2 < drawCount; i2++) {
      elementCount += counts[i2];
    }
    info.update(elementCount, mode, 1);
  }
  function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
    if (drawCount === 0) return;
    const extension = extensions.get("WEBGL_multi_draw");
    if (extension === null) {
      for (let i2 = 0; i2 < starts.length; i2++) {
        renderInstances(starts[i2] / bytesPerElement, counts[i2], primcount[i2]);
      }
    } else {
      extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, type, starts, 0, primcount, 0, drawCount);
      let elementCount = 0;
      for (let i2 = 0; i2 < drawCount; i2++) {
        elementCount += counts[i2] * primcount[i2];
      }
      info.update(elementCount, mode, 1);
    }
  }
  this.setMode = setMode;
  this.setIndex = setIndex;
  this.render = render;
  this.renderInstances = renderInstances;
  this.renderMultiDraw = renderMultiDraw;
  this.renderMultiDrawInstances = renderMultiDrawInstances;
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0
  };
  const render = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0
  };
  function update(count, mode, instanceCount) {
    render.calls++;
    switch (mode) {
      case gl.TRIANGLES:
        render.triangles += instanceCount * (count / 3);
        break;
      case gl.LINES:
        render.lines += instanceCount * (count / 2);
        break;
      case gl.LINE_STRIP:
        render.lines += instanceCount * (count - 1);
        break;
      case gl.LINE_LOOP:
        render.lines += instanceCount * count;
        break;
      case gl.POINTS:
        render.points += instanceCount * count;
        break;
      default:
        error("WebGLInfo: Unknown draw mode:", mode);
        break;
    }
  }
  function reset() {
    render.calls = 0;
    render.triangles = 0;
    render.points = 0;
    render.lines = 0;
  }
  return {
    memory,
    render,
    programs: null,
    autoReset: true,
    reset,
    update
  };
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const morphTextures = /* @__PURE__ */ new WeakMap();
  const morph = new Vector4();
  function update(object, geometry, program) {
    const objectInfluences = object.morphTargetInfluences;
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let entry = morphTextures.get(geometry);
    if (entry === void 0 || entry.count !== morphTargetsCount) {
      let disposeTexture = function() {
        texture.dispose();
        morphTextures.delete(geometry);
        geometry.removeEventListener("dispose", disposeTexture);
      };
      if (entry !== void 0) entry.texture.dispose();
      const hasMorphPosition = geometry.morphAttributes.position !== void 0;
      const hasMorphNormals = geometry.morphAttributes.normal !== void 0;
      const hasMorphColors = geometry.morphAttributes.color !== void 0;
      const morphTargets = geometry.morphAttributes.position || [];
      const morphNormals = geometry.morphAttributes.normal || [];
      const morphColors = geometry.morphAttributes.color || [];
      let vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      let width = geometry.attributes.position.count * vertexDataCount;
      let height = 1;
      if (width > capabilities.maxTextureSize) {
        height = Math.ceil(width / capabilities.maxTextureSize);
        width = capabilities.maxTextureSize;
      }
      const buffer = new Float32Array(width * height * 4 * morphTargetsCount);
      const texture = new DataArrayTexture(buffer, width, height, morphTargetsCount);
      texture.type = FloatType;
      texture.needsUpdate = true;
      const vertexDataStride = vertexDataCount * 4;
      for (let i2 = 0; i2 < morphTargetsCount; i2++) {
        const morphTarget = morphTargets[i2];
        const morphNormal = morphNormals[i2];
        const morphColor = morphColors[i2];
        const offset = width * height * 4 * i2;
        for (let j2 = 0; j2 < morphTarget.count; j2++) {
          const stride = j2 * vertexDataStride;
          if (hasMorphPosition === true) {
            morph.fromBufferAttribute(morphTarget, j2);
            buffer[offset + stride + 0] = morph.x;
            buffer[offset + stride + 1] = morph.y;
            buffer[offset + stride + 2] = morph.z;
            buffer[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            morph.fromBufferAttribute(morphNormal, j2);
            buffer[offset + stride + 4] = morph.x;
            buffer[offset + stride + 5] = morph.y;
            buffer[offset + stride + 6] = morph.z;
            buffer[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            morph.fromBufferAttribute(morphColor, j2);
            buffer[offset + stride + 8] = morph.x;
            buffer[offset + stride + 9] = morph.y;
            buffer[offset + stride + 10] = morph.z;
            buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture,
        size: new Vector2(width, height)
      };
      morphTextures.set(geometry, entry);
      geometry.addEventListener("dispose", disposeTexture);
    }
    if (object.isInstancedMesh === true && object.morphTexture !== null) {
      program.getUniforms().setValue(gl, "morphTexture", object.morphTexture, textures);
    } else {
      let morphInfluencesSum = 0;
      for (let i2 = 0; i2 < objectInfluences.length; i2++) {
        morphInfluencesSum += objectInfluences[i2];
      }
      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
      program.getUniforms().setValue(gl, "morphTargetBaseInfluence", morphBaseInfluence);
      program.getUniforms().setValue(gl, "morphTargetInfluences", objectInfluences);
    }
    program.getUniforms().setValue(gl, "morphTargetsTexture", entry.texture, textures);
    program.getUniforms().setValue(gl, "morphTargetsTextureSize", entry.size);
  }
  return {
    update
  };
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap();
  function update(object) {
    const frame = info.render.frame;
    const geometry = object.geometry;
    const buffergeometry = geometries.get(object, geometry);
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry);
      updateMap.set(buffergeometry, frame);
    }
    if (object.isInstancedMesh) {
      if (object.hasEventListener("dispose", onInstancedMeshDispose) === false) {
        object.addEventListener("dispose", onInstancedMeshDispose);
      }
      if (updateMap.get(object) !== frame) {
        attributes.update(object.instanceMatrix, gl.ARRAY_BUFFER);
        if (object.instanceColor !== null) {
          attributes.update(object.instanceColor, gl.ARRAY_BUFFER);
        }
        updateMap.set(object, frame);
      }
    }
    if (object.isSkinnedMesh) {
      const skeleton = object.skeleton;
      if (updateMap.get(skeleton) !== frame) {
        skeleton.update();
        updateMap.set(skeleton, frame);
      }
    }
    return buffergeometry;
  }
  function dispose2() {
    updateMap = /* @__PURE__ */ new WeakMap();
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target;
    instancedMesh.removeEventListener("dispose", onInstancedMeshDispose);
    attributes.remove(instancedMesh.instanceMatrix);
    if (instancedMesh.instanceColor !== null) attributes.remove(instancedMesh.instanceColor);
  }
  return {
    update,
    dispose: dispose2
  };
}
var toneMappingMap = {
  [LinearToneMapping]: "LINEAR_TONE_MAPPING",
  [ReinhardToneMapping]: "REINHARD_TONE_MAPPING",
  [CineonToneMapping]: "CINEON_TONE_MAPPING",
  [ACESFilmicToneMapping]: "ACES_FILMIC_TONE_MAPPING",
  [AgXToneMapping]: "AGX_TONE_MAPPING",
  [NeutralToneMapping]: "NEUTRAL_TONE_MAPPING",
  [CustomToneMapping]: "CUSTOM_TONE_MAPPING"
};
function WebGLOutput(type, width, height, depth, stencil) {
  const targetA = new WebGLRenderTarget(width, height, {
    type,
    depthBuffer: depth,
    stencilBuffer: stencil
  });
  const targetB = new WebGLRenderTarget(width, height, {
    type: HalfFloatType,
    depthBuffer: false,
    stencilBuffer: false
  });
  const geometry = new BufferGeometry();
  geometry.setAttribute("position", new Float32BufferAttribute([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
  geometry.setAttribute("uv", new Float32BufferAttribute([0, 2, 0, 0, 2, 0], 2));
  const material = new RawShaderMaterial({
    uniforms: {
      tDiffuse: { value: null }
    },
    vertexShader: (
      /* glsl */
      `
			precision highp float;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;
			attribute vec2 uv;

			varying vec2 vUv;

			void main() {
				vUv = uv;
				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
			}`
    ),
    fragmentShader: (
      /* glsl */
      `
			precision highp float;

			uniform sampler2D tDiffuse;

			varying vec2 vUv;

			#include <tonemapping_pars_fragment>
			#include <colorspace_pars_fragment>

			void main() {
				gl_FragColor = texture2D( tDiffuse, vUv );

				#ifdef LINEAR_TONE_MAPPING
					gl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );
				#elif defined( REINHARD_TONE_MAPPING )
					gl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );
				#elif defined( CINEON_TONE_MAPPING )
					gl_FragColor.rgb = CineonToneMapping( gl_FragColor.rgb );
				#elif defined( ACES_FILMIC_TONE_MAPPING )
					gl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );
				#elif defined( AGX_TONE_MAPPING )
					gl_FragColor.rgb = AgXToneMapping( gl_FragColor.rgb );
				#elif defined( NEUTRAL_TONE_MAPPING )
					gl_FragColor.rgb = NeutralToneMapping( gl_FragColor.rgb );
				#elif defined( CUSTOM_TONE_MAPPING )
					gl_FragColor.rgb = CustomToneMapping( gl_FragColor.rgb );
				#endif

				#ifdef SRGB_TRANSFER
					gl_FragColor = sRGBTransferOETF( gl_FragColor );
				#endif
			}`
    ),
    depthTest: false,
    depthWrite: false
  });
  const mesh = new Mesh(geometry, material);
  const camera = new OrthographicCamera(-1, 1, 1, -1, 0, 1);
  let _outputColorSpace = null;
  let _outputToneMapping = null;
  let _isCompositing = false;
  let _savedToneMapping;
  let _savedRenderTarget = null;
  let _effects = [];
  let _hasRenderPass = false;
  this.setSize = function(width2, height2) {
    targetA.setSize(width2, height2);
    targetB.setSize(width2, height2);
    for (let i2 = 0; i2 < _effects.length; i2++) {
      const effect = _effects[i2];
      if (effect.setSize) effect.setSize(width2, height2);
    }
  };
  this.setEffects = function(effects) {
    _effects = effects;
    _hasRenderPass = _effects.length > 0 && _effects[0].isRenderPass === true;
    const width2 = targetA.width;
    const height2 = targetA.height;
    for (let i2 = 0; i2 < _effects.length; i2++) {
      const effect = _effects[i2];
      if (effect.setSize) effect.setSize(width2, height2);
    }
  };
  this.begin = function(renderer, renderTarget) {
    if (_isCompositing) return false;
    if (renderer.toneMapping === NoToneMapping && _effects.length === 0) return false;
    _savedRenderTarget = renderTarget;
    if (renderTarget !== null) {
      const width2 = renderTarget.width;
      const height2 = renderTarget.height;
      if (targetA.width !== width2 || targetA.height !== height2) {
        this.setSize(width2, height2);
      }
    }
    if (_hasRenderPass === false) {
      renderer.setRenderTarget(targetA);
    }
    _savedToneMapping = renderer.toneMapping;
    renderer.toneMapping = NoToneMapping;
    return true;
  };
  this.hasRenderPass = function() {
    return _hasRenderPass;
  };
  this.end = function(renderer, deltaTime) {
    renderer.toneMapping = _savedToneMapping;
    _isCompositing = true;
    let readBuffer = targetA;
    let writeBuffer = targetB;
    for (let i2 = 0; i2 < _effects.length; i2++) {
      const effect = _effects[i2];
      if (effect.enabled === false) continue;
      effect.render(renderer, writeBuffer, readBuffer, deltaTime);
      if (effect.needsSwap !== false) {
        const temp = readBuffer;
        readBuffer = writeBuffer;
        writeBuffer = temp;
      }
    }
    if (_outputColorSpace !== renderer.outputColorSpace || _outputToneMapping !== renderer.toneMapping) {
      _outputColorSpace = renderer.outputColorSpace;
      _outputToneMapping = renderer.toneMapping;
      material.defines = {};
      if (ColorManagement.getTransfer(_outputColorSpace) === SRGBTransfer) material.defines.SRGB_TRANSFER = "";
      const toneMapping = toneMappingMap[_outputToneMapping];
      if (toneMapping) material.defines[toneMapping] = "";
      material.needsUpdate = true;
    }
    material.uniforms.tDiffuse.value = readBuffer.texture;
    renderer.setRenderTarget(_savedRenderTarget);
    renderer.render(mesh, camera);
    _savedRenderTarget = null;
    _isCompositing = false;
  };
  this.isCompositing = function() {
    return _isCompositing;
  };
  this.dispose = function() {
    targetA.dispose();
    targetB.dispose();
    geometry.dispose();
    material.dispose();
  };
}
var emptyTexture = /* @__PURE__ */ new Texture();
var emptyShadowTexture = /* @__PURE__ */ new DepthTexture(1, 1);
var emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture();
var empty3dTexture = /* @__PURE__ */ new Data3DTexture();
var emptyCubeTexture = /* @__PURE__ */ new CubeTexture();
var arrayCacheF32 = [];
var arrayCacheI32 = [];
var mat4array = new Float32Array(16);
var mat3array = new Float32Array(9);
var mat2array = new Float32Array(4);
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0];
  if (firstElem <= 0 || firstElem > 0) return array;
  const n2 = nBlocks * blockSize;
  let r2 = arrayCacheF32[n2];
  if (r2 === void 0) {
    r2 = new Float32Array(n2);
    arrayCacheF32[n2] = r2;
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r2, 0);
    for (let i2 = 1, offset = 0; i2 !== nBlocks; ++i2) {
      offset += blockSize;
      array[i2].toArray(r2, offset);
    }
  }
  return r2;
}
function arraysEqual(a2, b2) {
  if (a2.length !== b2.length) return false;
  for (let i2 = 0, l2 = a2.length; i2 < l2; i2++) {
    if (a2[i2] !== b2[i2]) return false;
  }
  return true;
}
function copyArray(a2, b2) {
  for (let i2 = 0, l2 = b2.length; i2 < l2; i2++) {
    a2[i2] = b2[i2];
  }
}
function allocTexUnits(textures, n2) {
  let r2 = arrayCacheI32[n2];
  if (r2 === void 0) {
    r2 = new Int32Array(n2);
    arrayCacheI32[n2] = r2;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    r2[i2] = textures.allocateTextureUnit();
  }
  return r2;
}
function setValueV1f(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1f(this.addr, v2);
  cache[0] = v2;
}
function setValueV2f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2f(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3f(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else if (v2.r !== void 0) {
    if (cache[0] !== v2.r || cache[1] !== v2.g || cache[2] !== v2.b) {
      gl.uniform3f(this.addr, v2.r, v2.g, v2.b);
      cache[0] = v2.r;
      cache[1] = v2.g;
      cache[2] = v2.b;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4f(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4f(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4fv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueM2(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix2fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat2array.set(elements);
    gl.uniformMatrix2fv(this.addr, false, mat2array);
    copyArray(cache, elements);
  }
}
function setValueM3(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix3fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat3array.set(elements);
    gl.uniformMatrix3fv(this.addr, false, mat3array);
    copyArray(cache, elements);
  }
}
function setValueM4(gl, v2) {
  const cache = this.cache;
  const elements = v2.elements;
  if (elements === void 0) {
    if (arraysEqual(cache, v2)) return;
    gl.uniformMatrix4fv(this.addr, false, v2);
    copyArray(cache, v2);
  } else {
    if (arraysEqual(cache, elements)) return;
    mat4array.set(elements);
    gl.uniformMatrix4fv(this.addr, false, mat4array);
    copyArray(cache, elements);
  }
}
function setValueV1i(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1i(this.addr, v2);
  cache[0] = v2;
}
function setValueV2i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2i(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3i(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4i(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4i(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4iv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV1ui(gl, v2) {
  const cache = this.cache;
  if (cache[0] === v2) return;
  gl.uniform1ui(this.addr, v2);
  cache[0] = v2;
}
function setValueV2ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y) {
      gl.uniform2ui(this.addr, v2.x, v2.y);
      cache[0] = v2.x;
      cache[1] = v2.y;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform2uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV3ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z) {
      gl.uniform3ui(this.addr, v2.x, v2.y, v2.z);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform3uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueV4ui(gl, v2) {
  const cache = this.cache;
  if (v2.x !== void 0) {
    if (cache[0] !== v2.x || cache[1] !== v2.y || cache[2] !== v2.z || cache[3] !== v2.w) {
      gl.uniform4ui(this.addr, v2.x, v2.y, v2.z, v2.w);
      cache[0] = v2.x;
      cache[1] = v2.y;
      cache[2] = v2.z;
      cache[3] = v2.w;
    }
  } else {
    if (arraysEqual(cache, v2)) return;
    gl.uniform4uiv(this.addr, v2);
    copyArray(cache, v2);
  }
}
function setValueT1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyShadowTexture.compareFunction = textures.isReversedDepthBuffer() ? GreaterEqualCompare : LessEqualCompare;
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  textures.setTexture2D(v2 || emptyTexture2D, unit);
}
function setValueT3D1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture3D(v2 || empty3dTexture, unit);
}
function setValueT6(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTextureCube(v2 || emptyCubeTexture, unit);
}
function setValueT2DArray1(gl, v2, textures) {
  const cache = this.cache;
  const unit = textures.allocateTextureUnit();
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit);
    cache[0] = unit;
  }
  textures.setTexture2DArray(v2 || emptyArrayTexture, unit);
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f;
    // FLOAT
    case 35664:
      return setValueV2f;
    // _VEC2
    case 35665:
      return setValueV3f;
    // _VEC3
    case 35666:
      return setValueV4f;
    // _VEC4
    case 35674:
      return setValueM2;
    // _MAT2
    case 35675:
      return setValueM3;
    // _MAT3
    case 35676:
      return setValueM4;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1i;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2i;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3i;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4i;
    // _VEC4
    case 5125:
      return setValueV1ui;
    // UINT
    case 36294:
      return setValueV2ui;
    // _VEC2
    case 36295:
      return setValueV3ui;
    // _VEC3
    case 36296:
      return setValueV4ui;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3D1;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArray1;
  }
}
function setValueV1fArray(gl, v2) {
  gl.uniform1fv(this.addr, v2);
}
function setValueV2fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 2);
  gl.uniform2fv(this.addr, data2);
}
function setValueV3fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 3);
  gl.uniform3fv(this.addr, data2);
}
function setValueV4fArray(gl, v2) {
  const data2 = flatten(v2, this.size, 4);
  gl.uniform4fv(this.addr, data2);
}
function setValueM2Array(gl, v2) {
  const data2 = flatten(v2, this.size, 4);
  gl.uniformMatrix2fv(this.addr, false, data2);
}
function setValueM3Array(gl, v2) {
  const data2 = flatten(v2, this.size, 9);
  gl.uniformMatrix3fv(this.addr, false, data2);
}
function setValueM4Array(gl, v2) {
  const data2 = flatten(v2, this.size, 16);
  gl.uniformMatrix4fv(this.addr, false, data2);
}
function setValueV1iArray(gl, v2) {
  gl.uniform1iv(this.addr, v2);
}
function setValueV2iArray(gl, v2) {
  gl.uniform2iv(this.addr, v2);
}
function setValueV3iArray(gl, v2) {
  gl.uniform3iv(this.addr, v2);
}
function setValueV4iArray(gl, v2) {
  gl.uniform4iv(this.addr, v2);
}
function setValueV1uiArray(gl, v2) {
  gl.uniform1uiv(this.addr, v2);
}
function setValueV2uiArray(gl, v2) {
  gl.uniform2uiv(this.addr, v2);
}
function setValueV3uiArray(gl, v2) {
  gl.uniform3uiv(this.addr, v2);
}
function setValueV4uiArray(gl, v2) {
  gl.uniform4uiv(this.addr, v2);
}
function setValueT1Array(gl, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  let emptyTexture2D;
  if (this.type === gl.SAMPLER_2D_SHADOW) {
    emptyTexture2D = emptyShadowTexture;
  } else {
    emptyTexture2D = emptyTexture;
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture2D(v2[i2] || emptyTexture2D, units[i2]);
  }
}
function setValueT3DArray(gl, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture3D(v2[i2] || empty3dTexture, units[i2]);
  }
}
function setValueT6Array(gl, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTextureCube(v2[i2] || emptyCubeTexture, units[i2]);
  }
}
function setValueT2DArrayArray(gl, v2, textures) {
  const cache = this.cache;
  const n2 = v2.length;
  const units = allocTexUnits(textures, n2);
  if (!arraysEqual(cache, units)) {
    gl.uniform1iv(this.addr, units);
    copyArray(cache, units);
  }
  for (let i2 = 0; i2 !== n2; ++i2) {
    textures.setTexture2DArray(v2[i2] || emptyArrayTexture, units[i2]);
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray;
    // FLOAT
    case 35664:
      return setValueV2fArray;
    // _VEC2
    case 35665:
      return setValueV3fArray;
    // _VEC3
    case 35666:
      return setValueV4fArray;
    // _VEC4
    case 35674:
      return setValueM2Array;
    // _MAT2
    case 35675:
      return setValueM3Array;
    // _MAT3
    case 35676:
      return setValueM4Array;
    // _MAT4
    case 5124:
    case 35670:
      return setValueV1iArray;
    // INT, BOOL
    case 35667:
    case 35671:
      return setValueV2iArray;
    // _VEC2
    case 35668:
    case 35672:
      return setValueV3iArray;
    // _VEC3
    case 35669:
    case 35673:
      return setValueV4iArray;
    // _VEC4
    case 5125:
      return setValueV1uiArray;
    // UINT
    case 36294:
      return setValueV2uiArray;
    // _VEC2
    case 36295:
      return setValueV3uiArray;
    // _VEC3
    case 36296:
      return setValueV4uiArray;
    // _VEC4
    case 35678:
    // SAMPLER_2D
    case 36198:
    // SAMPLER_EXTERNAL_OES
    case 36298:
    // INT_SAMPLER_2D
    case 36306:
    // UNSIGNED_INT_SAMPLER_2D
    case 35682:
      return setValueT1Array;
    case 35679:
    // SAMPLER_3D
    case 36299:
    // INT_SAMPLER_3D
    case 36307:
      return setValueT3DArray;
    case 35680:
    // SAMPLER_CUBE
    case 36300:
    // INT_SAMPLER_CUBE
    case 36308:
    // UNSIGNED_INT_SAMPLER_CUBE
    case 36293:
      return setValueT6Array;
    case 36289:
    // SAMPLER_2D_ARRAY
    case 36303:
    // INT_SAMPLER_2D_ARRAY
    case 36311:
    // UNSIGNED_INT_SAMPLER_2D_ARRAY
    case 36292:
      return setValueT2DArrayArray;
  }
}
var SingleUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.setValue = getSingularSetter(activeInfo.type);
  }
};
var PureArrayUniform = class {
  constructor(id, activeInfo, addr) {
    this.id = id;
    this.addr = addr;
    this.cache = [];
    this.type = activeInfo.type;
    this.size = activeInfo.size;
    this.setValue = getPureArraySetter(activeInfo.type);
  }
};
var StructuredUniform = class {
  constructor(id) {
    this.id = id;
    this.seq = [];
    this.map = {};
  }
  setValue(gl, value, textures) {
    const seq = this.seq;
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2];
      u2.setValue(gl, value[u2.id], textures);
    }
  }
};
var RePathPart = /(\w+)(\])?(\[|\.)?/g;
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject);
  container.map[uniformObject.id] = uniformObject;
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name, pathLength = path.length;
  RePathPart.lastIndex = 0;
  while (true) {
    const match = RePathPart.exec(path), matchEnd = RePathPart.lastIndex;
    let id = match[1];
    const idIsIndex = match[2] === "]", subscript = match[3];
    if (idIsIndex) id = id | 0;
    if (subscript === void 0 || subscript === "[" && matchEnd + 2 === pathLength) {
      addUniform(container, subscript === void 0 ? new SingleUniform(id, activeInfo, addr) : new PureArrayUniform(id, activeInfo, addr));
      break;
    } else {
      const map = container.map;
      let next = map[id];
      if (next === void 0) {
        next = new StructuredUniform(id);
        addUniform(container, next);
      }
      container = next;
    }
  }
}
var WebGLUniforms = class {
  constructor(gl, program) {
    this.seq = [];
    this.map = {};
    const n2 = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
    for (let i2 = 0; i2 < n2; ++i2) {
      const info = gl.getActiveUniform(program, i2), addr = gl.getUniformLocation(program, info.name);
      parseUniform(info, addr, this);
    }
    const shadowSamplers = [];
    const otherUniforms = [];
    for (const u2 of this.seq) {
      if (u2.type === gl.SAMPLER_2D_SHADOW || u2.type === gl.SAMPLER_CUBE_SHADOW || u2.type === gl.SAMPLER_2D_ARRAY_SHADOW) {
        shadowSamplers.push(u2);
      } else {
        otherUniforms.push(u2);
      }
    }
    if (shadowSamplers.length > 0) {
      this.seq = shadowSamplers.concat(otherUniforms);
    }
  }
  setValue(gl, name, value, textures) {
    const u2 = this.map[name];
    if (u2 !== void 0) u2.setValue(gl, value, textures);
  }
  setOptional(gl, object, name) {
    const v2 = object[name];
    if (v2 !== void 0) this.setValue(gl, name, v2);
  }
  static upload(gl, seq, values, textures) {
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2], v2 = values[u2.id];
      if (v2.needsUpdate !== false) {
        u2.setValue(gl, v2.value, textures);
      }
    }
  }
  static seqWithValue(seq, values) {
    const r2 = [];
    for (let i2 = 0, n2 = seq.length; i2 !== n2; ++i2) {
      const u2 = seq[i2];
      if (u2.id in values) r2.push(u2);
    }
    return r2;
  }
};
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, string);
  gl.compileShader(shader);
  return shader;
}
var COMPLETION_STATUS_KHR = 37297;
var programIdCount = 0;
function handleSource(string, errorLine) {
  const lines = string.split("\n");
  const lines2 = [];
  const from = Math.max(errorLine - 6, 0);
  const to2 = Math.min(errorLine + 6, lines.length);
  for (let i2 = from; i2 < to2; i2++) {
    const line = i2 + 1;
    lines2.push(`${line === errorLine ? ">" : " "} ${line}: ${lines[i2]}`);
  }
  return lines2.join("\n");
}
var _m0 = /* @__PURE__ */ new Matrix3();
function getEncodingComponents(colorSpace) {
  ColorManagement._getMatrix(_m0, ColorManagement.workingColorSpace, colorSpace);
  const encodingMatrix = `mat3( ${_m0.elements.map((v2) => v2.toFixed(4))} )`;
  switch (ColorManagement.getTransfer(colorSpace)) {
    case LinearTransfer:
      return [encodingMatrix, "LinearTransferOETF"];
    case SRGBTransfer:
      return [encodingMatrix, "sRGBTransferOETF"];
    default:
      warn("WebGLProgram: Unsupported color space: ", colorSpace);
      return [encodingMatrix, "LinearTransferOETF"];
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  const shaderInfoLog = gl.getShaderInfoLog(shader) || "";
  const errors = shaderInfoLog.trim();
  if (status && errors === "") return "";
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors);
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1]);
    return type.toUpperCase() + "\n\n" + errors + "\n\n" + handleSource(gl.getShaderSource(shader), errorLine);
  } else {
    return errors;
  }
}
function getTexelEncodingFunction(functionName, colorSpace) {
  const components = getEncodingComponents(colorSpace);
  return [
    `vec4 ${functionName}( vec4 value ) {`,
    `	return ${components[1]}( vec4( value.rgb * ${components[0]}, value.a ) );`,
    "}"
  ].join("\n");
}
var toneMappingFunctions = {
  [LinearToneMapping]: "Linear",
  [ReinhardToneMapping]: "Reinhard",
  [CineonToneMapping]: "Cineon",
  [ACESFilmicToneMapping]: "ACESFilmic",
  [AgXToneMapping]: "AgX",
  [NeutralToneMapping]: "Neutral",
  [CustomToneMapping]: "Custom"
};
function getToneMappingFunction(functionName, toneMapping) {
  const toneMappingName = toneMappingFunctions[toneMapping];
  if (toneMappingName === void 0) {
    warn("WebGLProgram: Unsupported toneMapping:", toneMapping);
    return "vec3 " + functionName + "( vec3 color ) { return LinearToneMapping( color ); }";
  }
  return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
}
var _v0 = /* @__PURE__ */ new Vector3();
function getLuminanceFunction() {
  ColorManagement.getLuminanceCoefficients(_v0);
  const r2 = _v0.x.toFixed(4);
  const g2 = _v0.y.toFixed(4);
  const b2 = _v0.z.toFixed(4);
  return [
    "float luminance( const in vec3 rgb ) {",
    `	const vec3 weights = vec3( ${r2}, ${g2}, ${b2} );`,
    "	return dot( weights, rgb );",
    "}"
  ].join("\n");
}
function generateVertexExtensions(parameters) {
  const chunks = [
    parameters.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "",
    parameters.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""
  ];
  return chunks.filter(filterEmptyLine).join("\n");
}
function generateDefines(defines) {
  const chunks = [];
  for (const name in defines) {
    const value = defines[name];
    if (value === false) continue;
    chunks.push("#define " + name + " " + value);
  }
  return chunks.join("\n");
}
function fetchAttributeLocations(gl, program) {
  const attributes = {};
  const n2 = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);
  for (let i2 = 0; i2 < n2; i2++) {
    const info = gl.getActiveAttrib(program, i2);
    const name = info.name;
    let locationSize = 1;
    if (info.type === gl.FLOAT_MAT2) locationSize = 2;
    if (info.type === gl.FLOAT_MAT3) locationSize = 3;
    if (info.type === gl.FLOAT_MAT4) locationSize = 4;
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize
    };
  }
  return attributes;
}
function filterEmptyLine(string) {
  return string !== "";
}
function replaceLightNums(string, parameters) {
  const numSpotLightCoords = parameters.numSpotLightShadows + parameters.numSpotLightMaps - parameters.numSpotLightShadowsWithMaps;
  return string.replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows);
}
function replaceClippingPlaneNums(string, parameters) {
  return string.replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, parameters.numClippingPlanes - parameters.numClipIntersection);
}
var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer);
}
var shaderChunkMap = /* @__PURE__ */ new Map();
function includeReplacer(match, include) {
  let string = ShaderChunk[include];
  if (string === void 0) {
    const newInclude = shaderChunkMap.get(include);
    if (newInclude !== void 0) {
      string = ShaderChunk[newInclude];
      warn('WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', include, newInclude);
    } else {
      throw new Error("Can not resolve #include <" + include + ">");
    }
  }
  return resolveIncludes(string);
}
var unrollLoopPattern = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function unrollLoops(string) {
  return string.replace(unrollLoopPattern, loopReplacer);
}
function loopReplacer(match, start, end, snippet) {
  let string = "";
  for (let i2 = parseInt(start); i2 < parseInt(end); i2++) {
    string += snippet.replace(/\[\s*i\s*\]/g, "[ " + i2 + " ]").replace(/UNROLLED_LOOP_INDEX/g, i2);
  }
  return string;
}
function generatePrecision(parameters) {
  let precisionstring = `precision ${parameters.precision} float;
	precision ${parameters.precision} int;
	precision ${parameters.precision} sampler2D;
	precision ${parameters.precision} samplerCube;
	precision ${parameters.precision} sampler3D;
	precision ${parameters.precision} sampler2DArray;
	precision ${parameters.precision} sampler2DShadow;
	precision ${parameters.precision} samplerCubeShadow;
	precision ${parameters.precision} sampler2DArrayShadow;
	precision ${parameters.precision} isampler2D;
	precision ${parameters.precision} isampler3D;
	precision ${parameters.precision} isamplerCube;
	precision ${parameters.precision} isampler2DArray;
	precision ${parameters.precision} usampler2D;
	precision ${parameters.precision} usampler3D;
	precision ${parameters.precision} usamplerCube;
	precision ${parameters.precision} usampler2DArray;
	`;
  if (parameters.precision === "highp") {
    precisionstring += "\n#define HIGH_PRECISION";
  } else if (parameters.precision === "mediump") {
    precisionstring += "\n#define MEDIUM_PRECISION";
  } else if (parameters.precision === "lowp") {
    precisionstring += "\n#define LOW_PRECISION";
  }
  return precisionstring;
}
var shadowMapTypeDefines = {
  [PCFShadowMap]: "SHADOWMAP_TYPE_PCF",
  [VSMShadowMap]: "SHADOWMAP_TYPE_VSM"
};
function generateShadowMapTypeDefine(parameters) {
  return shadowMapTypeDefines[parameters.shadowMapType] || "SHADOWMAP_TYPE_BASIC";
}
var envMapTypeDefines = {
  [CubeReflectionMapping]: "ENVMAP_TYPE_CUBE",
  [CubeRefractionMapping]: "ENVMAP_TYPE_CUBE",
  [CubeUVReflectionMapping]: "ENVMAP_TYPE_CUBE_UV"
};
function generateEnvMapTypeDefine(parameters) {
  if (parameters.envMap === false) return "ENVMAP_TYPE_CUBE";
  return envMapTypeDefines[parameters.envMapMode] || "ENVMAP_TYPE_CUBE";
}
var envMapModeDefines = {
  [CubeRefractionMapping]: "ENVMAP_MODE_REFRACTION"
};
function generateEnvMapModeDefine(parameters) {
  if (parameters.envMap === false) return "ENVMAP_MODE_REFLECTION";
  return envMapModeDefines[parameters.envMapMode] || "ENVMAP_MODE_REFLECTION";
}
var envMapBlendingDefines = {
  [MultiplyOperation]: "ENVMAP_BLENDING_MULTIPLY",
  [MixOperation]: "ENVMAP_BLENDING_MIX",
  [AddOperation]: "ENVMAP_BLENDING_ADD"
};
function generateEnvMapBlendingDefine(parameters) {
  if (parameters.envMap === false) return "ENVMAP_BLENDING_NONE";
  return envMapBlendingDefines[parameters.combine] || "ENVMAP_BLENDING_NONE";
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight;
  if (imageHeight === null) return null;
  const maxMip = Math.log2(imageHeight) - 2;
  const texelHeight = 1 / imageHeight;
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
  return { texelWidth, texelHeight, maxMip };
}
function WebGLProgram(renderer, cacheKey, parameters, bindingStates) {
  const gl = renderer.getContext();
  const defines = parameters.defines;
  let vertexShader = parameters.vertexShader;
  let fragmentShader = parameters.fragmentShader;
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters);
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters);
  const envMapModeDefine = generateEnvMapModeDefine(parameters);
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters);
  const envMapCubeUVSize = generateCubeUVSize(parameters);
  const customVertexExtensions = generateVertexExtensions(parameters);
  const customDefines = generateDefines(defines);
  const program = gl.createProgram();
  let prefixVertex, prefixFragment;
  let versionString = parameters.glslVersion ? "#version " + parameters.glslVersion + "\n" : "";
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixVertex.length > 0) {
      prefixVertex += "\n";
    }
    prefixFragment = [
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines
    ].filter(filterEmptyLine).join("\n");
    if (prefixFragment.length > 0) {
      prefixFragment += "\n";
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "",
      parameters.batching ? "#define USE_BATCHING" : "",
      parameters.batchingColor ? "#define USE_BATCHING_COLOR" : "",
      parameters.instancing ? "#define USE_INSTANCING" : "",
      parameters.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
      parameters.instancingMorph ? "#define USE_INSTANCING_MORPH" : "",
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      //
      parameters.mapUv ? "#define MAP_UV " + parameters.mapUv : "",
      parameters.alphaMapUv ? "#define ALPHAMAP_UV " + parameters.alphaMapUv : "",
      parameters.lightMapUv ? "#define LIGHTMAP_UV " + parameters.lightMapUv : "",
      parameters.aoMapUv ? "#define AOMAP_UV " + parameters.aoMapUv : "",
      parameters.emissiveMapUv ? "#define EMISSIVEMAP_UV " + parameters.emissiveMapUv : "",
      parameters.bumpMapUv ? "#define BUMPMAP_UV " + parameters.bumpMapUv : "",
      parameters.normalMapUv ? "#define NORMALMAP_UV " + parameters.normalMapUv : "",
      parameters.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + parameters.displacementMapUv : "",
      parameters.metalnessMapUv ? "#define METALNESSMAP_UV " + parameters.metalnessMapUv : "",
      parameters.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + parameters.roughnessMapUv : "",
      parameters.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + parameters.anisotropyMapUv : "",
      parameters.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + parameters.clearcoatMapUv : "",
      parameters.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + parameters.clearcoatNormalMapUv : "",
      parameters.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + parameters.clearcoatRoughnessMapUv : "",
      parameters.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + parameters.iridescenceMapUv : "",
      parameters.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + parameters.iridescenceThicknessMapUv : "",
      parameters.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + parameters.sheenColorMapUv : "",
      parameters.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + parameters.sheenRoughnessMapUv : "",
      parameters.specularMapUv ? "#define SPECULARMAP_UV " + parameters.specularMapUv : "",
      parameters.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + parameters.specularColorMapUv : "",
      parameters.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + parameters.specularIntensityMapUv : "",
      parameters.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + parameters.transmissionMapUv : "",
      parameters.thicknessMapUv ? "#define THICKNESSMAP_UV " + parameters.thicknessMapUv : "",
      //
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.skinning ? "#define USE_SKINNING" : "",
      parameters.morphTargets ? "#define USE_MORPHTARGETS" : "",
      parameters.morphNormals && parameters.flatShading === false ? "#define USE_MORPHNORMALS" : "",
      parameters.morphColors ? "#define USE_MORPHCOLORS" : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + parameters.morphTextureStride : "",
      parameters.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + parameters.morphTargetsCount : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
      parameters.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
      "uniform mat4 modelMatrix;",
      "uniform mat4 modelViewMatrix;",
      "uniform mat4 projectionMatrix;",
      "uniform mat4 viewMatrix;",
      "uniform mat3 normalMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      "#ifdef USE_INSTANCING",
      "	attribute mat4 instanceMatrix;",
      "#endif",
      "#ifdef USE_INSTANCING_COLOR",
      "	attribute vec3 instanceColor;",
      "#endif",
      "#ifdef USE_INSTANCING_MORPH",
      "	uniform sampler2D morphTexture;",
      "#endif",
      "attribute vec3 position;",
      "attribute vec3 normal;",
      "attribute vec2 uv;",
      "#ifdef USE_UV1",
      "	attribute vec2 uv1;",
      "#endif",
      "#ifdef USE_UV2",
      "	attribute vec2 uv2;",
      "#endif",
      "#ifdef USE_UV3",
      "	attribute vec2 uv3;",
      "#endif",
      "#ifdef USE_TANGENT",
      "	attribute vec4 tangent;",
      "#endif",
      "#if defined( USE_COLOR_ALPHA )",
      "	attribute vec4 color;",
      "#elif defined( USE_COLOR )",
      "	attribute vec3 color;",
      "#endif",
      "#ifdef USE_SKINNING",
      "	attribute vec4 skinIndex;",
      "	attribute vec4 skinWeight;",
      "#endif",
      "\n"
    ].filter(filterEmptyLine).join("\n");
    prefixFragment = [
      generatePrecision(parameters),
      "#define SHADER_TYPE " + parameters.shaderType,
      "#define SHADER_NAME " + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? "#define USE_FOG" : "",
      parameters.useFog && parameters.fogExp2 ? "#define FOG_EXP2" : "",
      parameters.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "",
      parameters.map ? "#define USE_MAP" : "",
      parameters.matcap ? "#define USE_MATCAP" : "",
      parameters.envMap ? "#define USE_ENVMAP" : "",
      parameters.envMap ? "#define " + envMapTypeDefine : "",
      parameters.envMap ? "#define " + envMapModeDefine : "",
      parameters.envMap ? "#define " + envMapBlendingDefine : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_WIDTH " + envMapCubeUVSize.texelWidth : "",
      envMapCubeUVSize ? "#define CUBEUV_TEXEL_HEIGHT " + envMapCubeUVSize.texelHeight : "",
      envMapCubeUVSize ? "#define CUBEUV_MAX_MIP " + envMapCubeUVSize.maxMip + ".0" : "",
      parameters.lightMap ? "#define USE_LIGHTMAP" : "",
      parameters.aoMap ? "#define USE_AOMAP" : "",
      parameters.bumpMap ? "#define USE_BUMPMAP" : "",
      parameters.normalMap ? "#define USE_NORMALMAP" : "",
      parameters.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
      parameters.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
      parameters.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
      parameters.anisotropy ? "#define USE_ANISOTROPY" : "",
      parameters.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
      parameters.clearcoat ? "#define USE_CLEARCOAT" : "",
      parameters.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
      parameters.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
      parameters.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
      parameters.dispersion ? "#define USE_DISPERSION" : "",
      parameters.iridescence ? "#define USE_IRIDESCENCE" : "",
      parameters.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
      parameters.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "",
      parameters.specularMap ? "#define USE_SPECULARMAP" : "",
      parameters.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
      parameters.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
      parameters.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
      parameters.metalnessMap ? "#define USE_METALNESSMAP" : "",
      parameters.alphaMap ? "#define USE_ALPHAMAP" : "",
      parameters.alphaTest ? "#define USE_ALPHATEST" : "",
      parameters.alphaHash ? "#define USE_ALPHAHASH" : "",
      parameters.sheen ? "#define USE_SHEEN" : "",
      parameters.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
      parameters.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
      parameters.transmission ? "#define USE_TRANSMISSION" : "",
      parameters.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
      parameters.thicknessMap ? "#define USE_THICKNESSMAP" : "",
      parameters.vertexTangents && parameters.flatShading === false ? "#define USE_TANGENT" : "",
      parameters.vertexColors || parameters.instancingColor || parameters.batchingColor ? "#define USE_COLOR" : "",
      parameters.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
      parameters.vertexUv1s ? "#define USE_UV1" : "",
      parameters.vertexUv2s ? "#define USE_UV2" : "",
      parameters.vertexUv3s ? "#define USE_UV3" : "",
      parameters.pointsUvs ? "#define USE_POINTS_UV" : "",
      parameters.gradientMap ? "#define USE_GRADIENTMAP" : "",
      parameters.flatShading ? "#define FLAT_SHADED" : "",
      parameters.doubleSided ? "#define DOUBLE_SIDED" : "",
      parameters.flipSided ? "#define FLIP_SIDED" : "",
      parameters.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
      parameters.shadowMapEnabled ? "#define " + shadowMapTypeDefine : "",
      parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
      parameters.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "",
      parameters.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
      parameters.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "",
      parameters.logarithmicDepthBuffer ? "#define USE_LOGARITHMIC_DEPTH_BUFFER" : "",
      parameters.reversedDepthBuffer ? "#define USE_REVERSED_DEPTH_BUFFER" : "",
      "uniform mat4 viewMatrix;",
      "uniform vec3 cameraPosition;",
      "uniform bool isOrthographic;",
      parameters.toneMapping !== NoToneMapping ? "#define TONE_MAPPING" : "",
      parameters.toneMapping !== NoToneMapping ? ShaderChunk["tonemapping_pars_fragment"] : "",
      // this code is required here because it is used by the toneMapping() function defined below
      parameters.toneMapping !== NoToneMapping ? getToneMappingFunction("toneMapping", parameters.toneMapping) : "",
      parameters.dithering ? "#define DITHERING" : "",
      parameters.opaque ? "#define OPAQUE" : "",
      ShaderChunk["colorspace_pars_fragment"],
      // this code is required here because it is used by the various encoding/decoding function defined below
      getTexelEncodingFunction("linearToOutputTexel", parameters.outputColorSpace),
      getLuminanceFunction(),
      parameters.useDepthPacking ? "#define DEPTH_PACKING " + parameters.depthPacking : "",
      "\n"
    ].filter(filterEmptyLine).join("\n");
  }
  vertexShader = resolveIncludes(vertexShader);
  vertexShader = replaceLightNums(vertexShader, parameters);
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters);
  fragmentShader = resolveIncludes(fragmentShader);
  fragmentShader = replaceLightNums(fragmentShader, parameters);
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters);
  vertexShader = unrollLoops(vertexShader);
  fragmentShader = unrollLoops(fragmentShader);
  if (parameters.isRawShaderMaterial !== true) {
    versionString = "#version 300 es\n";
    prefixVertex = [
      customVertexExtensions,
      "#define attribute in",
      "#define varying out",
      "#define texture2D texture"
    ].join("\n") + "\n" + prefixVertex;
    prefixFragment = [
      "#define varying in",
      parameters.glslVersion === GLSL3 ? "" : "layout(location = 0) out highp vec4 pc_fragColor;",
      parameters.glslVersion === GLSL3 ? "" : "#define gl_FragColor pc_fragColor",
      "#define gl_FragDepthEXT gl_FragDepth",
      "#define texture2D texture",
      "#define textureCube texture",
      "#define texture2DProj textureProj",
      "#define texture2DLodEXT textureLod",
      "#define texture2DProjLodEXT textureProjLod",
      "#define textureCubeLodEXT textureLod",
      "#define texture2DGradEXT textureGrad",
      "#define texture2DProjGradEXT textureProjGrad",
      "#define textureCubeGradEXT textureGrad"
    ].join("\n") + "\n" + prefixFragment;
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader;
  const fragmentGlsl = versionString + prefixFragment + fragmentShader;
  const glVertexShader = WebGLShader(gl, gl.VERTEX_SHADER, vertexGlsl);
  const glFragmentShader = WebGLShader(gl, gl.FRAGMENT_SHADER, fragmentGlsl);
  gl.attachShader(program, glVertexShader);
  gl.attachShader(program, glFragmentShader);
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName);
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, "position");
  }
  gl.linkProgram(program);
  function onFirstUse(self2) {
    if (renderer.debug.checkShaderErrors) {
      const programInfoLog = gl.getProgramInfoLog(program) || "";
      const vertexShaderInfoLog = gl.getShaderInfoLog(glVertexShader) || "";
      const fragmentShaderInfoLog = gl.getShaderInfoLog(glFragmentShader) || "";
      const programLog = programInfoLog.trim();
      const vertexLog = vertexShaderInfoLog.trim();
      const fragmentLog = fragmentShaderInfoLog.trim();
      let runnable = true;
      let haveDiagnostics = true;
      if (gl.getProgramParameter(program, gl.LINK_STATUS) === false) {
        runnable = false;
        if (typeof renderer.debug.onShaderError === "function") {
          renderer.debug.onShaderError(gl, program, glVertexShader, glFragmentShader);
        } else {
          const vertexErrors = getShaderErrors(gl, glVertexShader, "vertex");
          const fragmentErrors = getShaderErrors(gl, glFragmentShader, "fragment");
          error(
            "THREE.WebGLProgram: Shader Error " + gl.getError() + " - VALIDATE_STATUS " + gl.getProgramParameter(program, gl.VALIDATE_STATUS) + "\n\nMaterial Name: " + self2.name + "\nMaterial Type: " + self2.type + "\n\nProgram Info Log: " + programLog + "\n" + vertexErrors + "\n" + fragmentErrors
          );
        }
      } else if (programLog !== "") {
        warn("WebGLProgram: Program Info Log:", programLog);
      } else if (vertexLog === "" || fragmentLog === "") {
        haveDiagnostics = false;
      }
      if (haveDiagnostics) {
        self2.diagnostics = {
          runnable,
          programLog,
          vertexShader: {
            log: vertexLog,
            prefix: prefixVertex
          },
          fragmentShader: {
            log: fragmentLog,
            prefix: prefixFragment
          }
        };
      }
    }
    gl.deleteShader(glVertexShader);
    gl.deleteShader(glFragmentShader);
    cachedUniforms = new WebGLUniforms(gl, program);
    cachedAttributes = fetchAttributeLocations(gl, program);
  }
  let cachedUniforms;
  this.getUniforms = function() {
    if (cachedUniforms === void 0) {
      onFirstUse(this);
    }
    return cachedUniforms;
  };
  let cachedAttributes;
  this.getAttributes = function() {
    if (cachedAttributes === void 0) {
      onFirstUse(this);
    }
    return cachedAttributes;
  };
  let programReady = parameters.rendererExtensionParallelShaderCompile === false;
  this.isReady = function() {
    if (programReady === false) {
      programReady = gl.getProgramParameter(program, COMPLETION_STATUS_KHR);
    }
    return programReady;
  };
  this.destroy = function() {
    bindingStates.releaseStatesOfProgram(this);
    gl.deleteProgram(program);
    this.program = void 0;
  };
  this.type = parameters.shaderType;
  this.name = parameters.shaderName;
  this.id = programIdCount++;
  this.cacheKey = cacheKey;
  this.usedTimes = 1;
  this.program = program;
  this.vertexShader = glVertexShader;
  this.fragmentShader = glFragmentShader;
  return this;
}
var _id = 0;
var WebGLShaderCache = class {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map();
    this.materialCache = /* @__PURE__ */ new Map();
  }
  update(material) {
    const vertexShader = material.vertexShader;
    const fragmentShader = material.fragmentShader;
    const vertexShaderStage = this._getShaderStage(vertexShader);
    const fragmentShaderStage = this._getShaderStage(fragmentShader);
    const materialShaders = this._getShaderCacheForMaterial(material);
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage);
      vertexShaderStage.usedTimes++;
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage);
      fragmentShaderStage.usedTimes++;
    }
    return this;
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material);
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--;
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code);
    }
    this.materialCache.delete(material);
    return this;
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id;
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear();
    this.materialCache.clear();
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache;
    let set = cache.get(material);
    if (set === void 0) {
      set = /* @__PURE__ */ new Set();
      cache.set(material, set);
    }
    return set;
  }
  _getShaderStage(code) {
    const cache = this.shaderCache;
    let stage = cache.get(code);
    if (stage === void 0) {
      stage = new WebGLShaderStage(code);
      cache.set(code, stage);
    }
    return stage;
  }
};
var WebGLShaderStage = class {
  constructor(code) {
    this.id = _id++;
    this.code = code;
    this.usedTimes = 0;
  }
};
function WebGLPrograms(renderer, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping) {
  const _programLayers = new Layers();
  const _customShaders = new WebGLShaderCache();
  const _activeChannels = /* @__PURE__ */ new Set();
  const programs = [];
  const programsMap = /* @__PURE__ */ new Map();
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
  let precision = capabilities.precision;
  const shaderIDs = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distance",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite"
  };
  function getChannel(value) {
    _activeChannels.add(value);
    if (value === 0) return "uv";
    return `uv${value}`;
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog;
    const geometry = object.geometry;
    const environment = material.isMeshStandardMaterial ? scene.environment : null;
    const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
    const envMapCubeUVHeight = !!envMap && envMap.mapping === CubeUVReflectionMapping ? envMap.image.height : null;
    const shaderID = shaderIDs[material.type];
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision);
      if (precision !== material.precision) {
        warn("WebGLProgram.getParameters:", material.precision, "not supported, using", precision, "instead.");
      }
    }
    const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
    let morphTextureStride = 0;
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1;
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2;
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3;
    let vertexShader, fragmentShader;
    let customVertexShaderID, customFragmentShaderID;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      vertexShader = shader.vertexShader;
      fragmentShader = shader.fragmentShader;
    } else {
      vertexShader = material.vertexShader;
      fragmentShader = material.fragmentShader;
      _customShaders.update(material);
      customVertexShaderID = _customShaders.getVertexShaderID(material);
      customFragmentShaderID = _customShaders.getFragmentShaderID(material);
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();
    const IS_INSTANCEDMESH = object.isInstancedMesh === true;
    const IS_BATCHEDMESH = object.isBatchedMesh === true;
    const HAS_MAP = !!material.map;
    const HAS_MATCAP = !!material.matcap;
    const HAS_ENVMAP = !!envMap;
    const HAS_AOMAP = !!material.aoMap;
    const HAS_LIGHTMAP = !!material.lightMap;
    const HAS_BUMPMAP = !!material.bumpMap;
    const HAS_NORMALMAP = !!material.normalMap;
    const HAS_DISPLACEMENTMAP = !!material.displacementMap;
    const HAS_EMISSIVEMAP = !!material.emissiveMap;
    const HAS_METALNESSMAP = !!material.metalnessMap;
    const HAS_ROUGHNESSMAP = !!material.roughnessMap;
    const HAS_ANISOTROPY = material.anisotropy > 0;
    const HAS_CLEARCOAT = material.clearcoat > 0;
    const HAS_DISPERSION = material.dispersion > 0;
    const HAS_IRIDESCENCE = material.iridescence > 0;
    const HAS_SHEEN = material.sheen > 0;
    const HAS_TRANSMISSION = material.transmission > 0;
    const HAS_ANISOTROPYMAP = HAS_ANISOTROPY && !!material.anisotropyMap;
    const HAS_CLEARCOATMAP = HAS_CLEARCOAT && !!material.clearcoatMap;
    const HAS_CLEARCOAT_NORMALMAP = HAS_CLEARCOAT && !!material.clearcoatNormalMap;
    const HAS_CLEARCOAT_ROUGHNESSMAP = HAS_CLEARCOAT && !!material.clearcoatRoughnessMap;
    const HAS_IRIDESCENCEMAP = HAS_IRIDESCENCE && !!material.iridescenceMap;
    const HAS_IRIDESCENCE_THICKNESSMAP = HAS_IRIDESCENCE && !!material.iridescenceThicknessMap;
    const HAS_SHEEN_COLORMAP = HAS_SHEEN && !!material.sheenColorMap;
    const HAS_SHEEN_ROUGHNESSMAP = HAS_SHEEN && !!material.sheenRoughnessMap;
    const HAS_SPECULARMAP = !!material.specularMap;
    const HAS_SPECULAR_COLORMAP = !!material.specularColorMap;
    const HAS_SPECULAR_INTENSITYMAP = !!material.specularIntensityMap;
    const HAS_TRANSMISSIONMAP = HAS_TRANSMISSION && !!material.transmissionMap;
    const HAS_THICKNESSMAP = HAS_TRANSMISSION && !!material.thicknessMap;
    const HAS_GRADIENTMAP = !!material.gradientMap;
    const HAS_ALPHAMAP = !!material.alphaMap;
    const HAS_ALPHATEST = material.alphaTest > 0;
    const HAS_ALPHAHASH = !!material.alphaHash;
    const HAS_EXTENSIONS = !!material.extensions;
    let toneMapping = NoToneMapping;
    if (material.toneMapped) {
      if (currentRenderTarget === null || currentRenderTarget.isXRRenderTarget === true) {
        toneMapping = renderer.toneMapping;
      }
    }
    const parameters = {
      shaderID,
      shaderType: material.type,
      shaderName: material.name,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      batching: IS_BATCHEDMESH,
      batchingColor: IS_BATCHEDMESH && object._colorsTexture !== null,
      instancing: IS_INSTANCEDMESH,
      instancingColor: IS_INSTANCEDMESH && object.instanceColor !== null,
      instancingMorph: IS_INSTANCEDMESH && object.morphTexture !== null,
      outputColorSpace: currentRenderTarget === null ? renderer.outputColorSpace : currentRenderTarget.isXRRenderTarget === true ? currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace,
      alphaToCoverage: !!material.alphaToCoverage,
      map: HAS_MAP,
      matcap: HAS_MATCAP,
      envMap: HAS_ENVMAP,
      envMapMode: HAS_ENVMAP && envMap.mapping,
      envMapCubeUVHeight,
      aoMap: HAS_AOMAP,
      lightMap: HAS_LIGHTMAP,
      bumpMap: HAS_BUMPMAP,
      normalMap: HAS_NORMALMAP,
      displacementMap: HAS_DISPLACEMENTMAP,
      emissiveMap: HAS_EMISSIVEMAP,
      normalMapObjectSpace: HAS_NORMALMAP && material.normalMapType === ObjectSpaceNormalMap,
      normalMapTangentSpace: HAS_NORMALMAP && material.normalMapType === TangentSpaceNormalMap,
      metalnessMap: HAS_METALNESSMAP,
      roughnessMap: HAS_ROUGHNESSMAP,
      anisotropy: HAS_ANISOTROPY,
      anisotropyMap: HAS_ANISOTROPYMAP,
      clearcoat: HAS_CLEARCOAT,
      clearcoatMap: HAS_CLEARCOATMAP,
      clearcoatNormalMap: HAS_CLEARCOAT_NORMALMAP,
      clearcoatRoughnessMap: HAS_CLEARCOAT_ROUGHNESSMAP,
      dispersion: HAS_DISPERSION,
      iridescence: HAS_IRIDESCENCE,
      iridescenceMap: HAS_IRIDESCENCEMAP,
      iridescenceThicknessMap: HAS_IRIDESCENCE_THICKNESSMAP,
      sheen: HAS_SHEEN,
      sheenColorMap: HAS_SHEEN_COLORMAP,
      sheenRoughnessMap: HAS_SHEEN_ROUGHNESSMAP,
      specularMap: HAS_SPECULARMAP,
      specularColorMap: HAS_SPECULAR_COLORMAP,
      specularIntensityMap: HAS_SPECULAR_INTENSITYMAP,
      transmission: HAS_TRANSMISSION,
      transmissionMap: HAS_TRANSMISSIONMAP,
      thicknessMap: HAS_THICKNESSMAP,
      gradientMap: HAS_GRADIENTMAP,
      opaque: material.transparent === false && material.blending === NormalBlending && material.alphaToCoverage === false,
      alphaMap: HAS_ALPHAMAP,
      alphaTest: HAS_ALPHATEST,
      alphaHash: HAS_ALPHAHASH,
      combine: material.combine,
      //
      mapUv: HAS_MAP && getChannel(material.map.channel),
      aoMapUv: HAS_AOMAP && getChannel(material.aoMap.channel),
      lightMapUv: HAS_LIGHTMAP && getChannel(material.lightMap.channel),
      bumpMapUv: HAS_BUMPMAP && getChannel(material.bumpMap.channel),
      normalMapUv: HAS_NORMALMAP && getChannel(material.normalMap.channel),
      displacementMapUv: HAS_DISPLACEMENTMAP && getChannel(material.displacementMap.channel),
      emissiveMapUv: HAS_EMISSIVEMAP && getChannel(material.emissiveMap.channel),
      metalnessMapUv: HAS_METALNESSMAP && getChannel(material.metalnessMap.channel),
      roughnessMapUv: HAS_ROUGHNESSMAP && getChannel(material.roughnessMap.channel),
      anisotropyMapUv: HAS_ANISOTROPYMAP && getChannel(material.anisotropyMap.channel),
      clearcoatMapUv: HAS_CLEARCOATMAP && getChannel(material.clearcoatMap.channel),
      clearcoatNormalMapUv: HAS_CLEARCOAT_NORMALMAP && getChannel(material.clearcoatNormalMap.channel),
      clearcoatRoughnessMapUv: HAS_CLEARCOAT_ROUGHNESSMAP && getChannel(material.clearcoatRoughnessMap.channel),
      iridescenceMapUv: HAS_IRIDESCENCEMAP && getChannel(material.iridescenceMap.channel),
      iridescenceThicknessMapUv: HAS_IRIDESCENCE_THICKNESSMAP && getChannel(material.iridescenceThicknessMap.channel),
      sheenColorMapUv: HAS_SHEEN_COLORMAP && getChannel(material.sheenColorMap.channel),
      sheenRoughnessMapUv: HAS_SHEEN_ROUGHNESSMAP && getChannel(material.sheenRoughnessMap.channel),
      specularMapUv: HAS_SPECULARMAP && getChannel(material.specularMap.channel),
      specularColorMapUv: HAS_SPECULAR_COLORMAP && getChannel(material.specularColorMap.channel),
      specularIntensityMapUv: HAS_SPECULAR_INTENSITYMAP && getChannel(material.specularIntensityMap.channel),
      transmissionMapUv: HAS_TRANSMISSIONMAP && getChannel(material.transmissionMap.channel),
      thicknessMapUv: HAS_THICKNESSMAP && getChannel(material.thicknessMap.channel),
      alphaMapUv: HAS_ALPHAMAP && getChannel(material.alphaMap.channel),
      //
      vertexTangents: !!geometry.attributes.tangent && (HAS_NORMALMAP || HAS_ANISOTROPY),
      vertexColors: material.vertexColors,
      vertexAlphas: material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4,
      pointsUvs: object.isPoints === true && !!geometry.attributes.uv && (HAS_MAP || HAS_ALPHAMAP),
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: !!fog && fog.isFogExp2,
      flatShading: material.flatShading === true && material.wireframe === false,
      sizeAttenuation: material.sizeAttenuation === true,
      logarithmicDepthBuffer,
      reversedDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numSpotLightMaps: lights.spotLightMap.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numSpotLightShadowsWithMaps: lights.numSpotLightShadowsWithMaps,
      numLightProbes: lights.numLightProbes,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer.shadowMap.type,
      toneMapping,
      decodeVideoTexture: HAS_MAP && material.map.isVideoTexture === true && ColorManagement.getTransfer(material.map.colorSpace) === SRGBTransfer,
      decodeVideoTextureEmissive: HAS_EMISSIVEMAP && material.emissiveMap.isVideoTexture === true && ColorManagement.getTransfer(material.emissiveMap.colorSpace) === SRGBTransfer,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: material.depthPacking >= 0,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionClipCullDistance: HAS_EXTENSIONS && material.extensions.clipCullDistance === true && extensions.has("WEBGL_clip_cull_distance"),
      extensionMultiDraw: (HAS_EXTENSIONS && material.extensions.multiDraw === true || IS_BATCHEDMESH) && extensions.has("WEBGL_multi_draw"),
      rendererExtensionParallelShaderCompile: extensions.has("KHR_parallel_shader_compile"),
      customProgramCacheKey: material.customProgramCacheKey()
    };
    parameters.vertexUv1s = _activeChannels.has(1);
    parameters.vertexUv2s = _activeChannels.has(2);
    parameters.vertexUv3s = _activeChannels.has(3);
    _activeChannels.clear();
    return parameters;
  }
  function getProgramCacheKey(parameters) {
    const array = [];
    if (parameters.shaderID) {
      array.push(parameters.shaderID);
    } else {
      array.push(parameters.customVertexShaderID);
      array.push(parameters.customFragmentShaderID);
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name);
        array.push(parameters.defines[name]);
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters);
      getProgramCacheKeyBooleans(array, parameters);
      array.push(renderer.outputColorSpace);
    }
    array.push(parameters.customProgramCacheKey);
    return array.join();
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision);
    array.push(parameters.outputColorSpace);
    array.push(parameters.envMapMode);
    array.push(parameters.envMapCubeUVHeight);
    array.push(parameters.mapUv);
    array.push(parameters.alphaMapUv);
    array.push(parameters.lightMapUv);
    array.push(parameters.aoMapUv);
    array.push(parameters.bumpMapUv);
    array.push(parameters.normalMapUv);
    array.push(parameters.displacementMapUv);
    array.push(parameters.emissiveMapUv);
    array.push(parameters.metalnessMapUv);
    array.push(parameters.roughnessMapUv);
    array.push(parameters.anisotropyMapUv);
    array.push(parameters.clearcoatMapUv);
    array.push(parameters.clearcoatNormalMapUv);
    array.push(parameters.clearcoatRoughnessMapUv);
    array.push(parameters.iridescenceMapUv);
    array.push(parameters.iridescenceThicknessMapUv);
    array.push(parameters.sheenColorMapUv);
    array.push(parameters.sheenRoughnessMapUv);
    array.push(parameters.specularMapUv);
    array.push(parameters.specularColorMapUv);
    array.push(parameters.specularIntensityMapUv);
    array.push(parameters.transmissionMapUv);
    array.push(parameters.thicknessMapUv);
    array.push(parameters.combine);
    array.push(parameters.fogExp2);
    array.push(parameters.sizeAttenuation);
    array.push(parameters.morphTargetsCount);
    array.push(parameters.morphAttributeCount);
    array.push(parameters.numDirLights);
    array.push(parameters.numPointLights);
    array.push(parameters.numSpotLights);
    array.push(parameters.numSpotLightMaps);
    array.push(parameters.numHemiLights);
    array.push(parameters.numRectAreaLights);
    array.push(parameters.numDirLightShadows);
    array.push(parameters.numPointLightShadows);
    array.push(parameters.numSpotLightShadows);
    array.push(parameters.numSpotLightShadowsWithMaps);
    array.push(parameters.numLightProbes);
    array.push(parameters.shadowMapType);
    array.push(parameters.toneMapping);
    array.push(parameters.numClippingPlanes);
    array.push(parameters.numClipIntersection);
    array.push(parameters.depthPacking);
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll();
    if (parameters.instancing)
      _programLayers.enable(0);
    if (parameters.instancingColor)
      _programLayers.enable(1);
    if (parameters.instancingMorph)
      _programLayers.enable(2);
    if (parameters.matcap)
      _programLayers.enable(3);
    if (parameters.envMap)
      _programLayers.enable(4);
    if (parameters.normalMapObjectSpace)
      _programLayers.enable(5);
    if (parameters.normalMapTangentSpace)
      _programLayers.enable(6);
    if (parameters.clearcoat)
      _programLayers.enable(7);
    if (parameters.iridescence)
      _programLayers.enable(8);
    if (parameters.alphaTest)
      _programLayers.enable(9);
    if (parameters.vertexColors)
      _programLayers.enable(10);
    if (parameters.vertexAlphas)
      _programLayers.enable(11);
    if (parameters.vertexUv1s)
      _programLayers.enable(12);
    if (parameters.vertexUv2s)
      _programLayers.enable(13);
    if (parameters.vertexUv3s)
      _programLayers.enable(14);
    if (parameters.vertexTangents)
      _programLayers.enable(15);
    if (parameters.anisotropy)
      _programLayers.enable(16);
    if (parameters.alphaHash)
      _programLayers.enable(17);
    if (parameters.batching)
      _programLayers.enable(18);
    if (parameters.dispersion)
      _programLayers.enable(19);
    if (parameters.batchingColor)
      _programLayers.enable(20);
    if (parameters.gradientMap)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
    _programLayers.disableAll();
    if (parameters.fog)
      _programLayers.enable(0);
    if (parameters.useFog)
      _programLayers.enable(1);
    if (parameters.flatShading)
      _programLayers.enable(2);
    if (parameters.logarithmicDepthBuffer)
      _programLayers.enable(3);
    if (parameters.reversedDepthBuffer)
      _programLayers.enable(4);
    if (parameters.skinning)
      _programLayers.enable(5);
    if (parameters.morphTargets)
      _programLayers.enable(6);
    if (parameters.morphNormals)
      _programLayers.enable(7);
    if (parameters.morphColors)
      _programLayers.enable(8);
    if (parameters.premultipliedAlpha)
      _programLayers.enable(9);
    if (parameters.shadowMapEnabled)
      _programLayers.enable(10);
    if (parameters.doubleSided)
      _programLayers.enable(11);
    if (parameters.flipSided)
      _programLayers.enable(12);
    if (parameters.useDepthPacking)
      _programLayers.enable(13);
    if (parameters.dithering)
      _programLayers.enable(14);
    if (parameters.transmission)
      _programLayers.enable(15);
    if (parameters.sheen)
      _programLayers.enable(16);
    if (parameters.opaque)
      _programLayers.enable(17);
    if (parameters.pointsUvs)
      _programLayers.enable(18);
    if (parameters.decodeVideoTexture)
      _programLayers.enable(19);
    if (parameters.decodeVideoTextureEmissive)
      _programLayers.enable(20);
    if (parameters.alphaToCoverage)
      _programLayers.enable(21);
    array.push(_programLayers.mask);
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type];
    let uniforms;
    if (shaderID) {
      const shader = ShaderLib[shaderID];
      uniforms = UniformsUtils.clone(shader.uniforms);
    } else {
      uniforms = material.uniforms;
    }
    return uniforms;
  }
  function acquireProgram(parameters, cacheKey) {
    let program = programsMap.get(cacheKey);
    if (program !== void 0) {
      ++program.usedTimes;
    } else {
      program = new WebGLProgram(renderer, cacheKey, parameters, bindingStates);
      programs.push(program);
      programsMap.set(cacheKey, program);
    }
    return program;
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i2 = programs.indexOf(program);
      programs[i2] = programs[programs.length - 1];
      programs.pop();
      programsMap.delete(program.cacheKey);
      program.destroy();
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material);
  }
  function dispose2() {
    _customShaders.dispose();
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    // Exposed for resource monitoring & error feedback via renderer.info:
    programs,
    dispose: dispose2
  };
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap();
  function has(object) {
    return properties.has(object);
  }
  function get(object) {
    let map = properties.get(object);
    if (map === void 0) {
      map = {};
      properties.set(object, map);
    }
    return map;
  }
  function remove(object) {
    properties.delete(object);
  }
  function update(object, key, value) {
    properties.get(object)[key] = value;
  }
  function dispose2() {
    properties = /* @__PURE__ */ new WeakMap();
  }
  return {
    has,
    get,
    remove,
    update,
    dispose: dispose2
  };
}
function painterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.material.id !== b2.material.id) {
    return a2.material.id - b2.material.id;
  } else if (a2.z !== b2.z) {
    return a2.z - b2.z;
  } else {
    return a2.id - b2.id;
  }
}
function reversePainterSortStable(a2, b2) {
  if (a2.groupOrder !== b2.groupOrder) {
    return a2.groupOrder - b2.groupOrder;
  } else if (a2.renderOrder !== b2.renderOrder) {
    return a2.renderOrder - b2.renderOrder;
  } else if (a2.z !== b2.z) {
    return b2.z - a2.z;
  } else {
    return a2.id - b2.id;
  }
}
function WebGLRenderList() {
  const renderItems = [];
  let renderItemsIndex = 0;
  const opaque = [];
  const transmissive = [];
  const transparent = [];
  function init() {
    renderItemsIndex = 0;
    opaque.length = 0;
    transmissive.length = 0;
    transparent.length = 0;
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z2, group) {
    let renderItem = renderItems[renderItemsIndex];
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z: z2,
        group
      };
      renderItems[renderItemsIndex] = renderItem;
    } else {
      renderItem.id = object.id;
      renderItem.object = object;
      renderItem.geometry = geometry;
      renderItem.material = material;
      renderItem.groupOrder = groupOrder;
      renderItem.renderOrder = object.renderOrder;
      renderItem.z = z2;
      renderItem.group = group;
    }
    renderItemsIndex++;
    return renderItem;
  }
  function push(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.push(renderItem);
    } else if (material.transparent === true) {
      transparent.push(renderItem);
    } else {
      opaque.push(renderItem);
    }
  }
  function unshift(object, geometry, material, groupOrder, z2, group) {
    const renderItem = getNextRenderItem(object, geometry, material, groupOrder, z2, group);
    if (material.transmission > 0) {
      transmissive.unshift(renderItem);
    } else if (material.transparent === true) {
      transparent.unshift(renderItem);
    } else {
      opaque.unshift(renderItem);
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable);
    if (transmissive.length > 1) transmissive.sort(customTransparentSort || reversePainterSortStable);
    if (transparent.length > 1) transparent.sort(customTransparentSort || reversePainterSortStable);
  }
  function finish() {
    for (let i2 = renderItemsIndex, il = renderItems.length; i2 < il; i2++) {
      const renderItem = renderItems[i2];
      if (renderItem.id === null) break;
      renderItem.id = null;
      renderItem.object = null;
      renderItem.geometry = null;
      renderItem.material = null;
      renderItem.group = null;
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort
  };
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth) {
    const listArray = lists.get(scene);
    let list;
    if (listArray === void 0) {
      list = new WebGLRenderList();
      lists.set(scene, [list]);
    } else {
      if (renderCallDepth >= listArray.length) {
        list = new WebGLRenderList();
        listArray.push(list);
      } else {
        list = listArray[renderCallDepth];
      }
    }
    return list;
  }
  function dispose2() {
    lists = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
function UniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            direction: new Vector3(),
            color: new Color()
          };
          break;
        case "SpotLight":
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0
          };
          break;
        case "PointLight":
          uniforms = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0
          };
          break;
        case "HemisphereLight":
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color()
          };
          break;
        case "RectAreaLight":
          uniforms = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3()
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
function ShadowUniformsCache() {
  const lights = {};
  return {
    get: function(light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id];
      }
      let uniforms;
      switch (light.type) {
        case "DirectionalLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "SpotLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2()
          };
          break;
        case "PointLight":
          uniforms = {
            shadowIntensity: 1,
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3
          };
          break;
      }
      lights[light.id] = uniforms;
      return uniforms;
    }
  };
}
var nextVersion = 0;
function shadowCastingAndTexturingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 2 : 0) - (lightA.castShadow ? 2 : 0) + (lightB.map ? 1 : 0) - (lightA.map ? 1 : 0);
}
function WebGLLights(extensions) {
  const cache = new UniformsCache();
  const shadowCache = ShadowUniformsCache();
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
      numSpotMaps: -1,
      numLightProbes: -1
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotLightMap: [],
    spotShadow: [],
    spotShadowMap: [],
    spotLightMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
    numSpotLightShadowsWithMaps: 0,
    numLightProbes: 0
  };
  for (let i2 = 0; i2 < 9; i2++) state.probe.push(new Vector3());
  const vector3 = new Vector3();
  const matrix4 = new Matrix4();
  const matrix42 = new Matrix4();
  function setup(lights) {
    let r2 = 0, g2 = 0, b2 = 0;
    for (let i2 = 0; i2 < 9; i2++) state.probe[i2].set(0, 0, 0);
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    let numDirectionalShadows = 0;
    let numPointShadows = 0;
    let numSpotShadows = 0;
    let numSpotMaps = 0;
    let numSpotShadowsWithMaps = 0;
    let numLightProbes = 0;
    lights.sort(shadowCastingAndTexturingLightsFirst);
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      const color = light.color;
      const intensity = light.intensity;
      const distance = light.distance;
      let shadowMap = null;
      if (light.shadow && light.shadow.map) {
        if (light.shadow.map.texture.format === RGFormat) {
          shadowMap = light.shadow.map.texture;
        } else {
          shadowMap = light.shadow.map.depthTexture || light.shadow.map.texture;
        }
      }
      if (light.isAmbientLight) {
        r2 += color.r * intensity;
        g2 += color.g * intensity;
        b2 += color.b * intensity;
      } else if (light.isLightProbe) {
        for (let j2 = 0; j2 < 9; j2++) {
          state.probe[j2].addScaledVector(light.sh.coefficients[j2], intensity);
        }
        numLightProbes++;
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.directionalShadow[directionalLength] = shadowUniforms;
          state.directionalShadowMap[directionalLength] = shadowMap;
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix;
          numDirectionalShadows++;
        }
        state.directional[directionalLength] = uniforms;
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light);
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.distance = distance;
        uniforms.coneCos = Math.cos(light.angle);
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra));
        uniforms.decay = light.decay;
        state.spot[spotLength] = uniforms;
        const shadow = light.shadow;
        if (light.map) {
          state.spotLightMap[numSpotMaps] = light.map;
          numSpotMaps++;
          shadow.updateMatrices(light);
          if (light.castShadow) numSpotShadowsWithMaps++;
        }
        state.spotLightMatrix[spotLength] = shadow.matrix;
        if (light.castShadow) {
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          state.spotShadow[spotLength] = shadowUniforms;
          state.spotShadowMap[spotLength] = shadowMap;
          numSpotShadows++;
        }
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(color).multiplyScalar(intensity);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        state.rectArea[rectAreaLength] = uniforms;
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = cache.get(light);
        uniforms.color.copy(light.color).multiplyScalar(light.intensity);
        uniforms.distance = light.distance;
        uniforms.decay = light.decay;
        if (light.castShadow) {
          const shadow = light.shadow;
          const shadowUniforms = shadowCache.get(light);
          shadowUniforms.shadowIntensity = shadow.intensity;
          shadowUniforms.shadowBias = shadow.bias;
          shadowUniforms.shadowNormalBias = shadow.normalBias;
          shadowUniforms.shadowRadius = shadow.radius;
          shadowUniforms.shadowMapSize = shadow.mapSize;
          shadowUniforms.shadowCameraNear = shadow.camera.near;
          shadowUniforms.shadowCameraFar = shadow.camera.far;
          state.pointShadow[pointLength] = shadowUniforms;
          state.pointShadowMap[pointLength] = shadowMap;
          state.pointShadowMatrix[pointLength] = light.shadow.matrix;
          numPointShadows++;
        }
        state.point[pointLength] = uniforms;
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light);
        uniforms.skyColor.copy(light.color).multiplyScalar(intensity);
        uniforms.groundColor.copy(light.groundColor).multiplyScalar(intensity);
        state.hemi[hemiLength] = uniforms;
        hemiLength++;
      }
    }
    if (rectAreaLength > 0) {
      if (extensions.has("OES_texture_float_linear") === true) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1;
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2;
      } else {
        state.rectAreaLTC1 = UniformsLib.LTC_HALF_1;
        state.rectAreaLTC2 = UniformsLib.LTC_HALF_2;
      }
    }
    state.ambient[0] = r2;
    state.ambient[1] = g2;
    state.ambient[2] = b2;
    const hash = state.hash;
    if (hash.directionalLength !== directionalLength || hash.pointLength !== pointLength || hash.spotLength !== spotLength || hash.rectAreaLength !== rectAreaLength || hash.hemiLength !== hemiLength || hash.numDirectionalShadows !== numDirectionalShadows || hash.numPointShadows !== numPointShadows || hash.numSpotShadows !== numSpotShadows || hash.numSpotMaps !== numSpotMaps || hash.numLightProbes !== numLightProbes) {
      state.directional.length = directionalLength;
      state.spot.length = spotLength;
      state.rectArea.length = rectAreaLength;
      state.point.length = pointLength;
      state.hemi.length = hemiLength;
      state.directionalShadow.length = numDirectionalShadows;
      state.directionalShadowMap.length = numDirectionalShadows;
      state.pointShadow.length = numPointShadows;
      state.pointShadowMap.length = numPointShadows;
      state.spotShadow.length = numSpotShadows;
      state.spotShadowMap.length = numSpotShadows;
      state.directionalShadowMatrix.length = numDirectionalShadows;
      state.pointShadowMatrix.length = numPointShadows;
      state.spotLightMatrix.length = numSpotShadows + numSpotMaps - numSpotShadowsWithMaps;
      state.spotLightMap.length = numSpotMaps;
      state.numSpotLightShadowsWithMaps = numSpotShadowsWithMaps;
      state.numLightProbes = numLightProbes;
      hash.directionalLength = directionalLength;
      hash.pointLength = pointLength;
      hash.spotLength = spotLength;
      hash.rectAreaLength = rectAreaLength;
      hash.hemiLength = hemiLength;
      hash.numDirectionalShadows = numDirectionalShadows;
      hash.numPointShadows = numPointShadows;
      hash.numSpotShadows = numSpotShadows;
      hash.numSpotMaps = numSpotMaps;
      hash.numLightProbes = numLightProbes;
      state.version = nextVersion++;
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0;
    let pointLength = 0;
    let spotLength = 0;
    let rectAreaLength = 0;
    let hemiLength = 0;
    const viewMatrix = camera.matrixWorldInverse;
    for (let i2 = 0, l2 = lights.length; i2 < l2; i2++) {
      const light = lights[i2];
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        directionalLength++;
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        vector3.setFromMatrixPosition(light.target.matrixWorld);
        uniforms.direction.sub(vector3);
        uniforms.direction.transformDirection(viewMatrix);
        spotLength++;
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        matrix42.identity();
        matrix4.copy(light.matrixWorld);
        matrix4.premultiply(viewMatrix);
        matrix42.extractRotation(matrix4);
        uniforms.halfWidth.set(light.width * 0.5, 0, 0);
        uniforms.halfHeight.set(0, light.height * 0.5, 0);
        uniforms.halfWidth.applyMatrix4(matrix42);
        uniforms.halfHeight.applyMatrix4(matrix42);
        rectAreaLength++;
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength];
        uniforms.position.setFromMatrixPosition(light.matrixWorld);
        uniforms.position.applyMatrix4(viewMatrix);
        pointLength++;
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength];
        uniforms.direction.setFromMatrixPosition(light.matrixWorld);
        uniforms.direction.transformDirection(viewMatrix);
        hemiLength++;
      }
    }
  }
  return {
    setup,
    setupView,
    state
  };
}
function WebGLRenderState(extensions) {
  const lights = new WebGLLights(extensions);
  const lightsArray = [];
  const shadowsArray = [];
  function init(camera) {
    state.camera = camera;
    lightsArray.length = 0;
    shadowsArray.length = 0;
  }
  function pushLight(light) {
    lightsArray.push(light);
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight);
  }
  function setupLights() {
    lights.setup(lightsArray);
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera);
  }
  const state = {
    lightsArray,
    shadowsArray,
    camera: null,
    lights,
    transmissionRenderTarget: {}
  };
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow
  };
}
function WebGLRenderStates(extensions) {
  let renderStates = /* @__PURE__ */ new WeakMap();
  function get(scene, renderCallDepth = 0) {
    const renderStateArray = renderStates.get(scene);
    let renderState;
    if (renderStateArray === void 0) {
      renderState = new WebGLRenderState(extensions);
      renderStates.set(scene, [renderState]);
    } else {
      if (renderCallDepth >= renderStateArray.length) {
        renderState = new WebGLRenderState(extensions);
        renderStateArray.push(renderState);
      } else {
        renderState = renderStateArray[renderCallDepth];
      }
    }
    return renderState;
  }
  function dispose2() {
    renderStates = /* @__PURE__ */ new WeakMap();
  }
  return {
    get,
    dispose: dispose2
  };
}
var vertex = "void main() {\n	gl_Position = vec4( position, 1.0 );\n}";
var fragment = "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ).rg;\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ).r;\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( max( 0.0, squared_mean - mean * mean ) );\n	gl_FragColor = vec4( mean, std_dev, 0.0, 1.0 );\n}";
var _cubeDirections = [
  /* @__PURE__ */ new Vector3(1, 0, 0),
  /* @__PURE__ */ new Vector3(-1, 0, 0),
  /* @__PURE__ */ new Vector3(0, 1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, 0, -1)
];
var _cubeUps = [
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, 0, 1),
  /* @__PURE__ */ new Vector3(0, 0, -1),
  /* @__PURE__ */ new Vector3(0, -1, 0),
  /* @__PURE__ */ new Vector3(0, -1, 0)
];
var _projScreenMatrix2 = /* @__PURE__ */ new Matrix4();
var _lightPositionWorld2 = /* @__PURE__ */ new Vector3();
var _lookTarget2 = /* @__PURE__ */ new Vector3();
function WebGLShadowMap(renderer, objects, capabilities) {
  let _frustum = new Frustum();
  const _shadowMapSize = new Vector2(), _viewportSize = new Vector2(), _viewport = new Vector4(), _depthMaterial = new MeshDepthMaterial(), _distanceMaterial = new MeshDistanceMaterial(), _materialCache = {}, _maxTextureSize = capabilities.maxTextureSize;
  const shadowSide = { [FrontSide]: BackSide, [BackSide]: FrontSide, [DoubleSide]: DoubleSide };
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 }
    },
    vertexShader: vertex,
    fragmentShader: fragment
  });
  const shadowMaterialHorizontal = shadowMaterialVertical.clone();
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1;
  const fullScreenTri = new BufferGeometry();
  fullScreenTri.setAttribute(
    "position",
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3
    )
  );
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical);
  const scope = this;
  this.enabled = false;
  this.autoUpdate = true;
  this.needsUpdate = false;
  this.type = PCFShadowMap;
  let _previousType = this.type;
  this.render = function(lights, scene, camera) {
    if (scope.enabled === false) return;
    if (scope.autoUpdate === false && scope.needsUpdate === false) return;
    if (lights.length === 0) return;
    if (lights.type === PCFSoftShadowMap) {
      warn("WebGLShadowMap: PCFSoftShadowMap has been deprecated. Using PCFShadowMap instead.");
      lights.type = PCFShadowMap;
    }
    const currentRenderTarget = renderer.getRenderTarget();
    const activeCubeFace = renderer.getActiveCubeFace();
    const activeMipmapLevel = renderer.getActiveMipmapLevel();
    const _state = renderer.state;
    _state.setBlending(NoBlending);
    if (_state.buffers.depth.getReversed() === true) {
      _state.buffers.color.setClear(0, 0, 0, 0);
    } else {
      _state.buffers.color.setClear(1, 1, 1, 1);
    }
    _state.buffers.depth.setTest(true);
    _state.setScissorTest(false);
    const typeChanged = _previousType !== this.type;
    if (typeChanged) {
      scene.traverse(function(object) {
        if (object.material) {
          if (Array.isArray(object.material)) {
            object.material.forEach((mat) => mat.needsUpdate = true);
          } else {
            object.material.needsUpdate = true;
          }
        }
      });
    }
    for (let i2 = 0, il = lights.length; i2 < il; i2++) {
      const light = lights[i2];
      const shadow = light.shadow;
      if (shadow === void 0) {
        warn("WebGLShadowMap:", light, "has no shadow.");
        continue;
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue;
      _shadowMapSize.copy(shadow.mapSize);
      const shadowFrameExtents = shadow.getFrameExtents();
      _shadowMapSize.multiply(shadowFrameExtents);
      _viewportSize.copy(shadow.mapSize);
      if (_shadowMapSize.x > _maxTextureSize || _shadowMapSize.y > _maxTextureSize) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x);
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x;
          shadow.mapSize.x = _viewportSize.x;
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y);
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y;
          shadow.mapSize.y = _viewportSize.y;
        }
      }
      if (shadow.map === null || typeChanged === true) {
        if (shadow.map !== null) {
          if (shadow.map.depthTexture !== null) {
            shadow.map.depthTexture.dispose();
            shadow.map.depthTexture = null;
          }
          shadow.map.dispose();
        }
        if (this.type === VSMShadowMap) {
          if (light.isPointLight) {
            warn("WebGLShadowMap: VSM shadow maps are not supported for PointLights. Use PCF or BasicShadowMap instead.");
            continue;
          }
          shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, {
            format: RGFormat,
            type: HalfFloatType,
            minFilter: LinearFilter,
            magFilter: LinearFilter,
            generateMipmaps: false
          });
          shadow.map.texture.name = light.name + ".shadowMap";
          shadow.map.depthTexture = new DepthTexture(_shadowMapSize.x, _shadowMapSize.y, FloatType);
          shadow.map.depthTexture.name = light.name + ".shadowMapDepth";
          shadow.map.depthTexture.format = DepthFormat;
          shadow.map.depthTexture.compareFunction = null;
          shadow.map.depthTexture.minFilter = NearestFilter;
          shadow.map.depthTexture.magFilter = NearestFilter;
        } else {
          if (light.isPointLight) {
            shadow.map = new WebGLCubeRenderTarget(_shadowMapSize.x);
            shadow.map.depthTexture = new CubeDepthTexture(_shadowMapSize.x, UnsignedIntType);
          } else {
            shadow.map = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y);
            shadow.map.depthTexture = new DepthTexture(_shadowMapSize.x, _shadowMapSize.y, UnsignedIntType);
          }
          shadow.map.depthTexture.name = light.name + ".shadowMap";
          shadow.map.depthTexture.format = DepthFormat;
          const reversedDepthBuffer = renderer.state.buffers.depth.getReversed();
          if (this.type === PCFShadowMap) {
            shadow.map.depthTexture.compareFunction = reversedDepthBuffer ? GreaterEqualCompare : LessEqualCompare;
            shadow.map.depthTexture.minFilter = LinearFilter;
            shadow.map.depthTexture.magFilter = LinearFilter;
          } else {
            shadow.map.depthTexture.compareFunction = null;
            shadow.map.depthTexture.minFilter = NearestFilter;
            shadow.map.depthTexture.magFilter = NearestFilter;
          }
        }
        shadow.camera.updateProjectionMatrix();
      }
      const faceCount = shadow.map.isWebGLCubeRenderTarget ? 6 : 1;
      for (let face = 0; face < faceCount; face++) {
        if (shadow.map.isWebGLCubeRenderTarget) {
          renderer.setRenderTarget(shadow.map, face);
          renderer.clear();
        } else {
          if (face === 0) {
            renderer.setRenderTarget(shadow.map);
            renderer.clear();
          }
          const viewport = shadow.getViewport(face);
          _viewport.set(
            _viewportSize.x * viewport.x,
            _viewportSize.y * viewport.y,
            _viewportSize.x * viewport.z,
            _viewportSize.y * viewport.w
          );
          _state.viewport(_viewport);
        }
        if (light.isPointLight) {
          const camera2 = shadow.camera;
          const shadowMatrix = shadow.matrix;
          const far = light.distance || camera2.far;
          if (far !== camera2.far) {
            camera2.far = far;
            camera2.updateProjectionMatrix();
          }
          _lightPositionWorld2.setFromMatrixPosition(light.matrixWorld);
          camera2.position.copy(_lightPositionWorld2);
          _lookTarget2.copy(camera2.position);
          _lookTarget2.add(_cubeDirections[face]);
          camera2.up.copy(_cubeUps[face]);
          camera2.lookAt(_lookTarget2);
          camera2.updateMatrixWorld();
          shadowMatrix.makeTranslation(-_lightPositionWorld2.x, -_lightPositionWorld2.y, -_lightPositionWorld2.z);
          _projScreenMatrix2.multiplyMatrices(camera2.projectionMatrix, camera2.matrixWorldInverse);
          shadow._frustum.setFromProjectionMatrix(_projScreenMatrix2, camera2.coordinateSystem, camera2.reversedDepth);
        } else {
          shadow.updateMatrices(light);
        }
        _frustum = shadow.getFrustum();
        renderObject(scene, camera, shadow.camera, light, this.type);
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera);
      }
      shadow.needsUpdate = false;
    }
    _previousType = this.type;
    scope.needsUpdate = false;
    renderer.setRenderTarget(currentRenderTarget, activeCubeFace, activeMipmapLevel);
  };
  function VSMPass(shadow, camera) {
    const geometry = objects.update(fullScreenMesh);
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples;
      shadowMaterialVertical.needsUpdate = true;
      shadowMaterialHorizontal.needsUpdate = true;
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y, {
        format: RGFormat,
        type: HalfFloatType
      });
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.depthTexture;
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialVertical.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.mapPass);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialVertical, fullScreenMesh, null);
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture;
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize;
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius;
    renderer.setRenderTarget(shadow.map);
    renderer.clear();
    renderer.renderBufferDirect(camera, null, geometry, shadowMaterialHorizontal, fullScreenMesh, null);
  }
  function getDepthMaterial(object, material, light, type) {
    let result = null;
    const customMaterial = light.isPointLight === true ? object.customDistanceMaterial : object.customDepthMaterial;
    if (customMaterial !== void 0) {
      result = customMaterial;
    } else {
      result = light.isPointLight === true ? _distanceMaterial : _depthMaterial;
      if (renderer.localClippingEnabled && material.clipShadows === true && Array.isArray(material.clippingPlanes) && material.clippingPlanes.length !== 0 || material.displacementMap && material.displacementScale !== 0 || material.alphaMap && material.alphaTest > 0 || material.map && material.alphaTest > 0 || material.alphaToCoverage === true) {
        const keyA = result.uuid, keyB = material.uuid;
        let materialsForVariant = _materialCache[keyA];
        if (materialsForVariant === void 0) {
          materialsForVariant = {};
          _materialCache[keyA] = materialsForVariant;
        }
        let cachedMaterial = materialsForVariant[keyB];
        if (cachedMaterial === void 0) {
          cachedMaterial = result.clone();
          materialsForVariant[keyB] = cachedMaterial;
          material.addEventListener("dispose", onMaterialDispose);
        }
        result = cachedMaterial;
      }
    }
    result.visible = material.visible;
    result.wireframe = material.wireframe;
    if (type === VSMShadowMap) {
      result.side = material.shadowSide !== null ? material.shadowSide : material.side;
    } else {
      result.side = material.shadowSide !== null ? material.shadowSide : shadowSide[material.side];
    }
    result.alphaMap = material.alphaMap;
    result.alphaTest = material.alphaToCoverage === true ? 0.5 : material.alphaTest;
    result.map = material.map;
    result.clipShadows = material.clipShadows;
    result.clippingPlanes = material.clippingPlanes;
    result.clipIntersection = material.clipIntersection;
    result.displacementMap = material.displacementMap;
    result.displacementScale = material.displacementScale;
    result.displacementBias = material.displacementBias;
    result.wireframeLinewidth = material.wireframeLinewidth;
    result.linewidth = material.linewidth;
    if (light.isPointLight === true && result.isMeshDistanceMaterial === true) {
      const materialProperties = renderer.properties.get(result);
      materialProperties.light = light;
    }
    return result;
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return;
    const visible = object.layers.test(camera.layers);
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if ((object.castShadow || object.receiveShadow && type === VSMShadowMap) && (!object.frustumCulled || _frustum.intersectsObject(object))) {
        object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse, object.matrixWorld);
        const geometry = objects.update(object);
        const material = object.material;
        if (Array.isArray(material)) {
          const groups = geometry.groups;
          for (let k2 = 0, kl = groups.length; k2 < kl; k2++) {
            const group = groups[k2];
            const groupMaterial = material[group.materialIndex];
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(object, groupMaterial, light, type);
              object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
              renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, group);
              object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, group);
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(object, material, light, type);
          object.onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
          renderer.renderBufferDirect(shadowCamera, null, geometry, depthMaterial, object, null);
          object.onAfterShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial, null);
        }
      }
    }
    const children = object.children;
    for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
      renderObject(children[i2], camera, shadowCamera, light, type);
    }
  }
  function onMaterialDispose(event) {
    const material = event.target;
    material.removeEventListener("dispose", onMaterialDispose);
    for (const id in _materialCache) {
      const cache = _materialCache[id];
      const uuid = event.target.uuid;
      if (uuid in cache) {
        const shadowMaterial = cache[uuid];
        shadowMaterial.dispose();
        delete cache[uuid];
      }
    }
  }
}
var reversedFuncs = {
  [NeverDepth]: AlwaysDepth,
  [LessDepth]: GreaterDepth,
  [EqualDepth]: NotEqualDepth,
  [LessEqualDepth]: GreaterEqualDepth,
  [AlwaysDepth]: NeverDepth,
  [GreaterDepth]: LessDepth,
  [NotEqualDepth]: EqualDepth,
  [GreaterEqualDepth]: LessEqualDepth
};
function WebGLState(gl, extensions) {
  function ColorBuffer() {
    let locked = false;
    const color = new Vector4();
    let currentColorMask = null;
    const currentColorClear = new Vector4(0, 0, 0, 0);
    return {
      setMask: function(colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          currentColorMask = colorMask;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(r2, g2, b2, a2, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r2 *= a2;
          g2 *= a2;
          b2 *= a2;
        }
        color.set(r2, g2, b2, a2);
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r2, g2, b2, a2);
          currentColorClear.copy(color);
        }
      },
      reset: function() {
        locked = false;
        currentColorMask = null;
        currentColorClear.set(-1, 0, 0, 0);
      }
    };
  }
  function DepthBuffer() {
    let locked = false;
    let currentReversed = false;
    let currentDepthMask = null;
    let currentDepthFunc = null;
    let currentDepthClear = null;
    return {
      setReversed: function(reversed) {
        if (currentReversed !== reversed) {
          const ext = extensions.get("EXT_clip_control");
          if (reversed) {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.ZERO_TO_ONE_EXT);
          } else {
            ext.clipControlEXT(ext.LOWER_LEFT_EXT, ext.NEGATIVE_ONE_TO_ONE_EXT);
          }
          currentReversed = reversed;
          const oldDepth = currentDepthClear;
          currentDepthClear = null;
          this.setClear(oldDepth);
        }
      },
      getReversed: function() {
        return currentReversed;
      },
      setTest: function(depthTest) {
        if (depthTest) {
          enable(gl.DEPTH_TEST);
        } else {
          disable(gl.DEPTH_TEST);
        }
      },
      setMask: function(depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask);
          currentDepthMask = depthMask;
        }
      },
      setFunc: function(depthFunc) {
        if (currentReversed) depthFunc = reversedFuncs[depthFunc];
        if (currentDepthFunc !== depthFunc) {
          switch (depthFunc) {
            case NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          currentDepthFunc = depthFunc;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(depth) {
        if (currentDepthClear !== depth) {
          if (currentReversed) {
            depth = 1 - depth;
          }
          gl.clearDepth(depth);
          currentDepthClear = depth;
        }
      },
      reset: function() {
        locked = false;
        currentDepthMask = null;
        currentDepthFunc = null;
        currentDepthClear = null;
        currentReversed = false;
      }
    };
  }
  function StencilBuffer() {
    let locked = false;
    let currentStencilMask = null;
    let currentStencilFunc = null;
    let currentStencilRef = null;
    let currentStencilFuncMask = null;
    let currentStencilFail = null;
    let currentStencilZFail = null;
    let currentStencilZPass = null;
    let currentStencilClear = null;
    return {
      setTest: function(stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(gl.STENCIL_TEST);
          } else {
            disable(gl.STENCIL_TEST);
          }
        }
      },
      setMask: function(stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask);
          currentStencilMask = stencilMask;
        }
      },
      setFunc: function(stencilFunc, stencilRef, stencilMask) {
        if (currentStencilFunc !== stencilFunc || currentStencilRef !== stencilRef || currentStencilFuncMask !== stencilMask) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          currentStencilFunc = stencilFunc;
          currentStencilRef = stencilRef;
          currentStencilFuncMask = stencilMask;
        }
      },
      setOp: function(stencilFail, stencilZFail, stencilZPass) {
        if (currentStencilFail !== stencilFail || currentStencilZFail !== stencilZFail || currentStencilZPass !== stencilZPass) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          currentStencilFail = stencilFail;
          currentStencilZFail = stencilZFail;
          currentStencilZPass = stencilZPass;
        }
      },
      setLocked: function(lock) {
        locked = lock;
      },
      setClear: function(stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil);
          currentStencilClear = stencil;
        }
      },
      reset: function() {
        locked = false;
        currentStencilMask = null;
        currentStencilFunc = null;
        currentStencilRef = null;
        currentStencilFuncMask = null;
        currentStencilFail = null;
        currentStencilZFail = null;
        currentStencilZPass = null;
        currentStencilClear = null;
      }
    };
  }
  const colorBuffer = new ColorBuffer();
  const depthBuffer = new DepthBuffer();
  const stencilBuffer = new StencilBuffer();
  const uboBindings = /* @__PURE__ */ new WeakMap();
  const uboProgramMap = /* @__PURE__ */ new WeakMap();
  let enabledCapabilities = {};
  let currentBoundFramebuffers = {};
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap();
  let defaultDrawbuffers = [];
  let currentProgram = null;
  let currentBlendingEnabled = false;
  let currentBlending = null;
  let currentBlendEquation = null;
  let currentBlendSrc = null;
  let currentBlendDst = null;
  let currentBlendEquationAlpha = null;
  let currentBlendSrcAlpha = null;
  let currentBlendDstAlpha = null;
  let currentBlendColor = new Color(0, 0, 0);
  let currentBlendAlpha = 0;
  let currentPremultipledAlpha = false;
  let currentFlipSided = null;
  let currentCullFace = null;
  let currentLineWidth = null;
  let currentPolygonOffsetFactor = null;
  let currentPolygonOffsetUnits = null;
  const maxTextures = gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let lineWidthAvailable = false;
  let version = 0;
  const glVersion = gl.getParameter(gl.VERSION);
  if (glVersion.indexOf("WebGL") !== -1) {
    version = parseFloat(/^WebGL (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 1;
  } else if (glVersion.indexOf("OpenGL ES") !== -1) {
    version = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1]);
    lineWidthAvailable = version >= 2;
  }
  let currentTextureSlot = null;
  let currentBoundTextures = {};
  const scissorParam = gl.getParameter(gl.SCISSOR_BOX);
  const viewportParam = gl.getParameter(gl.VIEWPORT);
  const currentScissor = new Vector4().fromArray(scissorParam);
  const currentViewport = new Vector4().fromArray(viewportParam);
  function createTexture(type, target, count, dimensions) {
    const data2 = new Uint8Array(4);
    const texture = gl.createTexture();
    gl.bindTexture(type, texture);
    gl.texParameteri(type, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
    gl.texParameteri(type, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
    for (let i2 = 0; i2 < count; i2++) {
      if (type === gl.TEXTURE_3D || type === gl.TEXTURE_2D_ARRAY) {
        gl.texImage3D(target, 0, gl.RGBA, 1, 1, dimensions, 0, gl.RGBA, gl.UNSIGNED_BYTE, data2);
      } else {
        gl.texImage2D(target + i2, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data2);
      }
    }
    return texture;
  }
  const emptyTextures = {};
  emptyTextures[gl.TEXTURE_2D] = createTexture(gl.TEXTURE_2D, gl.TEXTURE_2D, 1);
  emptyTextures[gl.TEXTURE_CUBE_MAP] = createTexture(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6);
  emptyTextures[gl.TEXTURE_2D_ARRAY] = createTexture(gl.TEXTURE_2D_ARRAY, gl.TEXTURE_2D_ARRAY, 1, 1);
  emptyTextures[gl.TEXTURE_3D] = createTexture(gl.TEXTURE_3D, gl.TEXTURE_3D, 1, 1);
  colorBuffer.setClear(0, 0, 0, 1);
  depthBuffer.setClear(1);
  stencilBuffer.setClear(0);
  enable(gl.DEPTH_TEST);
  depthBuffer.setFunc(LessEqualDepth);
  setFlipSided(false);
  setCullFace(CullFaceBack);
  enable(gl.CULL_FACE);
  setBlending(NoBlending);
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id);
      enabledCapabilities[id] = true;
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id);
      enabledCapabilities[id] = false;
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer);
      currentBoundFramebuffers[target] = framebuffer;
      if (target === gl.DRAW_FRAMEBUFFER) {
        currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
      }
      if (target === gl.FRAMEBUFFER) {
        currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
      }
      return true;
    }
    return false;
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers;
    let needsUpdate = false;
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer);
      if (drawBuffers2 === void 0) {
        drawBuffers2 = [];
        currentDrawbuffers.set(framebuffer, drawBuffers2);
      }
      const textures = renderTarget.textures;
      if (drawBuffers2.length !== textures.length || drawBuffers2[0] !== gl.COLOR_ATTACHMENT0) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          drawBuffers2[i2] = gl.COLOR_ATTACHMENT0 + i2;
        }
        drawBuffers2.length = textures.length;
        needsUpdate = true;
      }
    } else {
      if (drawBuffers2[0] !== gl.BACK) {
        drawBuffers2[0] = gl.BACK;
        needsUpdate = true;
      }
    }
    if (needsUpdate) {
      gl.drawBuffers(drawBuffers2);
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program);
      currentProgram = program;
      return true;
    }
    return false;
  }
  const equationToGL = {
    [AddEquation]: gl.FUNC_ADD,
    [SubtractEquation]: gl.FUNC_SUBTRACT,
    [ReverseSubtractEquation]: gl.FUNC_REVERSE_SUBTRACT
  };
  equationToGL[MinEquation] = gl.MIN;
  equationToGL[MaxEquation] = gl.MAX;
  const factorToGL = {
    [ZeroFactor]: gl.ZERO,
    [OneFactor]: gl.ONE,
    [SrcColorFactor]: gl.SRC_COLOR,
    [SrcAlphaFactor]: gl.SRC_ALPHA,
    [SrcAlphaSaturateFactor]: gl.SRC_ALPHA_SATURATE,
    [DstColorFactor]: gl.DST_COLOR,
    [DstAlphaFactor]: gl.DST_ALPHA,
    [OneMinusSrcColorFactor]: gl.ONE_MINUS_SRC_COLOR,
    [OneMinusSrcAlphaFactor]: gl.ONE_MINUS_SRC_ALPHA,
    [OneMinusDstColorFactor]: gl.ONE_MINUS_DST_COLOR,
    [OneMinusDstAlphaFactor]: gl.ONE_MINUS_DST_ALPHA,
    [ConstantColorFactor]: gl.CONSTANT_COLOR,
    [OneMinusConstantColorFactor]: gl.ONE_MINUS_CONSTANT_COLOR,
    [ConstantAlphaFactor]: gl.CONSTANT_ALPHA,
    [OneMinusConstantAlphaFactor]: gl.ONE_MINUS_CONSTANT_ALPHA
  };
  function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, blendColor, blendAlpha, premultipliedAlpha) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(gl.BLEND);
        currentBlendingEnabled = false;
      }
      return;
    }
    if (currentBlendingEnabled === false) {
      enable(gl.BLEND);
      currentBlendingEnabled = true;
    }
    if (blending !== CustomBlending) {
      if (blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha) {
        if (currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation) {
          gl.blendEquation(gl.FUNC_ADD);
          currentBlendEquation = AddEquation;
          currentBlendEquationAlpha = AddEquation;
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFunc(gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
              break;
            case MultiplyBlending:
              gl.blendFuncSeparate(gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA, gl.ZERO, gl.ONE);
              break;
            default:
              error("WebGLState: Invalid blending: ", blending);
              break;
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
              break;
            case AdditiveBlending:
              gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE, gl.ONE, gl.ONE);
              break;
            case SubtractiveBlending:
              error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");
              break;
            case MultiplyBlending:
              error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");
              break;
            default:
              error("WebGLState: Invalid blending: ", blending);
              break;
          }
        }
        currentBlendSrc = null;
        currentBlendDst = null;
        currentBlendSrcAlpha = null;
        currentBlendDstAlpha = null;
        currentBlendColor.set(0, 0, 0);
        currentBlendAlpha = 0;
        currentBlending = blending;
        currentPremultipledAlpha = premultipliedAlpha;
      }
      return;
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation;
    blendSrcAlpha = blendSrcAlpha || blendSrc;
    blendDstAlpha = blendDstAlpha || blendDst;
    if (blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha) {
      gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
      currentBlendEquation = blendEquation;
      currentBlendEquationAlpha = blendEquationAlpha;
    }
    if (blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha) {
      gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
      currentBlendSrc = blendSrc;
      currentBlendDst = blendDst;
      currentBlendSrcAlpha = blendSrcAlpha;
      currentBlendDstAlpha = blendDstAlpha;
    }
    if (blendColor.equals(currentBlendColor) === false || blendAlpha !== currentBlendAlpha) {
      gl.blendColor(blendColor.r, blendColor.g, blendColor.b, blendAlpha);
      currentBlendColor.copy(blendColor);
      currentBlendAlpha = blendAlpha;
    }
    currentBlending = blending;
    currentPremultipledAlpha = false;
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(gl.CULL_FACE) : enable(gl.CULL_FACE);
    let flipSided = material.side === BackSide;
    if (frontFaceCW) flipSided = !flipSided;
    setFlipSided(flipSided);
    material.blending === NormalBlending && material.transparent === false ? setBlending(NoBlending) : setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.blendColor, material.blendAlpha, material.premultipliedAlpha);
    depthBuffer.setFunc(material.depthFunc);
    depthBuffer.setTest(material.depthTest);
    depthBuffer.setMask(material.depthWrite);
    colorBuffer.setMask(material.colorWrite);
    const stencilWrite = material.stencilWrite;
    stencilBuffer.setTest(stencilWrite);
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask);
      stencilBuffer.setFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
      stencilBuffer.setOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
    }
    setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
    material.alphaToCoverage === true ? enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(gl.CW);
      } else {
        gl.frontFace(gl.CCW);
      }
      currentFlipSided = flipSided;
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(gl.CULL_FACE);
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(gl.BACK);
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(gl.FRONT);
        } else {
          gl.cullFace(gl.FRONT_AND_BACK);
        }
      }
    } else {
      disable(gl.CULL_FACE);
    }
    currentCullFace = cullFace;
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width);
      currentLineWidth = width;
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(gl.POLYGON_OFFSET_FILL);
      if (currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units) {
        gl.polygonOffset(factor, units);
        currentPolygonOffsetFactor = factor;
        currentPolygonOffsetUnits = units;
      }
    } else {
      disable(gl.POLYGON_OFFSET_FILL);
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(gl.SCISSOR_TEST);
    } else {
      disable(gl.SCISSOR_TEST);
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = gl.TEXTURE0 + maxTextures - 1;
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot);
      currentTextureSlot = webglSlot;
    }
  }
  function bindTexture(webglType, webglTexture, webglSlot) {
    if (webglSlot === void 0) {
      if (currentTextureSlot === null) {
        webglSlot = gl.TEXTURE0 + maxTextures - 1;
      } else {
        webglSlot = currentTextureSlot;
      }
    }
    let boundTexture = currentBoundTextures[webglSlot];
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 };
      currentBoundTextures[webglSlot] = boundTexture;
    }
    if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
      if (currentTextureSlot !== webglSlot) {
        gl.activeTexture(webglSlot);
        currentTextureSlot = webglSlot;
      }
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType]);
      boundTexture.type = webglType;
      boundTexture.texture = webglTexture;
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot];
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null);
      boundTexture.type = void 0;
      boundTexture.texture = void 0;
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function compressedTexImage3D() {
    try {
      gl.compressedTexImage3D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function compressedTexSubImage3D() {
    try {
      gl.compressedTexSubImage3D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D(...arguments);
    } catch (e2) {
      error("WebGLState:", e2);
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w);
      currentScissor.copy(scissor2);
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w);
      currentViewport.copy(viewport2);
    }
  }
  function updateUBOMapping(uniformsGroup, program) {
    let mapping = uboProgramMap.get(program);
    if (mapping === void 0) {
      mapping = /* @__PURE__ */ new WeakMap();
      uboProgramMap.set(program, mapping);
    }
    let blockIndex = mapping.get(uniformsGroup);
    if (blockIndex === void 0) {
      blockIndex = gl.getUniformBlockIndex(program, uniformsGroup.name);
      mapping.set(uniformsGroup, blockIndex);
    }
  }
  function uniformBlockBinding(uniformsGroup, program) {
    const mapping = uboProgramMap.get(program);
    const blockIndex = mapping.get(uniformsGroup);
    if (uboBindings.get(program) !== blockIndex) {
      gl.uniformBlockBinding(program, blockIndex, uniformsGroup.__bindingPointIndex);
      uboBindings.set(program, blockIndex);
    }
  }
  function reset() {
    gl.disable(gl.BLEND);
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    gl.disable(gl.POLYGON_OFFSET_FILL);
    gl.disable(gl.SCISSOR_TEST);
    gl.disable(gl.STENCIL_TEST);
    gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
    gl.blendEquation(gl.FUNC_ADD);
    gl.blendFunc(gl.ONE, gl.ZERO);
    gl.blendFuncSeparate(gl.ONE, gl.ZERO, gl.ONE, gl.ZERO);
    gl.blendColor(0, 0, 0, 0);
    gl.colorMask(true, true, true, true);
    gl.clearColor(0, 0, 0, 0);
    gl.depthMask(true);
    gl.depthFunc(gl.LESS);
    depthBuffer.setReversed(false);
    gl.clearDepth(1);
    gl.stencilMask(4294967295);
    gl.stencilFunc(gl.ALWAYS, 0, 4294967295);
    gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
    gl.clearStencil(0);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW);
    gl.polygonOffset(0, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
    gl.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
    gl.useProgram(null);
    gl.lineWidth(1);
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    enabledCapabilities = {};
    currentTextureSlot = null;
    currentBoundTextures = {};
    currentBoundFramebuffers = {};
    currentDrawbuffers = /* @__PURE__ */ new WeakMap();
    defaultDrawbuffers = [];
    currentProgram = null;
    currentBlendingEnabled = false;
    currentBlending = null;
    currentBlendEquation = null;
    currentBlendSrc = null;
    currentBlendDst = null;
    currentBlendEquationAlpha = null;
    currentBlendSrcAlpha = null;
    currentBlendDstAlpha = null;
    currentBlendColor = new Color(0, 0, 0);
    currentBlendAlpha = 0;
    currentPremultipledAlpha = false;
    currentFlipSided = null;
    currentCullFace = null;
    currentLineWidth = null;
    currentPolygonOffsetFactor = null;
    currentPolygonOffsetUnits = null;
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height);
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height);
    colorBuffer.reset();
    depthBuffer.reset();
    stencilBuffer.reset();
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    compressedTexImage3D,
    texImage2D,
    texImage3D,
    updateUBOMapping,
    uniformBlockBinding,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    compressedTexSubImage3D,
    scissor,
    viewport,
    reset
  };
}
function WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info) {
  const multisampledRTTExt = extensions.has("WEBGL_multisampled_render_to_texture") ? extensions.get("WEBGL_multisampled_render_to_texture") : null;
  const supportsInvalidateFramebuffer = typeof navigator === "undefined" ? false : /OculusBrowser/g.test(navigator.userAgent);
  const _imageDimensions = new Vector2();
  const _videoTextures = /* @__PURE__ */ new WeakMap();
  let _canvas2;
  const _sources = /* @__PURE__ */ new WeakMap();
  let useOffscreenCanvas = false;
  try {
    useOffscreenCanvas = typeof OffscreenCanvas !== "undefined" && new OffscreenCanvas(1, 1).getContext("2d") !== null;
  } catch (err) {
  }
  function createCanvas(width, height) {
    return useOffscreenCanvas ? new OffscreenCanvas(width, height) : createElementNS("canvas");
  }
  function resizeImage(image, needsNewCanvas, maxSize) {
    let scale = 1;
    const dimensions = getDimensions(image);
    if (dimensions.width > maxSize || dimensions.height > maxSize) {
      scale = maxSize / Math.max(dimensions.width, dimensions.height);
    }
    if (scale < 1) {
      if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== "undefined" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap || typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
        const width = Math.floor(scale * dimensions.width);
        const height = Math.floor(scale * dimensions.height);
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height);
        const canvas = needsNewCanvas ? createCanvas(width, height) : _canvas2;
        canvas.width = width;
        canvas.height = height;
        const context = canvas.getContext("2d");
        context.drawImage(image, 0, 0, width, height);
        warn("WebGLRenderer: Texture has been resized from (" + dimensions.width + "x" + dimensions.height + ") to (" + width + "x" + height + ").");
        return canvas;
      } else {
        if ("data" in image) {
          warn("WebGLRenderer: Image in DataTexture is too big (" + dimensions.width + "x" + dimensions.height + ").");
        }
        return image;
      }
    }
    return image;
  }
  function textureNeedsGenerateMipmaps(texture) {
    return texture.generateMipmaps;
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target);
  }
  function getTargetType(texture) {
    if (texture.isWebGLCubeRenderTarget) return _gl.TEXTURE_CUBE_MAP;
    if (texture.isWebGL3DRenderTarget) return _gl.TEXTURE_3D;
    if (texture.isWebGLArrayRenderTarget || texture.isCompressedArrayTexture) return _gl.TEXTURE_2D_ARRAY;
    return _gl.TEXTURE_2D;
  }
  function getInternalFormat(internalFormatName, glFormat, glType, colorSpace, forceLinearTransfer = false) {
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName];
      warn("WebGLRenderer: Attempt to use non-existing WebGL internal format '" + internalFormatName + "'");
    }
    let internalFormat = glFormat;
    if (glFormat === _gl.RED) {
      if (glType === _gl.FLOAT) internalFormat = _gl.R32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.R16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8;
    }
    if (glFormat === _gl.RED_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.R8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.R16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.R32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.R8I;
      if (glType === _gl.SHORT) internalFormat = _gl.R16I;
      if (glType === _gl.INT) internalFormat = _gl.R32I;
    }
    if (glFormat === _gl.RG) {
      if (glType === _gl.FLOAT) internalFormat = _gl.RG32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RG16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8;
    }
    if (glFormat === _gl.RG_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RG8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RG16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RG32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RG8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RG16I;
      if (glType === _gl.INT) internalFormat = _gl.RG32I;
    }
    if (glFormat === _gl.RGB_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGB8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGB16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGB32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGB8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGB16I;
      if (glType === _gl.INT) internalFormat = _gl.RGB32I;
    }
    if (glFormat === _gl.RGBA_INTEGER) {
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = _gl.RGBA8UI;
      if (glType === _gl.UNSIGNED_SHORT) internalFormat = _gl.RGBA16UI;
      if (glType === _gl.UNSIGNED_INT) internalFormat = _gl.RGBA32UI;
      if (glType === _gl.BYTE) internalFormat = _gl.RGBA8I;
      if (glType === _gl.SHORT) internalFormat = _gl.RGBA16I;
      if (glType === _gl.INT) internalFormat = _gl.RGBA32I;
    }
    if (glFormat === _gl.RGB) {
      if (glType === _gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = _gl.RGB9_E5;
      if (glType === _gl.UNSIGNED_INT_10F_11F_11F_REV) internalFormat = _gl.R11F_G11F_B10F;
    }
    if (glFormat === _gl.RGBA) {
      const transfer = forceLinearTransfer ? LinearTransfer : ColorManagement.getTransfer(colorSpace);
      if (glType === _gl.FLOAT) internalFormat = _gl.RGBA32F;
      if (glType === _gl.HALF_FLOAT) internalFormat = _gl.RGBA16F;
      if (glType === _gl.UNSIGNED_BYTE) internalFormat = transfer === SRGBTransfer ? _gl.SRGB8_ALPHA8 : _gl.RGBA8;
      if (glType === _gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = _gl.RGBA4;
      if (glType === _gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = _gl.RGB5_A1;
    }
    if (internalFormat === _gl.R16F || internalFormat === _gl.R32F || internalFormat === _gl.RG16F || internalFormat === _gl.RG32F || internalFormat === _gl.RGBA16F || internalFormat === _gl.RGBA32F) {
      extensions.get("EXT_color_buffer_float");
    }
    return internalFormat;
  }
  function getInternalDepthFormat(useStencil, depthType) {
    let glInternalFormat;
    if (useStencil) {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH32F_STENCIL8;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH24_STENCIL8;
        warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.");
      }
    } else {
      if (depthType === null || depthType === UnsignedIntType || depthType === UnsignedInt248Type) {
        glInternalFormat = _gl.DEPTH_COMPONENT24;
      } else if (depthType === FloatType) {
        glInternalFormat = _gl.DEPTH_COMPONENT32F;
      } else if (depthType === UnsignedShortType) {
        glInternalFormat = _gl.DEPTH_COMPONENT16;
      }
    }
    return glInternalFormat;
  }
  function getMipLevels(texture, image) {
    if (textureNeedsGenerateMipmaps(texture) === true || texture.isFramebufferTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter) {
      return Math.log2(Math.max(image.width, image.height)) + 1;
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length;
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length;
    } else {
      return 1;
    }
  }
  function onTextureDispose(event) {
    const texture = event.target;
    texture.removeEventListener("dispose", onTextureDispose);
    deallocateTexture(texture);
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture);
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target;
    renderTarget.removeEventListener("dispose", onRenderTargetDispose);
    deallocateRenderTarget(renderTarget);
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture);
    if (textureProperties.__webglInit === void 0) return;
    const source = texture.source;
    const webglTextures = _sources.get(source);
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      webglTexture.usedTimes--;
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture);
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source);
      }
    }
    properties.remove(texture);
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture);
    _gl.deleteTexture(textureProperties.__webglTexture);
    const source = texture.source;
    const webglTextures = _sources.get(source);
    delete webglTextures[textureProperties.__cacheKey];
    info.memory.textures--;
  }
  function deallocateRenderTarget(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose();
      properties.remove(renderTarget.depthTexture);
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i2 = 0; i2 < 6; i2++) {
        if (Array.isArray(renderTargetProperties.__webglFramebuffer[i2])) {
          for (let level = 0; level < renderTargetProperties.__webglFramebuffer[i2].length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2][level]);
        } else {
          _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i2]);
        }
        if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i2]);
      }
    } else {
      if (Array.isArray(renderTargetProperties.__webglFramebuffer)) {
        for (let level = 0; level < renderTargetProperties.__webglFramebuffer.length; level++) _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[level]);
      } else {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);
      }
      if (renderTargetProperties.__webglDepthbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);
      if (renderTargetProperties.__webglMultisampledFramebuffer) _gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (let i2 = 0; i2 < renderTargetProperties.__webglColorRenderbuffer.length; i2++) {
          if (renderTargetProperties.__webglColorRenderbuffer[i2]) _gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer) _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer);
    }
    const textures = renderTarget.textures;
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const attachmentProperties = properties.get(textures[i2]);
      if (attachmentProperties.__webglTexture) {
        _gl.deleteTexture(attachmentProperties.__webglTexture);
        info.memory.textures--;
      }
      properties.remove(textures[i2]);
    }
    properties.remove(renderTarget);
  }
  let textureUnits = 0;
  function resetTextureUnits() {
    textureUnits = 0;
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits;
    if (textureUnit >= capabilities.maxTextures) {
      warn("WebGLTextures: Trying to use " + textureUnit + " texture units while this GPU supports only " + capabilities.maxTextures);
    }
    textureUnits += 1;
    return textureUnit;
  }
  function getTextureCacheKey(texture) {
    const array = [];
    array.push(texture.wrapS);
    array.push(texture.wrapT);
    array.push(texture.wrapR || 0);
    array.push(texture.magFilter);
    array.push(texture.minFilter);
    array.push(texture.anisotropy);
    array.push(texture.internalFormat);
    array.push(texture.format);
    array.push(texture.type);
    array.push(texture.generateMipmaps);
    array.push(texture.premultiplyAlpha);
    array.push(texture.flipY);
    array.push(texture.unpackAlignment);
    array.push(texture.colorSpace);
    return array.join();
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isVideoTexture) updateVideoTexture(texture);
    if (texture.isRenderTargetTexture === false && texture.isExternalTexture !== true && texture.version > 0 && textureProperties.__version !== texture.version) {
      const image = texture.image;
      if (image === null) {
        warn("WebGLRenderer: Texture marked for update but no image data found.");
      } else if (image.complete === false) {
        warn("WebGLRenderer: Texture marked for update but image is incomplete");
      } else {
        uploadTexture(textureProperties, texture, slot);
        return;
      }
    } else if (texture.isExternalTexture) {
      textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;
    }
    state.bindTexture(_gl.TEXTURE_2D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    } else if (texture.isExternalTexture) {
      textureProperties.__webglTexture = texture.sourceTexture ? texture.sourceTexture : null;
    }
    state.bindTexture(_gl.TEXTURE_2D_ARRAY, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isRenderTargetTexture === false && texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_3D, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture);
    if (texture.isCubeDepthTexture !== true && texture.version > 0 && textureProperties.__version !== texture.version) {
      uploadCubeTexture(textureProperties, texture, slot);
      return;
    }
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
  }
  const wrappingToGL = {
    [RepeatWrapping]: _gl.REPEAT,
    [ClampToEdgeWrapping]: _gl.CLAMP_TO_EDGE,
    [MirroredRepeatWrapping]: _gl.MIRRORED_REPEAT
  };
  const filterToGL = {
    [NearestFilter]: _gl.NEAREST,
    [NearestMipmapNearestFilter]: _gl.NEAREST_MIPMAP_NEAREST,
    [NearestMipmapLinearFilter]: _gl.NEAREST_MIPMAP_LINEAR,
    [LinearFilter]: _gl.LINEAR,
    [LinearMipmapNearestFilter]: _gl.LINEAR_MIPMAP_NEAREST,
    [LinearMipmapLinearFilter]: _gl.LINEAR_MIPMAP_LINEAR
  };
  const compareToGL = {
    [NeverCompare]: _gl.NEVER,
    [AlwaysCompare]: _gl.ALWAYS,
    [LessCompare]: _gl.LESS,
    [LessEqualCompare]: _gl.LEQUAL,
    [EqualCompare]: _gl.EQUAL,
    [GreaterEqualCompare]: _gl.GEQUAL,
    [GreaterCompare]: _gl.GREATER,
    [NotEqualCompare]: _gl.NOTEQUAL
  };
  function setTextureParameters(textureType, texture) {
    if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false && (texture.magFilter === LinearFilter || texture.magFilter === LinearMipmapNearestFilter || texture.magFilter === NearestMipmapLinearFilter || texture.magFilter === LinearMipmapLinearFilter || texture.minFilter === LinearFilter || texture.minFilter === LinearMipmapNearestFilter || texture.minFilter === NearestMipmapLinearFilter || texture.minFilter === LinearMipmapLinearFilter)) {
      warn("WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device.");
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
    _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
    if (textureType === _gl.TEXTURE_3D || textureType === _gl.TEXTURE_2D_ARRAY) {
      _gl.texParameteri(textureType, _gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
    }
    _gl.texParameteri(textureType, _gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
    _gl.texParameteri(textureType, _gl.TEXTURE_MIN_FILTER, filterToGL[texture.minFilter]);
    if (texture.compareFunction) {
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_MODE, _gl.COMPARE_REF_TO_TEXTURE);
      _gl.texParameteri(textureType, _gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
    }
    if (extensions.has("EXT_texture_filter_anisotropic") === true) {
      if (texture.magFilter === NearestFilter) return;
      if (texture.minFilter !== NearestMipmapLinearFilter && texture.minFilter !== LinearMipmapLinearFilter) return;
      if (texture.type === FloatType && extensions.has("OES_texture_float_linear") === false) return;
      if (texture.anisotropy > 1 || properties.get(texture).__currentAnisotropy) {
        const extension = extensions.get("EXT_texture_filter_anisotropic");
        _gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()));
        properties.get(texture).__currentAnisotropy = texture.anisotropy;
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false;
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true;
      texture.addEventListener("dispose", onTextureDispose);
    }
    const source = texture.source;
    let webglTextures = _sources.get(source);
    if (webglTextures === void 0) {
      webglTextures = {};
      _sources.set(source, webglTextures);
    }
    const textureCacheKey = getTextureCacheKey(texture);
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0
        };
        info.memory.textures++;
        forceUpload = true;
      }
      webglTextures[textureCacheKey].usedTimes++;
      const webglTexture = webglTextures[textureProperties.__cacheKey];
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--;
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture);
        }
      }
      textureProperties.__cacheKey = textureCacheKey;
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture;
    }
    return forceUpload;
  }
  function getRow(index, rowLength, componentStride) {
    return Math.floor(Math.floor(index / componentStride) / rowLength);
  }
  function updateTexture(texture, image, glFormat, glType) {
    const componentStride = 4;
    const updateRanges = texture.updateRanges;
    if (updateRanges.length === 0) {
      state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, image.width, image.height, glFormat, glType, image.data);
    } else {
      updateRanges.sort((a2, b2) => a2.start - b2.start);
      let mergeIndex = 0;
      for (let i2 = 1; i2 < updateRanges.length; i2++) {
        const previousRange = updateRanges[mergeIndex];
        const range = updateRanges[i2];
        const previousEnd = previousRange.start + previousRange.count;
        const currentRow = getRow(range.start, image.width, componentStride);
        const previousRow = getRow(previousRange.start, image.width, componentStride);
        if (range.start <= previousEnd + 1 && currentRow === previousRow && getRow(range.start + range.count - 1, image.width, componentStride) === currentRow) {
          previousRange.count = Math.max(
            previousRange.count,
            range.start + range.count - previousRange.start
          );
        } else {
          ++mergeIndex;
          updateRanges[mergeIndex] = range;
        }
      }
      updateRanges.length = mergeIndex + 1;
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      for (let i2 = 0, l2 = updateRanges.length; i2 < l2; i2++) {
        const range = updateRanges[i2];
        const pixelStart = Math.floor(range.start / componentStride);
        const pixelCount = Math.ceil(range.count / componentStride);
        const x2 = pixelStart % image.width;
        const y2 = Math.floor(pixelStart / image.width);
        const width = pixelCount;
        const height = 1;
        _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, x2);
        _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, y2);
        state.texSubImage2D(_gl.TEXTURE_2D, 0, x2, y2, width, height, glFormat, glType, image.data);
      }
      texture.clearUpdateRanges();
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
    }
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = _gl.TEXTURE_2D;
    if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) textureType = _gl.TEXTURE_2D_ARRAY;
    if (texture.isData3DTexture) textureType = _gl.TEXTURE_3D;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(textureType, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      let image = resizeImage(texture.image, false, capabilities.maxTextureSize);
      image = verifyColorSpace(texture, image);
      const glFormat = utils.convert(texture.format, texture.colorSpace);
      const glType = utils.convert(texture.type);
      let glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
      setTextureParameters(textureType, texture);
      let mipmap;
      const mipmaps = texture.mipmaps;
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      const levels = getMipLevels(texture, image);
      if (texture.isDepthTexture) {
        glInternalFormat = getInternalDepthFormat(texture.format === DepthStencilFormat, texture.type);
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, 1, glInternalFormat, image.width, image.height);
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null);
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
            }
            if (dataReady) {
              updateTexture(texture, image, glFormat, glType);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data);
          }
        }
      } else if (texture.isCompressedTexture) {
        if (texture.isCompressedArrayTexture) {
          if (useTexStorage && allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height, image.depth);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    if (texture.layerUpdates.size > 0) {
                      const layerByteLength = getByteLength(mipmap.width, mipmap.height, texture.format, texture.type);
                      for (const layerIndex of texture.layerUpdates) {
                        const layerData = mipmap.data.subarray(
                          layerIndex * layerByteLength / mipmap.data.BYTES_PER_ELEMENT,
                          (layerIndex + 1) * layerByteLength / mipmap.data.BYTES_PER_ELEMENT
                        );
                        state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, layerIndex, mipmap.width, mipmap.height, 1, glFormat, layerData);
                      }
                      texture.clearLayerUpdates();
                    } else {
                      state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                    }
                  }
                } else {
                  state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, mipmap.data, 0, 0);
                }
              } else {
                warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, i2, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage3D(_gl.TEXTURE_2D_ARRAY, i2, glInternalFormat, mipmap.width, mipmap.height, image.depth, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        } else {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, mipmaps[0].width, mipmaps[0].height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            if (texture.layerUpdates.size > 0) {
              const layerByteLength = getByteLength(image.width, image.height, texture.format, texture.type);
              for (const layerIndex of texture.layerUpdates) {
                const layerData = image.data.subarray(
                  layerIndex * layerByteLength / image.data.BYTES_PER_ELEMENT,
                  (layerIndex + 1) * layerByteLength / image.data.BYTES_PER_ELEMENT
                );
                state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, layerIndex, image.width, image.height, 1, glFormat, glType, layerData);
              }
              texture.clearLayerUpdates();
            } else {
              state.texSubImage3D(_gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
            }
          }
        } else {
          state.texImage3D(_gl.TEXTURE_2D_ARRAY, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(_gl.TEXTURE_3D, levels, glInternalFormat, image.width, image.height, image.depth);
          }
          if (dataReady) {
            state.texSubImage3D(_gl.TEXTURE_3D, 0, 0, 0, 0, image.width, image.height, image.depth, glFormat, glType, image.data);
          }
        } else {
          state.texImage3D(_gl.TEXTURE_3D, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data);
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, image.width, image.height);
          } else {
            let width = image.width, height = image.height;
            for (let i2 = 0; i2 < levels; i2++) {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, width, height, 0, glFormat, glType, null);
              width >>= 1;
              height >>= 1;
            }
          }
        }
      } else {
        if (mipmaps.length > 0) {
          if (useTexStorage && allocateMemory) {
            const dimensions = getDimensions(mipmaps[0]);
            state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
          }
          for (let i2 = 0, il = mipmaps.length; i2 < il; i2++) {
            mipmap = mipmaps[i2];
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_2D, i2, 0, 0, glFormat, glType, mipmap);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_2D, i2, glInternalFormat, glFormat, glType, mipmap);
            }
          }
          texture.generateMipmaps = false;
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              const dimensions = getDimensions(image);
              state.texStorage2D(_gl.TEXTURE_2D, levels, glInternalFormat, dimensions.width, dimensions.height);
            }
            if (dataReady) {
              state.texSubImage2D(_gl.TEXTURE_2D, 0, 0, 0, glFormat, glType, image);
            }
          } else {
            state.texImage2D(_gl.TEXTURE_2D, 0, glInternalFormat, glFormat, glType, image);
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(textureType);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return;
    const forceUpload = initTexture(textureProperties, texture);
    const source = texture.source;
    state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture, _gl.TEXTURE0 + slot);
    const sourceProperties = properties.get(source);
    if (source.version !== sourceProperties.__version || forceUpload === true) {
      state.activeTexture(_gl.TEXTURE0 + slot);
      const workingPrimaries = ColorManagement.getPrimaries(ColorManagement.workingColorSpace);
      const texturePrimaries = texture.colorSpace === NoColorSpace ? null : ColorManagement.getPrimaries(texture.colorSpace);
      const unpackConversion = texture.colorSpace === NoColorSpace || workingPrimaries === texturePrimaries ? _gl.NONE : _gl.BROWSER_DEFAULT_WEBGL;
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
      _gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, unpackConversion);
      const isCompressed = texture.isCompressedTexture || texture.image[0].isCompressedTexture;
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture;
      const cubeImage = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i2] = resizeImage(texture.image[i2], true, capabilities.maxCubemapSize);
        } else {
          cubeImage[i2] = isDataTexture ? texture.image[i2].image : texture.image[i2];
        }
        cubeImage[i2] = verifyColorSpace(texture, cubeImage[i2]);
      }
      const image = cubeImage[0], glFormat = utils.convert(texture.format, texture.colorSpace), glType = utils.convert(texture.type), glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
      const useTexStorage = texture.isVideoTexture !== true;
      const allocateMemory = sourceProperties.__version === void 0 || forceUpload === true;
      const dataReady = source.dataReady;
      let levels = getMipLevels(texture, image);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      let mipmaps;
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, image.width, image.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          mipmaps = cubeImage[i2].mipmaps;
          for (let j2 = 0; j2 < mipmaps.length; j2++) {
            const mipmap = mipmaps[j2];
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  if (dataReady) {
                    state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
                  }
                } else {
                  state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data);
                }
              } else {
                warn("WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()");
              }
            } else {
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, 0, 0, mipmap.width, mipmap.height, glFormat, glType, mipmap.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data);
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps;
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++;
          const dimensions = getDimensions(cubeImage[0]);
          state.texStorage2D(_gl.TEXTURE_CUBE_MAP, levels, glInternalFormat, dimensions.width, dimensions.height);
        }
        for (let i2 = 0; i2 < 6; i2++) {
          if (isDataTexture) {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, cubeImage[i2].width, cubeImage[i2].height, glFormat, glType, cubeImage[i2].data);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, cubeImage[i2].width, cubeImage[i2].height, 0, glFormat, glType, cubeImage[i2].data);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              const mipmapImage = mipmap.image[i2].image;
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, mipmapImage.width, mipmapImage.height, glFormat, glType, mipmapImage.data);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, mipmapImage.width, mipmapImage.height, 0, glFormat, glType, mipmapImage.data);
              }
            }
          } else {
            if (useTexStorage) {
              if (dataReady) {
                state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, 0, 0, glFormat, glType, cubeImage[i2]);
              }
            } else {
              state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, glFormat, glType, cubeImage[i2]);
            }
            for (let j2 = 0; j2 < mipmaps.length; j2++) {
              const mipmap = mipmaps[j2];
              if (useTexStorage) {
                if (dataReady) {
                  state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, 0, 0, glFormat, glType, mipmap.image[i2]);
                }
              } else {
                state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, j2 + 1, glInternalFormat, glFormat, glType, mipmap.image[i2]);
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      sourceProperties.__version = source.version;
      if (texture.onUpdate) texture.onUpdate(texture);
    }
    textureProperties.__version = texture.version;
  }
  function setupFrameBufferTexture(framebuffer, renderTarget, texture, attachment, textureTarget, level) {
    const glFormat = utils.convert(texture.format, texture.colorSpace);
    const glType = utils.convert(texture.type);
    const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    textureProperties.__renderTarget = renderTarget;
    if (!renderTargetProperties.__hasExternalTextures) {
      const width = Math.max(1, renderTarget.width >> level);
      const height = Math.max(1, renderTarget.height >> level);
      if (textureTarget === _gl.TEXTURE_3D || textureTarget === _gl.TEXTURE_2D_ARRAY) {
        state.texImage3D(textureTarget, level, glInternalFormat, width, height, renderTarget.depth, 0, glFormat, glType, null);
      } else {
        state.texImage2D(textureTarget, level, glInternalFormat, width, height, 0, glFormat, glType, null);
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, 0, getRenderTargetSamples(renderTarget));
    } else if (textureTarget === _gl.TEXTURE_2D || textureTarget >= _gl.TEXTURE_CUBE_MAP_POSITIVE_X && textureTarget <= _gl.TEXTURE_CUBE_MAP_NEGATIVE_Z) {
      _gl.framebufferTexture2D(_gl.FRAMEBUFFER, attachment, textureTarget, textureProperties.__webglTexture, level);
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, useMultisample) {
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
    if (renderTarget.depthBuffer) {
      const depthTexture = renderTarget.depthTexture;
      const depthType = depthTexture && depthTexture.isDepthTexture ? depthTexture.type : null;
      const glInternalFormat = getInternalDepthFormat(renderTarget.stencilBuffer, depthType);
      const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, getRenderTargetSamples(renderTarget), glInternalFormat, renderTarget.width, renderTarget.height);
      } else if (useMultisample) {
        _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, getRenderTargetSamples(renderTarget), glInternalFormat, renderTarget.width, renderTarget.height);
      } else {
        _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
      }
      _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
    } else {
      const textures = renderTarget.textures;
      for (let i2 = 0; i2 < textures.length; i2++) {
        const texture = textures[i2];
        const glFormat = utils.convert(texture.format, texture.colorSpace);
        const glType = utils.convert(texture.type);
        const glInternalFormat = getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace);
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER, getRenderTargetSamples(renderTarget), glInternalFormat, renderTarget.width, renderTarget.height);
        } else if (useMultisample) {
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, getRenderTargetSamples(renderTarget), glInternalFormat, renderTarget.width, renderTarget.height);
        } else {
          _gl.renderbufferStorage(_gl.RENDERBUFFER, glInternalFormat, renderTarget.width, renderTarget.height);
        }
      }
    }
    _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
  }
  function setupDepthTexture(framebuffer, renderTarget, cubeFace) {
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
    if (!(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)) {
      throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
    }
    const textureProperties = properties.get(renderTarget.depthTexture);
    textureProperties.__renderTarget = renderTarget;
    if (!textureProperties.__webglTexture || renderTarget.depthTexture.image.width !== renderTarget.width || renderTarget.depthTexture.image.height !== renderTarget.height) {
      renderTarget.depthTexture.image.width = renderTarget.width;
      renderTarget.depthTexture.image.height = renderTarget.height;
      renderTarget.depthTexture.needsUpdate = true;
    }
    if (isCube) {
      if (textureProperties.__webglInit === void 0) {
        textureProperties.__webglInit = true;
        renderTarget.depthTexture.addEventListener("dispose", onTextureDispose);
      }
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
        state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
        setTextureParameters(_gl.TEXTURE_CUBE_MAP, renderTarget.depthTexture);
        const glFormat = utils.convert(renderTarget.depthTexture.format);
        const glType = utils.convert(renderTarget.depthTexture.type);
        let glInternalFormat;
        if (renderTarget.depthTexture.format === DepthFormat) {
          glInternalFormat = _gl.DEPTH_COMPONENT24;
        } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
          glInternalFormat = _gl.DEPTH24_STENCIL8;
        }
        for (let i2 = 0; i2 < 6; i2++) {
          _gl.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null);
        }
      }
    } else {
      setTexture2D(renderTarget.depthTexture, 0);
    }
    const webglDepthTexture = textureProperties.__webglTexture;
    const samples = getRenderTargetSamples(renderTarget);
    const glTextureType = isCube ? _gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace : _gl.TEXTURE_2D;
    const glAttachmentType = renderTarget.depthTexture.format === DepthStencilFormat ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, glAttachmentType, glTextureType, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, glAttachmentType, glTextureType, webglDepthTexture, 0);
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER, glAttachmentType, glTextureType, webglDepthTexture, 0, samples);
      } else {
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, glAttachmentType, glTextureType, webglDepthTexture, 0);
      }
    } else {
      throw new Error("Unknown depthTexture format");
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    if (renderTargetProperties.__boundDepthTexture !== renderTarget.depthTexture) {
      const depthTexture = renderTarget.depthTexture;
      if (renderTargetProperties.__depthDisposeCallback) {
        renderTargetProperties.__depthDisposeCallback();
      }
      if (depthTexture) {
        const disposeEvent = () => {
          delete renderTargetProperties.__boundDepthTexture;
          delete renderTargetProperties.__depthDisposeCallback;
          depthTexture.removeEventListener("dispose", disposeEvent);
        };
        depthTexture.addEventListener("dispose", disposeEvent);
        renderTargetProperties.__depthDisposeCallback = disposeEvent;
      }
      renderTargetProperties.__boundDepthTexture = depthTexture;
    }
    if (renderTarget.depthTexture && !renderTargetProperties.__autoAllocateDepthBuffer) {
      if (isCube) {
        for (let i2 = 0; i2 < 6; i2++) {
          setupDepthTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, i2);
        }
      } else {
        const mipmaps = renderTarget.texture.mipmaps;
        if (mipmaps && mipmaps.length > 0) {
          setupDepthTexture(renderTargetProperties.__webglFramebuffer[0], renderTarget, 0);
        } else {
          setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget, 0);
        }
      }
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = [];
        for (let i2 = 0; i2 < 6; i2++) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[i2]);
          if (renderTargetProperties.__webglDepthbuffer[i2] === void 0) {
            renderTargetProperties.__webglDepthbuffer[i2] = _gl.createRenderbuffer();
            setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[i2], renderTarget, false);
          } else {
            const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
            const renderbuffer = renderTargetProperties.__webglDepthbuffer[i2];
            _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
          }
        }
      } else {
        const mipmaps = renderTarget.texture.mipmaps;
        if (mipmaps && mipmaps.length > 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[0]);
        } else {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        }
        if (renderTargetProperties.__webglDepthbuffer === void 0) {
          renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer, renderTarget, false);
        } else {
          const glAttachmentType = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          const renderbuffer = renderTargetProperties.__webglDepthbuffer;
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderbuffer);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, glAttachmentType, _gl.RENDERBUFFER, renderbuffer);
        }
      }
    }
    state.bindFramebuffer(_gl.FRAMEBUFFER, null);
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget);
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, renderTarget.texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, 0);
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture;
    const renderTargetProperties = properties.get(renderTarget);
    const textureProperties = properties.get(texture);
    renderTarget.addEventListener("dispose", onRenderTargetDispose);
    const textures = renderTarget.textures;
    const isCube = renderTarget.isWebGLCubeRenderTarget === true;
    const isMultipleRenderTargets = textures.length > 1;
    if (!isMultipleRenderTargets) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture();
      }
      textureProperties.__version = texture.version;
      info.memory.textures++;
    }
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = [];
      for (let i2 = 0; i2 < 6; i2++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          renderTargetProperties.__webglFramebuffer[i2] = [];
          for (let level = 0; level < texture.mipmaps.length; level++) {
            renderTargetProperties.__webglFramebuffer[i2][level] = _gl.createFramebuffer();
          }
        } else {
          renderTargetProperties.__webglFramebuffer[i2] = _gl.createFramebuffer();
        }
      }
    } else {
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        renderTargetProperties.__webglFramebuffer = [];
        for (let level = 0; level < texture.mipmaps.length; level++) {
          renderTargetProperties.__webglFramebuffer[level] = _gl.createFramebuffer();
        }
      } else {
        renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
      }
      if (isMultipleRenderTargets) {
        for (let i2 = 0, il = textures.length; i2 < il; i2++) {
          const attachmentProperties = properties.get(textures[i2]);
          if (attachmentProperties.__webglTexture === void 0) {
            attachmentProperties.__webglTexture = _gl.createTexture();
            info.memory.textures++;
          }
        }
      }
      if (renderTarget.samples > 0 && useMultisampledRTT(renderTarget) === false) {
        renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
        renderTargetProperties.__webglColorRenderbuffer = [];
        state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        for (let i2 = 0; i2 < textures.length; i2++) {
          const texture2 = textures[i2];
          renderTargetProperties.__webglColorRenderbuffer[i2] = _gl.createRenderbuffer();
          _gl.bindRenderbuffer(_gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
          const glFormat = utils.convert(texture2.format, texture2.colorSpace);
          const glType = utils.convert(texture2.type);
          const glInternalFormat = getInternalFormat(texture2.internalFormat, glFormat, glType, texture2.colorSpace, renderTarget.isXRRenderTarget === true);
          const samples = getRenderTargetSamples(renderTarget);
          _gl.renderbufferStorageMultisample(_gl.RENDERBUFFER, samples, glInternalFormat, renderTarget.width, renderTarget.height);
          _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
        }
        _gl.bindRenderbuffer(_gl.RENDERBUFFER, null);
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
          setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true);
        }
        state.bindFramebuffer(_gl.FRAMEBUFFER, null);
      }
    }
    if (isCube) {
      state.bindTexture(_gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture);
      setTextureParameters(_gl.TEXTURE_CUBE_MAP, texture);
      for (let i2 = 0; i2 < 6; i2++) {
        if (texture.mipmaps && texture.mipmaps.length > 0) {
          for (let level = 0; level < texture.mipmaps.length; level++) {
            setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2][level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, level);
          }
        } else {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[i2], renderTarget, texture, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i2, 0);
        }
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(_gl.TEXTURE_CUBE_MAP);
      }
      state.unbindTexture();
    } else if (isMultipleRenderTargets) {
      for (let i2 = 0, il = textures.length; i2 < il; i2++) {
        const attachment = textures[i2];
        const attachmentProperties = properties.get(attachment);
        let glTextureType = _gl.TEXTURE_2D;
        if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
        }
        state.bindTexture(glTextureType, attachmentProperties.__webglTexture);
        setTextureParameters(glTextureType, attachment);
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, attachment, _gl.COLOR_ATTACHMENT0 + i2, glTextureType, 0);
        if (textureNeedsGenerateMipmaps(attachment)) {
          generateMipmap(glTextureType);
        }
      }
      state.unbindTexture();
    } else {
      let glTextureType = _gl.TEXTURE_2D;
      if (renderTarget.isWebGL3DRenderTarget || renderTarget.isWebGLArrayRenderTarget) {
        glTextureType = renderTarget.isWebGL3DRenderTarget ? _gl.TEXTURE_3D : _gl.TEXTURE_2D_ARRAY;
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture);
      setTextureParameters(glTextureType, texture);
      if (texture.mipmaps && texture.mipmaps.length > 0) {
        for (let level = 0; level < texture.mipmaps.length; level++) {
          setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[level], renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, level);
        }
      } else {
        setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer, renderTarget, texture, _gl.COLOR_ATTACHMENT0, glTextureType, 0);
      }
      if (textureNeedsGenerateMipmaps(texture)) {
        generateMipmap(glTextureType);
      }
      state.unbindTexture();
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget);
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const textures = renderTarget.textures;
    for (let i2 = 0, il = textures.length; i2 < il; i2++) {
      const texture = textures[i2];
      if (textureNeedsGenerateMipmaps(texture)) {
        const targetType = getTargetType(renderTarget);
        const webglTexture = properties.get(texture).__webglTexture;
        state.bindTexture(targetType, webglTexture);
        generateMipmap(targetType);
        state.unbindTexture();
      }
    }
  }
  const invalidationArrayRead = [];
  const invalidationArrayDraw = [];
  function updateMultisampleRenderTarget(renderTarget) {
    if (renderTarget.samples > 0) {
      if (useMultisampledRTT(renderTarget) === false) {
        const textures = renderTarget.textures;
        const width = renderTarget.width;
        const height = renderTarget.height;
        let mask = _gl.COLOR_BUFFER_BIT;
        const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
        const renderTargetProperties = properties.get(renderTarget);
        const isMultipleRenderTargets = textures.length > 1;
        if (isMultipleRenderTargets) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, null);
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, null, 0);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
        const mipmaps = renderTarget.texture.mipmaps;
        if (mipmaps && mipmaps.length > 0) {
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[0]);
        } else {
          state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
        }
        for (let i2 = 0; i2 < textures.length; i2++) {
          if (renderTarget.resolveDepthBuffer) {
            if (renderTarget.depthBuffer) mask |= _gl.DEPTH_BUFFER_BIT;
            if (renderTarget.stencilBuffer && renderTarget.resolveStencilBuffer) mask |= _gl.STENCIL_BUFFER_BIT;
          }
          if (isMultipleRenderTargets) {
            _gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
            const webglTexture = properties.get(textures[i2]).__webglTexture;
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, webglTexture, 0);
          }
          _gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, _gl.NEAREST);
          if (supportsInvalidateFramebuffer === true) {
            invalidationArrayRead.length = 0;
            invalidationArrayDraw.length = 0;
            invalidationArrayRead.push(_gl.COLOR_ATTACHMENT0 + i2);
            if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false) {
              invalidationArrayRead.push(depthStyle);
              invalidationArrayDraw.push(depthStyle);
              _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, invalidationArrayDraw);
            }
            _gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER, invalidationArrayRead);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
        if (isMultipleRenderTargets) {
          for (let i2 = 0; i2 < textures.length; i2++) {
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
            _gl.framebufferRenderbuffer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.RENDERBUFFER, renderTargetProperties.__webglColorRenderbuffer[i2]);
            const webglTexture = properties.get(textures[i2]).__webglTexture;
            state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, _gl.TEXTURE_2D, webglTexture, 0);
          }
        }
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, renderTargetProperties.__webglMultisampledFramebuffer);
      } else {
        if (renderTarget.depthBuffer && renderTarget.resolveDepthBuffer === false && supportsInvalidateFramebuffer) {
          const depthStyle = renderTarget.stencilBuffer ? _gl.DEPTH_STENCIL_ATTACHMENT : _gl.DEPTH_ATTACHMENT;
          _gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER, [depthStyle]);
        }
      }
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(capabilities.maxSamples, renderTarget.samples);
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget);
    return renderTarget.samples > 0 && extensions.has("WEBGL_multisampled_render_to_texture") === true && renderTargetProperties.__useRenderToTexture !== false;
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame;
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame);
      texture.update();
    }
  }
  function verifyColorSpace(texture, image) {
    const colorSpace = texture.colorSpace;
    const format = texture.format;
    const type = texture.type;
    if (texture.isCompressedTexture === true || texture.isVideoTexture === true) return image;
    if (colorSpace !== LinearSRGBColorSpace && colorSpace !== NoColorSpace) {
      if (ColorManagement.getTransfer(colorSpace) === SRGBTransfer) {
        if (format !== RGBAFormat || type !== UnsignedByteType) {
          warn("WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.");
        }
      } else {
        error("WebGLTextures: Unsupported texture color space:", colorSpace);
      }
    }
    return image;
  }
  function getDimensions(image) {
    if (typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement) {
      _imageDimensions.width = image.naturalWidth || image.width;
      _imageDimensions.height = image.naturalHeight || image.height;
    } else if (typeof VideoFrame !== "undefined" && image instanceof VideoFrame) {
      _imageDimensions.width = image.displayWidth;
      _imageDimensions.height = image.displayHeight;
    } else {
      _imageDimensions.width = image.width;
      _imageDimensions.height = image.height;
    }
    return _imageDimensions;
  }
  this.allocateTextureUnit = allocateTextureUnit;
  this.resetTextureUnits = resetTextureUnits;
  this.setTexture2D = setTexture2D;
  this.setTexture2DArray = setTexture2DArray;
  this.setTexture3D = setTexture3D;
  this.setTextureCube = setTextureCube;
  this.rebindTextures = rebindTextures;
  this.setupRenderTarget = setupRenderTarget;
  this.updateRenderTargetMipmap = updateRenderTargetMipmap;
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
  this.setupDepthRenderbuffer = setupDepthRenderbuffer;
  this.setupFrameBufferTexture = setupFrameBufferTexture;
  this.useMultisampledRTT = useMultisampledRTT;
  this.isReversedDepthBuffer = function() {
    return state.buffers.depth.getReversed();
  };
}
function WebGLUtils(gl, extensions) {
  function convert(p2, colorSpace = NoColorSpace) {
    let extension;
    const transfer = ColorManagement.getTransfer(colorSpace);
    if (p2 === UnsignedByteType) return gl.UNSIGNED_BYTE;
    if (p2 === UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
    if (p2 === UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
    if (p2 === UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
    if (p2 === UnsignedInt101111Type) return gl.UNSIGNED_INT_10F_11F_11F_REV;
    if (p2 === ByteType) return gl.BYTE;
    if (p2 === ShortType) return gl.SHORT;
    if (p2 === UnsignedShortType) return gl.UNSIGNED_SHORT;
    if (p2 === IntType) return gl.INT;
    if (p2 === UnsignedIntType) return gl.UNSIGNED_INT;
    if (p2 === FloatType) return gl.FLOAT;
    if (p2 === HalfFloatType) return gl.HALF_FLOAT;
    if (p2 === AlphaFormat) return gl.ALPHA;
    if (p2 === RGBFormat) return gl.RGB;
    if (p2 === RGBAFormat) return gl.RGBA;
    if (p2 === DepthFormat) return gl.DEPTH_COMPONENT;
    if (p2 === DepthStencilFormat) return gl.DEPTH_STENCIL;
    if (p2 === RedFormat) return gl.RED;
    if (p2 === RedIntegerFormat) return gl.RED_INTEGER;
    if (p2 === RGFormat) return gl.RG;
    if (p2 === RGIntegerFormat) return gl.RG_INTEGER;
    if (p2 === RGBAIntegerFormat) return gl.RGBA_INTEGER;
    if (p2 === RGB_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT1_Format || p2 === RGBA_S3TC_DXT3_Format || p2 === RGBA_S3TC_DXT5_Format) {
      if (transfer === SRGBTransfer) {
        extension = extensions.get("WEBGL_compressed_texture_s3tc_srgb");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      } else {
        extension = extensions.get("WEBGL_compressed_texture_s3tc");
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (p2 === RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (p2 === RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        } else {
          return null;
        }
      }
    }
    if (p2 === RGB_PVRTC_4BPPV1_Format || p2 === RGB_PVRTC_2BPPV1_Format || p2 === RGBA_PVRTC_4BPPV1_Format || p2 === RGBA_PVRTC_2BPPV1_Format) {
      extension = extensions.get("WEBGL_compressed_texture_pvrtc");
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (p2 === RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (p2 === RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (p2 === RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      } else {
        return null;
      }
    }
    if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format || p2 === R11_EAC_Format || p2 === SIGNED_R11_EAC_Format || p2 === RG11_EAC_Format || p2 === SIGNED_RG11_EAC_Format) {
      extension = extensions.get("WEBGL_compressed_texture_etc");
      if (extension !== null) {
        if (p2 === RGB_ETC1_Format || p2 === RGB_ETC2_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
        if (p2 === RGBA_ETC2_EAC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
        if (p2 === R11_EAC_Format) return extension.COMPRESSED_R11_EAC;
        if (p2 === SIGNED_R11_EAC_Format) return extension.COMPRESSED_SIGNED_R11_EAC;
        if (p2 === RG11_EAC_Format) return extension.COMPRESSED_RG11_EAC;
        if (p2 === SIGNED_RG11_EAC_Format) return extension.COMPRESSED_SIGNED_RG11_EAC;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_ASTC_4x4_Format || p2 === RGBA_ASTC_5x4_Format || p2 === RGBA_ASTC_5x5_Format || p2 === RGBA_ASTC_6x5_Format || p2 === RGBA_ASTC_6x6_Format || p2 === RGBA_ASTC_8x5_Format || p2 === RGBA_ASTC_8x6_Format || p2 === RGBA_ASTC_8x8_Format || p2 === RGBA_ASTC_10x5_Format || p2 === RGBA_ASTC_10x6_Format || p2 === RGBA_ASTC_10x8_Format || p2 === RGBA_ASTC_10x10_Format || p2 === RGBA_ASTC_12x10_Format || p2 === RGBA_ASTC_12x12_Format) {
      extension = extensions.get("WEBGL_compressed_texture_astc");
      if (extension !== null) {
        if (p2 === RGBA_ASTC_4x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (p2 === RGBA_ASTC_5x4_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (p2 === RGBA_ASTC_5x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (p2 === RGBA_ASTC_6x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (p2 === RGBA_ASTC_6x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (p2 === RGBA_ASTC_8x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (p2 === RGBA_ASTC_8x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (p2 === RGBA_ASTC_8x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (p2 === RGBA_ASTC_10x5_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (p2 === RGBA_ASTC_10x6_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (p2 === RGBA_ASTC_10x8_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (p2 === RGBA_ASTC_10x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (p2 === RGBA_ASTC_12x10_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (p2 === RGBA_ASTC_12x12_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
      } else {
        return null;
      }
    }
    if (p2 === RGBA_BPTC_Format || p2 === RGB_BPTC_SIGNED_Format || p2 === RGB_BPTC_UNSIGNED_Format) {
      extension = extensions.get("EXT_texture_compression_bptc");
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format) return transfer === SRGBTransfer ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (p2 === RGB_BPTC_SIGNED_Format) return extension.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (p2 === RGB_BPTC_UNSIGNED_Format) return extension.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      } else {
        return null;
      }
    }
    if (p2 === RED_RGTC1_Format || p2 === SIGNED_RED_RGTC1_Format || p2 === RED_GREEN_RGTC2_Format || p2 === SIGNED_RED_GREEN_RGTC2_Format) {
      extension = extensions.get("EXT_texture_compression_rgtc");
      if (extension !== null) {
        if (p2 === RED_RGTC1_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
        if (p2 === SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (p2 === RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (p2 === SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      } else {
        return null;
      }
    }
    if (p2 === UnsignedInt248Type) return gl.UNSIGNED_INT_24_8;
    return gl[p2] !== void 0 ? gl[p2] : null;
  }
  return { convert };
}
var _occlusion_vertex = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`;
var _occlusion_fragment = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
var WebXRDepthSensing = class {
  /**
   * Constructs a new depth sensing module.
   */
  constructor() {
    this.texture = null;
    this.mesh = null;
    this.depthNear = 0;
    this.depthFar = 0;
  }
  /**
   * Inits the depth sensing module
   *
   * @param {XRWebGLDepthInformation} depthData - The XR depth data.
   * @param {XRRenderState} renderState - The XR render state.
   */
  init(depthData, renderState) {
    if (this.texture === null) {
      const texture = new ExternalTexture(depthData.texture);
      if (depthData.depthNear !== renderState.depthNear || depthData.depthFar !== renderState.depthFar) {
        this.depthNear = depthData.depthNear;
        this.depthFar = depthData.depthFar;
      }
      this.texture = texture;
    }
  }
  /**
   * Returns a plane mesh that visualizes the depth texture.
   *
   * @param {ArrayCamera} cameraXR - The XR camera.
   * @return {?Mesh} The plane mesh.
   */
  getMesh(cameraXR) {
    if (this.texture !== null) {
      if (this.mesh === null) {
        const viewport = cameraXR.cameras[0].viewport;
        const material = new ShaderMaterial({
          vertexShader: _occlusion_vertex,
          fragmentShader: _occlusion_fragment,
          uniforms: {
            depthColor: { value: this.texture },
            depthWidth: { value: viewport.z },
            depthHeight: { value: viewport.w }
          }
        });
        this.mesh = new Mesh(new PlaneGeometry(20, 20), material);
      }
    }
    return this.mesh;
  }
  /**
   * Resets the module
   */
  reset() {
    this.texture = null;
    this.mesh = null;
  }
  /**
   * Returns a texture representing the depth of the user's environment.
   *
   * @return {?ExternalTexture} The depth texture.
   */
  getDepthTexture() {
    return this.texture;
  }
};
var WebXRManager = class extends EventDispatcher {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer} renderer - The renderer.
   * @param {WebGL2RenderingContext} gl - The rendering context.
   */
  constructor(renderer, gl) {
    super();
    const scope = this;
    let session = null;
    let framebufferScaleFactor = 1;
    let referenceSpace = null;
    let referenceSpaceType = "local-floor";
    let foveation = 1;
    let customReferenceSpace = null;
    let pose = null;
    let glBinding = null;
    let glProjLayer = null;
    let glBaseLayer = null;
    let xrFrame = null;
    const supportsGlBinding = typeof XRWebGLBinding !== "undefined";
    const depthSensing = new WebXRDepthSensing();
    const cameraAccessTextures = {};
    const attributes = gl.getContextAttributes();
    let initialRenderTarget = null;
    let newRenderTarget = null;
    const controllers = [];
    const controllerInputSources = [];
    const currentSize = new Vector2();
    let currentPixelRatio = null;
    const cameraL = new PerspectiveCamera();
    cameraL.viewport = new Vector4();
    const cameraR = new PerspectiveCamera();
    cameraR.viewport = new Vector4();
    const cameras = [cameraL, cameraR];
    const cameraXR = new ArrayCamera();
    let _currentDepthNear = null;
    let _currentDepthFar = null;
    this.cameraAutoUpdate = true;
    this.enabled = false;
    this.isPresenting = false;
    this.getController = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getTargetRaySpace();
    };
    this.getControllerGrip = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getGripSpace();
    };
    this.getHand = function(index) {
      let controller = controllers[index];
      if (controller === void 0) {
        controller = new WebXRController();
        controllers[index] = controller;
      }
      return controller.getHandSpace();
    };
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource);
      if (controllerIndex === -1) {
        return;
      }
      const controller = controllers[controllerIndex];
      if (controller !== void 0) {
        controller.update(event.inputSource, event.frame, customReferenceSpace || referenceSpace);
        controller.dispatchEvent({ type: event.type, data: event.inputSource });
      }
    }
    function onSessionEnd() {
      session.removeEventListener("select", onSessionEvent);
      session.removeEventListener("selectstart", onSessionEvent);
      session.removeEventListener("selectend", onSessionEvent);
      session.removeEventListener("squeeze", onSessionEvent);
      session.removeEventListener("squeezestart", onSessionEvent);
      session.removeEventListener("squeezeend", onSessionEvent);
      session.removeEventListener("end", onSessionEnd);
      session.removeEventListener("inputsourceschange", onInputSourcesChange);
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        if (inputSource === null) continue;
        controllerInputSources[i2] = null;
        controllers[i2].disconnect(inputSource);
      }
      _currentDepthNear = null;
      _currentDepthFar = null;
      depthSensing.reset();
      for (const key in cameraAccessTextures) {
        delete cameraAccessTextures[key];
      }
      renderer.setRenderTarget(initialRenderTarget);
      glBaseLayer = null;
      glProjLayer = null;
      glBinding = null;
      session = null;
      newRenderTarget = null;
      animation.stop();
      scope.isPresenting = false;
      renderer.setPixelRatio(currentPixelRatio);
      renderer.setSize(currentSize.width, currentSize.height, false);
      scope.dispatchEvent({ type: "sessionend" });
    }
    this.setFramebufferScaleFactor = function(value) {
      framebufferScaleFactor = value;
      if (scope.isPresenting === true) {
        warn("WebXRManager: Cannot change framebuffer scale while presenting.");
      }
    };
    this.setReferenceSpaceType = function(value) {
      referenceSpaceType = value;
      if (scope.isPresenting === true) {
        warn("WebXRManager: Cannot change reference space type while presenting.");
      }
    };
    this.getReferenceSpace = function() {
      return customReferenceSpace || referenceSpace;
    };
    this.setReferenceSpace = function(space) {
      customReferenceSpace = space;
    };
    this.getBaseLayer = function() {
      return glProjLayer !== null ? glProjLayer : glBaseLayer;
    };
    this.getBinding = function() {
      if (glBinding === null && supportsGlBinding) {
        glBinding = new XRWebGLBinding(session, gl);
      }
      return glBinding;
    };
    this.getFrame = function() {
      return xrFrame;
    };
    this.getSession = function() {
      return session;
    };
    this.setSession = async function(value) {
      session = value;
      if (session !== null) {
        initialRenderTarget = renderer.getRenderTarget();
        session.addEventListener("select", onSessionEvent);
        session.addEventListener("selectstart", onSessionEvent);
        session.addEventListener("selectend", onSessionEvent);
        session.addEventListener("squeeze", onSessionEvent);
        session.addEventListener("squeezestart", onSessionEvent);
        session.addEventListener("squeezeend", onSessionEvent);
        session.addEventListener("end", onSessionEnd);
        session.addEventListener("inputsourceschange", onInputSourcesChange);
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible();
        }
        currentPixelRatio = renderer.getPixelRatio();
        renderer.getSize(currentSize);
        const supportsLayers = supportsGlBinding && "createProjectionLayer" in XRWebGLBinding.prototype;
        if (!supportsLayers) {
          const layerInit = {
            antialias: attributes.antialias,
            alpha: true,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor
          };
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit);
          session.updateRenderState({ baseLayer: glBaseLayer });
          renderer.setPixelRatio(1);
          renderer.setSize(glBaseLayer.framebufferWidth, glBaseLayer.framebufferHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              colorSpace: renderer.outputColorSpace,
              stencilBuffer: attributes.stencil,
              resolveDepthBuffer: glBaseLayer.ignoreDepthValues === false,
              resolveStencilBuffer: glBaseLayer.ignoreDepthValues === false
            }
          );
        } else {
          let depthFormat = null;
          let depthType = null;
          let glDepthFormat = null;
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? gl.DEPTH24_STENCIL8 : gl.DEPTH_COMPONENT24;
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat;
            depthType = attributes.stencil ? UnsignedInt248Type : UnsignedIntType;
          }
          const projectionlayerInit = {
            colorFormat: gl.RGBA8,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor
          };
          glBinding = this.getBinding();
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit);
          session.updateRenderState({ layers: [glProjLayer] });
          renderer.setPixelRatio(1);
          renderer.setSize(glProjLayer.textureWidth, glProjLayer.textureHeight, false);
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(glProjLayer.textureWidth, glProjLayer.textureHeight, depthType, void 0, void 0, void 0, void 0, void 0, void 0, depthFormat),
              stencilBuffer: attributes.stencil,
              colorSpace: renderer.outputColorSpace,
              samples: attributes.antialias ? 4 : 0,
              resolveDepthBuffer: glProjLayer.ignoreDepthValues === false,
              resolveStencilBuffer: glProjLayer.ignoreDepthValues === false
            }
          );
        }
        newRenderTarget.isXRRenderTarget = true;
        this.setFoveation(foveation);
        customReferenceSpace = null;
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType);
        animation.setContext(session);
        animation.start();
        scope.isPresenting = true;
        scope.dispatchEvent({ type: "sessionstart" });
      }
    };
    this.getEnvironmentBlendMode = function() {
      if (session !== null) {
        return session.environmentBlendMode;
      }
    };
    this.getDepthTexture = function() {
      return depthSensing.getDepthTexture();
    };
    function onInputSourcesChange(event) {
      for (let i2 = 0; i2 < event.removed.length; i2++) {
        const inputSource = event.removed[i2];
        const index = controllerInputSources.indexOf(inputSource);
        if (index >= 0) {
          controllerInputSources[index] = null;
          controllers[index].disconnect(inputSource);
        }
      }
      for (let i2 = 0; i2 < event.added.length; i2++) {
        const inputSource = event.added[i2];
        let controllerIndex = controllerInputSources.indexOf(inputSource);
        if (controllerIndex === -1) {
          for (let i3 = 0; i3 < controllers.length; i3++) {
            if (i3 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource);
              controllerIndex = i3;
              break;
            } else if (controllerInputSources[i3] === null) {
              controllerInputSources[i3] = inputSource;
              controllerIndex = i3;
              break;
            }
          }
          if (controllerIndex === -1) break;
        }
        const controller = controllers[controllerIndex];
        if (controller) {
          controller.connect(inputSource);
        }
      }
    }
    const cameraLPos = new Vector3();
    const cameraRPos = new Vector3();
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld);
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld);
      const ipd = cameraLPos.distanceTo(cameraRPos);
      const projL = cameraL2.projectionMatrix.elements;
      const projR = cameraR2.projectionMatrix.elements;
      const near = projL[14] / (projL[10] - 1);
      const far = projL[14] / (projL[10] + 1);
      const topFov = (projL[9] + 1) / projL[5];
      const bottomFov = (projL[9] - 1) / projL[5];
      const leftFov = (projL[8] - 1) / projL[0];
      const rightFov = (projR[8] + 1) / projR[0];
      const left = near * leftFov;
      const right = near * rightFov;
      const zOffset = ipd / (-leftFov + rightFov);
      const xOffset = zOffset * -leftFov;
      cameraL2.matrixWorld.decompose(camera.position, camera.quaternion, camera.scale);
      camera.translateX(xOffset);
      camera.translateZ(zOffset);
      camera.matrixWorld.compose(camera.position, camera.quaternion, camera.scale);
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
      if (projL[10] === -1) {
        camera.projectionMatrix.copy(cameraL2.projectionMatrix);
        camera.projectionMatrixInverse.copy(cameraL2.projectionMatrixInverse);
      } else {
        const near2 = near + zOffset;
        const far2 = far + zOffset;
        const left2 = left - xOffset;
        const right2 = right + (ipd - xOffset);
        const top2 = topFov * far / far2 * near2;
        const bottom2 = bottomFov * far / far2 * near2;
        camera.projectionMatrix.makePerspective(left2, right2, top2, bottom2, near2, far2);
        camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
      }
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix);
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix);
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    }
    this.updateCamera = function(camera) {
      if (session === null) return;
      let depthNear = camera.near;
      let depthFar = camera.far;
      if (depthSensing.texture !== null) {
        if (depthSensing.depthNear > 0) depthNear = depthSensing.depthNear;
        if (depthSensing.depthFar > 0) depthFar = depthSensing.depthFar;
      }
      cameraXR.near = cameraR.near = cameraL.near = depthNear;
      cameraXR.far = cameraR.far = cameraL.far = depthFar;
      if (_currentDepthNear !== cameraXR.near || _currentDepthFar !== cameraXR.far) {
        session.updateRenderState({
          depthNear: cameraXR.near,
          depthFar: cameraXR.far
        });
        _currentDepthNear = cameraXR.near;
        _currentDepthFar = cameraXR.far;
      }
      cameraXR.layers.mask = camera.layers.mask | 6;
      cameraL.layers.mask = cameraXR.layers.mask & 3;
      cameraR.layers.mask = cameraXR.layers.mask & 5;
      const parent = camera.parent;
      const cameras2 = cameraXR.cameras;
      updateCamera(cameraXR, parent);
      for (let i2 = 0; i2 < cameras2.length; i2++) {
        updateCamera(cameras2[i2], parent);
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraXR, cameraL, cameraR);
      } else {
        cameraXR.projectionMatrix.copy(cameraL.projectionMatrix);
      }
      updateUserCamera(camera, cameraXR, parent);
    };
    function updateUserCamera(camera, cameraXR2, parent) {
      if (parent === null) {
        camera.matrix.copy(cameraXR2.matrixWorld);
      } else {
        camera.matrix.copy(parent.matrixWorld);
        camera.matrix.invert();
        camera.matrix.multiply(cameraXR2.matrixWorld);
      }
      camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
      camera.updateMatrixWorld(true);
      camera.projectionMatrix.copy(cameraXR2.projectionMatrix);
      camera.projectionMatrixInverse.copy(cameraXR2.projectionMatrixInverse);
      if (camera.isPerspectiveCamera) {
        camera.fov = RAD2DEG * 2 * Math.atan(1 / camera.projectionMatrix.elements[5]);
        camera.zoom = 1;
      }
    }
    this.getCamera = function() {
      return cameraXR;
    };
    this.getFoveation = function() {
      if (glProjLayer === null && glBaseLayer === null) {
        return void 0;
      }
      return foveation;
    };
    this.setFoveation = function(value) {
      foveation = value;
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = value;
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = value;
      }
    };
    this.hasDepthSensing = function() {
      return depthSensing.texture !== null;
    };
    this.getDepthSensingMesh = function() {
      return depthSensing.getMesh(cameraXR);
    };
    this.getCameraTexture = function(xrCamera) {
      return cameraAccessTextures[xrCamera];
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace);
      xrFrame = frame;
      if (pose !== null) {
        const views = pose.views;
        if (glBaseLayer !== null) {
          renderer.setRenderTargetFramebuffer(newRenderTarget, glBaseLayer.framebuffer);
          renderer.setRenderTarget(newRenderTarget);
        }
        let cameraXRNeedsUpdate = false;
        if (views.length !== cameraXR.cameras.length) {
          cameraXR.cameras.length = 0;
          cameraXRNeedsUpdate = true;
        }
        for (let i2 = 0; i2 < views.length; i2++) {
          const view = views[i2];
          let viewport = null;
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view);
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view);
            viewport = glSubImage.viewport;
            if (i2 === 0) {
              renderer.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glSubImage.depthStencilTexture
              );
              renderer.setRenderTarget(newRenderTarget);
            }
          }
          let camera = cameras[i2];
          if (camera === void 0) {
            camera = new PerspectiveCamera();
            camera.layers.enable(i2);
            camera.viewport = new Vector4();
            cameras[i2] = camera;
          }
          camera.matrix.fromArray(view.transform.matrix);
          camera.matrix.decompose(camera.position, camera.quaternion, camera.scale);
          camera.projectionMatrix.fromArray(view.projectionMatrix);
          camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();
          camera.viewport.set(viewport.x, viewport.y, viewport.width, viewport.height);
          if (i2 === 0) {
            cameraXR.matrix.copy(camera.matrix);
            cameraXR.matrix.decompose(cameraXR.position, cameraXR.quaternion, cameraXR.scale);
          }
          if (cameraXRNeedsUpdate === true) {
            cameraXR.cameras.push(camera);
          }
        }
        const enabledFeatures = session.enabledFeatures;
        const gpuDepthSensingEnabled = enabledFeatures && enabledFeatures.includes("depth-sensing") && session.depthUsage == "gpu-optimized";
        if (gpuDepthSensingEnabled && supportsGlBinding) {
          glBinding = scope.getBinding();
          const depthData = glBinding.getDepthInformation(views[0]);
          if (depthData && depthData.isValid && depthData.texture) {
            depthSensing.init(depthData, session.renderState);
          }
        }
        const cameraAccessEnabled = enabledFeatures && enabledFeatures.includes("camera-access");
        if (cameraAccessEnabled && supportsGlBinding) {
          renderer.state.unbindTexture();
          glBinding = scope.getBinding();
          for (let i2 = 0; i2 < views.length; i2++) {
            const camera = views[i2].camera;
            if (camera) {
              let cameraTex = cameraAccessTextures[camera];
              if (!cameraTex) {
                cameraTex = new ExternalTexture();
                cameraAccessTextures[camera] = cameraTex;
              }
              const glTexture = glBinding.getCameraImage(camera);
              cameraTex.sourceTexture = glTexture;
            }
          }
        }
      }
      for (let i2 = 0; i2 < controllers.length; i2++) {
        const inputSource = controllerInputSources[i2];
        const controller = controllers[i2];
        if (inputSource !== null && controller !== void 0) {
          controller.update(inputSource, frame, customReferenceSpace || referenceSpace);
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame);
      if (frame.detectedPlanes) {
        scope.dispatchEvent({ type: "planesdetected", data: frame });
      }
      xrFrame = null;
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
    };
    this.dispose = function() {
    };
  }
};
var _e1 = /* @__PURE__ */ new Euler();
var _m12 = /* @__PURE__ */ new Matrix4();
function WebGLMaterials(renderer, properties) {
  function refreshTransformUniform(map, uniform) {
    if (map.matrixAutoUpdate === true) {
      map.updateMatrix();
    }
    uniform.value.copy(map.matrix);
  }
  function refreshFogUniforms(uniforms, fog) {
    fog.color.getRGB(uniforms.fogColor.value, getUnlitUniformColorSpace(renderer));
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near;
      uniforms.fogFar.value = fog.far;
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density;
    }
  }
  function refreshMaterialUniforms(uniforms, material, pixelRatio, height, transmissionRenderTarget) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsToon(uniforms, material);
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsPhong(uniforms, material);
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsStandard(uniforms, material);
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget);
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsMatcap(uniforms, material);
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material);
      refreshUniformsDistance(uniforms, material);
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material);
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material);
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material);
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height);
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material);
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color);
      uniforms.opacity.value = material.opacity;
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false;
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity;
    if (material.color) {
      uniforms.diffuse.value.copy(material.color);
    }
    if (material.emissive) {
      uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);
    }
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap;
      refreshTransformUniform(material.bumpMap, uniforms.bumpMapTransform);
      uniforms.bumpScale.value = material.bumpScale;
      if (material.side === BackSide) {
        uniforms.bumpScale.value *= -1;
      }
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap;
      refreshTransformUniform(material.normalMap, uniforms.normalMapTransform);
      uniforms.normalScale.value.copy(material.normalScale);
      if (material.side === BackSide) {
        uniforms.normalScale.value.negate();
      }
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap;
      refreshTransformUniform(material.displacementMap, uniforms.displacementMapTransform);
      uniforms.displacementScale.value = material.displacementScale;
      uniforms.displacementBias.value = material.displacementBias;
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap;
      refreshTransformUniform(material.emissiveMap, uniforms.emissiveMapTransform);
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap;
      refreshTransformUniform(material.specularMap, uniforms.specularMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
    const materialProperties = properties.get(material);
    const envMap = materialProperties.envMap;
    const envMapRotation = materialProperties.envMapRotation;
    if (envMap) {
      uniforms.envMap.value = envMap;
      _e1.copy(envMapRotation);
      _e1.x *= -1;
      _e1.y *= -1;
      _e1.z *= -1;
      if (envMap.isCubeTexture && envMap.isRenderTargetTexture === false) {
        _e1.y *= -1;
        _e1.z *= -1;
      }
      uniforms.envMapRotation.value.setFromMatrix4(_m12.makeRotationFromEuler(_e1));
      uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      uniforms.reflectivity.value = material.reflectivity;
      uniforms.ior.value = material.ior;
      uniforms.refractionRatio.value = material.refractionRatio;
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap;
      uniforms.lightMapIntensity.value = material.lightMapIntensity;
      refreshTransformUniform(material.lightMap, uniforms.lightMapTransform);
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap;
      uniforms.aoMapIntensity.value = material.aoMapIntensity;
      refreshTransformUniform(material.aoMap, uniforms.aoMapTransform);
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize;
    uniforms.totalSize.value = material.dashSize + material.gapSize;
    uniforms.scale.value = material.scale;
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.size.value = material.size * pixelRatio;
    uniforms.scale.value = height * 0.5;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.uvTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color);
    uniforms.opacity.value = material.opacity;
    uniforms.rotation.value = material.rotation;
    if (material.map) {
      uniforms.map.value = material.map;
      refreshTransformUniform(material.map, uniforms.mapTransform);
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap;
      refreshTransformUniform(material.alphaMap, uniforms.alphaMapTransform);
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest;
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular);
    uniforms.shininess.value = Math.max(material.shininess, 1e-4);
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap;
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.metalness.value = material.metalness;
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap;
      refreshTransformUniform(material.metalnessMap, uniforms.metalnessMapTransform);
    }
    uniforms.roughness.value = material.roughness;
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap;
      refreshTransformUniform(material.roughnessMap, uniforms.roughnessMapTransform);
    }
    if (material.envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity;
    }
  }
  function refreshUniformsPhysical(uniforms, material, transmissionRenderTarget) {
    uniforms.ior.value = material.ior;
    if (material.sheen > 0) {
      uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen);
      uniforms.sheenRoughness.value = material.sheenRoughness;
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap;
        refreshTransformUniform(material.sheenColorMap, uniforms.sheenColorMapTransform);
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap;
        refreshTransformUniform(material.sheenRoughnessMap, uniforms.sheenRoughnessMapTransform);
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat;
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness;
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap;
        refreshTransformUniform(material.clearcoatMap, uniforms.clearcoatMapTransform);
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap;
        refreshTransformUniform(material.clearcoatRoughnessMap, uniforms.clearcoatRoughnessMapTransform);
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap;
        refreshTransformUniform(material.clearcoatNormalMap, uniforms.clearcoatNormalMapTransform);
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale);
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate();
        }
      }
    }
    if (material.dispersion > 0) {
      uniforms.dispersion.value = material.dispersion;
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence;
      uniforms.iridescenceIOR.value = material.iridescenceIOR;
      uniforms.iridescenceThicknessMinimum.value = material.iridescenceThicknessRange[0];
      uniforms.iridescenceThicknessMaximum.value = material.iridescenceThicknessRange[1];
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap;
        refreshTransformUniform(material.iridescenceMap, uniforms.iridescenceMapTransform);
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value = material.iridescenceThicknessMap;
        refreshTransformUniform(material.iridescenceThicknessMap, uniforms.iridescenceThicknessMapTransform);
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission;
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture;
      uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width, transmissionRenderTarget.height);
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap;
        refreshTransformUniform(material.transmissionMap, uniforms.transmissionMapTransform);
      }
      uniforms.thickness.value = material.thickness;
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap;
        refreshTransformUniform(material.thicknessMap, uniforms.thicknessMapTransform);
      }
      uniforms.attenuationDistance.value = material.attenuationDistance;
      uniforms.attenuationColor.value.copy(material.attenuationColor);
    }
    if (material.anisotropy > 0) {
      uniforms.anisotropyVector.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
      if (material.anisotropyMap) {
        uniforms.anisotropyMap.value = material.anisotropyMap;
        refreshTransformUniform(material.anisotropyMap, uniforms.anisotropyMapTransform);
      }
    }
    uniforms.specularIntensity.value = material.specularIntensity;
    uniforms.specularColor.value.copy(material.specularColor);
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap;
      refreshTransformUniform(material.specularColorMap, uniforms.specularColorMapTransform);
    }
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap;
      refreshTransformUniform(material.specularIntensityMap, uniforms.specularIntensityMapTransform);
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap;
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    const light = properties.get(material).light;
    uniforms.referencePosition.value.setFromMatrixPosition(light.matrixWorld);
    uniforms.nearDistance.value = light.shadow.camera.near;
    uniforms.farDistance.value = light.shadow.camera.far;
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms
  };
}
function WebGLUniformsGroups(gl, info, capabilities, state) {
  let buffers = {};
  let updateList = {};
  let allocatedBindingPoints = [];
  const maxBindingPoints = gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS);
  function bind2(uniformsGroup, program) {
    const webglProgram = program.program;
    state.uniformBlockBinding(uniformsGroup, webglProgram);
  }
  function update(uniformsGroup, program) {
    let buffer = buffers[uniformsGroup.id];
    if (buffer === void 0) {
      prepareUniformsGroup(uniformsGroup);
      buffer = createBuffer(uniformsGroup);
      buffers[uniformsGroup.id] = buffer;
      uniformsGroup.addEventListener("dispose", onUniformsGroupsDispose);
    }
    const webglProgram = program.program;
    state.updateUBOMapping(uniformsGroup, webglProgram);
    const frame = info.render.frame;
    if (updateList[uniformsGroup.id] !== frame) {
      updateBufferData(uniformsGroup);
      updateList[uniformsGroup.id] = frame;
    }
  }
  function createBuffer(uniformsGroup) {
    const bindingPointIndex = allocateBindingPointIndex();
    uniformsGroup.__bindingPointIndex = bindingPointIndex;
    const buffer = gl.createBuffer();
    const size = uniformsGroup.__size;
    const usage = uniformsGroup.usage;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    gl.bufferData(gl.UNIFORM_BUFFER, size, usage);
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
    gl.bindBufferBase(gl.UNIFORM_BUFFER, bindingPointIndex, buffer);
    return buffer;
  }
  function allocateBindingPointIndex() {
    for (let i2 = 0; i2 < maxBindingPoints; i2++) {
      if (allocatedBindingPoints.indexOf(i2) === -1) {
        allocatedBindingPoints.push(i2);
        return i2;
      }
    }
    error("WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");
    return 0;
  }
  function updateBufferData(uniformsGroup) {
    const buffer = buffers[uniformsGroup.id];
    const uniforms = uniformsGroup.uniforms;
    const cache = uniformsGroup.__cache;
    gl.bindBuffer(gl.UNIFORM_BUFFER, buffer);
    for (let i2 = 0, il = uniforms.length; i2 < il; i2++) {
      const uniformArray = Array.isArray(uniforms[i2]) ? uniforms[i2] : [uniforms[i2]];
      for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
        const uniform = uniformArray[j2];
        if (hasUniformChanged(uniform, i2, j2, cache) === true) {
          const offset = uniform.__offset;
          const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
          let arrayOffset = 0;
          for (let k2 = 0; k2 < values.length; k2++) {
            const value = values[k2];
            const info2 = getUniformSize(value);
            if (typeof value === "number" || typeof value === "boolean") {
              uniform.__data[0] = value;
              gl.bufferSubData(gl.UNIFORM_BUFFER, offset + arrayOffset, uniform.__data);
            } else if (value.isMatrix3) {
              uniform.__data[0] = value.elements[0];
              uniform.__data[1] = value.elements[1];
              uniform.__data[2] = value.elements[2];
              uniform.__data[3] = 0;
              uniform.__data[4] = value.elements[3];
              uniform.__data[5] = value.elements[4];
              uniform.__data[6] = value.elements[5];
              uniform.__data[7] = 0;
              uniform.__data[8] = value.elements[6];
              uniform.__data[9] = value.elements[7];
              uniform.__data[10] = value.elements[8];
              uniform.__data[11] = 0;
            } else {
              value.toArray(uniform.__data, arrayOffset);
              arrayOffset += info2.storage / Float32Array.BYTES_PER_ELEMENT;
            }
          }
          gl.bufferSubData(gl.UNIFORM_BUFFER, offset, uniform.__data);
        }
      }
    }
    gl.bindBuffer(gl.UNIFORM_BUFFER, null);
  }
  function hasUniformChanged(uniform, index, indexArray, cache) {
    const value = uniform.value;
    const indexString = index + "_" + indexArray;
    if (cache[indexString] === void 0) {
      if (typeof value === "number" || typeof value === "boolean") {
        cache[indexString] = value;
      } else {
        cache[indexString] = value.clone();
      }
      return true;
    } else {
      const cachedObject = cache[indexString];
      if (typeof value === "number" || typeof value === "boolean") {
        if (cachedObject !== value) {
          cache[indexString] = value;
          return true;
        }
      } else {
        if (cachedObject.equals(value) === false) {
          cachedObject.copy(value);
          return true;
        }
      }
    }
    return false;
  }
  function prepareUniformsGroup(uniformsGroup) {
    const uniforms = uniformsGroup.uniforms;
    let offset = 0;
    const chunkSize = 16;
    for (let i2 = 0, l2 = uniforms.length; i2 < l2; i2++) {
      const uniformArray = Array.isArray(uniforms[i2]) ? uniforms[i2] : [uniforms[i2]];
      for (let j2 = 0, jl = uniformArray.length; j2 < jl; j2++) {
        const uniform = uniformArray[j2];
        const values = Array.isArray(uniform.value) ? uniform.value : [uniform.value];
        for (let k2 = 0, kl = values.length; k2 < kl; k2++) {
          const value = values[k2];
          const info2 = getUniformSize(value);
          const chunkOffset2 = offset % chunkSize;
          const chunkPadding = chunkOffset2 % info2.boundary;
          const chunkStart = chunkOffset2 + chunkPadding;
          offset += chunkPadding;
          if (chunkStart !== 0 && chunkSize - chunkStart < info2.storage) {
            offset += chunkSize - chunkStart;
          }
          uniform.__data = new Float32Array(info2.storage / Float32Array.BYTES_PER_ELEMENT);
          uniform.__offset = offset;
          offset += info2.storage;
        }
      }
    }
    const chunkOffset = offset % chunkSize;
    if (chunkOffset > 0) offset += chunkSize - chunkOffset;
    uniformsGroup.__size = offset;
    uniformsGroup.__cache = {};
    return this;
  }
  function getUniformSize(value) {
    const info2 = {
      boundary: 0,
      // bytes
      storage: 0
      // bytes
    };
    if (typeof value === "number" || typeof value === "boolean") {
      info2.boundary = 4;
      info2.storage = 4;
    } else if (value.isVector2) {
      info2.boundary = 8;
      info2.storage = 8;
    } else if (value.isVector3 || value.isColor) {
      info2.boundary = 16;
      info2.storage = 12;
    } else if (value.isVector4) {
      info2.boundary = 16;
      info2.storage = 16;
    } else if (value.isMatrix3) {
      info2.boundary = 48;
      info2.storage = 48;
    } else if (value.isMatrix4) {
      info2.boundary = 64;
      info2.storage = 64;
    } else if (value.isTexture) {
      warn("WebGLRenderer: Texture samplers can not be part of an uniforms group.");
    } else {
      warn("WebGLRenderer: Unsupported uniform value type.", value);
    }
    return info2;
  }
  function onUniformsGroupsDispose(event) {
    const uniformsGroup = event.target;
    uniformsGroup.removeEventListener("dispose", onUniformsGroupsDispose);
    const index = allocatedBindingPoints.indexOf(uniformsGroup.__bindingPointIndex);
    allocatedBindingPoints.splice(index, 1);
    gl.deleteBuffer(buffers[uniformsGroup.id]);
    delete buffers[uniformsGroup.id];
    delete updateList[uniformsGroup.id];
  }
  function dispose2() {
    for (const id in buffers) {
      gl.deleteBuffer(buffers[id]);
    }
    allocatedBindingPoints = [];
    buffers = {};
    updateList = {};
  }
  return {
    bind: bind2,
    update,
    dispose: dispose2
  };
}
var DATA = new Uint16Array([
  12469,
  15057,
  12620,
  14925,
  13266,
  14620,
  13807,
  14376,
  14323,
  13990,
  14545,
  13625,
  14713,
  13328,
  14840,
  12882,
  14931,
  12528,
  14996,
  12233,
  15039,
  11829,
  15066,
  11525,
  15080,
  11295,
  15085,
  10976,
  15082,
  10705,
  15073,
  10495,
  13880,
  14564,
  13898,
  14542,
  13977,
  14430,
  14158,
  14124,
  14393,
  13732,
  14556,
  13410,
  14702,
  12996,
  14814,
  12596,
  14891,
  12291,
  14937,
  11834,
  14957,
  11489,
  14958,
  11194,
  14943,
  10803,
  14921,
  10506,
  14893,
  10278,
  14858,
  9960,
  14484,
  14039,
  14487,
  14025,
  14499,
  13941,
  14524,
  13740,
  14574,
  13468,
  14654,
  13106,
  14743,
  12678,
  14818,
  12344,
  14867,
  11893,
  14889,
  11509,
  14893,
  11180,
  14881,
  10751,
  14852,
  10428,
  14812,
  10128,
  14765,
  9754,
  14712,
  9466,
  14764,
  13480,
  14764,
  13475,
  14766,
  13440,
  14766,
  13347,
  14769,
  13070,
  14786,
  12713,
  14816,
  12387,
  14844,
  11957,
  14860,
  11549,
  14868,
  11215,
  14855,
  10751,
  14825,
  10403,
  14782,
  10044,
  14729,
  9651,
  14666,
  9352,
  14599,
  9029,
  14967,
  12835,
  14966,
  12831,
  14963,
  12804,
  14954,
  12723,
  14936,
  12564,
  14917,
  12347,
  14900,
  11958,
  14886,
  11569,
  14878,
  11247,
  14859,
  10765,
  14828,
  10401,
  14784,
  10011,
  14727,
  9600,
  14660,
  9289,
  14586,
  8893,
  14508,
  8533,
  15111,
  12234,
  15110,
  12234,
  15104,
  12216,
  15092,
  12156,
  15067,
  12010,
  15028,
  11776,
  14981,
  11500,
  14942,
  11205,
  14902,
  10752,
  14861,
  10393,
  14812,
  9991,
  14752,
  9570,
  14682,
  9252,
  14603,
  8808,
  14519,
  8445,
  14431,
  8145,
  15209,
  11449,
  15208,
  11451,
  15202,
  11451,
  15190,
  11438,
  15163,
  11384,
  15117,
  11274,
  15055,
  10979,
  14994,
  10648,
  14932,
  10343,
  14871,
  9936,
  14803,
  9532,
  14729,
  9218,
  14645,
  8742,
  14556,
  8381,
  14461,
  8020,
  14365,
  7603,
  15273,
  10603,
  15272,
  10607,
  15267,
  10619,
  15256,
  10631,
  15231,
  10614,
  15182,
  10535,
  15118,
  10389,
  15042,
  10167,
  14963,
  9787,
  14883,
  9447,
  14800,
  9115,
  14710,
  8665,
  14615,
  8318,
  14514,
  7911,
  14411,
  7507,
  14279,
  7198,
  15314,
  9675,
  15313,
  9683,
  15309,
  9712,
  15298,
  9759,
  15277,
  9797,
  15229,
  9773,
  15166,
  9668,
  15084,
  9487,
  14995,
  9274,
  14898,
  8910,
  14800,
  8539,
  14697,
  8234,
  14590,
  7790,
  14479,
  7409,
  14367,
  7067,
  14178,
  6621,
  15337,
  8619,
  15337,
  8631,
  15333,
  8677,
  15325,
  8769,
  15305,
  8871,
  15264,
  8940,
  15202,
  8909,
  15119,
  8775,
  15022,
  8565,
  14916,
  8328,
  14804,
  8009,
  14688,
  7614,
  14569,
  7287,
  14448,
  6888,
  14321,
  6483,
  14088,
  6171,
  15350,
  7402,
  15350,
  7419,
  15347,
  7480,
  15340,
  7613,
  15322,
  7804,
  15287,
  7973,
  15229,
  8057,
  15148,
  8012,
  15046,
  7846,
  14933,
  7611,
  14810,
  7357,
  14682,
  7069,
  14552,
  6656,
  14421,
  6316,
  14251,
  5948,
  14007,
  5528,
  15356,
  5942,
  15356,
  5977,
  15353,
  6119,
  15348,
  6294,
  15332,
  6551,
  15302,
  6824,
  15249,
  7044,
  15171,
  7122,
  15070,
  7050,
  14949,
  6861,
  14818,
  6611,
  14679,
  6349,
  14538,
  6067,
  14398,
  5651,
  14189,
  5311,
  13935,
  4958,
  15359,
  4123,
  15359,
  4153,
  15356,
  4296,
  15353,
  4646,
  15338,
  5160,
  15311,
  5508,
  15263,
  5829,
  15188,
  6042,
  15088,
  6094,
  14966,
  6001,
  14826,
  5796,
  14678,
  5543,
  14527,
  5287,
  14377,
  4985,
  14133,
  4586,
  13869,
  4257,
  15360,
  1563,
  15360,
  1642,
  15358,
  2076,
  15354,
  2636,
  15341,
  3350,
  15317,
  4019,
  15273,
  4429,
  15203,
  4732,
  15105,
  4911,
  14981,
  4932,
  14836,
  4818,
  14679,
  4621,
  14517,
  4386,
  14359,
  4156,
  14083,
  3795,
  13808,
  3437,
  15360,
  122,
  15360,
  137,
  15358,
  285,
  15355,
  636,
  15344,
  1274,
  15322,
  2177,
  15281,
  2765,
  15215,
  3223,
  15120,
  3451,
  14995,
  3569,
  14846,
  3567,
  14681,
  3466,
  14511,
  3305,
  14344,
  3121,
  14037,
  2800,
  13753,
  2467,
  15360,
  0,
  15360,
  1,
  15359,
  21,
  15355,
  89,
  15346,
  253,
  15325,
  479,
  15287,
  796,
  15225,
  1148,
  15133,
  1492,
  15008,
  1749,
  14856,
  1882,
  14685,
  1886,
  14506,
  1783,
  14324,
  1608,
  13996,
  1398,
  13702,
  1183
]);
var lut = null;
function getDFGLUT() {
  if (lut === null) {
    lut = new DataTexture(DATA, 16, 16, RGFormat, HalfFloatType);
    lut.name = "DFG_LUT";
    lut.minFilter = LinearFilter;
    lut.magFilter = LinearFilter;
    lut.wrapS = ClampToEdgeWrapping;
    lut.wrapT = ClampToEdgeWrapping;
    lut.generateMipmaps = false;
    lut.needsUpdate = true;
  }
  return lut;
}
var WebGLRenderer = class {
  /**
   * Constructs a new WebGL renderer.
   *
   * @param {WebGLRenderer~Options} [parameters] - The configuration parameter.
   */
  constructor(parameters = {}) {
    const {
      canvas = createCanvasElement(),
      context = null,
      depth = true,
      stencil = false,
      alpha = false,
      antialias = false,
      premultipliedAlpha = true,
      preserveDrawingBuffer = false,
      powerPreference = "default",
      failIfMajorPerformanceCaveat = false,
      reversedDepthBuffer = false,
      outputBufferType = UnsignedByteType
    } = parameters;
    this.isWebGLRenderer = true;
    let _alpha;
    if (context !== null) {
      if (typeof WebGLRenderingContext !== "undefined" && context instanceof WebGLRenderingContext) {
        throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
      }
      _alpha = context.getContextAttributes().alpha;
    } else {
      _alpha = alpha;
    }
    const _outputBufferType = outputBufferType;
    const INTEGER_FORMATS = /* @__PURE__ */ new Set([
      RGBAIntegerFormat,
      RGIntegerFormat,
      RedIntegerFormat
    ]);
    const UNSIGNED_TYPES = /* @__PURE__ */ new Set([
      UnsignedByteType,
      UnsignedIntType,
      UnsignedShortType,
      UnsignedInt248Type,
      UnsignedShort4444Type,
      UnsignedShort5551Type
    ]);
    const uintClearColor = new Uint32Array(4);
    const intClearColor = new Int32Array(4);
    let currentRenderList = null;
    let currentRenderState = null;
    const renderListStack = [];
    const renderStateStack = [];
    let output = null;
    this.domElement = canvas;
    this.debug = {
      /**
       * Enables error checking and reporting when shader programs are being compiled.
       * @type {boolean}
       */
      checkShaderErrors: true,
      /**
       * Callback for custom error reporting.
       * @type {?Function}
       */
      onShaderError: null
    };
    this.autoClear = true;
    this.autoClearColor = true;
    this.autoClearDepth = true;
    this.autoClearStencil = true;
    this.sortObjects = true;
    this.clippingPlanes = [];
    this.localClippingEnabled = false;
    this.toneMapping = NoToneMapping;
    this.toneMappingExposure = 1;
    this.transmissionResolutionScale = 1;
    const _this = this;
    let _isContextLost = false;
    this._outputColorSpace = SRGBColorSpace;
    let _currentActiveCubeFace = 0;
    let _currentActiveMipmapLevel = 0;
    let _currentRenderTarget = null;
    let _currentMaterialId = -1;
    let _currentCamera = null;
    const _currentViewport = new Vector4();
    const _currentScissor = new Vector4();
    let _currentScissorTest = null;
    const _currentClearColor = new Color(0);
    let _currentClearAlpha = 0;
    let _width = canvas.width;
    let _height = canvas.height;
    let _pixelRatio = 1;
    let _opaqueSort = null;
    let _transparentSort = null;
    const _viewport = new Vector4(0, 0, _width, _height);
    const _scissor = new Vector4(0, 0, _width, _height);
    let _scissorTest = false;
    const _frustum = new Frustum();
    let _clippingEnabled = false;
    let _localClippingEnabled = false;
    const _projScreenMatrix3 = new Matrix4();
    const _vector32 = new Vector3();
    const _vector4 = new Vector4();
    const _emptyScene = { background: null, fog: null, environment: null, overrideMaterial: null, isScene: true };
    let _renderBackground = false;
    function getTargetPixelRatio() {
      return _currentRenderTarget === null ? _pixelRatio : 1;
    }
    let _gl = context;
    function getContext(contextName, contextAttributes) {
      return canvas.getContext(contextName, contextAttributes);
    }
    try {
      const contextAttributes = {
        alpha: true,
        depth,
        stencil,
        antialias,
        premultipliedAlpha,
        preserveDrawingBuffer,
        powerPreference,
        failIfMajorPerformanceCaveat
      };
      if ("setAttribute" in canvas) canvas.setAttribute("data-engine", `three.js r${REVISION}`);
      canvas.addEventListener("webglcontextlost", onContextLost, false);
      canvas.addEventListener("webglcontextrestored", onContextRestore, false);
      canvas.addEventListener("webglcontextcreationerror", onContextCreationError, false);
      if (_gl === null) {
        const contextName = "webgl2";
        _gl = getContext(contextName, contextAttributes);
        if (_gl === null) {
          if (getContext(contextName)) {
            throw new Error("Error creating WebGL context with your selected attributes.");
          } else {
            throw new Error("Error creating WebGL context.");
          }
        }
      }
    } catch (e2) {
      error("WebGLRenderer: " + e2.message);
      throw e2;
    }
    let extensions, capabilities, state, info;
    let properties, textures, cubemaps, cubeuvmaps, attributes, geometries, objects;
    let programCache, materials, renderLists, renderStates, clipping, shadowMap;
    let background, morphtargets, bufferRenderer, indexedBufferRenderer;
    let utils, bindingStates, uniformsGroups;
    function initGLContext() {
      extensions = new WebGLExtensions(_gl);
      extensions.init();
      utils = new WebGLUtils(_gl, extensions);
      capabilities = new WebGLCapabilities(_gl, extensions, parameters, utils);
      state = new WebGLState(_gl, extensions);
      if (capabilities.reversedDepthBuffer && reversedDepthBuffer) {
        state.buffers.depth.setReversed(true);
      }
      info = new WebGLInfo(_gl);
      properties = new WebGLProperties();
      textures = new WebGLTextures(_gl, extensions, state, properties, capabilities, utils, info);
      cubemaps = new WebGLCubeMaps(_this);
      cubeuvmaps = new WebGLCubeUVMaps(_this);
      attributes = new WebGLAttributes(_gl);
      bindingStates = new WebGLBindingStates(_gl, attributes);
      geometries = new WebGLGeometries(_gl, attributes, info, bindingStates);
      objects = new WebGLObjects(_gl, geometries, attributes, info);
      morphtargets = new WebGLMorphtargets(_gl, capabilities, textures);
      clipping = new WebGLClipping(properties);
      programCache = new WebGLPrograms(_this, cubemaps, cubeuvmaps, extensions, capabilities, bindingStates, clipping);
      materials = new WebGLMaterials(_this, properties);
      renderLists = new WebGLRenderLists();
      renderStates = new WebGLRenderStates(extensions);
      background = new WebGLBackground(_this, cubemaps, cubeuvmaps, state, objects, _alpha, premultipliedAlpha);
      shadowMap = new WebGLShadowMap(_this, objects, capabilities);
      uniformsGroups = new WebGLUniformsGroups(_gl, info, capabilities, state);
      bufferRenderer = new WebGLBufferRenderer(_gl, extensions, info);
      indexedBufferRenderer = new WebGLIndexedBufferRenderer(_gl, extensions, info);
      info.programs = programCache.programs;
      _this.capabilities = capabilities;
      _this.extensions = extensions;
      _this.properties = properties;
      _this.renderLists = renderLists;
      _this.shadowMap = shadowMap;
      _this.state = state;
      _this.info = info;
    }
    initGLContext();
    if (_outputBufferType !== UnsignedByteType) {
      output = new WebGLOutput(_outputBufferType, canvas.width, canvas.height, depth, stencil);
    }
    const xr2 = new WebXRManager(_this, _gl);
    this.xr = xr2;
    this.getContext = function() {
      return _gl;
    };
    this.getContextAttributes = function() {
      return _gl.getContextAttributes();
    };
    this.forceContextLoss = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.loseContext();
    };
    this.forceContextRestore = function() {
      const extension = extensions.get("WEBGL_lose_context");
      if (extension) extension.restoreContext();
    };
    this.getPixelRatio = function() {
      return _pixelRatio;
    };
    this.setPixelRatio = function(value) {
      if (value === void 0) return;
      _pixelRatio = value;
      this.setSize(_width, _height, false);
    };
    this.getSize = function(target) {
      return target.set(_width, _height);
    };
    this.setSize = function(width, height, updateStyle = true) {
      if (xr2.isPresenting) {
        warn("WebGLRenderer: Can't change size while VR device is presenting.");
        return;
      }
      _width = width;
      _height = height;
      canvas.width = Math.floor(width * _pixelRatio);
      canvas.height = Math.floor(height * _pixelRatio);
      if (updateStyle === true) {
        canvas.style.width = width + "px";
        canvas.style.height = height + "px";
      }
      if (output !== null) {
        output.setSize(canvas.width, canvas.height);
      }
      this.setViewport(0, 0, width, height);
    };
    this.getDrawingBufferSize = function(target) {
      return target.set(_width * _pixelRatio, _height * _pixelRatio).floor();
    };
    this.setDrawingBufferSize = function(width, height, pixelRatio) {
      _width = width;
      _height = height;
      _pixelRatio = pixelRatio;
      canvas.width = Math.floor(width * pixelRatio);
      canvas.height = Math.floor(height * pixelRatio);
      this.setViewport(0, 0, width, height);
    };
    this.setEffects = function(effects) {
      if (_outputBufferType === UnsignedByteType) {
        console.error("THREE.WebGLRenderer: setEffects() requires outputBufferType set to HalfFloatType or FloatType.");
        return;
      }
      if (effects) {
        for (let i2 = 0; i2 < effects.length; i2++) {
          if (effects[i2].isOutputPass === true) {
            console.warn("THREE.WebGLRenderer: OutputPass is not needed in setEffects(). Tone mapping and color space conversion are applied automatically.");
            break;
          }
        }
      }
      output.setEffects(effects || []);
    };
    this.getCurrentViewport = function(target) {
      return target.copy(_currentViewport);
    };
    this.getViewport = function(target) {
      return target.copy(_viewport);
    };
    this.setViewport = function(x2, y2, width, height) {
      if (x2.isVector4) {
        _viewport.set(x2.x, x2.y, x2.z, x2.w);
      } else {
        _viewport.set(x2, y2, width, height);
      }
      state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).round());
    };
    this.getScissor = function(target) {
      return target.copy(_scissor);
    };
    this.setScissor = function(x2, y2, width, height) {
      if (x2.isVector4) {
        _scissor.set(x2.x, x2.y, x2.z, x2.w);
      } else {
        _scissor.set(x2, y2, width, height);
      }
      state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).round());
    };
    this.getScissorTest = function() {
      return _scissorTest;
    };
    this.setScissorTest = function(boolean) {
      state.setScissorTest(_scissorTest = boolean);
    };
    this.setOpaqueSort = function(method) {
      _opaqueSort = method;
    };
    this.setTransparentSort = function(method) {
      _transparentSort = method;
    };
    this.getClearColor = function(target) {
      return target.copy(background.getClearColor());
    };
    this.setClearColor = function() {
      background.setClearColor(...arguments);
    };
    this.getClearAlpha = function() {
      return background.getClearAlpha();
    };
    this.setClearAlpha = function() {
      background.setClearAlpha(...arguments);
    };
    this.clear = function(color = true, depth2 = true, stencil2 = true) {
      let bits = 0;
      if (color) {
        let isIntegerFormat = false;
        if (_currentRenderTarget !== null) {
          const targetFormat = _currentRenderTarget.texture.format;
          isIntegerFormat = INTEGER_FORMATS.has(targetFormat);
        }
        if (isIntegerFormat) {
          const targetType = _currentRenderTarget.texture.type;
          const isUnsignedType = UNSIGNED_TYPES.has(targetType);
          const clearColor = background.getClearColor();
          const a2 = background.getClearAlpha();
          const r2 = clearColor.r;
          const g2 = clearColor.g;
          const b2 = clearColor.b;
          if (isUnsignedType) {
            uintClearColor[0] = r2;
            uintClearColor[1] = g2;
            uintClearColor[2] = b2;
            uintClearColor[3] = a2;
            _gl.clearBufferuiv(_gl.COLOR, 0, uintClearColor);
          } else {
            intClearColor[0] = r2;
            intClearColor[1] = g2;
            intClearColor[2] = b2;
            intClearColor[3] = a2;
            _gl.clearBufferiv(_gl.COLOR, 0, intClearColor);
          }
        } else {
          bits |= _gl.COLOR_BUFFER_BIT;
        }
      }
      if (depth2) {
        bits |= _gl.DEPTH_BUFFER_BIT;
      }
      if (stencil2) {
        bits |= _gl.STENCIL_BUFFER_BIT;
        this.state.buffers.stencil.setMask(4294967295);
      }
      _gl.clear(bits);
    };
    this.clearColor = function() {
      this.clear(true, false, false);
    };
    this.clearDepth = function() {
      this.clear(false, true, false);
    };
    this.clearStencil = function() {
      this.clear(false, false, true);
    };
    this.dispose = function() {
      canvas.removeEventListener("webglcontextlost", onContextLost, false);
      canvas.removeEventListener("webglcontextrestored", onContextRestore, false);
      canvas.removeEventListener("webglcontextcreationerror", onContextCreationError, false);
      background.dispose();
      renderLists.dispose();
      renderStates.dispose();
      properties.dispose();
      cubemaps.dispose();
      cubeuvmaps.dispose();
      objects.dispose();
      bindingStates.dispose();
      uniformsGroups.dispose();
      programCache.dispose();
      xr2.dispose();
      xr2.removeEventListener("sessionstart", onXRSessionStart);
      xr2.removeEventListener("sessionend", onXRSessionEnd);
      animation.stop();
    };
    function onContextLost(event) {
      event.preventDefault();
      log("WebGLRenderer: Context Lost.");
      _isContextLost = true;
    }
    function onContextRestore() {
      log("WebGLRenderer: Context Restored.");
      _isContextLost = false;
      const infoAutoReset = info.autoReset;
      const shadowMapEnabled = shadowMap.enabled;
      const shadowMapAutoUpdate = shadowMap.autoUpdate;
      const shadowMapNeedsUpdate = shadowMap.needsUpdate;
      const shadowMapType = shadowMap.type;
      initGLContext();
      info.autoReset = infoAutoReset;
      shadowMap.enabled = shadowMapEnabled;
      shadowMap.autoUpdate = shadowMapAutoUpdate;
      shadowMap.needsUpdate = shadowMapNeedsUpdate;
      shadowMap.type = shadowMapType;
    }
    function onContextCreationError(event) {
      error("WebGLRenderer: A WebGL context could not be created. Reason: ", event.statusMessage);
    }
    function onMaterialDispose(event) {
      const material = event.target;
      material.removeEventListener("dispose", onMaterialDispose);
      deallocateMaterial(material);
    }
    function deallocateMaterial(material) {
      releaseMaterialProgramReferences(material);
      properties.remove(material);
    }
    function releaseMaterialProgramReferences(material) {
      const programs = properties.get(material).programs;
      if (programs !== void 0) {
        programs.forEach(function(program) {
          programCache.releaseProgram(program);
        });
        if (material.isShaderMaterial) {
          programCache.releaseShaderCache(material);
        }
      }
    }
    this.renderBufferDirect = function(camera, scene, geometry, material, object, group) {
      if (scene === null) scene = _emptyScene;
      const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
      const program = setProgram(camera, scene, geometry, material, object);
      state.setMaterial(material, frontFaceCW);
      let index = geometry.index;
      let rangeFactor = 1;
      if (material.wireframe === true) {
        index = geometries.getWireframeAttribute(geometry);
        if (index === void 0) return;
        rangeFactor = 2;
      }
      const drawRange = geometry.drawRange;
      const position = geometry.attributes.position;
      let drawStart = drawRange.start * rangeFactor;
      let drawEnd = (drawRange.start + drawRange.count) * rangeFactor;
      if (group !== null) {
        drawStart = Math.max(drawStart, group.start * rangeFactor);
        drawEnd = Math.min(drawEnd, (group.start + group.count) * rangeFactor);
      }
      if (index !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, index.count);
      } else if (position !== void 0 && position !== null) {
        drawStart = Math.max(drawStart, 0);
        drawEnd = Math.min(drawEnd, position.count);
      }
      const drawCount = drawEnd - drawStart;
      if (drawCount < 0 || drawCount === Infinity) return;
      bindingStates.setup(object, material, program, geometry, index);
      let attribute;
      let renderer = bufferRenderer;
      if (index !== null) {
        attribute = attributes.get(index);
        renderer = indexedBufferRenderer;
        renderer.setIndex(attribute);
      }
      if (object.isMesh) {
        if (material.wireframe === true) {
          state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio());
          renderer.setMode(_gl.LINES);
        } else {
          renderer.setMode(_gl.TRIANGLES);
        }
      } else if (object.isLine) {
        let lineWidth = material.linewidth;
        if (lineWidth === void 0) lineWidth = 1;
        state.setLineWidth(lineWidth * getTargetPixelRatio());
        if (object.isLineSegments) {
          renderer.setMode(_gl.LINES);
        } else if (object.isLineLoop) {
          renderer.setMode(_gl.LINE_LOOP);
        } else {
          renderer.setMode(_gl.LINE_STRIP);
        }
      } else if (object.isPoints) {
        renderer.setMode(_gl.POINTS);
      } else if (object.isSprite) {
        renderer.setMode(_gl.TRIANGLES);
      }
      if (object.isBatchedMesh) {
        if (object._multiDrawInstances !== null) {
          warnOnce("WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");
          renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
        } else {
          if (!extensions.get("WEBGL_multi_draw")) {
            const starts = object._multiDrawStarts;
            const counts = object._multiDrawCounts;
            const drawCount2 = object._multiDrawCount;
            const bytesPerElement = index ? attributes.get(index).bytesPerElement : 1;
            const uniforms = properties.get(material).currentProgram.getUniforms();
            for (let i2 = 0; i2 < drawCount2; i2++) {
              uniforms.setValue(_gl, "_gl_DrawID", i2);
              renderer.render(starts[i2] / bytesPerElement, counts[i2]);
            }
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        }
      } else if (object.isInstancedMesh) {
        renderer.renderInstances(drawStart, drawCount, object.count);
      } else if (geometry.isInstancedBufferGeometry) {
        const maxInstanceCount = geometry._maxInstanceCount !== void 0 ? geometry._maxInstanceCount : Infinity;
        const instanceCount = Math.min(geometry.instanceCount, maxInstanceCount);
        renderer.renderInstances(drawStart, drawCount, instanceCount);
      } else {
        renderer.render(drawStart, drawCount);
      }
    };
    function prepareMaterial(material, scene, object) {
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = FrontSide;
        material.needsUpdate = true;
        getProgram(material, scene, object);
        material.side = DoubleSide;
      } else {
        getProgram(material, scene, object);
      }
    }
    this.compile = function(scene, camera, targetScene = null) {
      if (targetScene === null) targetScene = scene;
      currentRenderState = renderStates.get(targetScene);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      targetScene.traverseVisible(function(object) {
        if (object.isLight && object.layers.test(camera.layers)) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        }
      });
      if (scene !== targetScene) {
        scene.traverseVisible(function(object) {
          if (object.isLight && object.layers.test(camera.layers)) {
            currentRenderState.pushLight(object);
            if (object.castShadow) {
              currentRenderState.pushShadow(object);
            }
          }
        });
      }
      currentRenderState.setupLights();
      const materials2 = /* @__PURE__ */ new Set();
      scene.traverse(function(object) {
        if (!(object.isMesh || object.isPoints || object.isLine || object.isSprite)) {
          return;
        }
        const material = object.material;
        if (material) {
          if (Array.isArray(material)) {
            for (let i2 = 0; i2 < material.length; i2++) {
              const material2 = material[i2];
              prepareMaterial(material2, targetScene, object);
              materials2.add(material2);
            }
          } else {
            prepareMaterial(material, targetScene, object);
            materials2.add(material);
          }
        }
      });
      currentRenderState = renderStateStack.pop();
      return materials2;
    };
    this.compileAsync = function(scene, camera, targetScene = null) {
      const materials2 = this.compile(scene, camera, targetScene);
      return new Promise((resolve) => {
        function checkMaterialsReady() {
          materials2.forEach(function(material) {
            const materialProperties = properties.get(material);
            const program = materialProperties.currentProgram;
            if (program.isReady()) {
              materials2.delete(material);
            }
          });
          if (materials2.size === 0) {
            resolve(scene);
            return;
          }
          setTimeout(checkMaterialsReady, 10);
        }
        if (extensions.get("KHR_parallel_shader_compile") !== null) {
          checkMaterialsReady();
        } else {
          setTimeout(checkMaterialsReady, 10);
        }
      });
    };
    let onAnimationFrameCallback = null;
    function onAnimationFrame(time) {
      if (onAnimationFrameCallback) onAnimationFrameCallback(time);
    }
    function onXRSessionStart() {
      animation.stop();
    }
    function onXRSessionEnd() {
      animation.start();
    }
    const animation = new WebGLAnimation();
    animation.setAnimationLoop(onAnimationFrame);
    if (typeof self !== "undefined") animation.setContext(self);
    this.setAnimationLoop = function(callback) {
      onAnimationFrameCallback = callback;
      xr2.setAnimationLoop(callback);
      callback === null ? animation.stop() : animation.start();
    };
    xr2.addEventListener("sessionstart", onXRSessionStart);
    xr2.addEventListener("sessionend", onXRSessionEnd);
    this.render = function(scene, camera) {
      if (camera !== void 0 && camera.isCamera !== true) {
        error("WebGLRenderer.render: camera is not an instance of THREE.Camera.");
        return;
      }
      if (_isContextLost === true) return;
      const isXRPresenting = xr2.enabled === true && xr2.isPresenting === true;
      const useOutput = output !== null && (_currentRenderTarget === null || isXRPresenting) && output.begin(_this, _currentRenderTarget);
      if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
      if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();
      if (xr2.enabled === true && xr2.isPresenting === true && (output === null || output.isCompositing() === false)) {
        if (xr2.cameraAutoUpdate === true) xr2.updateCamera(camera);
        camera = xr2.getCamera();
      }
      if (scene.isScene === true) scene.onBeforeRender(_this, scene, camera, _currentRenderTarget);
      currentRenderState = renderStates.get(scene, renderStateStack.length);
      currentRenderState.init(camera);
      renderStateStack.push(currentRenderState);
      _projScreenMatrix3.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
      _frustum.setFromProjectionMatrix(_projScreenMatrix3, WebGLCoordinateSystem, camera.reversedDepth);
      _localClippingEnabled = this.localClippingEnabled;
      _clippingEnabled = clipping.init(this.clippingPlanes, _localClippingEnabled);
      currentRenderList = renderLists.get(scene, renderListStack.length);
      currentRenderList.init();
      renderListStack.push(currentRenderList);
      if (xr2.enabled === true && xr2.isPresenting === true) {
        const depthSensingMesh = _this.xr.getDepthSensingMesh();
        if (depthSensingMesh !== null) {
          projectObject(depthSensingMesh, camera, -Infinity, _this.sortObjects);
        }
      }
      projectObject(scene, camera, 0, _this.sortObjects);
      currentRenderList.finish();
      if (_this.sortObjects === true) {
        currentRenderList.sort(_opaqueSort, _transparentSort);
      }
      _renderBackground = xr2.enabled === false || xr2.isPresenting === false || xr2.hasDepthSensing() === false;
      if (_renderBackground) {
        background.addToRenderList(currentRenderList, scene);
      }
      this.info.render.frame++;
      if (_clippingEnabled === true) clipping.beginShadows();
      const shadowsArray = currentRenderState.state.shadowsArray;
      shadowMap.render(shadowsArray, scene, camera);
      if (_clippingEnabled === true) clipping.endShadows();
      if (this.info.autoReset === true) this.info.reset();
      const skipSceneRender = useOutput && output.hasRenderPass();
      if (skipSceneRender === false) {
        const opaqueObjects = currentRenderList.opaque;
        const transmissiveObjects = currentRenderList.transmissive;
        currentRenderState.setupLights();
        if (camera.isArrayCamera) {
          const cameras = camera.cameras;
          if (transmissiveObjects.length > 0) {
            for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
              const camera2 = cameras[i2];
              renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera2);
            }
          }
          if (_renderBackground) background.render(scene);
          for (let i2 = 0, l2 = cameras.length; i2 < l2; i2++) {
            const camera2 = cameras[i2];
            renderScene(currentRenderList, scene, camera2, camera2.viewport);
          }
        } else {
          if (transmissiveObjects.length > 0) renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera);
          if (_renderBackground) background.render(scene);
          renderScene(currentRenderList, scene, camera);
        }
      }
      if (_currentRenderTarget !== null && _currentActiveMipmapLevel === 0) {
        textures.updateMultisampleRenderTarget(_currentRenderTarget);
        textures.updateRenderTargetMipmap(_currentRenderTarget);
      }
      if (useOutput) {
        output.end(_this);
      }
      if (scene.isScene === true) scene.onAfterRender(_this, scene, camera);
      bindingStates.resetDefaultState();
      _currentMaterialId = -1;
      _currentCamera = null;
      renderStateStack.pop();
      if (renderStateStack.length > 0) {
        currentRenderState = renderStateStack[renderStateStack.length - 1];
        if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, currentRenderState.state.camera);
      } else {
        currentRenderState = null;
      }
      renderListStack.pop();
      if (renderListStack.length > 0) {
        currentRenderList = renderListStack[renderListStack.length - 1];
      } else {
        currentRenderList = null;
      }
    };
    function projectObject(object, camera, groupOrder, sortObjects) {
      if (object.visible === false) return;
      const visible = object.layers.test(camera.layers);
      if (visible) {
        if (object.isGroup) {
          groupOrder = object.renderOrder;
        } else if (object.isLOD) {
          if (object.autoUpdate === true) object.update(camera);
        } else if (object.isLight) {
          currentRenderState.pushLight(object);
          if (object.castShadow) {
            currentRenderState.pushShadow(object);
          }
        } else if (object.isSprite) {
          if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
            if (sortObjects) {
              _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
            }
            const geometry = objects.update(object);
            const material = object.material;
            if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        } else if (object.isMesh || object.isLine || object.isPoints) {
          if (!object.frustumCulled || _frustum.intersectsObject(object)) {
            const geometry = objects.update(object);
            const material = object.material;
            if (sortObjects) {
              if (object.boundingSphere !== void 0) {
                if (object.boundingSphere === null) object.computeBoundingSphere();
                _vector4.copy(object.boundingSphere.center);
              } else {
                if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
                _vector4.copy(geometry.boundingSphere.center);
              }
              _vector4.applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix3);
            }
            if (Array.isArray(material)) {
              const groups = geometry.groups;
              for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
                const group = groups[i2];
                const groupMaterial = material[group.materialIndex];
                if (groupMaterial && groupMaterial.visible) {
                  currentRenderList.push(object, geometry, groupMaterial, groupOrder, _vector4.z, group);
                }
              }
            } else if (material.visible) {
              currentRenderList.push(object, geometry, material, groupOrder, _vector4.z, null);
            }
          }
        }
      }
      const children = object.children;
      for (let i2 = 0, l2 = children.length; i2 < l2; i2++) {
        projectObject(children[i2], camera, groupOrder, sortObjects);
      }
    }
    function renderScene(currentRenderList2, scene, camera, viewport) {
      const { opaque: opaqueObjects, transmissive: transmissiveObjects, transparent: transparentObjects } = currentRenderList2;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      if (viewport) state.viewport(_currentViewport.copy(viewport));
      if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera);
      if (transmissiveObjects.length > 0) renderObjects(transmissiveObjects, scene, camera);
      if (transparentObjects.length > 0) renderObjects(transparentObjects, scene, camera);
      state.buffers.depth.setTest(true);
      state.buffers.depth.setMask(true);
      state.buffers.color.setMask(true);
      state.setPolygonOffset(false);
    }
    function renderTransmissionPass(opaqueObjects, transmissiveObjects, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      if (overrideMaterial !== null) {
        return;
      }
      if (currentRenderState.state.transmissionRenderTarget[camera.id] === void 0) {
        const hasHalfFloatSupport = extensions.has("EXT_color_buffer_half_float") || extensions.has("EXT_color_buffer_float");
        currentRenderState.state.transmissionRenderTarget[camera.id] = new WebGLRenderTarget(1, 1, {
          generateMipmaps: true,
          type: hasHalfFloatSupport ? HalfFloatType : UnsignedByteType,
          minFilter: LinearMipmapLinearFilter,
          samples: capabilities.samples,
          stencilBuffer: stencil,
          resolveDepthBuffer: false,
          resolveStencilBuffer: false,
          colorSpace: ColorManagement.workingColorSpace
        });
      }
      const transmissionRenderTarget = currentRenderState.state.transmissionRenderTarget[camera.id];
      const activeViewport = camera.viewport || _currentViewport;
      transmissionRenderTarget.setSize(activeViewport.z * _this.transmissionResolutionScale, activeViewport.w * _this.transmissionResolutionScale);
      const currentRenderTarget = _this.getRenderTarget();
      const currentActiveCubeFace = _this.getActiveCubeFace();
      const currentActiveMipmapLevel = _this.getActiveMipmapLevel();
      _this.setRenderTarget(transmissionRenderTarget);
      _this.getClearColor(_currentClearColor);
      _currentClearAlpha = _this.getClearAlpha();
      if (_currentClearAlpha < 1) _this.setClearColor(16777215, 0.5);
      _this.clear();
      if (_renderBackground) background.render(scene);
      const currentToneMapping = _this.toneMapping;
      _this.toneMapping = NoToneMapping;
      const currentCameraViewport = camera.viewport;
      if (camera.viewport !== void 0) camera.viewport = void 0;
      currentRenderState.setupLightsView(camera);
      if (_clippingEnabled === true) clipping.setGlobalState(_this.clippingPlanes, camera);
      renderObjects(opaqueObjects, scene, camera);
      textures.updateMultisampleRenderTarget(transmissionRenderTarget);
      textures.updateRenderTargetMipmap(transmissionRenderTarget);
      if (extensions.has("WEBGL_multisampled_render_to_texture") === false) {
        let renderTargetNeedsUpdate = false;
        for (let i2 = 0, l2 = transmissiveObjects.length; i2 < l2; i2++) {
          const renderItem = transmissiveObjects[i2];
          const { object, geometry, material, group } = renderItem;
          if (material.side === DoubleSide && object.layers.test(camera.layers)) {
            const currentSide = material.side;
            material.side = BackSide;
            material.needsUpdate = true;
            renderObject(object, scene, camera, geometry, material, group);
            material.side = currentSide;
            material.needsUpdate = true;
            renderTargetNeedsUpdate = true;
          }
        }
        if (renderTargetNeedsUpdate === true) {
          textures.updateMultisampleRenderTarget(transmissionRenderTarget);
          textures.updateRenderTargetMipmap(transmissionRenderTarget);
        }
      }
      _this.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
      _this.setClearColor(_currentClearColor, _currentClearAlpha);
      if (currentCameraViewport !== void 0) camera.viewport = currentCameraViewport;
      _this.toneMapping = currentToneMapping;
    }
    function renderObjects(renderList, scene, camera) {
      const overrideMaterial = scene.isScene === true ? scene.overrideMaterial : null;
      for (let i2 = 0, l2 = renderList.length; i2 < l2; i2++) {
        const renderItem = renderList[i2];
        const { object, geometry, group } = renderItem;
        let material = renderItem.material;
        if (material.allowOverride === true && overrideMaterial !== null) {
          material = overrideMaterial;
        }
        if (object.layers.test(camera.layers)) {
          renderObject(object, scene, camera, geometry, material, group);
        }
      }
    }
    function renderObject(object, scene, camera, geometry, material, group) {
      object.onBeforeRender(_this, scene, camera, geometry, material, group);
      object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
      material.onBeforeRender(_this, scene, camera, geometry, object, group);
      if (material.transparent === true && material.side === DoubleSide && material.forceSinglePass === false) {
        material.side = BackSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = FrontSide;
        material.needsUpdate = true;
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
        material.side = DoubleSide;
      } else {
        _this.renderBufferDirect(camera, scene, geometry, material, object, group);
      }
      object.onAfterRender(_this, scene, camera, geometry, material, group);
    }
    function getProgram(material, scene, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      const shadowsArray = currentRenderState.state.shadowsArray;
      const lightsStateVersion = lights.state.version;
      const parameters2 = programCache.getParameters(material, lights.state, shadowsArray, scene, object);
      const programCacheKey = programCache.getProgramCacheKey(parameters2);
      let programs = materialProperties.programs;
      materialProperties.environment = material.isMeshStandardMaterial ? scene.environment : null;
      materialProperties.fog = scene.fog;
      materialProperties.envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || materialProperties.environment);
      materialProperties.envMapRotation = materialProperties.environment !== null && material.envMap === null ? scene.environmentRotation : material.envMapRotation;
      if (programs === void 0) {
        material.addEventListener("dispose", onMaterialDispose);
        programs = /* @__PURE__ */ new Map();
        materialProperties.programs = programs;
      }
      let program = programs.get(programCacheKey);
      if (program !== void 0) {
        if (materialProperties.currentProgram === program && materialProperties.lightsStateVersion === lightsStateVersion) {
          updateCommonMaterialProperties(material, parameters2);
          return program;
        }
      } else {
        parameters2.uniforms = programCache.getUniforms(material);
        material.onBeforeCompile(parameters2, _this);
        program = programCache.acquireProgram(parameters2, programCacheKey);
        programs.set(programCacheKey, program);
        materialProperties.uniforms = parameters2.uniforms;
      }
      const uniforms = materialProperties.uniforms;
      if (!material.isShaderMaterial && !material.isRawShaderMaterial || material.clipping === true) {
        uniforms.clippingPlanes = clipping.uniform;
      }
      updateCommonMaterialProperties(material, parameters2);
      materialProperties.needsLights = materialNeedsLights(material);
      materialProperties.lightsStateVersion = lightsStateVersion;
      if (materialProperties.needsLights) {
        uniforms.ambientLightColor.value = lights.state.ambient;
        uniforms.lightProbe.value = lights.state.probe;
        uniforms.directionalLights.value = lights.state.directional;
        uniforms.directionalLightShadows.value = lights.state.directionalShadow;
        uniforms.spotLights.value = lights.state.spot;
        uniforms.spotLightShadows.value = lights.state.spotShadow;
        uniforms.rectAreaLights.value = lights.state.rectArea;
        uniforms.ltc_1.value = lights.state.rectAreaLTC1;
        uniforms.ltc_2.value = lights.state.rectAreaLTC2;
        uniforms.pointLights.value = lights.state.point;
        uniforms.pointLightShadows.value = lights.state.pointShadow;
        uniforms.hemisphereLights.value = lights.state.hemi;
        uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
        uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
        uniforms.spotShadowMap.value = lights.state.spotShadowMap;
        uniforms.spotLightMatrix.value = lights.state.spotLightMatrix;
        uniforms.spotLightMap.value = lights.state.spotLightMap;
        uniforms.pointShadowMap.value = lights.state.pointShadowMap;
        uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
      }
      materialProperties.currentProgram = program;
      materialProperties.uniformsList = null;
      return program;
    }
    function getUniformList(materialProperties) {
      if (materialProperties.uniformsList === null) {
        const progUniforms = materialProperties.currentProgram.getUniforms();
        materialProperties.uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, materialProperties.uniforms);
      }
      return materialProperties.uniformsList;
    }
    function updateCommonMaterialProperties(material, parameters2) {
      const materialProperties = properties.get(material);
      materialProperties.outputColorSpace = parameters2.outputColorSpace;
      materialProperties.batching = parameters2.batching;
      materialProperties.batchingColor = parameters2.batchingColor;
      materialProperties.instancing = parameters2.instancing;
      materialProperties.instancingColor = parameters2.instancingColor;
      materialProperties.instancingMorph = parameters2.instancingMorph;
      materialProperties.skinning = parameters2.skinning;
      materialProperties.morphTargets = parameters2.morphTargets;
      materialProperties.morphNormals = parameters2.morphNormals;
      materialProperties.morphColors = parameters2.morphColors;
      materialProperties.morphTargetsCount = parameters2.morphTargetsCount;
      materialProperties.numClippingPlanes = parameters2.numClippingPlanes;
      materialProperties.numIntersection = parameters2.numClipIntersection;
      materialProperties.vertexAlphas = parameters2.vertexAlphas;
      materialProperties.vertexTangents = parameters2.vertexTangents;
      materialProperties.toneMapping = parameters2.toneMapping;
    }
    function setProgram(camera, scene, geometry, material, object) {
      if (scene.isScene !== true) scene = _emptyScene;
      textures.resetTextureUnits();
      const fog = scene.fog;
      const environment = material.isMeshStandardMaterial ? scene.environment : null;
      const colorSpace = _currentRenderTarget === null ? _this.outputColorSpace : _currentRenderTarget.isXRRenderTarget === true ? _currentRenderTarget.texture.colorSpace : LinearSRGBColorSpace;
      const envMap = (material.isMeshStandardMaterial ? cubeuvmaps : cubemaps).get(material.envMap || environment);
      const vertexAlphas = material.vertexColors === true && !!geometry.attributes.color && geometry.attributes.color.itemSize === 4;
      const vertexTangents = !!geometry.attributes.tangent && (!!material.normalMap || material.anisotropy > 0);
      const morphTargets = !!geometry.morphAttributes.position;
      const morphNormals = !!geometry.morphAttributes.normal;
      const morphColors = !!geometry.morphAttributes.color;
      let toneMapping = NoToneMapping;
      if (material.toneMapped) {
        if (_currentRenderTarget === null || _currentRenderTarget.isXRRenderTarget === true) {
          toneMapping = _this.toneMapping;
        }
      }
      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
      const morphTargetsCount = morphAttribute !== void 0 ? morphAttribute.length : 0;
      const materialProperties = properties.get(material);
      const lights = currentRenderState.state.lights;
      if (_clippingEnabled === true) {
        if (_localClippingEnabled === true || camera !== _currentCamera) {
          const useCache = camera === _currentCamera && material.id === _currentMaterialId;
          clipping.setState(material, camera, useCache);
        }
      }
      let needsProgramChange = false;
      if (material.version === materialProperties.__version) {
        if (materialProperties.needsLights && materialProperties.lightsStateVersion !== lights.state.version) {
          needsProgramChange = true;
        } else if (materialProperties.outputColorSpace !== colorSpace) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batching === false) {
          needsProgramChange = true;
        } else if (!object.isBatchedMesh && materialProperties.batching === true) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === true && object.colorTexture === null) {
          needsProgramChange = true;
        } else if (object.isBatchedMesh && materialProperties.batchingColor === false && object.colorTexture !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancing === false) {
          needsProgramChange = true;
        } else if (!object.isInstancedMesh && materialProperties.instancing === true) {
          needsProgramChange = true;
        } else if (object.isSkinnedMesh && materialProperties.skinning === false) {
          needsProgramChange = true;
        } else if (!object.isSkinnedMesh && materialProperties.skinning === true) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === true && object.instanceColor === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingColor === false && object.instanceColor !== null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === true && object.morphTexture === null) {
          needsProgramChange = true;
        } else if (object.isInstancedMesh && materialProperties.instancingMorph === false && object.morphTexture !== null) {
          needsProgramChange = true;
        } else if (materialProperties.envMap !== envMap) {
          needsProgramChange = true;
        } else if (material.fog === true && materialProperties.fog !== fog) {
          needsProgramChange = true;
        } else if (materialProperties.numClippingPlanes !== void 0 && (materialProperties.numClippingPlanes !== clipping.numPlanes || materialProperties.numIntersection !== clipping.numIntersection)) {
          needsProgramChange = true;
        } else if (materialProperties.vertexAlphas !== vertexAlphas) {
          needsProgramChange = true;
        } else if (materialProperties.vertexTangents !== vertexTangents) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargets !== morphTargets) {
          needsProgramChange = true;
        } else if (materialProperties.morphNormals !== morphNormals) {
          needsProgramChange = true;
        } else if (materialProperties.morphColors !== morphColors) {
          needsProgramChange = true;
        } else if (materialProperties.toneMapping !== toneMapping) {
          needsProgramChange = true;
        } else if (materialProperties.morphTargetsCount !== morphTargetsCount) {
          needsProgramChange = true;
        }
      } else {
        needsProgramChange = true;
        materialProperties.__version = material.version;
      }
      let program = materialProperties.currentProgram;
      if (needsProgramChange === true) {
        program = getProgram(material, scene, object);
      }
      let refreshProgram = false;
      let refreshMaterial = false;
      let refreshLights = false;
      const p_uniforms = program.getUniforms(), m_uniforms = materialProperties.uniforms;
      if (state.useProgram(program.program)) {
        refreshProgram = true;
        refreshMaterial = true;
        refreshLights = true;
      }
      if (material.id !== _currentMaterialId) {
        _currentMaterialId = material.id;
        refreshMaterial = true;
      }
      if (refreshProgram || _currentCamera !== camera) {
        const reversedDepthBuffer2 = state.buffers.depth.getReversed();
        if (reversedDepthBuffer2 && camera.reversedDepth !== true) {
          camera._reversedDepth = true;
          camera.updateProjectionMatrix();
        }
        p_uniforms.setValue(_gl, "projectionMatrix", camera.projectionMatrix);
        p_uniforms.setValue(_gl, "viewMatrix", camera.matrixWorldInverse);
        const uCamPos = p_uniforms.map.cameraPosition;
        if (uCamPos !== void 0) {
          uCamPos.setValue(_gl, _vector32.setFromMatrixPosition(camera.matrixWorld));
        }
        if (capabilities.logarithmicDepthBuffer) {
          p_uniforms.setValue(
            _gl,
            "logDepthBufFC",
            2 / (Math.log(camera.far + 1) / Math.LN2)
          );
        }
        if (material.isMeshPhongMaterial || material.isMeshToonMaterial || material.isMeshLambertMaterial || material.isMeshBasicMaterial || material.isMeshStandardMaterial || material.isShaderMaterial) {
          p_uniforms.setValue(_gl, "isOrthographic", camera.isOrthographicCamera === true);
        }
        if (_currentCamera !== camera) {
          _currentCamera = camera;
          refreshMaterial = true;
          refreshLights = true;
        }
      }
      if (materialProperties.needsLights) {
        if (lights.state.directionalShadowMap.length > 0) {
          p_uniforms.setValue(_gl, "directionalShadowMap", lights.state.directionalShadowMap, textures);
        }
        if (lights.state.spotShadowMap.length > 0) {
          p_uniforms.setValue(_gl, "spotShadowMap", lights.state.spotShadowMap, textures);
        }
        if (lights.state.pointShadowMap.length > 0) {
          p_uniforms.setValue(_gl, "pointShadowMap", lights.state.pointShadowMap, textures);
        }
      }
      if (object.isSkinnedMesh) {
        p_uniforms.setOptional(_gl, object, "bindMatrix");
        p_uniforms.setOptional(_gl, object, "bindMatrixInverse");
        const skeleton = object.skeleton;
        if (skeleton) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture();
          p_uniforms.setValue(_gl, "boneTexture", skeleton.boneTexture, textures);
        }
      }
      if (object.isBatchedMesh) {
        p_uniforms.setOptional(_gl, object, "batchingTexture");
        p_uniforms.setValue(_gl, "batchingTexture", object._matricesTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingIdTexture");
        p_uniforms.setValue(_gl, "batchingIdTexture", object._indirectTexture, textures);
        p_uniforms.setOptional(_gl, object, "batchingColorTexture");
        if (object._colorsTexture !== null) {
          p_uniforms.setValue(_gl, "batchingColorTexture", object._colorsTexture, textures);
        }
      }
      const morphAttributes = geometry.morphAttributes;
      if (morphAttributes.position !== void 0 || morphAttributes.normal !== void 0 || morphAttributes.color !== void 0) {
        morphtargets.update(object, geometry, program);
      }
      if (refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow) {
        materialProperties.receiveShadow = object.receiveShadow;
        p_uniforms.setValue(_gl, "receiveShadow", object.receiveShadow);
      }
      if (material.isMeshGouraudMaterial && material.envMap !== null) {
        m_uniforms.envMap.value = envMap;
        m_uniforms.flipEnvMap.value = envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1;
      }
      if (material.isMeshStandardMaterial && material.envMap === null && scene.environment !== null) {
        m_uniforms.envMapIntensity.value = scene.environmentIntensity;
      }
      if (m_uniforms.dfgLUT !== void 0) {
        m_uniforms.dfgLUT.value = getDFGLUT();
      }
      if (refreshMaterial) {
        p_uniforms.setValue(_gl, "toneMappingExposure", _this.toneMappingExposure);
        if (materialProperties.needsLights) {
          markUniformsLightsNeedsUpdate(m_uniforms, refreshLights);
        }
        if (fog && material.fog === true) {
          materials.refreshFogUniforms(m_uniforms, fog);
        }
        materials.refreshMaterialUniforms(m_uniforms, material, _pixelRatio, _height, currentRenderState.state.transmissionRenderTarget[camera.id]);
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
      }
      if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
        WebGLUniforms.upload(_gl, getUniformList(materialProperties), m_uniforms, textures);
        material.uniformsNeedUpdate = false;
      }
      if (material.isSpriteMaterial) {
        p_uniforms.setValue(_gl, "center", object.center);
      }
      p_uniforms.setValue(_gl, "modelViewMatrix", object.modelViewMatrix);
      p_uniforms.setValue(_gl, "normalMatrix", object.normalMatrix);
      p_uniforms.setValue(_gl, "modelMatrix", object.matrixWorld);
      if (material.isShaderMaterial || material.isRawShaderMaterial) {
        const groups = material.uniformsGroups;
        for (let i2 = 0, l2 = groups.length; i2 < l2; i2++) {
          const group = groups[i2];
          uniformsGroups.update(group, program);
          uniformsGroups.bind(group, program);
        }
      }
      return program;
    }
    function markUniformsLightsNeedsUpdate(uniforms, value) {
      uniforms.ambientLightColor.needsUpdate = value;
      uniforms.lightProbe.needsUpdate = value;
      uniforms.directionalLights.needsUpdate = value;
      uniforms.directionalLightShadows.needsUpdate = value;
      uniforms.pointLights.needsUpdate = value;
      uniforms.pointLightShadows.needsUpdate = value;
      uniforms.spotLights.needsUpdate = value;
      uniforms.spotLightShadows.needsUpdate = value;
      uniforms.rectAreaLights.needsUpdate = value;
      uniforms.hemisphereLights.needsUpdate = value;
    }
    function materialNeedsLights(material) {
      return material.isMeshLambertMaterial || material.isMeshToonMaterial || material.isMeshPhongMaterial || material.isMeshStandardMaterial || material.isShadowMaterial || material.isShaderMaterial && material.lights === true;
    }
    this.getActiveCubeFace = function() {
      return _currentActiveCubeFace;
    };
    this.getActiveMipmapLevel = function() {
      return _currentActiveMipmapLevel;
    };
    this.getRenderTarget = function() {
      return _currentRenderTarget;
    };
    this.setRenderTargetTextures = function(renderTarget, colorTexture, depthTexture) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__autoAllocateDepthBuffer = renderTarget.resolveDepthBuffer === false;
      if (renderTargetProperties.__autoAllocateDepthBuffer === false) {
        renderTargetProperties.__useRenderToTexture = false;
      }
      properties.get(renderTarget.texture).__webglTexture = colorTexture;
      properties.get(renderTarget.depthTexture).__webglTexture = renderTargetProperties.__autoAllocateDepthBuffer ? void 0 : depthTexture;
      renderTargetProperties.__hasExternalTextures = true;
    };
    this.setRenderTargetFramebuffer = function(renderTarget, defaultFramebuffer) {
      const renderTargetProperties = properties.get(renderTarget);
      renderTargetProperties.__webglFramebuffer = defaultFramebuffer;
      renderTargetProperties.__useDefaultFramebuffer = defaultFramebuffer === void 0;
    };
    const _scratchFrameBuffer = _gl.createFramebuffer();
    this.setRenderTarget = function(renderTarget, activeCubeFace = 0, activeMipmapLevel = 0) {
      _currentRenderTarget = renderTarget;
      _currentActiveCubeFace = activeCubeFace;
      _currentActiveMipmapLevel = activeMipmapLevel;
      let framebuffer = null;
      let isCube = false;
      let isRenderTarget3D = false;
      if (renderTarget) {
        const renderTargetProperties = properties.get(renderTarget);
        if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer);
          _currentViewport.copy(renderTarget.viewport);
          _currentScissor.copy(renderTarget.scissor);
          _currentScissorTest = renderTarget.scissorTest;
          state.viewport(_currentViewport);
          state.scissor(_currentScissor);
          state.setScissorTest(_currentScissorTest);
          _currentMaterialId = -1;
          return;
        } else if (renderTargetProperties.__webglFramebuffer === void 0) {
          textures.setupRenderTarget(renderTarget);
        } else if (renderTargetProperties.__hasExternalTextures) {
          textures.rebindTextures(renderTarget, properties.get(renderTarget.texture).__webglTexture, properties.get(renderTarget.depthTexture).__webglTexture);
        } else if (renderTarget.depthBuffer) {
          const depthTexture = renderTarget.depthTexture;
          if (renderTargetProperties.__boundDepthTexture !== depthTexture) {
            if (depthTexture !== null && properties.has(depthTexture) && (renderTarget.width !== depthTexture.image.width || renderTarget.height !== depthTexture.image.height)) {
              throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
            }
            textures.setupDepthRenderbuffer(renderTarget);
          }
        }
        const texture = renderTarget.texture;
        if (texture.isData3DTexture || texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          isRenderTarget3D = true;
        }
        const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer;
        if (renderTarget.isWebGLCubeRenderTarget) {
          if (Array.isArray(__webglFramebuffer[activeCubeFace])) {
            framebuffer = __webglFramebuffer[activeCubeFace][activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer[activeCubeFace];
          }
          isCube = true;
        } else if (renderTarget.samples > 0 && textures.useMultisampledRTT(renderTarget) === false) {
          framebuffer = properties.get(renderTarget).__webglMultisampledFramebuffer;
        } else {
          if (Array.isArray(__webglFramebuffer)) {
            framebuffer = __webglFramebuffer[activeMipmapLevel];
          } else {
            framebuffer = __webglFramebuffer;
          }
        }
        _currentViewport.copy(renderTarget.viewport);
        _currentScissor.copy(renderTarget.scissor);
        _currentScissorTest = renderTarget.scissorTest;
      } else {
        _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor();
        _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor();
        _currentScissorTest = _scissorTest;
      }
      if (activeMipmapLevel !== 0) {
        framebuffer = _scratchFrameBuffer;
      }
      const framebufferBound = state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
      if (framebufferBound) {
        state.drawBuffers(renderTarget, framebuffer);
      }
      state.viewport(_currentViewport);
      state.scissor(_currentScissor);
      state.setScissorTest(_currentScissorTest);
      if (isCube) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + activeCubeFace, textureProperties.__webglTexture, activeMipmapLevel);
      } else if (isRenderTarget3D) {
        const layer = activeCubeFace;
        for (let i2 = 0; i2 < renderTarget.textures.length; i2++) {
          const textureProperties = properties.get(renderTarget.textures[i2]);
          _gl.framebufferTextureLayer(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0 + i2, textureProperties.__webglTexture, activeMipmapLevel, layer);
        }
      } else if (renderTarget !== null && activeMipmapLevel !== 0) {
        const textureProperties = properties.get(renderTarget.texture);
        _gl.framebufferTexture2D(_gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, textureProperties.__webglTexture, activeMipmapLevel);
      }
      _currentMaterialId = -1;
    };
    this.readRenderTargetPixels = function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex, textureIndex = 0) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        error("WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
        return;
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
        try {
          const texture = renderTarget.textures[textureIndex];
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
            return;
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            error("WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
            return;
          }
          if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
            if (renderTarget.textures.length > 1) _gl.readBuffer(_gl.COLOR_ATTACHMENT0 + textureIndex);
            _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), buffer);
          }
        } finally {
          const framebuffer2 = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer2);
        }
      }
    };
    this.readRenderTargetPixelsAsync = async function(renderTarget, x2, y2, width, height, buffer, activeCubeFaceIndex, textureIndex = 0) {
      if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
        throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
      }
      let framebuffer = properties.get(renderTarget).__webglFramebuffer;
      if (renderTarget.isWebGLCubeRenderTarget && activeCubeFaceIndex !== void 0) {
        framebuffer = framebuffer[activeCubeFaceIndex];
      }
      if (framebuffer) {
        if (x2 >= 0 && x2 <= renderTarget.width - width && (y2 >= 0 && y2 <= renderTarget.height - height)) {
          state.bindFramebuffer(_gl.FRAMEBUFFER, framebuffer);
          const texture = renderTarget.textures[textureIndex];
          const textureFormat = texture.format;
          const textureType = texture.type;
          if (!capabilities.textureFormatReadable(textureFormat)) {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
          }
          if (!capabilities.textureTypeReadable(textureType)) {
            throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
          }
          const glBuffer = _gl.createBuffer();
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.bufferData(_gl.PIXEL_PACK_BUFFER, buffer.byteLength, _gl.STREAM_READ);
          if (renderTarget.textures.length > 1) _gl.readBuffer(_gl.COLOR_ATTACHMENT0 + textureIndex);
          _gl.readPixels(x2, y2, width, height, utils.convert(textureFormat), utils.convert(textureType), 0);
          const currFramebuffer = _currentRenderTarget !== null ? properties.get(_currentRenderTarget).__webglFramebuffer : null;
          state.bindFramebuffer(_gl.FRAMEBUFFER, currFramebuffer);
          const sync = _gl.fenceSync(_gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
          _gl.flush();
          await probeAsync(_gl, sync, 4);
          _gl.bindBuffer(_gl.PIXEL_PACK_BUFFER, glBuffer);
          _gl.getBufferSubData(_gl.PIXEL_PACK_BUFFER, 0, buffer);
          _gl.deleteBuffer(glBuffer);
          _gl.deleteSync(sync);
          return buffer;
        } else {
          throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.");
        }
      }
    };
    this.copyFramebufferToTexture = function(texture, position = null, level = 0) {
      const levelScale = Math.pow(2, -level);
      const width = Math.floor(texture.image.width * levelScale);
      const height = Math.floor(texture.image.height * levelScale);
      const x2 = position !== null ? position.x : 0;
      const y2 = position !== null ? position.y : 0;
      textures.setTexture2D(texture, 0);
      _gl.copyTexSubImage2D(_gl.TEXTURE_2D, level, 0, 0, x2, y2, width, height);
      state.unbindTexture();
    };
    const _srcFramebuffer = _gl.createFramebuffer();
    const _dstFramebuffer = _gl.createFramebuffer();
    this.copyTextureToTexture = function(srcTexture, dstTexture, srcRegion = null, dstPosition = null, srcLevel = 0, dstLevel = null) {
      if (dstLevel === null) {
        if (srcLevel !== 0) {
          warnOnce("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels.");
          dstLevel = srcLevel;
          srcLevel = 0;
        } else {
          dstLevel = 0;
        }
      }
      let width, height, depth2, minX, minY, minZ;
      let dstX, dstY, dstZ;
      const image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[dstLevel] : srcTexture.image;
      if (srcRegion !== null) {
        width = srcRegion.max.x - srcRegion.min.x;
        height = srcRegion.max.y - srcRegion.min.y;
        depth2 = srcRegion.isBox3 ? srcRegion.max.z - srcRegion.min.z : 1;
        minX = srcRegion.min.x;
        minY = srcRegion.min.y;
        minZ = srcRegion.isBox3 ? srcRegion.min.z : 0;
      } else {
        const levelScale = Math.pow(2, -srcLevel);
        width = Math.floor(image.width * levelScale);
        height = Math.floor(image.height * levelScale);
        if (srcTexture.isDataArrayTexture) {
          depth2 = image.depth;
        } else if (srcTexture.isData3DTexture) {
          depth2 = Math.floor(image.depth * levelScale);
        } else {
          depth2 = 1;
        }
        minX = 0;
        minY = 0;
        minZ = 0;
      }
      if (dstPosition !== null) {
        dstX = dstPosition.x;
        dstY = dstPosition.y;
        dstZ = dstPosition.z;
      } else {
        dstX = 0;
        dstY = 0;
        dstZ = 0;
      }
      const glFormat = utils.convert(dstTexture.format);
      const glType = utils.convert(dstTexture.type);
      let glTarget;
      if (dstTexture.isData3DTexture) {
        textures.setTexture3D(dstTexture, 0);
        glTarget = _gl.TEXTURE_3D;
      } else if (dstTexture.isDataArrayTexture || dstTexture.isCompressedArrayTexture) {
        textures.setTexture2DArray(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D_ARRAY;
      } else {
        textures.setTexture2D(dstTexture, 0);
        glTarget = _gl.TEXTURE_2D;
      }
      _gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
      _gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
      _gl.pixelStorei(_gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
      const currentUnpackRowLen = _gl.getParameter(_gl.UNPACK_ROW_LENGTH);
      const currentUnpackImageHeight = _gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT);
      const currentUnpackSkipPixels = _gl.getParameter(_gl.UNPACK_SKIP_PIXELS);
      const currentUnpackSkipRows = _gl.getParameter(_gl.UNPACK_SKIP_ROWS);
      const currentUnpackSkipImages = _gl.getParameter(_gl.UNPACK_SKIP_IMAGES);
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, image.width);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, image.height);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, minX);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, minY);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, minZ);
      const isSrc3D = srcTexture.isDataArrayTexture || srcTexture.isData3DTexture;
      const isDst3D = dstTexture.isDataArrayTexture || dstTexture.isData3DTexture;
      if (srcTexture.isDepthTexture) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        const srcRenderTargetProperties = properties.get(srcTextureProperties.__renderTarget);
        const dstRenderTargetProperties = properties.get(dstTextureProperties.__renderTarget);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, srcRenderTargetProperties.__webglFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, dstRenderTargetProperties.__webglFramebuffer);
        for (let i2 = 0; i2 < depth2; i2++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(srcTexture).__webglTexture, srcLevel, minZ + i2);
            _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, properties.get(dstTexture).__webglTexture, dstLevel, dstZ + i2);
          }
          _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.DEPTH_BUFFER_BIT, _gl.NEAREST);
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else if (srcLevel !== 0 || srcTexture.isRenderTargetTexture || properties.has(srcTexture)) {
        const srcTextureProperties = properties.get(srcTexture);
        const dstTextureProperties = properties.get(dstTexture);
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, _srcFramebuffer);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, _dstFramebuffer);
        for (let i2 = 0; i2 < depth2; i2++) {
          if (isSrc3D) {
            _gl.framebufferTextureLayer(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, srcTextureProperties.__webglTexture, srcLevel, minZ + i2);
          } else {
            _gl.framebufferTexture2D(_gl.READ_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, srcTextureProperties.__webglTexture, srcLevel);
          }
          if (isDst3D) {
            _gl.framebufferTextureLayer(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, dstTextureProperties.__webglTexture, dstLevel, dstZ + i2);
          } else {
            _gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D, dstTextureProperties.__webglTexture, dstLevel);
          }
          if (srcLevel !== 0) {
            _gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, _gl.COLOR_BUFFER_BIT, _gl.NEAREST);
          } else if (isDst3D) {
            _gl.copyTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ + i2, minX, minY, width, height);
          } else {
            _gl.copyTexSubImage2D(glTarget, dstLevel, dstX, dstY, minX, minY, width, height);
          }
        }
        state.bindFramebuffer(_gl.READ_FRAMEBUFFER, null);
        state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER, null);
      } else {
        if (isDst3D) {
          if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
            _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image.data);
          } else if (dstTexture.isCompressedArrayTexture) {
            _gl.compressedTexSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, image.data);
          } else {
            _gl.texSubImage3D(glTarget, dstLevel, dstX, dstY, dstZ, width, height, depth2, glFormat, glType, image);
          }
        } else {
          if (srcTexture.isDataTexture) {
            _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image.data);
          } else if (srcTexture.isCompressedTexture) {
            _gl.compressedTexSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, image.width, image.height, glFormat, image.data);
          } else {
            _gl.texSubImage2D(_gl.TEXTURE_2D, dstLevel, dstX, dstY, width, height, glFormat, glType, image);
          }
        }
      }
      _gl.pixelStorei(_gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
      _gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
      _gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
      _gl.pixelStorei(_gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
      _gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);
      if (dstLevel === 0 && dstTexture.generateMipmaps) {
        _gl.generateMipmap(glTarget);
      }
      state.unbindTexture();
    };
    this.initRenderTarget = function(target) {
      if (properties.get(target).__webglFramebuffer === void 0) {
        textures.setupRenderTarget(target);
      }
    };
    this.initTexture = function(texture) {
      if (texture.isCubeTexture) {
        textures.setTextureCube(texture, 0);
      } else if (texture.isData3DTexture) {
        textures.setTexture3D(texture, 0);
      } else if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
        textures.setTexture2DArray(texture, 0);
      } else {
        textures.setTexture2D(texture, 0);
      }
      state.unbindTexture();
    };
    this.resetState = function() {
      _currentActiveCubeFace = 0;
      _currentActiveMipmapLevel = 0;
      _currentRenderTarget = null;
      state.reset();
      bindingStates.reset();
    };
    if (typeof __THREE_DEVTOOLS__ !== "undefined") {
      __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", { detail: this }));
    }
  }
  /**
   * Defines the coordinate system of the renderer.
   *
   * In `WebGLRenderer`, the value is always `WebGLCoordinateSystem`.
   *
   * @type {WebGLCoordinateSystem|WebGPUCoordinateSystem}
   * @default WebGLCoordinateSystem
   * @readonly
   */
  get coordinateSystem() {
    return WebGLCoordinateSystem;
  }
  /**
   * Defines the output color space of the renderer.
   *
   * @type {SRGBColorSpace|LinearSRGBColorSpace}
   * @default SRGBColorSpace
   */
  get outputColorSpace() {
    return this._outputColorSpace;
  }
  set outputColorSpace(colorSpace) {
    this._outputColorSpace = colorSpace;
    const gl = this.getContext();
    gl.drawingBufferColorSpace = ColorManagement._getDrawingBufferColorSpace(colorSpace);
    gl.unpackColorSpace = ColorManagement._getUnpackColorSpace();
  }
};

// node_modules/three/examples/jsm/utils/BufferGeometryUtils.js
function toTrianglesDrawMode(geometry, drawMode) {
  if (drawMode === TrianglesDrawMode) {
    console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.");
    return geometry;
  }
  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {
    let index = geometry.getIndex();
    if (index === null) {
      const indices = [];
      const position = geometry.getAttribute("position");
      if (position !== void 0) {
        for (let i2 = 0; i2 < position.count; i2++) {
          indices.push(i2);
        }
        geometry.setIndex(indices);
        index = geometry.getIndex();
      } else {
        console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.");
        return geometry;
      }
    }
    const numberOfTriangles = index.count - 2;
    const newIndices = [];
    if (drawMode === TriangleFanDrawMode) {
      for (let i2 = 1; i2 <= numberOfTriangles; i2++) {
        newIndices.push(index.getX(0));
        newIndices.push(index.getX(i2));
        newIndices.push(index.getX(i2 + 1));
      }
    } else {
      for (let i2 = 0; i2 < numberOfTriangles; i2++) {
        if (i2 % 2 === 0) {
          newIndices.push(index.getX(i2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2 + 2));
        } else {
          newIndices.push(index.getX(i2 + 2));
          newIndices.push(index.getX(i2 + 1));
          newIndices.push(index.getX(i2));
        }
      }
    }
    if (newIndices.length / 3 !== numberOfTriangles) {
      console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
    }
    const newGeometry = geometry.clone();
    newGeometry.setIndex(newIndices);
    newGeometry.clearGroups();
    return newGeometry;
  } else {
    console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", drawMode);
    return geometry;
  }
}

// node_modules/three/examples/jsm/loaders/GLTFLoader.js
var GLTFLoader = class extends Loader {
  /**
   * Constructs a new glTF loader.
   *
   * @param {LoadingManager} [manager] - The loading manager.
   */
  constructor(manager) {
    super(manager);
    this.dracoLoader = null;
    this.ktx2Loader = null;
    this.meshoptDecoder = null;
    this.pluginCallbacks = [];
    this.register(function(parser) {
      return new GLTFMaterialsClearcoatExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsDispersionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureBasisUExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureWebPExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFTextureAVIFExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSheenExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsTransmissionExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsVolumeExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIorExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsSpecularExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsIridescenceExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsAnisotropyExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMaterialsBumpExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFLightsExtension(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshoptCompression(parser);
    });
    this.register(function(parser) {
      return new GLTFMeshGpuInstancing(parser);
    });
  }
  /**
   * Starts loading from the given URL and passes the loaded glTF asset
   * to the `onLoad()` callback.
   *
   * @param {string} url - The path/URL of the file to be loaded. This can also be a data URI.
   * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
   * @param {onProgressCallback} onProgress - Executed while the loading is in progress.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  load(url, onLoad, onProgress, onError) {
    const scope = this;
    let resourcePath;
    if (this.resourcePath !== "") {
      resourcePath = this.resourcePath;
    } else if (this.path !== "") {
      const relativeUrl = LoaderUtils.extractUrlBase(url);
      resourcePath = LoaderUtils.resolveURL(relativeUrl, this.path);
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url);
    }
    this.manager.itemStart(url);
    const _onError = function(e2) {
      if (onError) {
        onError(e2);
      } else {
        console.error(e2);
      }
      scope.manager.itemError(url);
      scope.manager.itemEnd(url);
    };
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setResponseType("arraybuffer");
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, function(data2) {
      try {
        scope.parse(data2, resourcePath, function(gltf) {
          onLoad(gltf);
          scope.manager.itemEnd(url);
        }, _onError);
      } catch (e2) {
        _onError(e2);
      }
    }, onProgress, _onError);
  }
  /**
   * Sets the given Draco loader to this loader. Required for decoding assets
   * compressed with the `KHR_draco_mesh_compression` extension.
   *
   * @param {DRACOLoader} dracoLoader - The Draco loader to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader;
    return this;
  }
  /**
   * Sets the given KTX2 loader to this loader. Required for loading KTX2
   * compressed textures.
   *
   * @param {KTX2Loader} ktx2Loader - The KTX2 loader to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader;
    return this;
  }
  /**
   * Sets the given meshopt decoder. Required for decoding assets
   * compressed with the `EXT_meshopt_compression` extension.
   *
   * @param {Object} meshoptDecoder - The meshopt decoder to set.
   * @return {GLTFLoader} A reference to this loader.
   */
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder;
    return this;
  }
  /**
   * Registers a plugin callback. This API is internally used to implement the various
   * glTF extensions but can also used by third-party code to add additional logic
   * to the loader.
   *
   * @param {function(parser:GLTFParser)} callback - The callback function to register.
   * @return {GLTFLoader} A reference to this loader.
   */
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback);
    }
    return this;
  }
  /**
   * Unregisters a plugin callback.
   *
   * @param {Function} callback - The callback function to unregister.
   * @return {GLTFLoader} A reference to this loader.
   */
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1);
    }
    return this;
  }
  /**
   * Parses the given FBX data and returns the resulting group.
   *
   * @param {string|ArrayBuffer} data - The raw glTF data.
   * @param {string} path - The URL base path.
   * @param {function(GLTFLoader~LoadObject)} onLoad - Executed when the loading process has been finished.
   * @param {onErrorCallback} onError - Executed when errors occur.
   */
  parse(data2, path, onLoad, onError) {
    let json;
    const extensions = {};
    const plugins = {};
    const textDecoder = new TextDecoder();
    if (typeof data2 === "string") {
      json = JSON.parse(data2);
    } else if (data2 instanceof ArrayBuffer) {
      const magic = textDecoder.decode(new Uint8Array(data2, 0, 4));
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data2);
        } catch (error2) {
          if (onError) onError(error2);
          return;
        }
        json = JSON.parse(extensions[EXTENSIONS.KHR_BINARY_GLTF].content);
      } else {
        json = JSON.parse(textDecoder.decode(data2));
      }
    } else {
      json = data2;
    }
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError) onError(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
      return;
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder
    });
    parser.fileLoader.setRequestHeader(this.requestHeader);
    for (let i2 = 0; i2 < this.pluginCallbacks.length; i2++) {
      const plugin = this.pluginCallbacks[i2](parser);
      if (!plugin.name) console.error("THREE.GLTFLoader: Invalid plugin found: missing name");
      plugins[plugin.name] = plugin;
      extensions[plugin.name] = true;
    }
    if (json.extensionsUsed) {
      for (let i2 = 0; i2 < json.extensionsUsed.length; ++i2) {
        const extensionName = json.extensionsUsed[i2];
        const extensionsRequired = json.extensionsRequired || [];
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension();
            break;
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(json, this.dracoLoader);
            break;
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension();
            break;
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension();
            break;
          default:
            if (extensionsRequired.indexOf(extensionName) >= 0 && plugins[extensionName] === void 0) {
              console.warn('THREE.GLTFLoader: Unknown extension "' + extensionName + '".');
            }
        }
      }
    }
    parser.setExtensions(extensions);
    parser.setPlugins(plugins);
    parser.parse(onLoad, onError);
  }
  /**
   * Async version of {@link GLTFLoader#parse}.
   *
   * @async
   * @param {string|ArrayBuffer} data - The raw glTF data.
   * @param {string} path - The URL base path.
   * @return {Promise<GLTFLoader~LoadObject>} A Promise that resolves with the loaded glTF when the parsing has been finished.
   */
  parseAsync(data2, path) {
    const scope = this;
    return new Promise(function(resolve, reject) {
      scope.parse(data2, path, resolve, reject);
    });
  }
};
function GLTFRegistry() {
  let objects = {};
  return {
    get: function(key) {
      return objects[key];
    },
    add: function(key, object) {
      objects[key] = object;
    },
    remove: function(key) {
      delete objects[key];
    },
    removeAll: function() {
      objects = {};
    }
  };
}
var EXTENSIONS = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_MATERIALS_BUMP: "EXT_materials_bump",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
var GLTFLightsExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL;
    this.cache = { refs: {}, uses: {} };
  }
  _markDefs() {
    const parser = this.parser;
    const nodeDefs = this.parser.json.nodes || [];
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.extensions && nodeDef.extensions[this.name] && nodeDef.extensions[this.name].light !== void 0) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light);
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser;
    const cacheKey = "light:" + lightIndex;
    let dependency = parser.cache.get(cacheKey);
    if (dependency) return dependency;
    const json = parser.json;
    const extensions = json.extensions && json.extensions[this.name] || {};
    const lightDefs = extensions.lights || [];
    const lightDef = lightDefs[lightIndex];
    let lightNode;
    const color = new Color(16777215);
    if (lightDef.color !== void 0) color.setRGB(lightDef.color[0], lightDef.color[1], lightDef.color[2], LinearSRGBColorSpace);
    const range = lightDef.range !== void 0 ? lightDef.range : 0;
    switch (lightDef.type) {
      case "directional":
        lightNode = new DirectionalLight(color);
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      case "point":
        lightNode = new PointLight(color);
        lightNode.distance = range;
        break;
      case "spot":
        lightNode = new SpotLight(color);
        lightNode.distance = range;
        lightDef.spot = lightDef.spot || {};
        lightDef.spot.innerConeAngle = lightDef.spot.innerConeAngle !== void 0 ? lightDef.spot.innerConeAngle : 0;
        lightDef.spot.outerConeAngle = lightDef.spot.outerConeAngle !== void 0 ? lightDef.spot.outerConeAngle : Math.PI / 4;
        lightNode.angle = lightDef.spot.outerConeAngle;
        lightNode.penumbra = 1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle;
        lightNode.target.position.set(0, 0, -1);
        lightNode.add(lightNode.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + lightDef.type);
    }
    lightNode.position.set(0, 0, 0);
    assignExtrasToUserData(lightNode, lightDef);
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity;
    lightNode.name = parser.createUniqueName(lightDef.name || "light_" + lightIndex);
    dependency = Promise.resolve(lightNode);
    parser.cache.add(cacheKey, dependency);
    return dependency;
  }
  getDependency(type, index) {
    if (type !== "light") return;
    return this._loadLight(index);
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this;
    const parser = this.parser;
    const json = parser.json;
    const nodeDef = json.nodes[nodeIndex];
    const lightDef = nodeDef.extensions && nodeDef.extensions[this.name] || {};
    const lightIndex = lightDef.light;
    if (lightIndex === void 0) return null;
    return this._loadLight(lightIndex).then(function(light) {
      return parser._getNodeRef(self2.cache, lightIndex, light);
    });
  }
};
var GLTFMaterialsUnlitExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return MeshBasicMaterial;
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = [];
    materialParams.color = new Color(1, 1, 1);
    materialParams.opacity = 1;
    const metallicRoughness = materialDef.pbrMetallicRoughness;
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsEmissiveStrengthExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength;
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength;
    }
    return Promise.resolve();
  }
};
var GLTFMaterialsClearcoatExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor;
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatMap", extension.clearcoatTexture));
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor;
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatRoughnessMap", extension.clearcoatRoughnessTexture));
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "clearcoatNormalMap", extension.clearcoatNormalTexture));
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale;
        materialParams.clearcoatNormalScale = new Vector2(scale, scale);
      }
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsDispersionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_DISPERSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.dispersion = extension.dispersion !== void 0 ? extension.dispersion : 0;
    return Promise.resolve();
  }
};
var GLTFMaterialsIridescenceExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor;
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceMap", extension.iridescenceTexture));
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor;
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400];
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] = extension.iridescenceThicknessMinimum;
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] = extension.iridescenceThicknessMaximum;
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "iridescenceThicknessMap", extension.iridescenceThicknessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsSheenExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    materialParams.sheenColor = new Color(0, 0, 0);
    materialParams.sheenRoughness = 0;
    materialParams.sheen = 1;
    const extension = materialDef.extensions[this.name];
    if (extension.sheenColorFactor !== void 0) {
      const colorFactor = extension.sheenColorFactor;
      materialParams.sheenColor.setRGB(colorFactor[0], colorFactor[1], colorFactor[2], LinearSRGBColorSpace);
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor;
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenColorMap", extension.sheenColorTexture, SRGBColorSpace));
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "sheenRoughnessMap", extension.sheenRoughnessTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsTransmissionExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor;
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "transmissionMap", extension.transmissionTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsVolumeExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.thickness = extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0;
    if (extension.thicknessTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "thicknessMap", extension.thicknessTexture));
    }
    materialParams.attenuationDistance = extension.attenuationDistance || Infinity;
    const colorArray = extension.attenuationColor || [1, 1, 1];
    materialParams.attenuationColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    return Promise.all(pending);
  }
};
var GLTFMaterialsIorExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_IOR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const extension = materialDef.extensions[this.name];
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5;
    return Promise.resolve();
  }
};
var GLTFMaterialsSpecularExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.specularIntensity = extension.specularFactor !== void 0 ? extension.specularFactor : 1;
    if (extension.specularTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularIntensityMap", extension.specularTexture));
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1];
    materialParams.specularColor = new Color().setRGB(colorArray[0], colorArray[1], colorArray[2], LinearSRGBColorSpace);
    if (extension.specularColorTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "specularColorMap", extension.specularColorTexture, SRGBColorSpace));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsBumpExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_MATERIALS_BUMP;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    materialParams.bumpScale = extension.bumpFactor !== void 0 ? extension.bumpFactor : 1;
    if (extension.bumpTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "bumpMap", extension.bumpTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFMaterialsAnisotropyExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_MATERIALS_ANISOTROPY;
  }
  getMaterialType(materialIndex) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) return null;
    return MeshPhysicalMaterial;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser;
    const materialDef = parser.json.materials[materialIndex];
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve();
    }
    const pending = [];
    const extension = materialDef.extensions[this.name];
    if (extension.anisotropyStrength !== void 0) {
      materialParams.anisotropy = extension.anisotropyStrength;
    }
    if (extension.anisotropyRotation !== void 0) {
      materialParams.anisotropyRotation = extension.anisotropyRotation;
    }
    if (extension.anisotropyTexture !== void 0) {
      pending.push(parser.assignTexture(materialParams, "anisotropyMap", extension.anisotropyTexture));
    }
    return Promise.all(pending);
  }
};
var GLTFTextureBasisUExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU;
  }
  loadTexture(textureIndex) {
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null;
    }
    const extension = textureDef.extensions[this.name];
    const loader = parser.options.ktx2Loader;
    if (!loader) {
      if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
        throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
      } else {
        return null;
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureWebPExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFTextureAVIFExtension = class {
  constructor(parser) {
    this.parser = parser;
    this.name = EXTENSIONS.EXT_TEXTURE_AVIF;
  }
  loadTexture(textureIndex) {
    const name = this.name;
    const parser = this.parser;
    const json = parser.json;
    const textureDef = json.textures[textureIndex];
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null;
    }
    const extension = textureDef.extensions[name];
    const source = json.images[extension.source];
    let loader = parser.textureLoader;
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri);
      if (handler !== null) loader = handler;
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader);
  }
};
var GLTFMeshoptCompression = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION;
    this.parser = parser;
  }
  loadBufferView(index) {
    const json = this.parser.json;
    const bufferView = json.bufferViews[index];
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name];
      const buffer = this.parser.getDependency("buffer", extensionDef.buffer);
      const decoder = this.parser.options.meshoptDecoder;
      if (!decoder || !decoder.supported) {
        if (json.extensionsRequired && json.extensionsRequired.indexOf(this.name) >= 0) {
          throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
        } else {
          return null;
        }
      }
      return buffer.then(function(res) {
        const byteOffset = extensionDef.byteOffset || 0;
        const byteLength = extensionDef.byteLength || 0;
        const count = extensionDef.count;
        const stride = extensionDef.byteStride;
        const source = new Uint8Array(res, byteOffset, byteLength);
        if (decoder.decodeGltfBufferAsync) {
          return decoder.decodeGltfBufferAsync(count, stride, source, extensionDef.mode, extensionDef.filter).then(function(res2) {
            return res2.buffer;
          });
        } else {
          return decoder.ready.then(function() {
            const result = new ArrayBuffer(count * stride);
            decoder.decodeGltfBuffer(new Uint8Array(result), count, stride, source, extensionDef.mode, extensionDef.filter);
            return result;
          });
        }
      });
    } else {
      return null;
    }
  }
};
var GLTFMeshGpuInstancing = class {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESH_GPU_INSTANCING;
    this.parser = parser;
  }
  createNodeMesh(nodeIndex) {
    const json = this.parser.json;
    const nodeDef = json.nodes[nodeIndex];
    if (!nodeDef.extensions || !nodeDef.extensions[this.name] || nodeDef.mesh === void 0) {
      return null;
    }
    const meshDef = json.meshes[nodeDef.mesh];
    for (const primitive of meshDef.primitives) {
      if (primitive.mode !== WEBGL_CONSTANTS.TRIANGLES && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_STRIP && primitive.mode !== WEBGL_CONSTANTS.TRIANGLE_FAN && primitive.mode !== void 0) {
        return null;
      }
    }
    const extensionDef = nodeDef.extensions[this.name];
    const attributesDef = extensionDef.attributes;
    const pending = [];
    const attributes = {};
    for (const key in attributesDef) {
      pending.push(this.parser.getDependency("accessor", attributesDef[key]).then((accessor) => {
        attributes[key] = accessor;
        return attributes[key];
      }));
    }
    if (pending.length < 1) {
      return null;
    }
    pending.push(this.parser.createNodeMesh(nodeIndex));
    return Promise.all(pending).then((results) => {
      const nodeObject = results.pop();
      const meshes = nodeObject.isGroup ? nodeObject.children : [nodeObject];
      const count = results[0].count;
      const instancedMeshes = [];
      for (const mesh of meshes) {
        const m2 = new Matrix4();
        const p2 = new Vector3();
        const q2 = new Quaternion();
        const s2 = new Vector3(1, 1, 1);
        const instancedMesh = new InstancedMesh(mesh.geometry, mesh.material, count);
        for (let i2 = 0; i2 < count; i2++) {
          if (attributes.TRANSLATION) {
            p2.fromBufferAttribute(attributes.TRANSLATION, i2);
          }
          if (attributes.ROTATION) {
            q2.fromBufferAttribute(attributes.ROTATION, i2);
          }
          if (attributes.SCALE) {
            s2.fromBufferAttribute(attributes.SCALE, i2);
          }
          instancedMesh.setMatrixAt(i2, m2.compose(p2, q2, s2));
        }
        for (const attributeName in attributes) {
          if (attributeName === "_COLOR_0") {
            const attr = attributes[attributeName];
            instancedMesh.instanceColor = new InstancedBufferAttribute(attr.array, attr.itemSize, attr.normalized);
          } else if (attributeName !== "TRANSLATION" && attributeName !== "ROTATION" && attributeName !== "SCALE") {
            mesh.geometry.setAttribute(attributeName, attributes[attributeName]);
          }
        }
        Object3D.prototype.copy.call(instancedMesh, mesh);
        this.parser.assignFinalMaterial(instancedMesh);
        instancedMeshes.push(instancedMesh);
      }
      if (nodeObject.isGroup) {
        nodeObject.clear();
        nodeObject.add(...instancedMeshes);
        return nodeObject;
      }
      return instancedMeshes[0];
    });
  }
};
var BINARY_EXTENSION_HEADER_MAGIC = "glTF";
var BINARY_EXTENSION_HEADER_LENGTH = 12;
var BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 };
var GLTFBinaryExtension = class {
  constructor(data2) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF;
    this.content = null;
    this.body = null;
    const headerView = new DataView(data2, 0, BINARY_EXTENSION_HEADER_LENGTH);
    const textDecoder = new TextDecoder();
    this.header = {
      magic: textDecoder.decode(new Uint8Array(data2.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true)
    };
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    } else if (this.header.version < 2) {
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    }
    const chunkContentsLength = this.header.length - BINARY_EXTENSION_HEADER_LENGTH;
    const chunkView = new DataView(data2, BINARY_EXTENSION_HEADER_LENGTH);
    let chunkIndex = 0;
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      const chunkType = chunkView.getUint32(chunkIndex, true);
      chunkIndex += 4;
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(data2, BINARY_EXTENSION_HEADER_LENGTH + chunkIndex, chunkLength);
        this.content = textDecoder.decode(contentArray);
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex;
        this.body = data2.slice(byteOffset, byteOffset + chunkLength);
      }
      chunkIndex += chunkLength;
    }
    if (this.content === null) {
      throw new Error("THREE.GLTFLoader: JSON content not found.");
    }
  }
};
var GLTFDracoMeshCompressionExtension = class {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION;
    this.json = json;
    this.dracoLoader = dracoLoader;
    this.dracoLoader.preload();
  }
  decodePrimitive(primitive, parser) {
    const json = this.json;
    const dracoLoader = this.dracoLoader;
    const bufferViewIndex = primitive.extensions[this.name].bufferView;
    const gltfAttributeMap = primitive.extensions[this.name].attributes;
    const threeAttributeMap = {};
    const attributeNormalizedMap = {};
    const attributeTypeMap = {};
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName];
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName = ATTRIBUTES[attributeName] || attributeName.toLowerCase();
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]];
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
        attributeTypeMap[threeAttributeName] = componentType.name;
        attributeNormalizedMap[threeAttributeName] = accessorDef.normalized === true;
      }
    }
    return parser.getDependency("bufferView", bufferViewIndex).then(function(bufferView) {
      return new Promise(function(resolve, reject) {
        dracoLoader.decodeDracoFile(bufferView, function(geometry) {
          for (const attributeName in geometry.attributes) {
            const attribute = geometry.attributes[attributeName];
            const normalized = attributeNormalizedMap[attributeName];
            if (normalized !== void 0) attribute.normalized = normalized;
          }
          resolve(geometry);
        }, threeAttributeMap, attributeTypeMap, LinearSRGBColorSpace, reject);
      });
    });
  }
};
var GLTFTextureTransformExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(texture, transform) {
    if ((transform.texCoord === void 0 || transform.texCoord === texture.channel) && transform.offset === void 0 && transform.rotation === void 0 && transform.scale === void 0) {
      return texture;
    }
    texture = texture.clone();
    if (transform.texCoord !== void 0) {
      texture.channel = transform.texCoord;
    }
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset);
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation;
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale);
    }
    texture.needsUpdate = true;
    return texture;
  }
};
var GLTFMeshQuantizationExtension = class {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION;
  }
};
var GLTFCubicSplineInterpolant = class extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer);
  }
  copySampleValue_(index) {
    const result = this.resultBuffer, values = this.sampleValues, valueSize = this.valueSize, offset = index * valueSize * 3 + valueSize;
    for (let i2 = 0; i2 !== valueSize; i2++) {
      result[i2] = values[offset + i2];
    }
    return result;
  }
  interpolate_(i1, t0, t2, t1) {
    const result = this.resultBuffer;
    const values = this.sampleValues;
    const stride = this.valueSize;
    const stride2 = stride * 2;
    const stride3 = stride * 3;
    const td = t1 - t0;
    const p2 = (t2 - t0) / td;
    const pp = p2 * p2;
    const ppp = pp * p2;
    const offset1 = i1 * stride3;
    const offset0 = offset1 - stride3;
    const s2 = -2 * ppp + 3 * pp;
    const s3 = ppp - pp;
    const s0 = 1 - s2;
    const s1 = s3 - pp + p2;
    for (let i2 = 0; i2 !== stride; i2++) {
      const p0 = values[offset0 + i2 + stride];
      const m0 = values[offset0 + i2 + stride2] * td;
      const p1 = values[offset1 + i2 + stride];
      const m1 = values[offset1 + i2] * td;
      result[i2] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1;
    }
    return result;
  }
};
var _quaternion = new Quaternion();
var GLTFCubicSplineQuaternionInterpolant = class extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t2, t1) {
    const result = super.interpolate_(i1, t0, t2, t1);
    _quaternion.fromArray(result).normalize().toArray(result);
    return result;
  }
};
var WEBGL_CONSTANTS = {
  FLOAT: 5126,
  //FLOAT_MAT2: 35674,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123
};
var WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array
};
var WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter
};
var WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping
};
var WEBGL_TYPE_SIZES = {
  "SCALAR": 1,
  "VEC2": 2,
  "VEC3": 3,
  "VEC4": 4,
  "MAT2": 4,
  "MAT3": 9,
  "MAT4": 16
};
var ATTRIBUTES = {
  POSITION: "position",
  NORMAL: "normal",
  TANGENT: "tangent",
  TEXCOORD_0: "uv",
  TEXCOORD_1: "uv1",
  TEXCOORD_2: "uv2",
  TEXCOORD_3: "uv3",
  COLOR_0: "color",
  WEIGHTS_0: "skinWeight",
  JOINTS_0: "skinIndex"
};
var PATH_PROPERTIES = {
  scale: "scale",
  translation: "position",
  rotation: "quaternion",
  weights: "morphTargetInfluences"
};
var INTERPOLATION = {
  CUBICSPLINE: void 0,
  // We use a custom interpolant (GLTFCubicSplineInterpolation) for CUBICSPLINE tracks. Each
  // keyframe track will be initialized with a default interpolation type, then modified.
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete
};
var ALPHA_MODES = {
  OPAQUE: "OPAQUE",
  MASK: "MASK",
  BLEND: "BLEND"
};
function createDefaultMaterial(cache) {
  if (cache["DefaultMaterial"] === void 0) {
    cache["DefaultMaterial"] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide
    });
  }
  return cache["DefaultMaterial"];
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {};
      object.userData.gltfExtensions[name] = objectDef.extensions[name];
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === "object") {
      Object.assign(object.userData, gltfDef.extras);
    } else {
      console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + gltfDef.extras);
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false;
  let hasMorphNormal = false;
  let hasMorphColor = false;
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (target.POSITION !== void 0) hasMorphPosition = true;
    if (target.NORMAL !== void 0) hasMorphNormal = true;
    if (target.COLOR_0 !== void 0) hasMorphColor = true;
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break;
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor) return Promise.resolve(geometry);
  const pendingPositionAccessors = [];
  const pendingNormalAccessors = [];
  const pendingColorAccessors = [];
  for (let i2 = 0, il = targets.length; i2 < il; i2++) {
    const target = targets[i2];
    if (hasMorphPosition) {
      const pendingAccessor = target.POSITION !== void 0 ? parser.getDependency("accessor", target.POSITION) : geometry.attributes.position;
      pendingPositionAccessors.push(pendingAccessor);
    }
    if (hasMorphNormal) {
      const pendingAccessor = target.NORMAL !== void 0 ? parser.getDependency("accessor", target.NORMAL) : geometry.attributes.normal;
      pendingNormalAccessors.push(pendingAccessor);
    }
    if (hasMorphColor) {
      const pendingAccessor = target.COLOR_0 !== void 0 ? parser.getDependency("accessor", target.COLOR_0) : geometry.attributes.color;
      pendingColorAccessors.push(pendingAccessor);
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors)
  ]).then(function(accessors) {
    const morphPositions = accessors[0];
    const morphNormals = accessors[1];
    const morphColors = accessors[2];
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions;
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals;
    if (hasMorphColor) geometry.morphAttributes.color = morphColors;
    geometry.morphTargetsRelative = true;
    return geometry;
  });
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets();
  if (meshDef.weights !== void 0) {
    for (let i2 = 0, il = meshDef.weights.length; i2 < il; i2++) {
      mesh.morphTargetInfluences[i2] = meshDef.weights[i2];
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames;
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {};
      for (let i2 = 0, il = targetNames.length; i2 < il; i2++) {
        mesh.morphTargetDictionary[targetNames[i2]] = i2;
      }
    } else {
      console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.");
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  let geometryKey;
  const dracoExtension = primitiveDef.extensions && primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION];
  if (dracoExtension) {
    geometryKey = "draco:" + dracoExtension.bufferView + ":" + dracoExtension.indices + ":" + createAttributesKey(dracoExtension.attributes);
  } else {
    geometryKey = primitiveDef.indices + ":" + createAttributesKey(primitiveDef.attributes) + ":" + primitiveDef.mode;
  }
  if (primitiveDef.targets !== void 0) {
    for (let i2 = 0, il = primitiveDef.targets.length; i2 < il; i2++) {
      geometryKey += ":" + createAttributesKey(primitiveDef.targets[i2]);
    }
  }
  return geometryKey;
}
function createAttributesKey(attributes) {
  let attributesKey = "";
  const keys = Object.keys(attributes).sort();
  for (let i2 = 0, il = keys.length; i2 < il; i2++) {
    attributesKey += keys[i2] + ":" + attributes[keys[i2]] + ";";
  }
  return attributesKey;
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.");
  }
}
function getImageURIMimeType(uri) {
  if (uri.search(/\.jpe?g($|\?)/i) > 0 || uri.search(/^data\:image\/jpeg/) === 0) return "image/jpeg";
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0) return "image/webp";
  if (uri.search(/\.ktx2($|\?)/i) > 0 || uri.search(/^data\:image\/ktx2/) === 0) return "image/ktx2";
  return "image/png";
}
var _identityMatrix2 = new Matrix4();
var GLTFParser = class {
  constructor(json = {}, options = {}) {
    this.json = json;
    this.extensions = {};
    this.plugins = {};
    this.options = options;
    this.cache = new GLTFRegistry();
    this.associations = /* @__PURE__ */ new Map();
    this.primitiveCache = {};
    this.nodeCache = {};
    this.meshCache = { refs: {}, uses: {} };
    this.cameraCache = { refs: {}, uses: {} };
    this.lightCache = { refs: {}, uses: {} };
    this.sourceCache = {};
    this.textureCache = {};
    this.nodeNamesUsed = {};
    let isSafari = false;
    let safariVersion = -1;
    let isFirefox = false;
    let firefoxVersion = -1;
    if (typeof navigator !== "undefined") {
      const userAgent = navigator.userAgent;
      isSafari = /^((?!chrome|android).)*safari/i.test(userAgent) === true;
      const safariMatch = userAgent.match(/Version\/(\d+)/);
      safariVersion = isSafari && safariMatch ? parseInt(safariMatch[1], 10) : -1;
      isFirefox = userAgent.indexOf("Firefox") > -1;
      firefoxVersion = isFirefox ? userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1;
    }
    if (typeof createImageBitmap === "undefined" || isSafari && safariVersion < 17 || isFirefox && firefoxVersion < 98) {
      this.textureLoader = new TextureLoader(this.options.manager);
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager);
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin);
    this.textureLoader.setRequestHeader(this.options.requestHeader);
    this.fileLoader = new FileLoader(this.options.manager);
    this.fileLoader.setResponseType("arraybuffer");
    if (this.options.crossOrigin === "use-credentials") {
      this.fileLoader.setWithCredentials(true);
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions;
  }
  setPlugins(plugins) {
    this.plugins = plugins;
  }
  parse(onLoad, onError) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    this.cache.removeAll();
    this.nodeCache = {};
    this._invokeAll(function(ext) {
      return ext._markDefs && ext._markDefs();
    });
    Promise.all(this._invokeAll(function(ext) {
      return ext.beforeRoot && ext.beforeRoot();
    })).then(function() {
      return Promise.all([
        parser.getDependencies("scene"),
        parser.getDependencies("animation"),
        parser.getDependencies("camera")
      ]);
    }).then(function(dependencies) {
      const result = {
        scene: dependencies[0][json.scene || 0],
        scenes: dependencies[0],
        animations: dependencies[1],
        cameras: dependencies[2],
        asset: json.asset,
        parser,
        userData: {}
      };
      addUnknownExtensionsToUserData(extensions, result, json);
      assignExtrasToUserData(result, json);
      return Promise.all(parser._invokeAll(function(ext) {
        return ext.afterRoot && ext.afterRoot(result);
      })).then(function() {
        for (const scene of result.scenes) {
          scene.updateMatrixWorld();
        }
        onLoad(result);
      });
    }).catch(onError);
  }
  /**
   * Marks the special nodes/meshes in json for efficient parse.
   *
   * @private
   */
  _markDefs() {
    const nodeDefs = this.json.nodes || [];
    const skinDefs = this.json.skins || [];
    const meshDefs = this.json.meshes || [];
    for (let skinIndex = 0, skinLength = skinDefs.length; skinIndex < skinLength; skinIndex++) {
      const joints = skinDefs[skinIndex].joints;
      for (let i2 = 0, il = joints.length; i2 < il; i2++) {
        nodeDefs[joints[i2]].isBone = true;
      }
    }
    for (let nodeIndex = 0, nodeLength = nodeDefs.length; nodeIndex < nodeLength; nodeIndex++) {
      const nodeDef = nodeDefs[nodeIndex];
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh);
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true;
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera);
      }
    }
  }
  /**
   * Counts references to shared node / Object3D resources. These resources
   * can be reused, or "instantiated", at multiple nodes in the scene
   * hierarchy. Mesh, Camera, and Light instances are instantiated and must
   * be marked. Non-scenegraph resources (like Materials, Geometries, and
   * Textures) can be reused directly and are not marked here.
   *
   * Example: CesiumMilkTruck sample model reuses "Wheel" meshes.
   *
   * @private
   * @param {Object} cache
   * @param {Object3D} index
   */
  _addNodeRef(cache, index) {
    if (index === void 0) return;
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0;
    }
    cache.refs[index]++;
  }
  /**
   * Returns a reference to a shared resource, cloning it if necessary.
   *
   * @private
   * @param {Object} cache
   * @param {number} index
   * @param {Object} object
   * @return {Object}
   */
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object;
    const ref = object.clone();
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original);
      if (mappings != null) {
        this.associations.set(clone, mappings);
      }
      for (const [i2, child] of original.children.entries()) {
        updateMappings(child, clone.children[i2]);
      }
    };
    updateMappings(object, ref);
    ref.name += "_instance_" + cache.uses[index]++;
    return ref;
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins);
    extensions.push(this);
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result) return result;
    }
    return null;
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins);
    extensions.unshift(this);
    const pending = [];
    for (let i2 = 0; i2 < extensions.length; i2++) {
      const result = func(extensions[i2]);
      if (result) pending.push(result);
    }
    return pending;
  }
  /**
   * Requests the specified dependency asynchronously, with caching.
   *
   * @private
   * @param {string} type
   * @param {number} index
   * @return {Promise<Object3D|Material|Texture|AnimationClip|ArrayBuffer|Object>}
   */
  getDependency(type, index) {
    const cacheKey = type + ":" + index;
    let dependency = this.cache.get(cacheKey);
    if (!dependency) {
      switch (type) {
        case "scene":
          dependency = this.loadScene(index);
          break;
        case "node":
          dependency = this._invokeOne(function(ext) {
            return ext.loadNode && ext.loadNode(index);
          });
          break;
        case "mesh":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMesh && ext.loadMesh(index);
          });
          break;
        case "accessor":
          dependency = this.loadAccessor(index);
          break;
        case "bufferView":
          dependency = this._invokeOne(function(ext) {
            return ext.loadBufferView && ext.loadBufferView(index);
          });
          break;
        case "buffer":
          dependency = this.loadBuffer(index);
          break;
        case "material":
          dependency = this._invokeOne(function(ext) {
            return ext.loadMaterial && ext.loadMaterial(index);
          });
          break;
        case "texture":
          dependency = this._invokeOne(function(ext) {
            return ext.loadTexture && ext.loadTexture(index);
          });
          break;
        case "skin":
          dependency = this.loadSkin(index);
          break;
        case "animation":
          dependency = this._invokeOne(function(ext) {
            return ext.loadAnimation && ext.loadAnimation(index);
          });
          break;
        case "camera":
          dependency = this.loadCamera(index);
          break;
        default:
          dependency = this._invokeOne(function(ext) {
            return ext != this && ext.getDependency && ext.getDependency(type, index);
          });
          if (!dependency) {
            throw new Error("Unknown type: " + type);
          }
          break;
      }
      this.cache.add(cacheKey, dependency);
    }
    return dependency;
  }
  /**
   * Requests all dependencies of the specified type asynchronously, with caching.
   *
   * @private
   * @param {string} type
   * @return {Promise<Array<Object>>}
   */
  getDependencies(type) {
    let dependencies = this.cache.get(type);
    if (!dependencies) {
      const parser = this;
      const defs = this.json[type + (type === "mesh" ? "es" : "s")] || [];
      dependencies = Promise.all(defs.map(function(def, index) {
        return parser.getDependency(type, index);
      }));
      this.cache.add(type, dependencies);
    }
    return dependencies;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   *
   * @private
   * @param {number} bufferIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex];
    const loader = this.fileLoader;
    if (bufferDef.type && bufferDef.type !== "arraybuffer") {
      throw new Error("THREE.GLTFLoader: " + bufferDef.type + " buffer type is not supported.");
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body);
    }
    const options = this.options;
    return new Promise(function(resolve, reject) {
      loader.load(LoaderUtils.resolveURL(bufferDef.uri, options.path), resolve, void 0, function() {
        reject(new Error('THREE.GLTFLoader: Failed to load buffer "' + bufferDef.uri + '".'));
      });
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#buffers-and-buffer-views
   *
   * @private
   * @param {number} bufferViewIndex
   * @return {Promise<ArrayBuffer>}
   */
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex];
    return this.getDependency("buffer", bufferViewDef.buffer).then(function(buffer) {
      const byteLength = bufferViewDef.byteLength || 0;
      const byteOffset = bufferViewDef.byteOffset || 0;
      return buffer.slice(byteOffset, byteOffset + byteLength);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#accessors
   *
   * @private
   * @param {number} accessorIndex
   * @return {Promise<BufferAttribute|InterleavedBufferAttribute>}
   */
  loadAccessor(accessorIndex) {
    const parser = this;
    const json = this.json;
    const accessorDef = this.json.accessors[accessorIndex];
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const normalized = accessorDef.normalized === true;
      const array = new TypedArray(accessorDef.count * itemSize);
      return Promise.resolve(new BufferAttribute(array, itemSize, normalized));
    }
    const pendingBufferViews = [];
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.bufferView));
    } else {
      pendingBufferViews.push(null);
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.indices.bufferView));
      pendingBufferViews.push(this.getDependency("bufferView", accessorDef.sparse.values.bufferView));
    }
    return Promise.all(pendingBufferViews).then(function(bufferViews) {
      const bufferView = bufferViews[0];
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type];
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType];
      const elementBytes = TypedArray.BYTES_PER_ELEMENT;
      const itemBytes = elementBytes * itemSize;
      const byteOffset = accessorDef.byteOffset || 0;
      const byteStride = accessorDef.bufferView !== void 0 ? json.bufferViews[accessorDef.bufferView].byteStride : void 0;
      const normalized = accessorDef.normalized === true;
      let array, bufferAttribute;
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride);
        const ibCacheKey = "InterleavedBuffer:" + accessorDef.bufferView + ":" + accessorDef.componentType + ":" + ibSlice + ":" + accessorDef.count;
        let ib = parser.cache.get(ibCacheKey);
        if (!ib) {
          array = new TypedArray(bufferView, ibSlice * byteStride, accessorDef.count * byteStride / elementBytes);
          ib = new InterleavedBuffer(array, byteStride / elementBytes);
          parser.cache.add(ibCacheKey, ib);
        }
        bufferAttribute = new InterleavedBufferAttribute(ib, itemSize, byteOffset % byteStride / elementBytes, normalized);
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize);
        } else {
          array = new TypedArray(bufferView, byteOffset, accessorDef.count * itemSize);
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized);
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR;
        const TypedArrayIndices = WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType];
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0;
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0;
        const sparseIndices = new TypedArrayIndices(bufferViews[1], byteOffsetIndices, accessorDef.sparse.count * itemSizeIndices);
        const sparseValues = new TypedArray(bufferViews[2], byteOffsetValues, accessorDef.sparse.count * itemSize);
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(bufferAttribute.array.slice(), bufferAttribute.itemSize, bufferAttribute.normalized);
        }
        bufferAttribute.normalized = false;
        for (let i2 = 0, il = sparseIndices.length; i2 < il; i2++) {
          const index = sparseIndices[i2];
          bufferAttribute.setX(index, sparseValues[i2 * itemSize]);
          if (itemSize >= 2) bufferAttribute.setY(index, sparseValues[i2 * itemSize + 1]);
          if (itemSize >= 3) bufferAttribute.setZ(index, sparseValues[i2 * itemSize + 2]);
          if (itemSize >= 4) bufferAttribute.setW(index, sparseValues[i2 * itemSize + 3]);
          if (itemSize >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.");
        }
        bufferAttribute.normalized = normalized;
      }
      return bufferAttribute;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#textures
   *
   * @private
   * @param {number} textureIndex
   * @return {Promise<?Texture>}
   */
  loadTexture(textureIndex) {
    const json = this.json;
    const options = this.options;
    const textureDef = json.textures[textureIndex];
    const sourceIndex = textureDef.source;
    const sourceDef = json.images[sourceIndex];
    let loader = this.textureLoader;
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri);
      if (handler !== null) loader = handler;
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader);
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const textureDef = json.textures[textureIndex];
    const sourceDef = json.images[sourceIndex];
    const cacheKey = (sourceDef.uri || sourceDef.bufferView) + ":" + textureDef.sampler;
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey];
    }
    const promise = this.loadImageSource(sourceIndex, loader).then(function(texture) {
      texture.flipY = false;
      texture.name = textureDef.name || sourceDef.name || "";
      if (texture.name === "" && typeof sourceDef.uri === "string" && sourceDef.uri.startsWith("data:image/") === false) {
        texture.name = sourceDef.uri;
      }
      const samplers = json.samplers || {};
      const sampler = samplers[textureDef.sampler] || {};
      texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter;
      texture.minFilter = WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter;
      texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping;
      texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping;
      texture.generateMipmaps = !texture.isCompressedTexture && texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
      parser.associations.set(texture, { textures: textureIndex });
      return texture;
    }).catch(function() {
      return null;
    });
    this.textureCache[cacheKey] = promise;
    return promise;
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this;
    const json = this.json;
    const options = this.options;
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone());
    }
    const sourceDef = json.images[sourceIndex];
    const URL2 = self.URL || self.webkitURL;
    let sourceURI = sourceDef.uri || "";
    let isObjectURL = false;
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser.getDependency("bufferView", sourceDef.bufferView).then(function(bufferView) {
        isObjectURL = true;
        const blob = new Blob([bufferView], { type: sourceDef.mimeType });
        sourceURI = URL2.createObjectURL(blob);
        return sourceURI;
      });
    } else if (sourceDef.uri === void 0) {
      throw new Error("THREE.GLTFLoader: Image " + sourceIndex + " is missing URI and bufferView");
    }
    const promise = Promise.resolve(sourceURI).then(function(sourceURI2) {
      return new Promise(function(resolve, reject) {
        let onLoad = resolve;
        if (loader.isImageBitmapLoader === true) {
          onLoad = function(imageBitmap) {
            const texture = new Texture(imageBitmap);
            texture.needsUpdate = true;
            resolve(texture);
          };
        }
        loader.load(LoaderUtils.resolveURL(sourceURI2, options.path), onLoad, void 0, reject);
      });
    }).then(function(texture) {
      if (isObjectURL === true) {
        URL2.revokeObjectURL(sourceURI);
      }
      assignExtrasToUserData(texture, sourceDef);
      texture.userData.mimeType = sourceDef.mimeType || getImageURIMimeType(sourceDef.uri);
      return texture;
    }).catch(function(error2) {
      console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI);
      throw error2;
    });
    this.sourceCache[sourceIndex] = promise;
    return promise;
  }
  /**
   * Asynchronously assigns a texture to the given material parameters.
   *
   * @private
   * @param {Object} materialParams
   * @param {string} mapName
   * @param {Object} mapDef
   * @param {string} [colorSpace]
   * @return {Promise<Texture>}
   */
  assignTexture(materialParams, mapName, mapDef, colorSpace) {
    const parser = this;
    return this.getDependency("texture", mapDef.index).then(function(texture) {
      if (!texture) return null;
      if (mapDef.texCoord !== void 0 && mapDef.texCoord > 0) {
        texture = texture.clone();
        texture.channel = mapDef.texCoord;
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform = mapDef.extensions !== void 0 ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM] : void 0;
        if (transform) {
          const gltfReference = parser.associations.get(texture);
          texture = parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM].extendTexture(texture, transform);
          parser.associations.set(texture, gltfReference);
        }
      }
      if (colorSpace !== void 0) {
        texture.colorSpace = colorSpace;
      }
      materialParams[mapName] = texture;
      return texture;
    });
  }
  /**
   * Assigns final material to a Mesh, Line, or Points instance. The instance
   * already has a material (generated from the glTF material options alone)
   * but reuse of the same glTF material may require multiple threejs materials
   * to accommodate different primitive types, defines, etc. New materials will
   * be created if necessary, and reused from a cache.
   *
   * @private
   * @param {Object3D} mesh Mesh, Line, or Points instance.
   */
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry;
    let material = mesh.material;
    const useDerivativeTangents = geometry.attributes.tangent === void 0;
    const useVertexColors = geometry.attributes.color !== void 0;
    const useFlatShading = geometry.attributes.normal === void 0;
    if (mesh.isPoints) {
      const cacheKey = "PointsMaterial:" + material.uuid;
      let pointsMaterial = this.cache.get(cacheKey);
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial();
        Material.prototype.copy.call(pointsMaterial, material);
        pointsMaterial.color.copy(material.color);
        pointsMaterial.map = material.map;
        pointsMaterial.sizeAttenuation = false;
        this.cache.add(cacheKey, pointsMaterial);
      }
      material = pointsMaterial;
    } else if (mesh.isLine) {
      const cacheKey = "LineBasicMaterial:" + material.uuid;
      let lineMaterial = this.cache.get(cacheKey);
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial();
        Material.prototype.copy.call(lineMaterial, material);
        lineMaterial.color.copy(material.color);
        lineMaterial.map = material.map;
        this.cache.add(cacheKey, lineMaterial);
      }
      material = lineMaterial;
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = "ClonedMaterial:" + material.uuid + ":";
      if (useDerivativeTangents) cacheKey += "derivative-tangents:";
      if (useVertexColors) cacheKey += "vertex-colors:";
      if (useFlatShading) cacheKey += "flat-shading:";
      let cachedMaterial = this.cache.get(cacheKey);
      if (!cachedMaterial) {
        cachedMaterial = material.clone();
        if (useVertexColors) cachedMaterial.vertexColors = true;
        if (useFlatShading) cachedMaterial.flatShading = true;
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1;
          if (cachedMaterial.clearcoatNormalScale) cachedMaterial.clearcoatNormalScale.y *= -1;
        }
        this.cache.add(cacheKey, cachedMaterial);
        this.associations.set(cachedMaterial, this.associations.get(material));
      }
      material = cachedMaterial;
    }
    mesh.material = material;
  }
  getMaterialType() {
    return MeshStandardMaterial;
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#materials
   *
   * @private
   * @param {number} materialIndex
   * @return {Promise<Material>}
   */
  loadMaterial(materialIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const materialDef = json.materials[materialIndex];
    let materialType;
    const materialParams = {};
    const materialExtensions = materialDef.extensions || {};
    const pending = [];
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT];
      materialType = kmuExtension.getMaterialType();
      pending.push(kmuExtension.extendParams(materialParams, materialDef, parser));
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {};
      materialParams.color = new Color(1, 1, 1);
      materialParams.opacity = 1;
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor;
        materialParams.color.setRGB(array[0], array[1], array[2], LinearSRGBColorSpace);
        materialParams.opacity = array[3];
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "map", metallicRoughness.baseColorTexture, SRGBColorSpace));
      }
      materialParams.metalness = metallicRoughness.metallicFactor !== void 0 ? metallicRoughness.metallicFactor : 1;
      materialParams.roughness = metallicRoughness.roughnessFactor !== void 0 ? metallicRoughness.roughnessFactor : 1;
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(parser.assignTexture(materialParams, "metalnessMap", metallicRoughness.metallicRoughnessTexture));
        pending.push(parser.assignTexture(materialParams, "roughnessMap", metallicRoughness.metallicRoughnessTexture));
      }
      materialType = this._invokeOne(function(ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex);
      });
      pending.push(Promise.all(this._invokeAll(function(ext) {
        return ext.extendMaterialParams && ext.extendMaterialParams(materialIndex, materialParams);
      })));
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide;
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE;
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true;
      materialParams.depthWrite = false;
    } else {
      materialParams.transparent = false;
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest = materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5;
      }
    }
    if (materialDef.normalTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "normalMap", materialDef.normalTexture));
      materialParams.normalScale = new Vector2(1, 1);
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale;
        materialParams.normalScale.set(scale, scale);
      }
    }
    if (materialDef.occlusionTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "aoMap", materialDef.occlusionTexture));
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength;
      }
    }
    if (materialDef.emissiveFactor !== void 0 && materialType !== MeshBasicMaterial) {
      const emissiveFactor = materialDef.emissiveFactor;
      materialParams.emissive = new Color().setRGB(emissiveFactor[0], emissiveFactor[1], emissiveFactor[2], LinearSRGBColorSpace);
    }
    if (materialDef.emissiveTexture !== void 0 && materialType !== MeshBasicMaterial) {
      pending.push(parser.assignTexture(materialParams, "emissiveMap", materialDef.emissiveTexture, SRGBColorSpace));
    }
    return Promise.all(pending).then(function() {
      const material = new materialType(materialParams);
      if (materialDef.name) material.name = materialDef.name;
      assignExtrasToUserData(material, materialDef);
      parser.associations.set(material, { materials: materialIndex });
      if (materialDef.extensions) addUnknownExtensionsToUserData(extensions, material, materialDef);
      return material;
    });
  }
  /**
   * When Object3D instances are targeted by animation, they need unique names.
   *
   * @private
   * @param {string} originalName
   * @return {string}
   */
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || "");
    if (sanitizedName in this.nodeNamesUsed) {
      return sanitizedName + "_" + ++this.nodeNamesUsed[sanitizedName];
    } else {
      this.nodeNamesUsed[sanitizedName] = 0;
      return sanitizedName;
    }
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#geometry
   *
   * Creates BufferGeometries from primitives.
   *
   * @private
   * @param {Array<GLTF.Primitive>} primitives
   * @return {Promise<Array<BufferGeometry>>}
   */
  loadGeometries(primitives) {
    const parser = this;
    const extensions = this.extensions;
    const cache = this.primitiveCache;
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(primitive, parser).then(function(geometry) {
        return addPrimitiveAttributes(geometry, primitive, parser);
      });
    }
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const primitive = primitives[i2];
      const cacheKey = createPrimitiveKey(primitive);
      const cached = cache[cacheKey];
      if (cached) {
        pending.push(cached.promise);
      } else {
        let geometryPromise;
        if (primitive.extensions && primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]) {
          geometryPromise = createDracoPrimitive(primitive);
        } else {
          geometryPromise = addPrimitiveAttributes(new BufferGeometry(), primitive, parser);
        }
        cache[cacheKey] = { primitive, promise: geometryPromise };
        pending.push(geometryPromise);
      }
    }
    return Promise.all(pending);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/blob/master/specification/2.0/README.md#meshes
   *
   * @private
   * @param {number} meshIndex
   * @return {Promise<Group|Mesh|SkinnedMesh|Line|Points>}
   */
  loadMesh(meshIndex) {
    const parser = this;
    const json = this.json;
    const extensions = this.extensions;
    const meshDef = json.meshes[meshIndex];
    const primitives = meshDef.primitives;
    const pending = [];
    for (let i2 = 0, il = primitives.length; i2 < il; i2++) {
      const material = primitives[i2].material === void 0 ? createDefaultMaterial(this.cache) : this.getDependency("material", primitives[i2].material);
      pending.push(material);
    }
    pending.push(parser.loadGeometries(primitives));
    return Promise.all(pending).then(function(results) {
      const materials = results.slice(0, results.length - 1);
      const geometries = results[results.length - 1];
      const meshes = [];
      for (let i2 = 0, il = geometries.length; i2 < il; i2++) {
        const geometry = geometries[i2];
        const primitive = primitives[i2];
        let mesh;
        const material = materials[i2];
        if (primitive.mode === WEBGL_CONSTANTS.TRIANGLES || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP || primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN || primitive.mode === void 0) {
          mesh = meshDef.isSkinnedMesh === true ? new SkinnedMesh(geometry, material) : new Mesh(geometry, material);
          if (mesh.isSkinnedMesh === true) {
            mesh.normalizeSkinWeights();
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleStripDrawMode);
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(mesh.geometry, TriangleFanDrawMode);
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material);
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material);
        } else {
          throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + primitive.mode);
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef);
        }
        mesh.name = parser.createUniqueName(meshDef.name || "mesh_" + meshIndex);
        assignExtrasToUserData(mesh, meshDef);
        if (primitive.extensions) addUnknownExtensionsToUserData(extensions, mesh, primitive);
        parser.assignFinalMaterial(mesh);
        meshes.push(mesh);
      }
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        parser.associations.set(meshes[i2], {
          meshes: meshIndex,
          primitives: i2
        });
      }
      if (meshes.length === 1) {
        if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, meshes[0], meshDef);
        return meshes[0];
      }
      const group = new Group();
      if (meshDef.extensions) addUnknownExtensionsToUserData(extensions, group, meshDef);
      parser.associations.set(group, { meshes: meshIndex });
      for (let i2 = 0, il = meshes.length; i2 < il; i2++) {
        group.add(meshes[i2]);
      }
      return group;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#cameras
   *
   * @private
   * @param {number} cameraIndex
   * @return {Promise<Camera>|undefined}
   */
  loadCamera(cameraIndex) {
    let camera;
    const cameraDef = this.json.cameras[cameraIndex];
    const params = cameraDef[cameraDef.type];
    if (!params) {
      console.warn("THREE.GLTFLoader: Missing camera parameters.");
      return;
    }
    if (cameraDef.type === "perspective") {
      camera = new PerspectiveCamera(MathUtils.radToDeg(params.yfov), params.aspectRatio || 1, params.znear || 1, params.zfar || 2e6);
    } else if (cameraDef.type === "orthographic") {
      camera = new OrthographicCamera(-params.xmag, params.xmag, params.ymag, -params.ymag, params.znear, params.zfar);
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name);
    assignExtrasToUserData(camera, cameraDef);
    return Promise.resolve(camera);
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#skins
   *
   * @private
   * @param {number} skinIndex
   * @return {Promise<Skeleton>}
   */
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex];
    const pending = [];
    for (let i2 = 0, il = skinDef.joints.length; i2 < il; i2++) {
      pending.push(this._loadNodeShallow(skinDef.joints[i2]));
    }
    if (skinDef.inverseBindMatrices !== void 0) {
      pending.push(this.getDependency("accessor", skinDef.inverseBindMatrices));
    } else {
      pending.push(null);
    }
    return Promise.all(pending).then(function(results) {
      const inverseBindMatrices = results.pop();
      const jointNodes = results;
      const bones = [];
      const boneInverses = [];
      for (let i2 = 0, il = jointNodes.length; i2 < il; i2++) {
        const jointNode = jointNodes[i2];
        if (jointNode) {
          bones.push(jointNode);
          const mat = new Matrix4();
          if (inverseBindMatrices !== null) {
            mat.fromArray(inverseBindMatrices.array, i2 * 16);
          }
          boneInverses.push(mat);
        } else {
          console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', skinDef.joints[i2]);
        }
      }
      return new Skeleton(bones, boneInverses);
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations
   *
   * @private
   * @param {number} animationIndex
   * @return {Promise<AnimationClip>}
   */
  loadAnimation(animationIndex) {
    const json = this.json;
    const parser = this;
    const animationDef = json.animations[animationIndex];
    const animationName = animationDef.name ? animationDef.name : "animation_" + animationIndex;
    const pendingNodes = [];
    const pendingInputAccessors = [];
    const pendingOutputAccessors = [];
    const pendingSamplers = [];
    const pendingTargets = [];
    for (let i2 = 0, il = animationDef.channels.length; i2 < il; i2++) {
      const channel = animationDef.channels[i2];
      const sampler = animationDef.samplers[channel.sampler];
      const target = channel.target;
      const name = target.node;
      const input = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.input] : sampler.input;
      const output = animationDef.parameters !== void 0 ? animationDef.parameters[sampler.output] : sampler.output;
      if (target.node === void 0) continue;
      pendingNodes.push(this.getDependency("node", name));
      pendingInputAccessors.push(this.getDependency("accessor", input));
      pendingOutputAccessors.push(this.getDependency("accessor", output));
      pendingSamplers.push(sampler);
      pendingTargets.push(target);
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets)
    ]).then(function(dependencies) {
      const nodes = dependencies[0];
      const inputAccessors = dependencies[1];
      const outputAccessors = dependencies[2];
      const samplers = dependencies[3];
      const targets = dependencies[4];
      const tracks = [];
      for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
        const node = nodes[i2];
        const inputAccessor = inputAccessors[i2];
        const outputAccessor = outputAccessors[i2];
        const sampler = samplers[i2];
        const target = targets[i2];
        if (node === void 0) continue;
        if (node.updateMatrix) {
          node.updateMatrix();
        }
        const createdTracks = parser._createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target);
        if (createdTracks) {
          for (let k2 = 0; k2 < createdTracks.length; k2++) {
            tracks.push(createdTracks[k2]);
          }
        }
      }
      const animation = new AnimationClip(animationName, void 0, tracks);
      assignExtrasToUserData(animation, animationDef);
      return animation;
    });
  }
  createNodeMesh(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    if (nodeDef.mesh === void 0) return null;
    return parser.getDependency("mesh", nodeDef.mesh).then(function(mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh);
      if (nodeDef.weights !== void 0) {
        node.traverse(function(o2) {
          if (!o2.isMesh) return;
          for (let i2 = 0, il = nodeDef.weights.length; i2 < il; i2++) {
            o2.morphTargetInfluences[i2] = nodeDef.weights[i2];
          }
        });
      }
      return node;
    });
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#nodes-and-hierarchy
   *
   * @private
   * @param {number} nodeIndex
   * @return {Promise<Object3D>}
   */
  loadNode(nodeIndex) {
    const json = this.json;
    const parser = this;
    const nodeDef = json.nodes[nodeIndex];
    const nodePending = parser._loadNodeShallow(nodeIndex);
    const childPending = [];
    const childrenDef = nodeDef.children || [];
    for (let i2 = 0, il = childrenDef.length; i2 < il; i2++) {
      childPending.push(parser.getDependency("node", childrenDef[i2]));
    }
    const skeletonPending = nodeDef.skin === void 0 ? Promise.resolve(null) : parser.getDependency("skin", nodeDef.skin);
    return Promise.all([
      nodePending,
      Promise.all(childPending),
      skeletonPending
    ]).then(function(results) {
      const node = results[0];
      const children = results[1];
      const skeleton = results[2];
      if (skeleton !== null) {
        node.traverse(function(mesh) {
          if (!mesh.isSkinnedMesh) return;
          mesh.bind(skeleton, _identityMatrix2);
        });
      }
      for (let i2 = 0, il = children.length; i2 < il; i2++) {
        node.add(children[i2]);
      }
      return node;
    });
  }
  // ._loadNodeShallow() parses a single node.
  // skin and child nodes are created and added in .loadNode() (no '_' prefix).
  _loadNodeShallow(nodeIndex) {
    const json = this.json;
    const extensions = this.extensions;
    const parser = this;
    if (this.nodeCache[nodeIndex] !== void 0) {
      return this.nodeCache[nodeIndex];
    }
    const nodeDef = json.nodes[nodeIndex];
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : "";
    const pending = [];
    const meshPromise = parser._invokeOne(function(ext) {
      return ext.createNodeMesh && ext.createNodeMesh(nodeIndex);
    });
    if (meshPromise) {
      pending.push(meshPromise);
    }
    if (nodeDef.camera !== void 0) {
      pending.push(parser.getDependency("camera", nodeDef.camera).then(function(camera) {
        return parser._getNodeRef(parser.cameraCache, nodeDef.camera, camera);
      }));
    }
    parser._invokeAll(function(ext) {
      return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex);
    }).forEach(function(promise) {
      pending.push(promise);
    });
    this.nodeCache[nodeIndex] = Promise.all(pending).then(function(objects) {
      let node;
      if (nodeDef.isBone === true) {
        node = new Bone();
      } else if (objects.length > 1) {
        node = new Group();
      } else if (objects.length === 1) {
        node = objects[0];
      } else {
        node = new Object3D();
      }
      if (node !== objects[0]) {
        for (let i2 = 0, il = objects.length; i2 < il; i2++) {
          node.add(objects[i2]);
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name;
        node.name = nodeName;
      }
      assignExtrasToUserData(node, nodeDef);
      if (nodeDef.extensions) addUnknownExtensionsToUserData(extensions, node, nodeDef);
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4();
        matrix.fromArray(nodeDef.matrix);
        node.applyMatrix4(matrix);
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation);
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation);
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale);
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {});
      } else if (nodeDef.mesh !== void 0 && parser.meshCache.refs[nodeDef.mesh] > 1) {
        const mapping = parser.associations.get(node);
        parser.associations.set(node, { ...mapping });
      }
      parser.associations.get(node).nodes = nodeIndex;
      return node;
    });
    return this.nodeCache[nodeIndex];
  }
  /**
   * Specification: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#scenes
   *
   * @private
   * @param {number} sceneIndex
   * @return {Promise<Group>}
   */
  loadScene(sceneIndex) {
    const extensions = this.extensions;
    const sceneDef = this.json.scenes[sceneIndex];
    const parser = this;
    const scene = new Group();
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name);
    assignExtrasToUserData(scene, sceneDef);
    if (sceneDef.extensions) addUnknownExtensionsToUserData(extensions, scene, sceneDef);
    const nodeIds = sceneDef.nodes || [];
    const pending = [];
    for (let i2 = 0, il = nodeIds.length; i2 < il; i2++) {
      pending.push(parser.getDependency("node", nodeIds[i2]));
    }
    return Promise.all(pending).then(function(nodes) {
      for (let i2 = 0, il = nodes.length; i2 < il; i2++) {
        scene.add(nodes[i2]);
      }
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map();
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value);
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2);
          if (mappings != null) {
            reducedAssociations.set(node2, mappings);
          }
        });
        return reducedAssociations;
      };
      parser.associations = reduceAssociations(scene);
      return scene;
    });
  }
  _createAnimationTracks(node, inputAccessor, outputAccessor, sampler, target) {
    const tracks = [];
    const targetName = node.name ? node.name : node.uuid;
    const targetNames = [];
    if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
      node.traverse(function(object) {
        if (object.morphTargetInfluences) {
          targetNames.push(object.name ? object.name : object.uuid);
        }
      });
    } else {
      targetNames.push(targetName);
    }
    let TypedKeyframeTrack;
    switch (PATH_PROPERTIES[target.path]) {
      case PATH_PROPERTIES.weights:
        TypedKeyframeTrack = NumberKeyframeTrack;
        break;
      case PATH_PROPERTIES.rotation:
        TypedKeyframeTrack = QuaternionKeyframeTrack;
        break;
      case PATH_PROPERTIES.translation:
      case PATH_PROPERTIES.scale:
        TypedKeyframeTrack = VectorKeyframeTrack;
        break;
      default:
        switch (outputAccessor.itemSize) {
          case 1:
            TypedKeyframeTrack = NumberKeyframeTrack;
            break;
          case 2:
          case 3:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack;
            break;
        }
        break;
    }
    const interpolation = sampler.interpolation !== void 0 ? INTERPOLATION[sampler.interpolation] : InterpolateLinear;
    const outputArray = this._getArrayFromAccessor(outputAccessor);
    for (let j2 = 0, jl = targetNames.length; j2 < jl; j2++) {
      const track = new TypedKeyframeTrack(
        targetNames[j2] + "." + PATH_PROPERTIES[target.path],
        inputAccessor.array,
        outputArray,
        interpolation
      );
      if (sampler.interpolation === "CUBICSPLINE") {
        this._createCubicSplineTrackInterpolant(track);
      }
      tracks.push(track);
    }
    return tracks;
  }
  _getArrayFromAccessor(accessor) {
    let outputArray = accessor.array;
    if (accessor.normalized) {
      const scale = getNormalizedComponentScale(outputArray.constructor);
      const scaled = new Float32Array(outputArray.length);
      for (let j2 = 0, jl = outputArray.length; j2 < jl; j2++) {
        scaled[j2] = outputArray[j2] * scale;
      }
      outputArray = scaled;
    }
    return outputArray;
  }
  _createCubicSplineTrackInterpolant(track) {
    track.createInterpolant = function InterpolantFactoryMethodGLTFCubicSpline(result) {
      const interpolantType = this instanceof QuaternionKeyframeTrack ? GLTFCubicSplineQuaternionInterpolant : GLTFCubicSplineInterpolant;
      return new interpolantType(this.times, this.values, this.getValueSize() / 3, result);
    };
    track.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true;
  }
};
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const box = new Box3();
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION];
    const min = accessor.min;
    const max = accessor.max;
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2])
      );
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
        box.min.multiplyScalar(boxScale);
        box.max.multiplyScalar(boxScale);
      }
    } else {
      console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
      return;
    }
  } else {
    return;
  }
  const targets = primitiveDef.targets;
  if (targets !== void 0) {
    const maxDisplacement = new Vector3();
    const vector = new Vector3();
    for (let i2 = 0, il = targets.length; i2 < il; i2++) {
      const target = targets[i2];
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION];
        const min = accessor.min;
        const max = accessor.max;
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])));
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])));
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])));
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(WEBGL_COMPONENT_TYPES[accessor.componentType]);
            vector.multiplyScalar(boxScale);
          }
          maxDisplacement.max(vector);
        } else {
          console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
        }
      }
    }
    box.expandByVector(maxDisplacement);
  }
  geometry.boundingBox = box;
  const sphere = new Sphere();
  box.getCenter(sphere.center);
  sphere.radius = box.min.distanceTo(box.max) / 2;
  geometry.boundingSphere = sphere;
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes;
  const pending = [];
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser.getDependency("accessor", accessorIndex).then(function(accessor) {
      geometry.setAttribute(attributeName, accessor);
    });
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName = ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase();
    if (threeAttributeName in geometry.attributes) continue;
    pending.push(assignAttributeAccessor(attributes[gltfAttributeName], threeAttributeName));
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser.getDependency("accessor", primitiveDef.indices).then(function(accessor2) {
      geometry.setIndex(accessor2);
    });
    pending.push(accessor);
  }
  if (ColorManagement.workingColorSpace !== LinearSRGBColorSpace && "COLOR_0" in attributes) {
    console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${ColorManagement.workingColorSpace}" not supported.`);
  }
  assignExtrasToUserData(geometry, primitiveDef);
  computeBounds(geometry, primitiveDef, parser);
  return Promise.all(pending).then(function() {
    return primitiveDef.targets !== void 0 ? addMorphTargets(geometry, primitiveDef.targets, parser) : geometry;
  });
}

// node_modules/@pixiv/three-vrm/lib/three-vrm.module.js
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __async2 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var VRMExpression = class extends Object3D {
  constructor(expressionName) {
    super();
    this.weight = 0;
    this.isBinary = false;
    this.overrideBlink = "none";
    this.overrideLookAt = "none";
    this.overrideMouth = "none";
    this._binds = [];
    this.name = `VRMExpression_${expressionName}`;
    this.expressionName = expressionName;
    this.type = "VRMExpression";
    this.visible = false;
  }
  /**
   * Binds that this expression influences.
   */
  get binds() {
    return this._binds;
  }
  /**
   * A value represents how much it should override blink expressions.
   * `0.0` == no override at all, `1.0` == completely block the expressions.
   */
  get overrideBlinkAmount() {
    if (this.overrideBlink === "block") {
      return 0 < this.outputWeight ? 1 : 0;
    } else if (this.overrideBlink === "blend") {
      return this.outputWeight;
    } else {
      return 0;
    }
  }
  /**
   * A value represents how much it should override lookAt expressions.
   * `0.0` == no override at all, `1.0` == completely block the expressions.
   */
  get overrideLookAtAmount() {
    if (this.overrideLookAt === "block") {
      return 0 < this.outputWeight ? 1 : 0;
    } else if (this.overrideLookAt === "blend") {
      return this.outputWeight;
    } else {
      return 0;
    }
  }
  /**
   * A value represents how much it should override mouth expressions.
   * `0.0` == no override at all, `1.0` == completely block the expressions.
   */
  get overrideMouthAmount() {
    if (this.overrideMouth === "block") {
      return 0 < this.outputWeight ? 1 : 0;
    } else if (this.overrideMouth === "blend") {
      return this.outputWeight;
    } else {
      return 0;
    }
  }
  /**
   * An output weight of this expression, considering the {@link isBinary}.
   */
  get outputWeight() {
    if (this.isBinary) {
      return this.weight > 0.5 ? 1 : 0;
    }
    return this.weight;
  }
  /**
   * Add an expression bind to the expression.
   *
   * @param bind A bind to add
   */
  addBind(bind2) {
    this._binds.push(bind2);
  }
  /**
   * Delete an expression bind from the expression.
   *
   * @param bind A bind to delete
   */
  deleteBind(bind2) {
    const index = this._binds.indexOf(bind2);
    if (index >= 0) {
      this._binds.splice(index, 1);
    }
  }
  /**
   * Apply weight to every assigned blend shapes.
   * Should be called every frame.
   */
  applyWeight(options) {
    var _a2;
    let actualWeight = this.outputWeight;
    actualWeight *= (_a2 = options == null ? void 0 : options.multiplier) != null ? _a2 : 1;
    if (this.isBinary && actualWeight < 1) {
      actualWeight = 0;
    }
    this._binds.forEach((bind2) => bind2.applyWeight(actualWeight));
  }
  /**
   * Clear previously assigned blend shapes.
   */
  clearAppliedWeight() {
    this._binds.forEach((bind2) => bind2.clearAppliedWeight());
  }
};
function extractPrimitivesInternal(gltf, nodeIndex, node) {
  var _a2, _b;
  const json = gltf.parser.json;
  const schemaNode = (_a2 = json.nodes) == null ? void 0 : _a2[nodeIndex];
  if (schemaNode == null) {
    console.warn(`extractPrimitivesInternal: Attempt to use nodes[${nodeIndex}] of glTF but the node doesn't exist`);
    return null;
  }
  const meshIndex = schemaNode.mesh;
  if (meshIndex == null) {
    return null;
  }
  const schemaMesh = (_b = json.meshes) == null ? void 0 : _b[meshIndex];
  if (schemaMesh == null) {
    console.warn(`extractPrimitivesInternal: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`);
    return null;
  }
  const primitiveCount = schemaMesh.primitives.length;
  const primitives = [];
  node.traverse((object) => {
    if (primitives.length < primitiveCount) {
      if (object.isMesh) {
        primitives.push(object);
      }
    }
  });
  return primitives;
}
function gltfExtractPrimitivesFromNode(gltf, nodeIndex) {
  return __async2(this, null, function* () {
    const node = yield gltf.parser.getDependency("node", nodeIndex);
    return extractPrimitivesInternal(gltf, nodeIndex, node);
  });
}
function gltfExtractPrimitivesFromNodes(gltf) {
  return __async2(this, null, function* () {
    const nodes = yield gltf.parser.getDependencies("node");
    const map = /* @__PURE__ */ new Map();
    nodes.forEach((node, index) => {
      const result = extractPrimitivesInternal(gltf, index, node);
      if (result != null) {
        map.set(index, result);
      }
    });
    return map;
  });
}
var VRMExpressionPresetName = {
  Aa: "aa",
  Ih: "ih",
  Ou: "ou",
  Ee: "ee",
  Oh: "oh",
  Blink: "blink",
  Happy: "happy",
  Angry: "angry",
  Sad: "sad",
  Relaxed: "relaxed",
  LookUp: "lookUp",
  Surprised: "surprised",
  LookDown: "lookDown",
  LookLeft: "lookLeft",
  LookRight: "lookRight",
  BlinkLeft: "blinkLeft",
  BlinkRight: "blinkRight",
  Neutral: "neutral"
};
function saturate(value) {
  return Math.max(Math.min(value, 1), 0);
}
var VRMExpressionManager = class _VRMExpressionManager {
  /**
   * Create a new {@link VRMExpressionManager}.
   */
  constructor() {
    this.blinkExpressionNames = ["blink", "blinkLeft", "blinkRight"];
    this.lookAtExpressionNames = ["lookLeft", "lookRight", "lookUp", "lookDown"];
    this.mouthExpressionNames = ["aa", "ee", "ih", "oh", "ou"];
    this._expressions = [];
    this._expressionMap = {};
  }
  get expressions() {
    return this._expressions.concat();
  }
  get expressionMap() {
    return Object.assign({}, this._expressionMap);
  }
  /**
   * A map from name to expression, but excluding custom expressions.
   */
  get presetExpressionMap() {
    const result = {};
    const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
    Object.entries(this._expressionMap).forEach(([name, expression]) => {
      if (presetNameSet.has(name)) {
        result[name] = expression;
      }
    });
    return result;
  }
  /**
   * A map from name to expression, but excluding preset expressions.
   */
  get customExpressionMap() {
    const result = {};
    const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
    Object.entries(this._expressionMap).forEach(([name, expression]) => {
      if (!presetNameSet.has(name)) {
        result[name] = expression;
      }
    });
    return result;
  }
  /**
   * Copy the given {@link VRMExpressionManager} into this one.
   * @param source The {@link VRMExpressionManager} you want to copy
   * @returns this
   */
  copy(source) {
    const expressions = this._expressions.concat();
    expressions.forEach((expression) => {
      this.unregisterExpression(expression);
    });
    source._expressions.forEach((expression) => {
      this.registerExpression(expression);
    });
    this.blinkExpressionNames = source.blinkExpressionNames.concat();
    this.lookAtExpressionNames = source.lookAtExpressionNames.concat();
    this.mouthExpressionNames = source.mouthExpressionNames.concat();
    return this;
  }
  /**
   * Returns a clone of this {@link VRMExpressionManager}.
   * @returns Copied {@link VRMExpressionManager}
   */
  clone() {
    return new _VRMExpressionManager().copy(this);
  }
  /**
   * Return a registered expression.
   * If it cannot find an expression, it will return `null` instead.
   *
   * @param name Name or preset name of the expression
   */
  getExpression(name) {
    var _a2;
    return (_a2 = this._expressionMap[name]) != null ? _a2 : null;
  }
  /**
   * Register an expression.
   *
   * @param expression {@link VRMExpression} that describes the expression
   */
  registerExpression(expression) {
    this._expressions.push(expression);
    this._expressionMap[expression.expressionName] = expression;
  }
  /**
   * Unregister an expression.
   *
   * @param expression The expression you want to unregister
   */
  unregisterExpression(expression) {
    const index = this._expressions.indexOf(expression);
    if (index === -1) {
      console.warn("VRMExpressionManager: The specified expressions is not registered");
    }
    this._expressions.splice(index, 1);
    delete this._expressionMap[expression.expressionName];
  }
  /**
   * Get the current weight of the specified expression.
   * If it doesn't have an expression of given name, it will return `null` instead.
   *
   * @param name Name of the expression
   */
  getValue(name) {
    var _a2;
    const expression = this.getExpression(name);
    return (_a2 = expression == null ? void 0 : expression.weight) != null ? _a2 : null;
  }
  /**
   * Set a weight to the specified expression.
   *
   * @param name Name of the expression
   * @param weight Weight
   */
  setValue(name, weight) {
    const expression = this.getExpression(name);
    if (expression) {
      expression.weight = saturate(weight);
    }
  }
  /**
   * Reset weights of all expressions to `0.0`.
   */
  resetValues() {
    this._expressions.forEach((expression) => {
      expression.weight = 0;
    });
  }
  /**
   * Get a track name of specified expression.
   * This track name is needed to manipulate its expression via keyframe animations.
   *
   * @example Manipulate an expression using keyframe animation
   * ```js
   * const trackName = vrm.expressionManager.getExpressionTrackName( 'blink' );
   * const track = new THREE.NumberKeyframeTrack(
   *   name,
   *   [ 0.0, 0.5, 1.0 ], // times
   *   [ 0.0, 1.0, 0.0 ] // values
   * );
   *
   * const clip = new THREE.AnimationClip(
   *   'blink', // name
   *   1.0, // duration
   *   [ track ] // tracks
   * );
   *
   * const mixer = new THREE.AnimationMixer( vrm.scene );
   * const action = mixer.clipAction( clip );
   * action.play();
   * ```
   *
   * @param name Name of the expression
   */
  getExpressionTrackName(name) {
    const expression = this.getExpression(name);
    return expression ? `${expression.name}.weight` : null;
  }
  /**
   * Update every expressions.
   */
  update() {
    const weightMultipliers = this._calculateWeightMultipliers();
    this._expressions.forEach((expression) => {
      expression.clearAppliedWeight();
    });
    this._expressions.forEach((expression) => {
      let multiplier = 1;
      const name = expression.expressionName;
      if (this.blinkExpressionNames.indexOf(name) !== -1) {
        multiplier *= weightMultipliers.blink;
      }
      if (this.lookAtExpressionNames.indexOf(name) !== -1) {
        multiplier *= weightMultipliers.lookAt;
      }
      if (this.mouthExpressionNames.indexOf(name) !== -1) {
        multiplier *= weightMultipliers.mouth;
      }
      expression.applyWeight({ multiplier });
    });
  }
  /**
   * Calculate sum of override amounts to see how much we should multiply weights of certain expressions.
   */
  _calculateWeightMultipliers() {
    let blink = 1;
    let lookAt = 1;
    let mouth = 1;
    this._expressions.forEach((expression) => {
      blink -= expression.overrideBlinkAmount;
      lookAt -= expression.overrideLookAtAmount;
      mouth -= expression.overrideMouthAmount;
    });
    blink = Math.max(0, blink);
    lookAt = Math.max(0, lookAt);
    mouth = Math.max(0, mouth);
    return { blink, lookAt, mouth };
  }
};
var VRMExpressionMaterialColorType = {
  Color: "color",
  EmissionColor: "emissionColor",
  ShadeColor: "shadeColor",
  MatcapColor: "matcapColor",
  RimColor: "rimColor",
  OutlineColor: "outlineColor"
};
var v0ExpressionMaterialColorMap = {
  _Color: VRMExpressionMaterialColorType.Color,
  _EmissionColor: VRMExpressionMaterialColorType.EmissionColor,
  _ShadeColor: VRMExpressionMaterialColorType.ShadeColor,
  _RimColor: VRMExpressionMaterialColorType.RimColor,
  _OutlineColor: VRMExpressionMaterialColorType.OutlineColor
};
var _color2 = new Color();
var _VRMExpressionMaterialColorBind = class _VRMExpressionMaterialColorBind2 {
  constructor({
    material,
    type,
    targetValue,
    targetAlpha
  }) {
    this.material = material;
    this.type = type;
    this.targetValue = targetValue;
    this.targetAlpha = targetAlpha != null ? targetAlpha : 1;
    const color = this._initColorBindState();
    const alpha = this._initAlphaBindState();
    this._state = { color, alpha };
  }
  applyWeight(weight) {
    const { color, alpha } = this._state;
    if (color != null) {
      const { propertyName, deltaValue } = color;
      const target = this.material[propertyName];
      if (target != void 0) {
        target.add(_color2.copy(deltaValue).multiplyScalar(weight));
      }
    }
    if (alpha != null) {
      const { propertyName, deltaValue } = alpha;
      const target = this.material[propertyName];
      if (target != void 0) {
        this.material[propertyName] += deltaValue * weight;
      }
    }
  }
  clearAppliedWeight() {
    const { color, alpha } = this._state;
    if (color != null) {
      const { propertyName, initialValue } = color;
      const target = this.material[propertyName];
      if (target != void 0) {
        target.copy(initialValue);
      }
    }
    if (alpha != null) {
      const { propertyName, initialValue } = alpha;
      const target = this.material[propertyName];
      if (target != void 0) {
        this.material[propertyName] = initialValue;
      }
    }
  }
  _initColorBindState() {
    var _a2, _b, _c2;
    const { material, type, targetValue } = this;
    const propertyNameMap = this._getPropertyNameMap();
    const propertyName = (_b = (_a2 = propertyNameMap == null ? void 0 : propertyNameMap[type]) == null ? void 0 : _a2[0]) != null ? _b : null;
    if (propertyName == null) {
      console.warn(
        `Tried to add a material color bind to the material ${(_c2 = material.name) != null ? _c2 : "(no name)"}, the type ${type} but the material or the type is not supported.`
      );
      return null;
    }
    const target = material[propertyName];
    const initialValue = target.clone();
    const deltaValue = new Color(
      targetValue.r - initialValue.r,
      targetValue.g - initialValue.g,
      targetValue.b - initialValue.b
    );
    return { propertyName, initialValue, deltaValue };
  }
  _initAlphaBindState() {
    var _a2, _b, _c2;
    const { material, type, targetAlpha } = this;
    const propertyNameMap = this._getPropertyNameMap();
    const propertyName = (_b = (_a2 = propertyNameMap == null ? void 0 : propertyNameMap[type]) == null ? void 0 : _a2[1]) != null ? _b : null;
    if (propertyName == null && targetAlpha !== 1) {
      console.warn(
        `Tried to add a material alpha bind to the material ${(_c2 = material.name) != null ? _c2 : "(no name)"}, the type ${type} but the material or the type does not support alpha.`
      );
      return null;
    }
    if (propertyName == null) {
      return null;
    }
    const initialValue = material[propertyName];
    const deltaValue = targetAlpha - initialValue;
    return { propertyName, initialValue, deltaValue };
  }
  _getPropertyNameMap() {
    var _a2, _b;
    return (_b = (_a2 = Object.entries(_VRMExpressionMaterialColorBind2._propertyNameMapMap).find(([distinguisher]) => {
      return this.material[distinguisher] === true;
    })) == null ? void 0 : _a2[1]) != null ? _b : null;
  }
};
_VRMExpressionMaterialColorBind._propertyNameMapMap = {
  isMeshStandardMaterial: {
    color: ["color", "opacity"],
    emissionColor: ["emissive", null]
  },
  isMeshBasicMaterial: {
    color: ["color", "opacity"]
  },
  isMToonMaterial: {
    color: ["color", "opacity"],
    emissionColor: ["emissive", null],
    outlineColor: ["outlineColorFactor", null],
    matcapColor: ["matcapFactor", null],
    rimColor: ["parametricRimColorFactor", null],
    shadeColor: ["shadeColorFactor", null]
  }
};
var VRMExpressionMaterialColorBind = _VRMExpressionMaterialColorBind;
var VRMExpressionMorphTargetBind = class {
  constructor({
    primitives,
    index,
    weight
  }) {
    this.primitives = primitives;
    this.index = index;
    this.weight = weight;
  }
  applyWeight(weight) {
    this.primitives.forEach((mesh) => {
      var _a2;
      if (((_a2 = mesh.morphTargetInfluences) == null ? void 0 : _a2[this.index]) != null) {
        mesh.morphTargetInfluences[this.index] += this.weight * weight;
      }
    });
  }
  clearAppliedWeight() {
    this.primitives.forEach((mesh) => {
      var _a2;
      if (((_a2 = mesh.morphTargetInfluences) == null ? void 0 : _a2[this.index]) != null) {
        mesh.morphTargetInfluences[this.index] = 0;
      }
    });
  }
};
var _v2 = new Vector2();
var _VRMExpressionTextureTransformBind = class _VRMExpressionTextureTransformBind2 {
  constructor({
    material,
    scale,
    offset
  }) {
    var _a2, _b;
    this.material = material;
    this.scale = scale;
    this.offset = offset;
    const propertyNames = (_a2 = Object.entries(_VRMExpressionTextureTransformBind2._propertyNamesMap).find(
      ([distinguisher]) => {
        return material[distinguisher] === true;
      }
    )) == null ? void 0 : _a2[1];
    if (propertyNames == null) {
      console.warn(
        `Tried to add a texture transform bind to the material ${(_b = material.name) != null ? _b : "(no name)"} but the material is not supported.`
      );
      this._properties = [];
    } else {
      this._properties = [];
      propertyNames.forEach((propertyName) => {
        var _a22;
        const texture = (_a22 = material[propertyName]) == null ? void 0 : _a22.clone();
        if (!texture) {
          return null;
        }
        material[propertyName] = texture;
        const initialOffset = texture.offset.clone();
        const initialScale = texture.repeat.clone();
        const deltaOffset = offset.clone().sub(initialOffset);
        const deltaScale = scale.clone().sub(initialScale);
        this._properties.push({
          name: propertyName,
          initialOffset,
          deltaOffset,
          initialScale,
          deltaScale
        });
      });
    }
  }
  applyWeight(weight) {
    this._properties.forEach((property) => {
      const target = this.material[property.name];
      if (target === void 0) {
        return;
      }
      target.offset.add(_v2.copy(property.deltaOffset).multiplyScalar(weight));
      target.repeat.add(_v2.copy(property.deltaScale).multiplyScalar(weight));
    });
  }
  clearAppliedWeight() {
    this._properties.forEach((property) => {
      const target = this.material[property.name];
      if (target === void 0) {
        return;
      }
      target.offset.copy(property.initialOffset);
      target.repeat.copy(property.initialScale);
    });
  }
};
_VRMExpressionTextureTransformBind._propertyNamesMap = {
  isMeshStandardMaterial: [
    "map",
    "emissiveMap",
    "bumpMap",
    "normalMap",
    "displacementMap",
    "roughnessMap",
    "metalnessMap",
    "alphaMap"
  ],
  isMeshBasicMaterial: ["map", "specularMap", "alphaMap"],
  isMToonMaterial: [
    "map",
    "normalMap",
    "emissiveMap",
    "shadeMultiplyTexture",
    "rimMultiplyTexture",
    "outlineWidthMultiplyTexture",
    "uvAnimationMaskTexture"
  ]
};
var VRMExpressionTextureTransformBind = _VRMExpressionTextureTransformBind;
var POSSIBLE_SPEC_VERSIONS = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var _VRMExpressionLoaderPlugin = class _VRMExpressionLoaderPlugin2 {
  get name() {
    return "VRMExpressionLoaderPlugin";
  }
  constructor(parser) {
    this.parser = parser;
  }
  afterRoot(gltf) {
    return __async2(this, null, function* () {
      gltf.userData.vrmExpressionManager = yield this._import(gltf);
    });
  }
  /**
   * Import a {@link VRMExpressionManager} from a VRM.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   */
  _import(gltf) {
    return __async2(this, null, function* () {
      const v1Result = yield this._v1Import(gltf);
      if (v1Result) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf);
      if (v0Result) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const json = this.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRMC_vrm")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
      if (!extension) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS.has(specVersion)) {
        console.warn(`VRMExpressionLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
        return null;
      }
      const schemaExpressions = extension.expressions;
      if (!schemaExpressions) {
        return null;
      }
      const presetNameSet = new Set(Object.values(VRMExpressionPresetName));
      const nameSchemaExpressionMap = /* @__PURE__ */ new Map();
      if (schemaExpressions.preset != null) {
        Object.entries(schemaExpressions.preset).forEach(([name, schemaExpression]) => {
          if (schemaExpression == null) {
            return;
          }
          if (!presetNameSet.has(name)) {
            console.warn(`VRMExpressionLoaderPlugin: Unknown preset name "${name}" detected. Ignoring the expression`);
            return;
          }
          nameSchemaExpressionMap.set(name, schemaExpression);
        });
      }
      if (schemaExpressions.custom != null) {
        Object.entries(schemaExpressions.custom).forEach(([name, schemaExpression]) => {
          if (presetNameSet.has(name)) {
            console.warn(
              `VRMExpressionLoaderPlugin: Custom expression cannot have preset name "${name}". Ignoring the expression`
            );
            return;
          }
          nameSchemaExpressionMap.set(name, schemaExpression);
        });
      }
      const manager = new VRMExpressionManager();
      yield Promise.all(
        Array.from(nameSchemaExpressionMap.entries()).map((_0) => __async2(this, [_0], function* ([name, schemaExpression]) {
          var _a22, _b2, _c2, _d, _e2, _f, _g;
          const expression = new VRMExpression(name);
          gltf.scene.add(expression);
          expression.isBinary = (_a22 = schemaExpression.isBinary) != null ? _a22 : false;
          expression.overrideBlink = (_b2 = schemaExpression.overrideBlink) != null ? _b2 : "none";
          expression.overrideLookAt = (_c2 = schemaExpression.overrideLookAt) != null ? _c2 : "none";
          expression.overrideMouth = (_d = schemaExpression.overrideMouth) != null ? _d : "none";
          (_e2 = schemaExpression.morphTargetBinds) == null ? void 0 : _e2.forEach((bind2) => __async2(this, null, function* () {
            var _a3;
            if (bind2.node === void 0 || bind2.index === void 0) {
              return;
            }
            const primitives = yield gltfExtractPrimitivesFromNode(gltf, bind2.node);
            const morphTargetIndex = bind2.index;
            if (!primitives.every(
              (primitive) => Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length
            )) {
              console.warn(
                `VRMExpressionLoaderPlugin: ${schemaExpression.name} attempts to index morph #${morphTargetIndex} but not found.`
              );
              return;
            }
            expression.addBind(
              new VRMExpressionMorphTargetBind({
                primitives,
                index: morphTargetIndex,
                weight: (_a3 = bind2.weight) != null ? _a3 : 1
              })
            );
          }));
          if (schemaExpression.materialColorBinds || schemaExpression.textureTransformBinds) {
            const gltfMaterials = [];
            gltf.scene.traverse((object) => {
              const material = object.material;
              if (material) {
                if (Array.isArray(material)) {
                  gltfMaterials.push(...material);
                } else {
                  gltfMaterials.push(material);
                }
              }
            });
            (_f = schemaExpression.materialColorBinds) == null ? void 0 : _f.forEach((bind2) => __async2(this, null, function* () {
              const materials = gltfMaterials.filter((material) => {
                var _a3;
                const materialIndex = (_a3 = this.parser.associations.get(material)) == null ? void 0 : _a3.materials;
                return bind2.material === materialIndex;
              });
              materials.forEach((material) => {
                expression.addBind(
                  new VRMExpressionMaterialColorBind({
                    material,
                    type: bind2.type,
                    targetValue: new Color().fromArray(bind2.targetValue),
                    targetAlpha: bind2.targetValue[3]
                  })
                );
              });
            }));
            (_g = schemaExpression.textureTransformBinds) == null ? void 0 : _g.forEach((bind2) => __async2(this, null, function* () {
              const materials = gltfMaterials.filter((material) => {
                var _a3;
                const materialIndex = (_a3 = this.parser.associations.get(material)) == null ? void 0 : _a3.materials;
                return bind2.material === materialIndex;
              });
              materials.forEach((material) => {
                var _a3, _b3;
                expression.addBind(
                  new VRMExpressionTextureTransformBind({
                    material,
                    offset: new Vector2().fromArray((_a3 = bind2.offset) != null ? _a3 : [0, 0]),
                    scale: new Vector2().fromArray((_b3 = bind2.scale) != null ? _b3 : [1, 1])
                  })
                );
              });
            }));
          }
          manager.registerExpression(expression);
        }))
      );
      return manager;
    });
  }
  _v0Import(gltf) {
    return __async2(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const vrmExt = (_a2 = json.extensions) == null ? void 0 : _a2.VRM;
      if (!vrmExt) {
        return null;
      }
      const schemaBlendShape = vrmExt.blendShapeMaster;
      if (!schemaBlendShape) {
        return null;
      }
      const manager = new VRMExpressionManager();
      const schemaBlendShapeGroups = schemaBlendShape.blendShapeGroups;
      if (!schemaBlendShapeGroups) {
        return manager;
      }
      const blendShapeNameSet = /* @__PURE__ */ new Set();
      yield Promise.all(
        schemaBlendShapeGroups.map((schemaGroup) => __async2(this, null, function* () {
          var _a22;
          const v0PresetName = schemaGroup.presetName;
          const v1PresetName = v0PresetName != null && _VRMExpressionLoaderPlugin2.v0v1PresetNameMap[v0PresetName] || null;
          const name = v1PresetName != null ? v1PresetName : schemaGroup.name;
          if (name == null) {
            console.warn("VRMExpressionLoaderPlugin: One of custom expressions has no name. Ignoring the expression");
            return;
          }
          if (blendShapeNameSet.has(name)) {
            console.warn(
              `VRMExpressionLoaderPlugin: An expression preset ${v0PresetName} has duplicated entries. Ignoring the expression`
            );
            return;
          }
          blendShapeNameSet.add(name);
          const expression = new VRMExpression(name);
          gltf.scene.add(expression);
          expression.isBinary = (_a22 = schemaGroup.isBinary) != null ? _a22 : false;
          if (schemaGroup.binds) {
            schemaGroup.binds.forEach((bind2) => __async2(this, null, function* () {
              var _a3;
              if (bind2.mesh === void 0 || bind2.index === void 0) {
                return;
              }
              const nodesUsingMesh = [];
              (_a3 = json.nodes) == null ? void 0 : _a3.forEach((node, i2) => {
                if (node.mesh === bind2.mesh) {
                  nodesUsingMesh.push(i2);
                }
              });
              const morphTargetIndex = bind2.index;
              yield Promise.all(
                nodesUsingMesh.map((nodeIndex) => __async2(this, null, function* () {
                  var _a4;
                  const primitives = yield gltfExtractPrimitivesFromNode(gltf, nodeIndex);
                  if (!primitives.every(
                    (primitive) => Array.isArray(primitive.morphTargetInfluences) && morphTargetIndex < primitive.morphTargetInfluences.length
                  )) {
                    console.warn(
                      `VRMExpressionLoaderPlugin: ${schemaGroup.name} attempts to index ${morphTargetIndex}th morph but not found.`
                    );
                    return;
                  }
                  expression.addBind(
                    new VRMExpressionMorphTargetBind({
                      primitives,
                      index: morphTargetIndex,
                      weight: 0.01 * ((_a4 = bind2.weight) != null ? _a4 : 100)
                      // narrowing the range from [ 0.0 - 100.0 ] to [ 0.0 - 1.0 ]
                    })
                  );
                }))
              );
            }));
          }
          const materialValues = schemaGroup.materialValues;
          if (materialValues && materialValues.length !== 0) {
            materialValues.forEach((materialValue) => {
              if (materialValue.materialName === void 0 || materialValue.propertyName === void 0 || materialValue.targetValue === void 0) {
                return;
              }
              const materials = [];
              gltf.scene.traverse((object) => {
                if (object.material) {
                  const material = object.material;
                  if (Array.isArray(material)) {
                    materials.push(
                      ...material.filter(
                        (mtl) => (mtl.name === materialValue.materialName || mtl.name === materialValue.materialName + " (Outline)") && materials.indexOf(mtl) === -1
                      )
                    );
                  } else if (material.name === materialValue.materialName && materials.indexOf(material) === -1) {
                    materials.push(material);
                  }
                }
              });
              const materialPropertyName = materialValue.propertyName;
              materials.forEach((material) => {
                if (materialPropertyName === "_MainTex_ST") {
                  const scale = new Vector2(materialValue.targetValue[0], materialValue.targetValue[1]);
                  const offset = new Vector2(materialValue.targetValue[2], materialValue.targetValue[3]);
                  offset.y = 1 - offset.y - scale.y;
                  expression.addBind(
                    new VRMExpressionTextureTransformBind({
                      material,
                      scale,
                      offset
                    })
                  );
                  return;
                }
                const materialColorType = v0ExpressionMaterialColorMap[materialPropertyName];
                if (materialColorType) {
                  expression.addBind(
                    new VRMExpressionMaterialColorBind({
                      material,
                      type: materialColorType,
                      targetValue: new Color().fromArray(materialValue.targetValue),
                      targetAlpha: materialValue.targetValue[3]
                    })
                  );
                  return;
                }
                console.warn(materialPropertyName + " is not supported");
              });
            });
          }
          manager.registerExpression(expression);
        }))
      );
      return manager;
    });
  }
};
_VRMExpressionLoaderPlugin.v0v1PresetNameMap = {
  a: "aa",
  e: "ee",
  i: "ih",
  o: "oh",
  u: "ou",
  blink: "blink",
  joy: "happy",
  angry: "angry",
  sorrow: "sad",
  fun: "relaxed",
  lookup: "lookUp",
  lookdown: "lookDown",
  lookleft: "lookLeft",
  lookright: "lookRight",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  blink_l: "blinkLeft",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  blink_r: "blinkRight",
  neutral: "neutral"
};
var VRMExpressionLoaderPlugin = _VRMExpressionLoaderPlugin;
var _VRMFirstPerson = class _VRMFirstPerson2 {
  /**
   * Create a new VRMFirstPerson object.
   *
   * @param humanoid A {@link VRMHumanoid}
   * @param meshAnnotations A {@link VRMFirstPersonMeshAnnotation}
   */
  constructor(humanoid, meshAnnotations) {
    this._firstPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_FIRSTPERSON_ONLY_LAYER;
    this._thirdPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_THIRDPERSON_ONLY_LAYER;
    this._initializedLayers = false;
    this.humanoid = humanoid;
    this.meshAnnotations = meshAnnotations;
  }
  /**
   * Copy the given {@link VRMFirstPerson} into this one.
   * {@link humanoid} must be same as the source one.
   * @param source The {@link VRMFirstPerson} you want to copy
   * @returns this
   */
  copy(source) {
    if (this.humanoid !== source.humanoid) {
      throw new Error("VRMFirstPerson: humanoid must be same in order to copy");
    }
    this.meshAnnotations = source.meshAnnotations.map((annotation) => ({
      meshes: annotation.meshes.concat(),
      type: annotation.type
    }));
    return this;
  }
  /**
   * Returns a clone of this {@link VRMFirstPerson}.
   * @returns Copied {@link VRMFirstPerson}
   */
  clone() {
    return new _VRMFirstPerson2(this.humanoid, this.meshAnnotations).copy(this);
  }
  /**
   * A camera layer represents `FirstPersonOnly` layer.
   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.
   *
   * The value is {@link DEFAULT_FIRSTPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.
   *
   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/
   * @see https://threejs.org/docs/#api/en/core/Layers
   */
  get firstPersonOnlyLayer() {
    return this._firstPersonOnlyLayer;
  }
  /**
   * A camera layer represents `ThirdPersonOnly` layer.
   * Note that **you must call {@link setup} first before you use the layer feature** or it does not work properly.
   *
   * The value is {@link DEFAULT_THIRDPERSON_ONLY_LAYER} by default but you can change the layer by specifying via {@link setup} if you prefer.
   *
   * @see https://vrm.dev/en/univrm/api/univrm_use_firstperson/
   * @see https://threejs.org/docs/#api/en/core/Layers
   */
  get thirdPersonOnlyLayer() {
    return this._thirdPersonOnlyLayer;
  }
  /**
   * In this method, it assigns layers for every meshes based on mesh annotations.
   * You must call this method first before you use the layer feature.
   *
   * This is an equivalent of [VRMFirstPerson.Setup](https://github.com/vrm-c/UniVRM/blob/73a5bd8fcddaa2a7a8735099a97e63c9db3e5ea0/Assets/VRM/Runtime/FirstPerson/VRMFirstPerson.cs#L295-L299) of the UniVRM.
   *
   * The `cameraLayer` parameter specifies which layer will be assigned for `FirstPersonOnly` / `ThirdPersonOnly`.
   * In UniVRM, we specified those by naming each desired layer as `FIRSTPERSON_ONLY_LAYER` / `THIRDPERSON_ONLY_LAYER`
   * but we are going to specify these layers at here since we are unable to name layers in Three.js.
   *
   * @param cameraLayer Specify which layer will be for `FirstPersonOnly` / `ThirdPersonOnly`.
   */
  setup({
    firstPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_FIRSTPERSON_ONLY_LAYER,
    thirdPersonOnlyLayer = _VRMFirstPerson2.DEFAULT_THIRDPERSON_ONLY_LAYER
  } = {}) {
    if (this._initializedLayers) {
      return;
    }
    this._firstPersonOnlyLayer = firstPersonOnlyLayer;
    this._thirdPersonOnlyLayer = thirdPersonOnlyLayer;
    this.meshAnnotations.forEach((item) => {
      item.meshes.forEach((mesh) => {
        if (item.type === "firstPersonOnly") {
          mesh.layers.set(this._firstPersonOnlyLayer);
          mesh.traverse((child) => child.layers.set(this._firstPersonOnlyLayer));
        } else if (item.type === "thirdPersonOnly") {
          mesh.layers.set(this._thirdPersonOnlyLayer);
          mesh.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
        } else if (item.type === "auto") {
          this._createHeadlessModel(mesh);
        }
      });
    });
    this._initializedLayers = true;
  }
  _excludeTriangles(triangles, bws, skinIndex, exclude) {
    let count = 0;
    if (bws != null && bws.length > 0) {
      for (let i2 = 0; i2 < triangles.length; i2 += 3) {
        const a2 = triangles[i2];
        const b2 = triangles[i2 + 1];
        const c2 = triangles[i2 + 2];
        const bw0 = bws[a2];
        const skin0 = skinIndex[a2];
        if (bw0[0] > 0 && exclude.includes(skin0[0])) continue;
        if (bw0[1] > 0 && exclude.includes(skin0[1])) continue;
        if (bw0[2] > 0 && exclude.includes(skin0[2])) continue;
        if (bw0[3] > 0 && exclude.includes(skin0[3])) continue;
        const bw1 = bws[b2];
        const skin1 = skinIndex[b2];
        if (bw1[0] > 0 && exclude.includes(skin1[0])) continue;
        if (bw1[1] > 0 && exclude.includes(skin1[1])) continue;
        if (bw1[2] > 0 && exclude.includes(skin1[2])) continue;
        if (bw1[3] > 0 && exclude.includes(skin1[3])) continue;
        const bw2 = bws[c2];
        const skin2 = skinIndex[c2];
        if (bw2[0] > 0 && exclude.includes(skin2[0])) continue;
        if (bw2[1] > 0 && exclude.includes(skin2[1])) continue;
        if (bw2[2] > 0 && exclude.includes(skin2[2])) continue;
        if (bw2[3] > 0 && exclude.includes(skin2[3])) continue;
        triangles[count++] = a2;
        triangles[count++] = b2;
        triangles[count++] = c2;
      }
    }
    return count;
  }
  _createErasedMesh(src, erasingBonesIndex) {
    const dst = new SkinnedMesh(src.geometry.clone(), src.material);
    dst.name = `${src.name}(erase)`;
    dst.frustumCulled = src.frustumCulled;
    dst.layers.set(this._firstPersonOnlyLayer);
    const geometry = dst.geometry;
    const skinIndexAttr = geometry.getAttribute("skinIndex");
    const skinIndexAttrArray = skinIndexAttr instanceof GLBufferAttribute ? [] : skinIndexAttr.array;
    const skinIndex = [];
    for (let i2 = 0; i2 < skinIndexAttrArray.length; i2 += 4) {
      skinIndex.push([
        skinIndexAttrArray[i2],
        skinIndexAttrArray[i2 + 1],
        skinIndexAttrArray[i2 + 2],
        skinIndexAttrArray[i2 + 3]
      ]);
    }
    const skinWeightAttr = geometry.getAttribute("skinWeight");
    const skinWeightAttrArray = skinWeightAttr instanceof GLBufferAttribute ? [] : skinWeightAttr.array;
    const skinWeight = [];
    for (let i2 = 0; i2 < skinWeightAttrArray.length; i2 += 4) {
      skinWeight.push([
        skinWeightAttrArray[i2],
        skinWeightAttrArray[i2 + 1],
        skinWeightAttrArray[i2 + 2],
        skinWeightAttrArray[i2 + 3]
      ]);
    }
    const index = geometry.getIndex();
    if (!index) {
      throw new Error("The geometry doesn't have an index buffer");
    }
    const oldTriangles = Array.from(index.array);
    const count = this._excludeTriangles(oldTriangles, skinWeight, skinIndex, erasingBonesIndex);
    const newTriangle = [];
    for (let i2 = 0; i2 < count; i2++) {
      newTriangle[i2] = oldTriangles[i2];
    }
    geometry.setIndex(newTriangle);
    if (src.onBeforeRender) {
      dst.onBeforeRender = src.onBeforeRender;
    }
    dst.bind(new Skeleton(src.skeleton.bones, src.skeleton.boneInverses), new Matrix4());
    return dst;
  }
  _createHeadlessModelForSkinnedMesh(parent, mesh) {
    const eraseBoneIndexes = [];
    mesh.skeleton.bones.forEach((bone, index) => {
      if (this._isEraseTarget(bone)) eraseBoneIndexes.push(index);
    });
    if (!eraseBoneIndexes.length) {
      mesh.layers.enable(this._thirdPersonOnlyLayer);
      mesh.layers.enable(this._firstPersonOnlyLayer);
      return;
    }
    mesh.layers.set(this._thirdPersonOnlyLayer);
    const newMesh = this._createErasedMesh(mesh, eraseBoneIndexes);
    parent.add(newMesh);
  }
  _createHeadlessModel(node) {
    if (node.type === "Group") {
      node.layers.set(this._thirdPersonOnlyLayer);
      if (this._isEraseTarget(node)) {
        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
      } else {
        const parent = new Group();
        parent.name = `_headless_${node.name}`;
        parent.layers.set(this._firstPersonOnlyLayer);
        node.parent.add(parent);
        node.children.filter((child) => child.type === "SkinnedMesh").forEach((child) => {
          const skinnedMesh = child;
          this._createHeadlessModelForSkinnedMesh(parent, skinnedMesh);
        });
      }
    } else if (node.type === "SkinnedMesh") {
      const skinnedMesh = node;
      this._createHeadlessModelForSkinnedMesh(node.parent, skinnedMesh);
    } else {
      if (this._isEraseTarget(node)) {
        node.layers.set(this._thirdPersonOnlyLayer);
        node.traverse((child) => child.layers.set(this._thirdPersonOnlyLayer));
      }
    }
  }
  _isEraseTarget(bone) {
    if (bone === this.humanoid.getRawBoneNode("head")) {
      return true;
    } else if (!bone.parent) {
      return false;
    } else {
      return this._isEraseTarget(bone.parent);
    }
  }
};
_VRMFirstPerson.DEFAULT_FIRSTPERSON_ONLY_LAYER = 9;
_VRMFirstPerson.DEFAULT_THIRDPERSON_ONLY_LAYER = 10;
var VRMFirstPerson = _VRMFirstPerson;
var POSSIBLE_SPEC_VERSIONS2 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var VRMFirstPersonLoaderPlugin = class {
  get name() {
    return "VRMFirstPersonLoaderPlugin";
  }
  constructor(parser) {
    this.parser = parser;
  }
  afterRoot(gltf) {
    return __async2(this, null, function* () {
      const vrmHumanoid = gltf.userData.vrmHumanoid;
      if (vrmHumanoid === null) {
        return;
      } else if (vrmHumanoid === void 0) {
        throw new Error(
          "VRMFirstPersonLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first"
        );
      }
      gltf.userData.vrmFirstPerson = yield this._import(gltf, vrmHumanoid);
    });
  }
  /**
   * Import a {@link VRMFirstPerson} from a VRM.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM
   */
  _import(gltf, humanoid) {
    return __async2(this, null, function* () {
      if (humanoid == null) {
        return null;
      }
      const v1Result = yield this._v1Import(gltf, humanoid);
      if (v1Result) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf, humanoid);
      if (v0Result) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf, humanoid) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const json = this.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRMC_vrm")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
      if (!extension) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS2.has(specVersion)) {
        console.warn(`VRMFirstPersonLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
        return null;
      }
      const schemaFirstPerson = extension.firstPerson;
      const meshAnnotations = [];
      const nodePrimitivesMap = yield gltfExtractPrimitivesFromNodes(gltf);
      Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {
        var _a22, _b2;
        const annotation = (_a22 = schemaFirstPerson == null ? void 0 : schemaFirstPerson.meshAnnotations) == null ? void 0 : _a22.find((a2) => a2.node === nodeIndex);
        meshAnnotations.push({
          meshes: primitives,
          type: (_b2 = annotation == null ? void 0 : annotation.type) != null ? _b2 : "auto"
        });
      });
      return new VRMFirstPerson(humanoid, meshAnnotations);
    });
  }
  _v0Import(gltf, humanoid) {
    return __async2(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const vrmExt = (_a2 = json.extensions) == null ? void 0 : _a2.VRM;
      if (!vrmExt) {
        return null;
      }
      const schemaFirstPerson = vrmExt.firstPerson;
      if (!schemaFirstPerson) {
        return null;
      }
      const meshAnnotations = [];
      const nodePrimitivesMap = yield gltfExtractPrimitivesFromNodes(gltf);
      Array.from(nodePrimitivesMap.entries()).forEach(([nodeIndex, primitives]) => {
        const schemaNode = json.nodes[nodeIndex];
        const flag = schemaFirstPerson.meshAnnotations ? schemaFirstPerson.meshAnnotations.find((a2) => a2.mesh === schemaNode.mesh) : void 0;
        meshAnnotations.push({
          meshes: primitives,
          type: this._convertV0FlagToV1Type(flag == null ? void 0 : flag.firstPersonFlag)
        });
      });
      return new VRMFirstPerson(humanoid, meshAnnotations);
    });
  }
  _convertV0FlagToV1Type(flag) {
    if (flag === "FirstPersonOnly") {
      return "firstPersonOnly";
    } else if (flag === "ThirdPersonOnly") {
      return "thirdPersonOnly";
    } else if (flag === "Both") {
      return "both";
    } else {
      return "auto";
    }
  }
};
var _v3A = new Vector3();
var _v3B = new Vector3();
var _quatA = new Quaternion();
var VRMHumanoidHelper = class extends Group {
  constructor(humanoid) {
    super();
    this.vrmHumanoid = humanoid;
    this._boneAxesMap = /* @__PURE__ */ new Map();
    Object.values(humanoid.humanBones).forEach((bone) => {
      const helper = new AxesHelper(1);
      helper.matrixAutoUpdate = false;
      helper.material.depthTest = false;
      helper.material.depthWrite = false;
      this.add(helper);
      this._boneAxesMap.set(bone, helper);
    });
  }
  dispose() {
    Array.from(this._boneAxesMap.values()).forEach((axes) => {
      axes.geometry.dispose();
      axes.material.dispose();
    });
  }
  updateMatrixWorld(force) {
    Array.from(this._boneAxesMap.entries()).forEach(([bone, axes]) => {
      bone.node.updateWorldMatrix(true, false);
      bone.node.matrixWorld.decompose(_v3A, _quatA, _v3B);
      const scale = _v3A.set(0.1, 0.1, 0.1).divide(_v3B);
      axes.matrix.copy(bone.node.matrixWorld).scale(scale);
    });
    super.updateMatrixWorld(force);
  }
};
var VRMHumanBoneList = [
  "hips",
  "spine",
  "chest",
  "upperChest",
  "neck",
  "head",
  "leftEye",
  "rightEye",
  "jaw",
  "leftUpperLeg",
  "leftLowerLeg",
  "leftFoot",
  "leftToes",
  "rightUpperLeg",
  "rightLowerLeg",
  "rightFoot",
  "rightToes",
  "leftShoulder",
  "leftUpperArm",
  "leftLowerArm",
  "leftHand",
  "rightShoulder",
  "rightUpperArm",
  "rightLowerArm",
  "rightHand",
  "leftThumbMetacarpal",
  "leftThumbProximal",
  "leftThumbDistal",
  "leftIndexProximal",
  "leftIndexIntermediate",
  "leftIndexDistal",
  "leftMiddleProximal",
  "leftMiddleIntermediate",
  "leftMiddleDistal",
  "leftRingProximal",
  "leftRingIntermediate",
  "leftRingDistal",
  "leftLittleProximal",
  "leftLittleIntermediate",
  "leftLittleDistal",
  "rightThumbMetacarpal",
  "rightThumbProximal",
  "rightThumbDistal",
  "rightIndexProximal",
  "rightIndexIntermediate",
  "rightIndexDistal",
  "rightMiddleProximal",
  "rightMiddleIntermediate",
  "rightMiddleDistal",
  "rightRingProximal",
  "rightRingIntermediate",
  "rightRingDistal",
  "rightLittleProximal",
  "rightLittleIntermediate",
  "rightLittleDistal"
];
var VRMHumanBoneParentMap = {
  hips: null,
  spine: "hips",
  chest: "spine",
  upperChest: "chest",
  neck: "upperChest",
  head: "neck",
  leftEye: "head",
  rightEye: "head",
  jaw: "head",
  leftUpperLeg: "hips",
  leftLowerLeg: "leftUpperLeg",
  leftFoot: "leftLowerLeg",
  leftToes: "leftFoot",
  rightUpperLeg: "hips",
  rightLowerLeg: "rightUpperLeg",
  rightFoot: "rightLowerLeg",
  rightToes: "rightFoot",
  leftShoulder: "upperChest",
  leftUpperArm: "leftShoulder",
  leftLowerArm: "leftUpperArm",
  leftHand: "leftLowerArm",
  rightShoulder: "upperChest",
  rightUpperArm: "rightShoulder",
  rightLowerArm: "rightUpperArm",
  rightHand: "rightLowerArm",
  leftThumbMetacarpal: "leftHand",
  leftThumbProximal: "leftThumbMetacarpal",
  leftThumbDistal: "leftThumbProximal",
  leftIndexProximal: "leftHand",
  leftIndexIntermediate: "leftIndexProximal",
  leftIndexDistal: "leftIndexIntermediate",
  leftMiddleProximal: "leftHand",
  leftMiddleIntermediate: "leftMiddleProximal",
  leftMiddleDistal: "leftMiddleIntermediate",
  leftRingProximal: "leftHand",
  leftRingIntermediate: "leftRingProximal",
  leftRingDistal: "leftRingIntermediate",
  leftLittleProximal: "leftHand",
  leftLittleIntermediate: "leftLittleProximal",
  leftLittleDistal: "leftLittleIntermediate",
  rightThumbMetacarpal: "rightHand",
  rightThumbProximal: "rightThumbMetacarpal",
  rightThumbDistal: "rightThumbProximal",
  rightIndexProximal: "rightHand",
  rightIndexIntermediate: "rightIndexProximal",
  rightIndexDistal: "rightIndexIntermediate",
  rightMiddleProximal: "rightHand",
  rightMiddleIntermediate: "rightMiddleProximal",
  rightMiddleDistal: "rightMiddleIntermediate",
  rightRingProximal: "rightHand",
  rightRingIntermediate: "rightRingProximal",
  rightRingDistal: "rightRingIntermediate",
  rightLittleProximal: "rightHand",
  rightLittleIntermediate: "rightLittleProximal",
  rightLittleDistal: "rightLittleIntermediate"
};
function quatInvertCompat(target) {
  if (target.invert) {
    target.invert();
  } else {
    target.inverse();
  }
  return target;
}
var _v3A2 = new Vector3();
var _quatA2 = new Quaternion();
var VRMRig = class {
  /**
   * Create a new {@link VRMHumanoid}.
   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid
   */
  constructor(humanBones) {
    this.humanBones = humanBones;
    this.restPose = this.getAbsolutePose();
  }
  /**
   * Return the current absolute pose of this humanoid as a {@link VRMPose}.
   * Note that the output result will contain initial state of the VRM and not compatible between different models.
   * You might want to use {@link getPose} instead.
   */
  getAbsolutePose() {
    const pose = {};
    Object.keys(this.humanBones).forEach((vrmBoneNameString) => {
      const vrmBoneName = vrmBoneNameString;
      const node = this.getBoneNode(vrmBoneName);
      if (!node) {
        return;
      }
      _v3A2.copy(node.position);
      _quatA2.copy(node.quaternion);
      pose[vrmBoneName] = {
        position: _v3A2.toArray(),
        rotation: _quatA2.toArray()
      };
    });
    return pose;
  }
  /**
   * Return the current pose of this humanoid as a {@link VRMPose}.
   *
   * Each transform is a local transform relative from rest pose (T-pose).
   */
  getPose() {
    const pose = {};
    Object.keys(this.humanBones).forEach((boneNameString) => {
      const boneName = boneNameString;
      const node = this.getBoneNode(boneName);
      if (!node) {
        return;
      }
      _v3A2.set(0, 0, 0);
      _quatA2.identity();
      const restState = this.restPose[boneName];
      if (restState == null ? void 0 : restState.position) {
        _v3A2.fromArray(restState.position).negate();
      }
      if (restState == null ? void 0 : restState.rotation) {
        quatInvertCompat(_quatA2.fromArray(restState.rotation));
      }
      _v3A2.add(node.position);
      _quatA2.premultiply(node.quaternion);
      pose[boneName] = {
        position: _v3A2.toArray(),
        rotation: _quatA2.toArray()
      };
    });
    return pose;
  }
  /**
   * Let the humanoid do a specified pose.
   *
   * Each transform have to be a local transform relative from rest pose (T-pose).
   * You can pass what you got from {@link getPose}.
   *
   * @param poseObject A {@link VRMPose} that represents a single pose
   */
  setPose(poseObject) {
    Object.entries(poseObject).forEach(([boneNameString, state]) => {
      const boneName = boneNameString;
      const node = this.getBoneNode(boneName);
      if (!node) {
        return;
      }
      const restState = this.restPose[boneName];
      if (!restState) {
        return;
      }
      if (state == null ? void 0 : state.position) {
        node.position.fromArray(state.position);
        if (restState.position) {
          node.position.add(_v3A2.fromArray(restState.position));
        }
      }
      if (state == null ? void 0 : state.rotation) {
        node.quaternion.fromArray(state.rotation);
        if (restState.rotation) {
          node.quaternion.multiply(_quatA2.fromArray(restState.rotation));
        }
      }
    });
  }
  /**
   * Reset the humanoid to its rest pose.
   */
  resetPose() {
    Object.entries(this.restPose).forEach(([boneName, rest]) => {
      const node = this.getBoneNode(boneName);
      if (!node) {
        return;
      }
      if (rest == null ? void 0 : rest.position) {
        node.position.fromArray(rest.position);
      }
      if (rest == null ? void 0 : rest.rotation) {
        node.quaternion.fromArray(rest.rotation);
      }
    });
  }
  /**
   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a {@link VRMHumanBone}.
   *
   * @param name Name of the bone you want
   */
  getBone(name) {
    var _a2;
    return (_a2 = this.humanBones[name]) != null ? _a2 : void 0;
  }
  /**
   * Return a bone bound to a specified {@link VRMHumanBoneName}, as a `THREE.Object3D`.
   *
   * @param name Name of the bone you want
   */
  getBoneNode(name) {
    var _a2, _b;
    return (_b = (_a2 = this.humanBones[name]) == null ? void 0 : _a2.node) != null ? _b : null;
  }
};
var _v3A3 = new Vector3();
var _quatA3 = new Quaternion();
var _boneWorldPos = new Vector3();
var VRMHumanoidRig = class _VRMHumanoidRig extends VRMRig {
  static _setupTransforms(modelRig) {
    const root = new Object3D();
    root.name = "VRMHumanoidRig";
    const boneWorldPositions = {};
    const boneWorldRotations = {};
    const boneRotations = {};
    const parentWorldRotations = {};
    VRMHumanBoneList.forEach((boneName) => {
      var _a2;
      const boneNode = modelRig.getBoneNode(boneName);
      if (boneNode) {
        const boneWorldPosition = new Vector3();
        const boneWorldRotation = new Quaternion();
        boneNode.updateWorldMatrix(true, false);
        boneNode.matrixWorld.decompose(boneWorldPosition, boneWorldRotation, _v3A3);
        boneWorldPositions[boneName] = boneWorldPosition;
        boneWorldRotations[boneName] = boneWorldRotation;
        boneRotations[boneName] = boneNode.quaternion.clone();
        const parentWorldRotation = new Quaternion();
        (_a2 = boneNode.parent) == null ? void 0 : _a2.matrixWorld.decompose(_v3A3, parentWorldRotation, _v3A3);
        parentWorldRotations[boneName] = parentWorldRotation;
      }
    });
    const rigBones = {};
    VRMHumanBoneList.forEach((boneName) => {
      var _a2;
      const boneNode = modelRig.getBoneNode(boneName);
      if (boneNode) {
        const boneWorldPosition = boneWorldPositions[boneName];
        let currentBoneName = boneName;
        let parentBoneWorldPosition;
        while (parentBoneWorldPosition == null) {
          currentBoneName = VRMHumanBoneParentMap[currentBoneName];
          if (currentBoneName == null) {
            break;
          }
          parentBoneWorldPosition = boneWorldPositions[currentBoneName];
        }
        const rigBoneNode = new Object3D();
        rigBoneNode.name = "Normalized_" + boneNode.name;
        const parentRigBoneNode = currentBoneName ? (_a2 = rigBones[currentBoneName]) == null ? void 0 : _a2.node : root;
        parentRigBoneNode.add(rigBoneNode);
        rigBoneNode.position.copy(boneWorldPosition);
        if (parentBoneWorldPosition) {
          rigBoneNode.position.sub(parentBoneWorldPosition);
        }
        rigBones[boneName] = { node: rigBoneNode };
      }
    });
    return {
      rigBones,
      root,
      parentWorldRotations,
      boneRotations
    };
  }
  constructor(humanoid) {
    const { rigBones, root, parentWorldRotations, boneRotations } = _VRMHumanoidRig._setupTransforms(humanoid);
    super(rigBones);
    this.original = humanoid;
    this.root = root;
    this._parentWorldRotations = parentWorldRotations;
    this._boneRotations = boneRotations;
  }
  /**
   * Update this humanoid rig.
   */
  update() {
    VRMHumanBoneList.forEach((boneName) => {
      const boneNode = this.original.getBoneNode(boneName);
      if (boneNode != null) {
        const rigBoneNode = this.getBoneNode(boneName);
        const parentWorldRotation = this._parentWorldRotations[boneName];
        const invParentWorldRotation = _quatA3.copy(parentWorldRotation).invert();
        const boneRotation = this._boneRotations[boneName];
        boneNode.quaternion.copy(rigBoneNode.quaternion).multiply(parentWorldRotation).premultiply(invParentWorldRotation).multiply(boneRotation);
        if (boneName === "hips") {
          const boneWorldPosition = rigBoneNode.getWorldPosition(_boneWorldPos);
          boneNode.parent.updateWorldMatrix(true, false);
          const parentWorldMatrix = boneNode.parent.matrixWorld;
          const localPosition = boneWorldPosition.applyMatrix4(parentWorldMatrix.invert());
          boneNode.position.copy(localPosition);
        }
      }
    });
  }
};
var VRMHumanoid = class _VRMHumanoid {
  // TODO: Rename
  /**
   * @deprecated Deprecated. Use either {@link rawRestPose} or {@link normalizedRestPose} instead.
   */
  get restPose() {
    console.warn("VRMHumanoid: restPose is deprecated. Use either rawRestPose or normalizedRestPose instead.");
    return this.rawRestPose;
  }
  /**
   * A {@link VRMPose} of its raw human bones that is its default state.
   * Note that it's not compatible with {@link setRawPose} and {@link getRawPose}, since it contains non-relative values of each local transforms.
   */
  get rawRestPose() {
    return this._rawHumanBones.restPose;
  }
  /**
   * A {@link VRMPose} of its normalized human bones that is its default state.
   * Note that it's not compatible with {@link setNormalizedPose} and {@link getNormalizedPose}, since it contains non-relative values of each local transforms.
   */
  get normalizedRestPose() {
    return this._normalizedHumanBones.restPose;
  }
  /**
   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.
   */
  get humanBones() {
    return this._rawHumanBones.humanBones;
  }
  /**
   * A map from {@link VRMHumanBoneName} to raw {@link VRMHumanBone}s.
   */
  get rawHumanBones() {
    return this._rawHumanBones.humanBones;
  }
  /**
   * A map from {@link VRMHumanBoneName} to normalized {@link VRMHumanBone}s.
   */
  get normalizedHumanBones() {
    return this._normalizedHumanBones.humanBones;
  }
  /**
   * The root of normalized {@link VRMHumanBone}s.
   */
  get normalizedHumanBonesRoot() {
    return this._normalizedHumanBones.root;
  }
  /**
   * Create a new {@link VRMHumanoid}.
   * @param humanBones A {@link VRMHumanBones} contains all the bones of the new humanoid
   * @param autoUpdateHumanBones Whether it copies pose from normalizedHumanBones to rawHumanBones on {@link update}. `true` by default.
   */
  constructor(humanBones, options) {
    var _a2;
    this.autoUpdateHumanBones = (_a2 = options == null ? void 0 : options.autoUpdateHumanBones) != null ? _a2 : true;
    this._rawHumanBones = new VRMRig(humanBones);
    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);
  }
  /**
   * Copy the given {@link VRMHumanoid} into this one.
   * @param source The {@link VRMHumanoid} you want to copy
   * @returns this
   */
  copy(source) {
    this.autoUpdateHumanBones = source.autoUpdateHumanBones;
    this._rawHumanBones = new VRMRig(source.humanBones);
    this._normalizedHumanBones = new VRMHumanoidRig(this._rawHumanBones);
    return this;
  }
  /**
   * Returns a clone of this {@link VRMHumanoid}.
   * @returns Copied {@link VRMHumanoid}
   */
  clone() {
    return new _VRMHumanoid(this.humanBones, { autoUpdateHumanBones: this.autoUpdateHumanBones }).copy(this);
  }
  /**
   * @deprecated Deprecated. Use either {@link getRawAbsolutePose} or {@link getNormalizedAbsolutePose} instead.
   */
  getAbsolutePose() {
    console.warn(
      "VRMHumanoid: getAbsolutePose() is deprecated. Use either getRawAbsolutePose() or getNormalizedAbsolutePose() instead."
    );
    return this.getRawAbsolutePose();
  }
  /**
   * Return the current absolute pose of this raw human bones as a {@link VRMPose}.
   * Note that the output result will contain initial state of the VRM and not compatible between different models.
   * You might want to use {@link getRawPose} instead.
   */
  getRawAbsolutePose() {
    return this._rawHumanBones.getAbsolutePose();
  }
  /**
   * Return the current absolute pose of this normalized human bones as a {@link VRMPose}.
   * Note that the output result will contain initial state of the VRM and not compatible between different models.
   * You might want to use {@link getNormalizedPose} instead.
   */
  getNormalizedAbsolutePose() {
    return this._normalizedHumanBones.getAbsolutePose();
  }
  /**
   * @deprecated Deprecated. Use either {@link getRawPose} or {@link getNormalizedPose} instead.
   */
  getPose() {
    console.warn("VRMHumanoid: getPose() is deprecated. Use either getRawPose() or getNormalizedPose() instead.");
    return this.getRawPose();
  }
  /**
   * Return the current pose of raw human bones as a {@link VRMPose}.
   *
   * Each transform is a local transform relative from rest pose (T-pose).
   */
  getRawPose() {
    return this._rawHumanBones.getPose();
  }
  /**
   * Return the current pose of normalized human bones as a {@link VRMPose}.
   *
   * Each transform is a local transform relative from rest pose (T-pose).
   */
  getNormalizedPose() {
    return this._normalizedHumanBones.getPose();
  }
  /**
   * @deprecated Deprecated. Use either {@link setRawPose} or {@link setNormalizedPose} instead.
   */
  setPose(poseObject) {
    console.warn("VRMHumanoid: setPose() is deprecated. Use either setRawPose() or setNormalizedPose() instead.");
    return this.setRawPose(poseObject);
  }
  /**
   * Let the raw human bones do a specified pose.
   *
   * Each transform have to be a local transform relative from rest pose (T-pose).
   * You can pass what you got from {@link getRawPose}.
   *
   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link setNormalizedPose} instead.
   *
   * @param poseObject A {@link VRMPose} that represents a single pose
   */
  setRawPose(poseObject) {
    return this._rawHumanBones.setPose(poseObject);
  }
  /**
   * Let the normalized human bones do a specified pose.
   *
   * Each transform have to be a local transform relative from rest pose (T-pose).
   * You can pass what you got from {@link getNormalizedPose}.
   *
   * @param poseObject A {@link VRMPose} that represents a single pose
   */
  setNormalizedPose(poseObject) {
    return this._normalizedHumanBones.setPose(poseObject);
  }
  /**
   * @deprecated Deprecated. Use either {@link resetRawPose} or {@link resetNormalizedPose} instead.
   */
  resetPose() {
    console.warn("VRMHumanoid: resetPose() is deprecated. Use either resetRawPose() or resetNormalizedPose() instead.");
    return this.resetRawPose();
  }
  /**
   * Reset the raw humanoid to its rest pose.
   *
   * If you are using {@link autoUpdateHumanBones}, you might want to use {@link resetNormalizedPose} instead.
   */
  resetRawPose() {
    return this._rawHumanBones.resetPose();
  }
  /**
   * Reset the normalized humanoid to its rest pose.
   */
  resetNormalizedPose() {
    return this._normalizedHumanBones.resetPose();
  }
  /**
   * @deprecated Deprecated. Use either {@link getRawBone} or {@link getNormalizedBone} instead.
   */
  getBone(name) {
    console.warn("VRMHumanoid: getBone() is deprecated. Use either getRawBone() or getNormalizedBone() instead.");
    return this.getRawBone(name);
  }
  /**
   * Return a raw {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.
   *
   * @param name Name of the bone you want
   */
  getRawBone(name) {
    return this._rawHumanBones.getBone(name);
  }
  /**
   * Return a normalized {@link VRMHumanBone} bound to a specified {@link VRMHumanBoneName}.
   *
   * @param name Name of the bone you want
   */
  getNormalizedBone(name) {
    return this._normalizedHumanBones.getBone(name);
  }
  /**
   * @deprecated Deprecated. Use either {@link getRawBoneNode} or {@link getNormalizedBoneNode} instead.
   */
  getBoneNode(name) {
    console.warn(
      "VRMHumanoid: getBoneNode() is deprecated. Use either getRawBoneNode() or getNormalizedBoneNode() instead."
    );
    return this.getRawBoneNode(name);
  }
  /**
   * Return a raw bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.
   *
   * @param name Name of the bone you want
   */
  getRawBoneNode(name) {
    return this._rawHumanBones.getBoneNode(name);
  }
  /**
   * Return a normalized bone as a `THREE.Object3D` bound to a specified {@link VRMHumanBoneName}.
   *
   * @param name Name of the bone you want
   */
  getNormalizedBoneNode(name) {
    return this._normalizedHumanBones.getBoneNode(name);
  }
  /**
   * Update the humanoid component.
   *
   * If {@link autoUpdateHumanBones} is `true`, it transfers the pose of normalized human bones to raw human bones.
   */
  update() {
    if (this.autoUpdateHumanBones) {
      this._normalizedHumanBones.update();
    }
  }
};
var VRMRequiredHumanBoneName = {
  Hips: "hips",
  Spine: "spine",
  Head: "head",
  LeftUpperLeg: "leftUpperLeg",
  LeftLowerLeg: "leftLowerLeg",
  LeftFoot: "leftFoot",
  RightUpperLeg: "rightUpperLeg",
  RightLowerLeg: "rightLowerLeg",
  RightFoot: "rightFoot",
  LeftUpperArm: "leftUpperArm",
  LeftLowerArm: "leftLowerArm",
  LeftHand: "leftHand",
  RightUpperArm: "rightUpperArm",
  RightLowerArm: "rightLowerArm",
  RightHand: "rightHand"
};
var POSSIBLE_SPEC_VERSIONS3 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var thumbBoneNameMap = {
  leftThumbProximal: "leftThumbMetacarpal",
  leftThumbIntermediate: "leftThumbProximal",
  rightThumbProximal: "rightThumbMetacarpal",
  rightThumbIntermediate: "rightThumbProximal"
};
var VRMHumanoidLoaderPlugin = class {
  get name() {
    return "VRMHumanoidLoaderPlugin";
  }
  constructor(parser, options) {
    this.parser = parser;
    this.helperRoot = options == null ? void 0 : options.helperRoot;
    this.autoUpdateHumanBones = options == null ? void 0 : options.autoUpdateHumanBones;
  }
  afterRoot(gltf) {
    return __async2(this, null, function* () {
      gltf.userData.vrmHumanoid = yield this._import(gltf);
    });
  }
  /**
   * Import a {@link VRMHumanoid} from a VRM.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   */
  _import(gltf) {
    return __async2(this, null, function* () {
      const v1Result = yield this._v1Import(gltf);
      if (v1Result) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf);
      if (v0Result) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf) {
    return __async2(this, null, function* () {
      var _a2, _b;
      const json = this.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRMC_vrm")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
      if (!extension) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS3.has(specVersion)) {
        console.warn(`VRMHumanoidLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
        return null;
      }
      const schemaHumanoid = extension.humanoid;
      if (!schemaHumanoid) {
        return null;
      }
      const existsPreviousThumbName = schemaHumanoid.humanBones.leftThumbIntermediate != null || schemaHumanoid.humanBones.rightThumbIntermediate != null;
      const humanBones = {};
      if (schemaHumanoid.humanBones != null) {
        yield Promise.all(
          Object.entries(schemaHumanoid.humanBones).map((_0) => __async2(this, [_0], function* ([boneNameString, schemaHumanBone]) {
            let boneName = boneNameString;
            const index = schemaHumanBone.node;
            if (existsPreviousThumbName) {
              const thumbBoneName = thumbBoneNameMap[boneName];
              if (thumbBoneName != null) {
                boneName = thumbBoneName;
              }
            }
            const node = yield this.parser.getDependency("node", index);
            if (node == null) {
              console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);
              return;
            }
            humanBones[boneName] = { node };
          }))
        );
      }
      const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {
        autoUpdateHumanBones: this.autoUpdateHumanBones
      });
      gltf.scene.add(humanoid.normalizedHumanBonesRoot);
      if (this.helperRoot) {
        const helper = new VRMHumanoidHelper(humanoid);
        this.helperRoot.add(helper);
        helper.renderOrder = this.helperRoot.renderOrder;
      }
      return humanoid;
    });
  }
  _v0Import(gltf) {
    return __async2(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const vrmExt = (_a2 = json.extensions) == null ? void 0 : _a2.VRM;
      if (!vrmExt) {
        return null;
      }
      const schemaHumanoid = vrmExt.humanoid;
      if (!schemaHumanoid) {
        return null;
      }
      const humanBones = {};
      if (schemaHumanoid.humanBones != null) {
        yield Promise.all(
          schemaHumanoid.humanBones.map((bone) => __async2(this, null, function* () {
            const boneName = bone.bone;
            const index = bone.node;
            if (boneName == null || index == null) {
              return;
            }
            const node = yield this.parser.getDependency("node", index);
            if (node == null) {
              console.warn(`A glTF node bound to the humanoid bone ${boneName} (index = ${index}) does not exist`);
              return;
            }
            const thumbBoneName = thumbBoneNameMap[boneName];
            const newBoneName = thumbBoneName != null ? thumbBoneName : boneName;
            if (humanBones[newBoneName] != null) {
              console.warn(
                `Multiple bone entries for ${newBoneName} detected (index = ${index}), ignoring duplicated entries.`
              );
              return;
            }
            humanBones[newBoneName] = { node };
          }))
        );
      }
      const humanoid = new VRMHumanoid(this._ensureRequiredBonesExist(humanBones), {
        autoUpdateHumanBones: this.autoUpdateHumanBones
      });
      gltf.scene.add(humanoid.normalizedHumanBonesRoot);
      if (this.helperRoot) {
        const helper = new VRMHumanoidHelper(humanoid);
        this.helperRoot.add(helper);
        helper.renderOrder = this.helperRoot.renderOrder;
      }
      return humanoid;
    });
  }
  /**
   * Ensure required bones exist in given human bones.
   * @param humanBones Human bones
   * @returns Human bones, no longer partial!
   */
  _ensureRequiredBonesExist(humanBones) {
    const missingRequiredBones = Object.values(VRMRequiredHumanBoneName).filter(
      (requiredBoneName) => humanBones[requiredBoneName] == null
    );
    if (missingRequiredBones.length > 0) {
      throw new Error(
        `VRMHumanoidLoaderPlugin: These humanoid bones are required but not exist: ${missingRequiredBones.join(", ")}`
      );
    }
    return humanBones;
  }
};
var FanBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this._currentTheta = 0;
    this._currentRadius = 0;
    this.theta = 0;
    this.radius = 0;
    this._currentTheta = 0;
    this._currentRadius = 0;
    this._attrPos = new BufferAttribute(new Float32Array(65 * 3), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(3 * 63), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    if (this._currentTheta !== this.theta) {
      this._currentTheta = this.theta;
      shouldUpdateGeometry = true;
    }
    if (this._currentRadius !== this.radius) {
      this._currentRadius = this.radius;
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    this._attrPos.setXYZ(0, 0, 0, 0);
    for (let i2 = 0; i2 < 64; i2++) {
      const t2 = i2 / 63 * this._currentTheta;
      this._attrPos.setXYZ(i2 + 1, this._currentRadius * Math.sin(t2), 0, this._currentRadius * Math.cos(t2));
    }
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    for (let i2 = 0; i2 < 63; i2++) {
      this._attrIndex.setXYZ(i2 * 3, 0, i2 + 1, i2 + 2);
    }
    this._attrIndex.needsUpdate = true;
  }
};
var LineAndSphereBufferGeometry = class extends BufferGeometry {
  constructor() {
    super();
    this.radius = 0;
    this._currentRadius = 0;
    this.tail = new Vector3();
    this._currentTail = new Vector3();
    this._attrPos = new BufferAttribute(new Float32Array(294), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(194), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    if (this._currentRadius !== this.radius) {
      this._currentRadius = this.radius;
      shouldUpdateGeometry = true;
    }
    if (!this._currentTail.equals(this.tail)) {
      this._currentTail.copy(this.tail);
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    for (let i2 = 0; i2 < 32; i2++) {
      const t2 = i2 / 16 * Math.PI;
      this._attrPos.setXYZ(i2, Math.cos(t2), Math.sin(t2), 0);
      this._attrPos.setXYZ(32 + i2, 0, Math.cos(t2), Math.sin(t2));
      this._attrPos.setXYZ(64 + i2, Math.sin(t2), 0, Math.cos(t2));
    }
    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
    this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);
    this._attrPos.setXYZ(96, 0, 0, 0);
    this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    for (let i2 = 0; i2 < 32; i2++) {
      const i1 = (i2 + 1) % 32;
      this._attrIndex.setXY(i2 * 2, i2, i1);
      this._attrIndex.setXY(64 + i2 * 2, 32 + i2, 32 + i1);
      this._attrIndex.setXY(128 + i2 * 2, 64 + i2, 64 + i1);
    }
    this._attrIndex.setXY(192, 96, 97);
    this._attrIndex.needsUpdate = true;
  }
};
var _quatA4 = new Quaternion();
var _quatB = new Quaternion();
var _v3A4 = new Vector3();
var _v3B2 = new Vector3();
var SQRT_2_OVER_2 = Math.sqrt(2) / 2;
var QUAT_XY_CW90 = new Quaternion(0, 0, -SQRT_2_OVER_2, SQRT_2_OVER_2);
var VEC3_POSITIVE_Y = new Vector3(0, 1, 0);
var VRMLookAtHelper = class extends Group {
  constructor(lookAt) {
    super();
    this.matrixAutoUpdate = false;
    this.vrmLookAt = lookAt;
    {
      const geometry = new FanBufferGeometry();
      geometry.radius = 0.5;
      const material = new MeshBasicMaterial({
        color: 65280,
        transparent: true,
        opacity: 0.5,
        side: DoubleSide,
        depthTest: false,
        depthWrite: false
      });
      this._meshPitch = new Mesh(geometry, material);
      this.add(this._meshPitch);
    }
    {
      const geometry = new FanBufferGeometry();
      geometry.radius = 0.5;
      const material = new MeshBasicMaterial({
        color: 16711680,
        transparent: true,
        opacity: 0.5,
        side: DoubleSide,
        depthTest: false,
        depthWrite: false
      });
      this._meshYaw = new Mesh(geometry, material);
      this.add(this._meshYaw);
    }
    {
      const geometry = new LineAndSphereBufferGeometry();
      geometry.radius = 0.1;
      const material = new LineBasicMaterial({
        color: 16777215,
        depthTest: false,
        depthWrite: false
      });
      this._lineTarget = new LineSegments(geometry, material);
      this._lineTarget.frustumCulled = false;
      this.add(this._lineTarget);
    }
  }
  dispose() {
    this._meshYaw.geometry.dispose();
    this._meshYaw.material.dispose();
    this._meshPitch.geometry.dispose();
    this._meshPitch.material.dispose();
    this._lineTarget.geometry.dispose();
    this._lineTarget.material.dispose();
  }
  updateMatrixWorld(force) {
    const yaw = MathUtils.DEG2RAD * this.vrmLookAt.yaw;
    this._meshYaw.geometry.theta = yaw;
    this._meshYaw.geometry.update();
    const pitch = MathUtils.DEG2RAD * this.vrmLookAt.pitch;
    this._meshPitch.geometry.theta = pitch;
    this._meshPitch.geometry.update();
    this.vrmLookAt.getLookAtWorldPosition(_v3A4);
    this.vrmLookAt.getLookAtWorldQuaternion(_quatA4);
    _quatA4.multiply(this.vrmLookAt.getFaceFrontQuaternion(_quatB));
    this._meshYaw.position.copy(_v3A4);
    this._meshYaw.quaternion.copy(_quatA4);
    this._meshPitch.position.copy(_v3A4);
    this._meshPitch.quaternion.copy(_quatA4);
    this._meshPitch.quaternion.multiply(_quatB.setFromAxisAngle(VEC3_POSITIVE_Y, yaw));
    this._meshPitch.quaternion.multiply(QUAT_XY_CW90);
    const { target, autoUpdate } = this.vrmLookAt;
    if (target != null && autoUpdate) {
      target.getWorldPosition(_v3B2).sub(_v3A4);
      this._lineTarget.geometry.tail.copy(_v3B2);
      this._lineTarget.geometry.update();
      this._lineTarget.position.copy(_v3A4);
    }
    super.updateMatrixWorld(force);
  }
};
var _position = new Vector3();
var _scale = new Vector3();
function getWorldQuaternionLite(object, out) {
  object.matrixWorld.decompose(_position, out, _scale);
  return out;
}
function calcAzimuthAltitude(vector) {
  return [Math.atan2(-vector.z, vector.x), Math.atan2(vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z))];
}
function sanitizeAngle(angle) {
  const roundTurn = Math.round(angle / 2 / Math.PI);
  return angle - 2 * Math.PI * roundTurn;
}
var VEC3_POSITIVE_Z = new Vector3(0, 0, 1);
var _v3A5 = new Vector3();
var _v3B3 = new Vector3();
var _v3C = new Vector3();
var _quatA5 = new Quaternion();
var _quatB2 = new Quaternion();
var _quatC = new Quaternion();
var _quatD = new Quaternion();
var _eulerA = new Euler();
var _VRMLookAt = class _VRMLookAt2 {
  /**
   * Create a new {@link VRMLookAt}.
   *
   * @param humanoid A {@link VRMHumanoid}
   * @param applier A {@link VRMLookAtApplier}
   */
  constructor(humanoid, applier) {
    this.offsetFromHeadBone = new Vector3();
    this.autoUpdate = true;
    this.faceFront = new Vector3(0, 0, 1);
    this.humanoid = humanoid;
    this.applier = applier;
    this._yaw = 0;
    this._pitch = 0;
    this._needsUpdate = true;
    this._restHeadWorldQuaternion = this.getLookAtWorldQuaternion(new Quaternion());
  }
  /**
   * Its current angle around Y axis, in degree.
   */
  get yaw() {
    return this._yaw;
  }
  /**
   * Its current angle around Y axis, in degree.
   */
  set yaw(value) {
    this._yaw = value;
    this._needsUpdate = true;
  }
  /**
   * Its current angle around X axis, in degree.
   */
  get pitch() {
    return this._pitch;
  }
  /**
   * Its current angle around X axis, in degree.
   */
  set pitch(value) {
    this._pitch = value;
    this._needsUpdate = true;
  }
  /**
   * @deprecated Use {@link getEuler} instead.
   */
  get euler() {
    console.warn("VRMLookAt: euler is deprecated. use getEuler() instead.");
    return this.getEuler(new Euler());
  }
  /**
   * Get its yaw-pitch angles as an `Euler`.
   * Does NOT consider {@link faceFront}; it returns `Euler(0, 0, 0; "YXZ")` by default regardless of the faceFront value.
   *
   * @param target The target euler
   */
  getEuler(target) {
    return target.set(MathUtils.DEG2RAD * this._pitch, MathUtils.DEG2RAD * this._yaw, 0, "YXZ");
  }
  /**
   * Copy the given {@link VRMLookAt} into this one.
   * {@link humanoid} must be same as the source one.
   * {@link applier} will reference the same instance as the source one.
   * @param source The {@link VRMLookAt} you want to copy
   * @returns this
   */
  copy(source) {
    if (this.humanoid !== source.humanoid) {
      throw new Error("VRMLookAt: humanoid must be same in order to copy");
    }
    this.offsetFromHeadBone.copy(source.offsetFromHeadBone);
    this.applier = source.applier;
    this.autoUpdate = source.autoUpdate;
    this.target = source.target;
    this.faceFront.copy(source.faceFront);
    return this;
  }
  /**
   * Returns a clone of this {@link VRMLookAt}.
   * Note that {@link humanoid} and {@link applier} will reference the same instance as this one.
   * @returns Copied {@link VRMLookAt}
   */
  clone() {
    return new _VRMLookAt2(this.humanoid, this.applier).copy(this);
  }
  /**
   * Reset the lookAt direction (yaw and pitch) to the initial direction.
   */
  reset() {
    this._yaw = 0;
    this._pitch = 0;
    this._needsUpdate = true;
  }
  /**
   * Get its lookAt position in world coordinate.
   *
   * @param target A target `THREE.Vector3`
   */
  getLookAtWorldPosition(target) {
    const head = this.humanoid.getRawBoneNode("head");
    return target.copy(this.offsetFromHeadBone).applyMatrix4(head.matrixWorld);
  }
  /**
   * Get its lookAt rotation in world coordinate.
   * Does NOT consider {@link faceFront}.
   *
   * @param target A target `THREE.Quaternion`
   */
  getLookAtWorldQuaternion(target) {
    const head = this.humanoid.getRawBoneNode("head");
    return getWorldQuaternionLite(head, target);
  }
  /**
   * Get a quaternion that rotates the +Z unit vector of the humanoid Head to the {@link faceFront} direction.
   *
   * @param target A target `THREE.Quaternion`
   */
  getFaceFrontQuaternion(target) {
    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z) < 0.01) {
      return target.copy(this._restHeadWorldQuaternion).invert();
    }
    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);
    _eulerA.set(0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, "YZX");
    return target.setFromEuler(_eulerA).premultiply(_quatD.copy(this._restHeadWorldQuaternion).invert());
  }
  /**
   * Get its LookAt direction in world coordinate.
   *
   * @param target A target `THREE.Vector3`
   */
  getLookAtWorldDirection(target) {
    this.getLookAtWorldQuaternion(_quatB2);
    this.getFaceFrontQuaternion(_quatC);
    return target.copy(VEC3_POSITIVE_Z).applyQuaternion(_quatB2).applyQuaternion(_quatC).applyEuler(this.getEuler(_eulerA));
  }
  /**
   * Set its lookAt target position.
   *
   * Note that its result will be instantly overwritten if {@link VRMLookAtHead.autoUpdate} is enabled.
   *
   * If you want to track an object continuously, you might want to use {@link target} instead.
   *
   * @param position A target position, in world space
   */
  lookAt(position) {
    const headRotDiffInv = _quatA5.copy(this._restHeadWorldQuaternion).multiply(quatInvertCompat(this.getLookAtWorldQuaternion(_quatB2)));
    const headPos = this.getLookAtWorldPosition(_v3B3);
    const lookAtDir = _v3C.copy(position).sub(headPos).applyQuaternion(headRotDiffInv).normalize();
    const [azimuthFrom, altitudeFrom] = calcAzimuthAltitude(this.faceFront);
    const [azimuthTo, altitudeTo] = calcAzimuthAltitude(lookAtDir);
    const yaw = sanitizeAngle(azimuthTo - azimuthFrom);
    const pitch = sanitizeAngle(altitudeFrom - altitudeTo);
    this._yaw = MathUtils.RAD2DEG * yaw;
    this._pitch = MathUtils.RAD2DEG * pitch;
    this._needsUpdate = true;
  }
  /**
   * Update the VRMLookAtHead.
   * If {@link autoUpdate} is enabled, this will make it look at the {@link target}.
   *
   * @param delta deltaTime, it isn't used though. You can use the parameter if you want to use this in your own extended {@link VRMLookAt}.
   */
  update(delta) {
    if (this.target != null && this.autoUpdate) {
      this.lookAt(this.target.getWorldPosition(_v3A5));
    }
    if (this._needsUpdate) {
      this._needsUpdate = false;
      this.applier.applyYawPitch(this._yaw, this._pitch);
    }
  }
};
_VRMLookAt.EULER_ORDER = "YXZ";
var VRMLookAt = _VRMLookAt;
var VEC3_POSITIVE_Z2 = new Vector3(0, 0, 1);
var _quatA6 = new Quaternion();
var _quatB3 = new Quaternion();
var _eulerA2 = new Euler(0, 0, 0, "YXZ");
var VRMLookAtBoneApplier = class {
  /**
   * Create a new {@link VRMLookAtBoneApplier}.
   *
   * @param humanoid A {@link VRMHumanoid}
   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction
   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction
   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction
   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction
   */
  constructor(humanoid, rangeMapHorizontalInner, rangeMapHorizontalOuter, rangeMapVerticalDown, rangeMapVerticalUp) {
    this.humanoid = humanoid;
    this.rangeMapHorizontalInner = rangeMapHorizontalInner;
    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;
    this.rangeMapVerticalDown = rangeMapVerticalDown;
    this.rangeMapVerticalUp = rangeMapVerticalUp;
    this.faceFront = new Vector3(0, 0, 1);
    this._restQuatLeftEye = new Quaternion();
    this._restQuatRightEye = new Quaternion();
    this._restLeftEyeParentWorldQuat = new Quaternion();
    this._restRightEyeParentWorldQuat = new Quaternion();
    const leftEye = this.humanoid.getRawBoneNode("leftEye");
    const rightEye = this.humanoid.getRawBoneNode("rightEye");
    if (leftEye) {
      this._restQuatLeftEye.copy(leftEye.quaternion);
      getWorldQuaternionLite(leftEye.parent, this._restLeftEyeParentWorldQuat);
    }
    if (rightEye) {
      this._restQuatRightEye.copy(rightEye.quaternion);
      getWorldQuaternionLite(rightEye.parent, this._restRightEyeParentWorldQuat);
    }
  }
  /**
   * Apply the input angle to its associated VRM model.
   *
   * @param yaw Rotation around Y axis, in degree
   * @param pitch Rotation around X axis, in degree
   */
  applyYawPitch(yaw, pitch) {
    const leftEye = this.humanoid.getRawBoneNode("leftEye");
    const rightEye = this.humanoid.getRawBoneNode("rightEye");
    const leftEyeNormalized = this.humanoid.getNormalizedBoneNode("leftEye");
    const rightEyeNormalized = this.humanoid.getNormalizedBoneNode("rightEye");
    if (leftEye) {
      if (pitch < 0) {
        _eulerA2.x = -MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);
      } else {
        _eulerA2.x = MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);
      }
      if (yaw < 0) {
        _eulerA2.y = -MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(-yaw);
      } else {
        _eulerA2.y = MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(yaw);
      }
      _quatA6.setFromEuler(_eulerA2);
      this._getWorldFaceFrontQuat(_quatB3);
      leftEyeNormalized.quaternion.copy(_quatB3).multiply(_quatA6).multiply(_quatB3.invert());
      _quatA6.copy(this._restLeftEyeParentWorldQuat);
      leftEye.quaternion.copy(leftEyeNormalized.quaternion).multiply(_quatA6).premultiply(_quatA6.invert()).multiply(this._restQuatLeftEye);
    }
    if (rightEye) {
      if (pitch < 0) {
        _eulerA2.x = -MathUtils.DEG2RAD * this.rangeMapVerticalDown.map(-pitch);
      } else {
        _eulerA2.x = MathUtils.DEG2RAD * this.rangeMapVerticalUp.map(pitch);
      }
      if (yaw < 0) {
        _eulerA2.y = -MathUtils.DEG2RAD * this.rangeMapHorizontalOuter.map(-yaw);
      } else {
        _eulerA2.y = MathUtils.DEG2RAD * this.rangeMapHorizontalInner.map(yaw);
      }
      _quatA6.setFromEuler(_eulerA2);
      this._getWorldFaceFrontQuat(_quatB3);
      rightEyeNormalized.quaternion.copy(_quatB3).multiply(_quatA6).multiply(_quatB3.invert());
      _quatA6.copy(this._restRightEyeParentWorldQuat);
      rightEye.quaternion.copy(rightEyeNormalized.quaternion).multiply(_quatA6).premultiply(_quatA6.invert()).multiply(this._restQuatRightEye);
    }
  }
  /**
   * @deprecated Use {@link applyYawPitch} instead.
   */
  lookAt(euler) {
    console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
    const yaw = MathUtils.RAD2DEG * euler.y;
    const pitch = MathUtils.RAD2DEG * euler.x;
    this.applyYawPitch(yaw, pitch);
  }
  /**
   * Get a quaternion that rotates the world-space +Z unit vector to the {@link faceFront} direction.
   *
   * @param target A target `THREE.Quaternion`
   */
  _getWorldFaceFrontQuat(target) {
    if (this.faceFront.distanceToSquared(VEC3_POSITIVE_Z2) < 0.01) {
      return target.identity();
    }
    const [faceFrontAzimuth, faceFrontAltitude] = calcAzimuthAltitude(this.faceFront);
    _eulerA2.set(0, 0.5 * Math.PI + faceFrontAzimuth, faceFrontAltitude, "YZX");
    return target.setFromEuler(_eulerA2);
  }
};
VRMLookAtBoneApplier.type = "bone";
var VRMLookAtExpressionApplier = class {
  /**
   * Create a new {@link VRMLookAtExpressionApplier}.
   *
   * @param expressions A {@link VRMExpressionManager}
   * @param rangeMapHorizontalInner A {@link VRMLookAtRangeMap} used for inner transverse direction
   * @param rangeMapHorizontalOuter A {@link VRMLookAtRangeMap} used for outer transverse direction
   * @param rangeMapVerticalDown A {@link VRMLookAtRangeMap} used for down direction
   * @param rangeMapVerticalUp A {@link VRMLookAtRangeMap} used for up direction
   */
  constructor(expressions, rangeMapHorizontalInner, rangeMapHorizontalOuter, rangeMapVerticalDown, rangeMapVerticalUp) {
    this.expressions = expressions;
    this.rangeMapHorizontalInner = rangeMapHorizontalInner;
    this.rangeMapHorizontalOuter = rangeMapHorizontalOuter;
    this.rangeMapVerticalDown = rangeMapVerticalDown;
    this.rangeMapVerticalUp = rangeMapVerticalUp;
  }
  /**
   * Apply the input angle to its associated VRM model.
   *
   * @param yaw Rotation around Y axis, in degree
   * @param pitch Rotation around X axis, in degree
   */
  applyYawPitch(yaw, pitch) {
    if (pitch < 0) {
      this.expressions.setValue("lookDown", 0);
      this.expressions.setValue("lookUp", this.rangeMapVerticalUp.map(-pitch));
    } else {
      this.expressions.setValue("lookUp", 0);
      this.expressions.setValue("lookDown", this.rangeMapVerticalDown.map(pitch));
    }
    if (yaw < 0) {
      this.expressions.setValue("lookLeft", 0);
      this.expressions.setValue("lookRight", this.rangeMapHorizontalOuter.map(-yaw));
    } else {
      this.expressions.setValue("lookRight", 0);
      this.expressions.setValue("lookLeft", this.rangeMapHorizontalOuter.map(yaw));
    }
  }
  /**
   * @deprecated Use {@link applyYawPitch} instead.
   */
  lookAt(euler) {
    console.warn("VRMLookAtBoneApplier: lookAt() is deprecated. use apply() instead.");
    const yaw = MathUtils.RAD2DEG * euler.y;
    const pitch = MathUtils.RAD2DEG * euler.x;
    this.applyYawPitch(yaw, pitch);
  }
};
VRMLookAtExpressionApplier.type = "expression";
var VRMLookAtRangeMap = class {
  /**
   * Create a new {@link VRMLookAtRangeMap}.
   *
   * @param inputMaxValue The {@link inputMaxValue} of the map
   * @param outputScale The {@link outputScale} of the map
   */
  constructor(inputMaxValue, outputScale) {
    this.inputMaxValue = inputMaxValue;
    this.outputScale = outputScale;
  }
  /**
   * Evaluate an input value and output a mapped value.
   * @param src The input value
   */
  map(src) {
    return this.outputScale * saturate(src / this.inputMaxValue);
  }
};
var POSSIBLE_SPEC_VERSIONS4 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var INPUT_MAX_VALUE_MINIMUM = 0.01;
var VRMLookAtLoaderPlugin = class {
  get name() {
    return "VRMLookAtLoaderPlugin";
  }
  constructor(parser, options) {
    this.parser = parser;
    this.helperRoot = options == null ? void 0 : options.helperRoot;
  }
  afterRoot(gltf) {
    return __async2(this, null, function* () {
      const vrmHumanoid = gltf.userData.vrmHumanoid;
      if (vrmHumanoid === null) {
        return;
      } else if (vrmHumanoid === void 0) {
        throw new Error("VRMLookAtLoaderPlugin: vrmHumanoid is undefined. VRMHumanoidLoaderPlugin have to be used first");
      }
      const vrmExpressionManager = gltf.userData.vrmExpressionManager;
      if (vrmExpressionManager === null) {
        return;
      } else if (vrmExpressionManager === void 0) {
        throw new Error(
          "VRMLookAtLoaderPlugin: vrmExpressionManager is undefined. VRMExpressionLoaderPlugin have to be used first"
        );
      }
      gltf.userData.vrmLookAt = yield this._import(gltf, vrmHumanoid, vrmExpressionManager);
    });
  }
  /**
   * Import a {@link VRMLookAt} from a VRM.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   * @param humanoid A {@link VRMHumanoid} instance that represents the VRM
   * @param expressions A {@link VRMExpressionManager} instance that represents the VRM
   */
  _import(gltf, humanoid, expressions) {
    return __async2(this, null, function* () {
      if (humanoid == null || expressions == null) {
        return null;
      }
      const v1Result = yield this._v1Import(gltf, humanoid, expressions);
      if (v1Result) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf, humanoid, expressions);
      if (v0Result) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf, humanoid, expressions) {
    return __async2(this, null, function* () {
      var _a2, _b, _c2;
      const json = this.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRMC_vrm")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
      if (!extension) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS4.has(specVersion)) {
        console.warn(`VRMLookAtLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
        return null;
      }
      const schemaLookAt = extension.lookAt;
      if (!schemaLookAt) {
        return null;
      }
      const defaultOutputScale = schemaLookAt.type === "expression" ? 1 : 10;
      const mapHI = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalInner, defaultOutputScale);
      const mapHO = this._v1ImportRangeMap(schemaLookAt.rangeMapHorizontalOuter, defaultOutputScale);
      const mapVD = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalDown, defaultOutputScale);
      const mapVU = this._v1ImportRangeMap(schemaLookAt.rangeMapVerticalUp, defaultOutputScale);
      let applier;
      if (schemaLookAt.type === "expression") {
        applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);
      } else {
        applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);
      }
      const lookAt = this._importLookAt(humanoid, applier);
      lookAt.offsetFromHeadBone.fromArray((_c2 = schemaLookAt.offsetFromHeadBone) != null ? _c2 : [0, 0.06, 0]);
      return lookAt;
    });
  }
  _v1ImportRangeMap(schemaRangeMap, defaultOutputScale) {
    var _a2, _b;
    let inputMaxValue = (_a2 = schemaRangeMap == null ? void 0 : schemaRangeMap.inputMaxValue) != null ? _a2 : 90;
    const outputScale = (_b = schemaRangeMap == null ? void 0 : schemaRangeMap.outputScale) != null ? _b : defaultOutputScale;
    if (inputMaxValue < INPUT_MAX_VALUE_MINIMUM) {
      console.warn(
        "VRMLookAtLoaderPlugin: inputMaxValue of a range map is too small. Consider reviewing the range map!"
      );
      inputMaxValue = INPUT_MAX_VALUE_MINIMUM;
    }
    return new VRMLookAtRangeMap(inputMaxValue, outputScale);
  }
  _v0Import(gltf, humanoid, expressions) {
    return __async2(this, null, function* () {
      var _a2, _b, _c2, _d;
      const json = this.parser.json;
      const vrmExt = (_a2 = json.extensions) == null ? void 0 : _a2.VRM;
      if (!vrmExt) {
        return null;
      }
      const schemaFirstPerson = vrmExt.firstPerson;
      if (!schemaFirstPerson) {
        return null;
      }
      const defaultOutputScale = schemaFirstPerson.lookAtTypeName === "BlendShape" ? 1 : 10;
      const mapHI = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalInner, defaultOutputScale);
      const mapHO = this._v0ImportDegreeMap(schemaFirstPerson.lookAtHorizontalOuter, defaultOutputScale);
      const mapVD = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalDown, defaultOutputScale);
      const mapVU = this._v0ImportDegreeMap(schemaFirstPerson.lookAtVerticalUp, defaultOutputScale);
      let applier;
      if (schemaFirstPerson.lookAtTypeName === "BlendShape") {
        applier = new VRMLookAtExpressionApplier(expressions, mapHI, mapHO, mapVD, mapVU);
      } else {
        applier = new VRMLookAtBoneApplier(humanoid, mapHI, mapHO, mapVD, mapVU);
      }
      const lookAt = this._importLookAt(humanoid, applier);
      if (schemaFirstPerson.firstPersonBoneOffset) {
        lookAt.offsetFromHeadBone.set(
          (_b = schemaFirstPerson.firstPersonBoneOffset.x) != null ? _b : 0,
          (_c2 = schemaFirstPerson.firstPersonBoneOffset.y) != null ? _c2 : 0.06,
          -((_d = schemaFirstPerson.firstPersonBoneOffset.z) != null ? _d : 0)
        );
      } else {
        lookAt.offsetFromHeadBone.set(0, 0.06, 0);
      }
      lookAt.faceFront.set(0, 0, -1);
      if (applier instanceof VRMLookAtBoneApplier) {
        applier.faceFront.set(0, 0, -1);
      }
      return lookAt;
    });
  }
  _v0ImportDegreeMap(schemaDegreeMap, defaultOutputScale) {
    var _a2, _b;
    const curve = schemaDegreeMap == null ? void 0 : schemaDegreeMap.curve;
    if (JSON.stringify(curve) !== "[0,0,0,1,1,1,1,0]") {
      console.warn("Curves of LookAtDegreeMap defined in VRM 0.0 are not supported");
    }
    let xRange = (_a2 = schemaDegreeMap == null ? void 0 : schemaDegreeMap.xRange) != null ? _a2 : 90;
    const yRange = (_b = schemaDegreeMap == null ? void 0 : schemaDegreeMap.yRange) != null ? _b : defaultOutputScale;
    if (xRange < INPUT_MAX_VALUE_MINIMUM) {
      console.warn("VRMLookAtLoaderPlugin: xRange of a degree map is too small. Consider reviewing the degree map!");
      xRange = INPUT_MAX_VALUE_MINIMUM;
    }
    return new VRMLookAtRangeMap(xRange, yRange);
  }
  _importLookAt(humanoid, applier) {
    const lookAt = new VRMLookAt(humanoid, applier);
    if (this.helperRoot) {
      const helper = new VRMLookAtHelper(lookAt);
      this.helperRoot.add(helper);
      helper.renderOrder = this.helperRoot.renderOrder;
    }
    return lookAt;
  }
};
function resolveURL(url, path) {
  if (typeof url !== "string" || url === "") return "";
  if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
    path = path.replace(/(^https?:\/\/[^/]+).*/i, "$1");
  }
  if (/^(https?:)?\/\//i.test(url)) return url;
  if (/^data:.*,.*$/i.test(url)) return url;
  if (/^blob:.*$/i.test(url)) return url;
  return path + url;
}
var POSSIBLE_SPEC_VERSIONS5 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var VRMMetaLoaderPlugin = class {
  get name() {
    return "VRMMetaLoaderPlugin";
  }
  constructor(parser, options) {
    var _a2, _b, _c2;
    this.parser = parser;
    this.needThumbnailImage = (_a2 = options == null ? void 0 : options.needThumbnailImage) != null ? _a2 : false;
    this.acceptLicenseUrls = (_b = options == null ? void 0 : options.acceptLicenseUrls) != null ? _b : ["https://vrm.dev/licenses/1.0/"];
    this.acceptV0Meta = (_c2 = options == null ? void 0 : options.acceptV0Meta) != null ? _c2 : true;
  }
  afterRoot(gltf) {
    return __async2(this, null, function* () {
      gltf.userData.vrmMeta = yield this._import(gltf);
    });
  }
  _import(gltf) {
    return __async2(this, null, function* () {
      const v1Result = yield this._v1Import(gltf);
      if (v1Result != null) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf);
      if (v0Result != null) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf) {
    return __async2(this, null, function* () {
      var _a2, _b, _c2;
      const json = this.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRMC_vrm")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRMC_vrm"];
      if (extension == null) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS5.has(specVersion)) {
        console.warn(`VRMMetaLoaderPlugin: Unknown VRMC_vrm specVersion "${specVersion}"`);
        return null;
      }
      const schemaMeta = extension.meta;
      if (!schemaMeta) {
        return null;
      }
      const licenseUrl = schemaMeta.licenseUrl;
      const acceptLicenseUrlsSet = new Set(this.acceptLicenseUrls);
      if (!acceptLicenseUrlsSet.has(licenseUrl)) {
        throw new Error(`VRMMetaLoaderPlugin: The license url "${licenseUrl}" is not accepted`);
      }
      let thumbnailImage = void 0;
      if (this.needThumbnailImage && schemaMeta.thumbnailImage != null) {
        thumbnailImage = (_c2 = yield this._extractGLTFImage(schemaMeta.thumbnailImage)) != null ? _c2 : void 0;
      }
      return {
        metaVersion: "1",
        name: schemaMeta.name,
        version: schemaMeta.version,
        authors: schemaMeta.authors,
        copyrightInformation: schemaMeta.copyrightInformation,
        contactInformation: schemaMeta.contactInformation,
        references: schemaMeta.references,
        thirdPartyLicenses: schemaMeta.thirdPartyLicenses,
        thumbnailImage,
        licenseUrl: schemaMeta.licenseUrl,
        avatarPermission: schemaMeta.avatarPermission,
        allowExcessivelyViolentUsage: schemaMeta.allowExcessivelyViolentUsage,
        allowExcessivelySexualUsage: schemaMeta.allowExcessivelySexualUsage,
        commercialUsage: schemaMeta.commercialUsage,
        allowPoliticalOrReligiousUsage: schemaMeta.allowPoliticalOrReligiousUsage,
        allowAntisocialOrHateUsage: schemaMeta.allowAntisocialOrHateUsage,
        creditNotation: schemaMeta.creditNotation,
        allowRedistribution: schemaMeta.allowRedistribution,
        modification: schemaMeta.modification,
        otherLicenseUrl: schemaMeta.otherLicenseUrl
      };
    });
  }
  _v0Import(gltf) {
    return __async2(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const vrmExt = (_a2 = json.extensions) == null ? void 0 : _a2.VRM;
      if (!vrmExt) {
        return null;
      }
      const schemaMeta = vrmExt.meta;
      if (!schemaMeta) {
        return null;
      }
      if (!this.acceptV0Meta) {
        throw new Error("VRMMetaLoaderPlugin: Attempted to load VRM0.0 meta but acceptV0Meta is false");
      }
      let texture;
      if (this.needThumbnailImage && schemaMeta.texture != null && schemaMeta.texture !== -1) {
        texture = yield this.parser.getDependency("texture", schemaMeta.texture);
      }
      return {
        metaVersion: "0",
        allowedUserName: schemaMeta.allowedUserName,
        author: schemaMeta.author,
        commercialUssageName: schemaMeta.commercialUssageName,
        contactInformation: schemaMeta.contactInformation,
        licenseName: schemaMeta.licenseName,
        otherLicenseUrl: schemaMeta.otherLicenseUrl,
        otherPermissionUrl: schemaMeta.otherPermissionUrl,
        reference: schemaMeta.reference,
        sexualUssageName: schemaMeta.sexualUssageName,
        texture: texture != null ? texture : void 0,
        title: schemaMeta.title,
        version: schemaMeta.version,
        violentUssageName: schemaMeta.violentUssageName
      };
    });
  }
  _extractGLTFImage(index) {
    return __async2(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const source = (_a2 = json.images) == null ? void 0 : _a2[index];
      if (source == null) {
        console.warn(
          `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image doesn't exist`
        );
        return null;
      }
      let sourceURI = source.uri;
      if (source.bufferView != null) {
        const bufferView = yield this.parser.getDependency("bufferView", source.bufferView);
        const blob = new Blob([bufferView], { type: source.mimeType });
        sourceURI = URL.createObjectURL(blob);
      }
      if (sourceURI == null) {
        console.warn(
          `VRMMetaLoaderPlugin: Attempt to use images[${index}] of glTF as a thumbnail but the image couldn't load properly`
        );
        return null;
      }
      const loader = new ImageLoader();
      return yield loader.loadAsync(resolveURL(sourceURI, this.parser.options.path)).catch((error2) => {
        console.error(error2);
        console.warn("VRMMetaLoaderPlugin: Failed to load a thumbnail image");
        return null;
      });
    });
  }
};
var VRMCore = class {
  /**
   * Create a new VRM instance.
   *
   * @param params {@link VRMParameters} that represents components of the VRM
   */
  constructor(params) {
    this.scene = params.scene;
    this.meta = params.meta;
    this.humanoid = params.humanoid;
    this.expressionManager = params.expressionManager;
    this.firstPerson = params.firstPerson;
    this.lookAt = params.lookAt;
  }
  /**
   * **You need to call this on your update loop.**
   *
   * This function updates every VRM components.
   *
   * @param delta deltaTime
   */
  update(delta) {
    this.humanoid.update();
    if (this.lookAt) {
      this.lookAt.update(delta);
    }
    if (this.expressionManager) {
      this.expressionManager.update();
    }
  }
};
var VRM = class extends VRMCore {
  /**
   * Create a new VRM instance.
   *
   * @param params {@link VRMParameters} that represents components of the VRM
   */
  constructor(params) {
    super(params);
    this.materials = params.materials;
    this.springBoneManager = params.springBoneManager;
    this.nodeConstraintManager = params.nodeConstraintManager;
  }
  /**
   * **You need to call this on your update loop.**
   *
   * This function updates every VRM components.
   *
   * @param delta deltaTime
   */
  update(delta) {
    super.update(delta);
    if (this.nodeConstraintManager) {
      this.nodeConstraintManager.update();
    }
    if (this.springBoneManager) {
      this.springBoneManager.update(delta);
    }
    if (this.materials) {
      this.materials.forEach((material) => {
        if (material.update) {
          material.update(delta);
        }
      });
    }
  }
};
var __defProp2 = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp2 = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp2.call(b2, prop))
      __defNormalProp(a2, prop, b2[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop))
        __defNormalProp(a2, prop, b2[prop]);
    }
  return a2;
};
var __async3 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var colorSpaceEncodingMap = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  "": 3e3,
  srgb: 3001
};
function setTextureColorSpace(texture, colorSpace) {
  if (parseInt(REVISION, 10) >= 152) {
    texture.colorSpace = colorSpace;
  } else {
    texture.encoding = colorSpaceEncodingMap[colorSpace];
  }
}
var GLTFMToonMaterialParamsAssignHelper = class {
  get pending() {
    return Promise.all(this._pendings);
  }
  constructor(parser, materialParams) {
    this._parser = parser;
    this._materialParams = materialParams;
    this._pendings = [];
  }
  assignPrimitive(key, value) {
    if (value != null) {
      this._materialParams[key] = value;
    }
  }
  assignColor(key, value, convertSRGBToLinear) {
    if (value != null) {
      const color = new Color().fromArray(value);
      if (convertSRGBToLinear) {
        color.convertSRGBToLinear();
      }
      this._materialParams[key] = color;
    }
  }
  assignTexture(key, texture, isColorTexture) {
    return __async3(this, null, function* () {
      const promise = (() => __async3(this, null, function* () {
        if (texture != null) {
          yield this._parser.assignTexture(this._materialParams, key, texture);
          if (isColorTexture) {
            setTextureColorSpace(this._materialParams[key], "srgb");
          }
        }
      }))();
      this._pendings.push(promise);
      return promise;
    });
  }
  assignTextureByIndex(key, textureIndex, isColorTexture) {
    return __async3(this, null, function* () {
      return this.assignTexture(key, textureIndex != null ? { index: textureIndex } : void 0, isColorTexture);
    });
  }
};
var mtoon_default = "// #define PHONG\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n  varying vec3 vNormal;\n#endif\n\n#include <common>\n\n// #include <uv_pars_vertex>\n#ifdef MTOON_USE_UV\n  varying vec2 vUv;\n\n  // COMPAT: pre-r151 uses a common uvTransform\n  #if THREE_VRM_THREE_REVISION < 151\n    uniform mat3 uvTransform;\n  #endif\n#endif\n\n// #include <uv2_pars_vertex>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    attribute vec2 uv2;\n    varying vec2 vUv2;\n    uniform mat3 uv2Transform;\n  #endif\n#endif\n\n// #include <displacementmap_pars_vertex>\n// #include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n  uniform sampler2D outlineWidthMultiplyTexture;\n  uniform mat3 outlineWidthMultiplyTextureUvTransform;\n#endif\n\nuniform float outlineWidthFactor;\n\nvoid main() {\n\n  // #include <uv_vertex>\n  #ifdef MTOON_USE_UV\n    // COMPAT: pre-r151 uses a common uvTransform\n    #if THREE_VRM_THREE_REVISION >= 151\n      vUv = uv;\n    #else\n      vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n    #endif\n  #endif\n\n  // #include <uv2_vertex>\n  // COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n  #if THREE_VRM_THREE_REVISION < 151\n    #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n      vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n    #endif\n  #endif\n\n  #include <color_vertex>\n\n  #include <beginnormal_vertex>\n  #include <morphnormal_vertex>\n  #include <skinbase_vertex>\n  #include <skinnormal_vertex>\n\n  // we need this to compute the outline properly\n  objectNormal = normalize( objectNormal );\n\n  #include <defaultnormal_vertex>\n\n  #ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n    vNormal = normalize( transformedNormal );\n  #endif\n\n  #include <begin_vertex>\n\n  #include <morphtarget_vertex>\n  #include <skinning_vertex>\n  // #include <displacementmap_vertex>\n  #include <project_vertex>\n  #include <logdepthbuf_vertex>\n  #include <clipping_planes_vertex>\n\n  vViewPosition = - mvPosition.xyz;\n\n  #ifdef OUTLINE\n    float worldNormalLength = length( transformedNormal );\n    vec3 outlineOffset = outlineWidthFactor * worldNormalLength * objectNormal;\n\n    #ifdef USE_OUTLINEWIDTHMULTIPLYTEXTURE\n      vec2 outlineWidthMultiplyTextureUv = ( outlineWidthMultiplyTextureUvTransform * vec3( vUv, 1 ) ).xy;\n      float outlineTex = texture2D( outlineWidthMultiplyTexture, outlineWidthMultiplyTextureUv ).g;\n      outlineOffset *= outlineTex;\n    #endif\n\n    #ifdef OUTLINE_WIDTH_SCREEN\n      outlineOffset *= vViewPosition.z / projectionMatrix[ 1 ].y;\n    #endif\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( outlineOffset + transformed, 1.0 );\n\n    gl_Position.z += 1E-6 * gl_Position.w; // anti-artifact magic\n  #endif\n\n  #include <worldpos_vertex>\n  // #include <envmap_vertex>\n  #include <shadowmap_vertex>\n  #include <fog_vertex>\n\n}";
var mtoon_default2 = "// #define PHONG\n\nuniform vec3 litFactor;\n\nuniform float opacity;\n\nuniform vec3 shadeColorFactor;\n#ifdef USE_SHADEMULTIPLYTEXTURE\n  uniform sampler2D shadeMultiplyTexture;\n  uniform mat3 shadeMultiplyTextureUvTransform;\n#endif\n\nuniform float shadingShiftFactor;\nuniform float shadingToonyFactor;\n\n#ifdef USE_SHADINGSHIFTTEXTURE\n  uniform sampler2D shadingShiftTexture;\n  uniform mat3 shadingShiftTextureUvTransform;\n  uniform float shadingShiftTextureScale;\n#endif\n\nuniform float giEqualizationFactor;\n\nuniform vec3 parametricRimColorFactor;\n#ifdef USE_RIMMULTIPLYTEXTURE\n  uniform sampler2D rimMultiplyTexture;\n  uniform mat3 rimMultiplyTextureUvTransform;\n#endif\nuniform float rimLightingMixFactor;\nuniform float parametricRimFresnelPowerFactor;\nuniform float parametricRimLiftFactor;\n\n#ifdef USE_MATCAPTEXTURE\n  uniform vec3 matcapFactor;\n  uniform sampler2D matcapTexture;\n  uniform mat3 matcapTextureUvTransform;\n#endif\n\nuniform vec3 emissive;\nuniform float emissiveIntensity;\n\nuniform vec3 outlineColorFactor;\nuniform float outlineLightingMixFactor;\n\n#ifdef USE_UVANIMATIONMASKTEXTURE\n  uniform sampler2D uvAnimationMaskTexture;\n  uniform mat3 uvAnimationMaskTextureUvTransform;\n#endif\n\nuniform float uvAnimationScrollXOffset;\nuniform float uvAnimationScrollYOffset;\nuniform float uvAnimationRotationPhase;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n\n// #include <uv_pars_fragment>\n#if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n  varying vec2 vUv;\n#endif\n\n// #include <uv2_pars_fragment>\n// COMAPT: pre-r151 uses uv2 for lightMap and aoMap\n#if THREE_VRM_THREE_REVISION < 151\n  #if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n    varying vec2 vUv2;\n  #endif\n#endif\n\n#include <map_pars_fragment>\n\n#ifdef USE_MAP\n  uniform mat3 mapUvTransform;\n#endif\n\n// #include <alphamap_pars_fragment>\n\n#include <alphatest_pars_fragment>\n\n#include <aomap_pars_fragment>\n// #include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n\n#ifdef USE_EMISSIVEMAP\n  uniform mat3 emissiveMapUvTransform;\n#endif\n\n// #include <envmap_common_pars_fragment>\n// #include <envmap_pars_fragment>\n// #include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n\n// #include <bsdfs>\n// COMPAT: pre-r151 doesn't have BRDF_Lambert in <common>\n#if THREE_VRM_THREE_REVISION < 151\n  vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n    return RECIPROCAL_PI * diffuseColor;\n  }\n#endif\n\n#include <lights_pars_begin>\n\n#include <normal_pars_fragment>\n\n// #include <lights_phong_pars_fragment>\nvarying vec3 vViewPosition;\n\nstruct MToonMaterial {\n  vec3 diffuseColor;\n  vec3 shadeColor;\n  float shadingShift;\n};\n\nfloat linearstep( float a, float b, float t ) {\n  return clamp( ( t - a ) / ( b - a ), 0.0, 1.0 );\n}\n\n/**\n * Convert NdotL into toon shading factor using shadingShift and shadingToony\n */\nfloat getShading(\n  const in float dotNL,\n  const in float shadow,\n  const in float shadingShift\n) {\n  float shading = dotNL;\n  shading = shading + shadingShift;\n  shading = linearstep( -1.0 + shadingToonyFactor, 1.0 - shadingToonyFactor, shading );\n  shading *= shadow;\n  return shading;\n}\n\n/**\n * Mix diffuseColor and shadeColor using shading factor and light color\n */\nvec3 getDiffuse(\n  const in MToonMaterial material,\n  const in float shading,\n  in vec3 lightColor\n) {\n  #ifdef DEBUG_LITSHADERATE\n    return vec3( BRDF_Lambert( shading * lightColor ) );\n  #endif\n\n  vec3 col = lightColor * BRDF_Lambert( mix( material.shadeColor, material.diffuseColor, shading ) );\n\n  // The \"comment out if you want to PBR absolutely\" line\n  #ifdef V0_COMPAT_SHADE\n    col = min( col, material.diffuseColor );\n  #endif\n\n  return col;\n}\n\n// COMPAT: pre-r156 uses a struct GeometricContext\n#if THREE_VRM_THREE_REVISION >= 157\n  void RE_Direct_MToon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometryNormal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#else\n  void RE_Direct_MToon( const in IncidentLight directLight, const in GeometricContext geometry, const in MToonMaterial material, const in float shadow, inout ReflectedLight reflectedLight ) {\n    float dotNL = clamp( dot( geometry.normal, directLight.direction ), -1.0, 1.0 );\n    vec3 irradiance = directLight.color;\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n\n    irradiance *= dotNL;\n\n    float shading = getShading( dotNL, shadow, material.shadingShift );\n\n    // toon shaded diffuse\n    reflectedLight.directDiffuse += getDiffuse( material, shading, directLight.color );\n  }\n\n  void RE_IndirectDiffuse_MToon( const in vec3 irradiance, const in GeometricContext geometry, const in MToonMaterial material, inout ReflectedLight reflectedLight ) {\n    // indirect diffuse will use diffuseColor, no shadeColor involved\n    reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\n    // directSpecular will be used for rim lighting, not an actual specular\n    reflectedLight.directSpecular += irradiance;\n  }\n#endif\n\n#define RE_Direct RE_Direct_MToon\n#define RE_IndirectDiffuse RE_IndirectDiffuse_MToon\n#define Material_LightProbeLOD( material ) (0)\n\n#include <shadowmap_pars_fragment>\n// #include <bumpmap_pars_fragment>\n\n// #include <normalmap_pars_fragment>\n#ifdef USE_NORMALMAP\n\n  uniform sampler2D normalMap;\n  uniform mat3 normalMapUvTransform;\n  uniform vec2 normalScale;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n#if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n  uniform mat3 normalMatrix;\n\n#endif\n\n// COMPAT: pre-r151\n// USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( TANGENTSPACE_NORMALMAP ) )\n\n  // Per-Pixel Tangent Space Normal Mapping\n  // http://hacksoflife.blogspot.ch/2009/11/per-pixel-tangent-space-normal-mapping.html\n\n  // three-vrm specific change: it requires `uv` as an input in order to support uv scrolls\n\n  // Temporary compat against shader change @ Three.js r126, r151\n  #if THREE_VRM_THREE_REVISION >= 151\n\n    mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\n      vec3 q0 = dFdx( eye_pos.xyz );\n      vec3 q1 = dFdy( eye_pos.xyz );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = surf_norm;\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\n      return mat3( T * scale, B * scale, N );\n\n    }\n\n  #else\n\n    vec3 perturbNormal2Arb( vec2 uv, vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\n      vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n      vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n      vec2 st0 = dFdx( uv.st );\n      vec2 st1 = dFdy( uv.st );\n\n      vec3 N = normalize( surf_norm );\n\n      vec3 q1perp = cross( q1, N );\n      vec3 q0perp = cross( N, q0 );\n\n      vec3 T = q1perp * st0.x + q0perp * st1.x;\n      vec3 B = q1perp * st0.y + q0perp * st1.y;\n\n      // three-vrm specific change: Workaround for the issue that happens when delta of uv = 0.0\n      // TODO: Is this still required? Or shall I make a PR about it?\n      if ( length( T ) == 0.0 || length( B ) == 0.0 ) {\n        return surf_norm;\n      }\n\n      float det = max( dot( T, T ), dot( B, B ) );\n      float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\n      return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\n    }\n\n  #endif\n\n#endif\n\n// #include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n// == post correction ==========================================================\nvoid postCorrection() {\n  #include <tonemapping_fragment>\n  #include <colorspace_fragment>\n  #include <fog_fragment>\n  #include <premultiplied_alpha_fragment>\n  #include <dithering_fragment>\n}\n\n// == main procedure ===========================================================\nvoid main() {\n  #include <clipping_planes_fragment>\n\n  vec2 uv = vec2(0.5, 0.5);\n\n  #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n    uv = vUv;\n\n    float uvAnimMask = 1.0;\n    #ifdef USE_UVANIMATIONMASKTEXTURE\n      vec2 uvAnimationMaskTextureUv = ( uvAnimationMaskTextureUvTransform * vec3( uv, 1 ) ).xy;\n      uvAnimMask = texture2D( uvAnimationMaskTexture, uvAnimationMaskTextureUv ).b;\n    #endif\n\n    float uvRotCos = cos( uvAnimationRotationPhase * uvAnimMask );\n    float uvRotSin = sin( uvAnimationRotationPhase * uvAnimMask );\n    uv = mat2( uvRotCos, -uvRotSin, uvRotSin, uvRotCos ) * ( uv - 0.5 ) + 0.5;\n    uv = uv + vec2( uvAnimationScrollXOffset, uvAnimationScrollYOffset ) * uvAnimMask;\n  #endif\n\n  #ifdef DEBUG_UV\n    gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    #if ( defined( MTOON_USE_UV ) && !defined( MTOON_UVS_VERTEX_ONLY ) )\n      gl_FragColor = vec4( uv, 0.0, 1.0 );\n    #endif\n    return;\n  #endif\n\n  vec4 diffuseColor = vec4( litFactor, opacity );\n  ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n  vec3 totalEmissiveRadiance = emissive * emissiveIntensity;\n\n  #include <logdepthbuf_fragment>\n\n  // #include <map_fragment>\n  #ifdef USE_MAP\n    vec2 mapUv = ( mapUvTransform * vec3( uv, 1 ) ).xy;\n    vec4 sampledDiffuseColor = texture2D( map, mapUv );\n    #ifdef DECODE_VIDEO_TEXTURE\n      sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n    #endif\n    diffuseColor *= sampledDiffuseColor;\n  #endif\n\n  // #include <color_fragment>\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    diffuseColor.rgb *= vColor;\n  #endif\n\n  // #include <alphamap_fragment>\n\n  #include <alphatest_fragment>\n\n  // #include <specularmap_fragment>\n\n  // #include <normal_fragment_begin>\n  float faceDirection = gl_FrontFacing ? 1.0 : -1.0;\n\n  #ifdef FLAT_SHADED\n\n    vec3 fdx = dFdx( vViewPosition );\n    vec3 fdy = dFdy( vViewPosition );\n    vec3 normal = normalize( cross( fdx, fdy ) );\n\n  #else\n\n    vec3 normal = normalize( vNormal );\n\n    #ifdef DOUBLE_SIDED\n\n      normal *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_NORMALMAP\n\n    vec2 normalMapUv = ( normalMapUvTransform * vec3( uv, 1 ) ).xy;\n\n  #endif\n\n  #ifdef USE_NORMALMAP_TANGENTSPACE\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn = getTangentFrame( - vViewPosition, normal, normalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn[0] *= faceDirection;\n      tbn[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  #ifdef USE_CLEARCOAT_NORMALMAP\n\n    #ifdef USE_TANGENT\n\n      mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\n    #else\n\n      mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\n    #endif\n\n    #if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\n      tbn2[0] *= faceDirection;\n      tbn2[1] *= faceDirection;\n\n    #endif\n\n  #endif\n\n  // non perturbed normal for clearcoat among others\n\n  vec3 nonPerturbedNormal = normal;\n\n  #ifdef OUTLINE\n    normal *= -1.0;\n  #endif\n\n  // #include <normal_fragment_maps>\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_OBJECTSPACE used to be OBJECTSPACE_NORMALMAP in pre-r151\n  #if defined( USE_NORMALMAP_OBJECTSPACE ) || defined( OBJECTSPACE_NORMALMAP )\n\n    normal = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n    #ifdef FLIP_SIDED\n\n      normal = - normal;\n\n    #endif\n\n    #ifdef DOUBLE_SIDED\n\n      normal = normal * faceDirection;\n\n    #endif\n\n    normal = normalize( normalMatrix * normal );\n\n  // COMPAT: pre-r151\n  // USE_NORMALMAP_TANGENTSPACE used to be TANGENTSPACE_NORMALMAP in pre-r151\n  #elif defined( USE_NORMALMAP_TANGENTSPACE ) || defined( TANGENTSPACE_NORMALMAP )\n\n    vec3 mapN = texture2D( normalMap, normalMapUv ).xyz * 2.0 - 1.0;\n    mapN.xy *= normalScale;\n\n    // COMPAT: pre-r151\n    #if THREE_VRM_THREE_REVISION >= 151 || defined( USE_TANGENT )\n\n      normal = normalize( tbn * mapN );\n\n    #else\n\n      normal = perturbNormal2Arb( uv, -vViewPosition, normal, mapN, faceDirection );\n\n    #endif\n\n  #endif\n\n  // #include <emissivemap_fragment>\n  #ifdef USE_EMISSIVEMAP\n    vec2 emissiveMapUv = ( emissiveMapUvTransform * vec3( uv, 1 ) ).xy;\n    totalEmissiveRadiance *= texture2D( emissiveMap, emissiveMapUv ).rgb;\n  #endif\n\n  #ifdef DEBUG_NORMAL\n    gl_FragColor = vec4( 0.5 + 0.5 * normal, 1.0 );\n    return;\n  #endif\n\n  // -- MToon: lighting --------------------------------------------------------\n  // accumulation\n  // #include <lights_phong_fragment>\n  MToonMaterial material;\n\n  material.diffuseColor = diffuseColor.rgb;\n\n  material.shadeColor = shadeColorFactor;\n  #ifdef USE_SHADEMULTIPLYTEXTURE\n    vec2 shadeMultiplyTextureUv = ( shadeMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadeColor *= texture2D( shadeMultiplyTexture, shadeMultiplyTextureUv ).rgb;\n  #endif\n\n  #if ( defined( USE_COLOR ) && !defined( IGNORE_VERTEX_COLOR ) )\n    material.shadeColor.rgb *= vColor;\n  #endif\n\n  material.shadingShift = shadingShiftFactor;\n  #ifdef USE_SHADINGSHIFTTEXTURE\n    vec2 shadingShiftTextureUv = ( shadingShiftTextureUvTransform * vec3( uv, 1 ) ).xy;\n    material.shadingShift += texture2D( shadingShiftTexture, shadingShiftTextureUv ).r * shadingShiftTextureScale;\n  #endif\n\n  // #include <lights_fragment_begin>\n\n  // MToon Specific changes:\n  // Since we want to take shadows into account of shading instead of irradiance,\n  // we had to modify the codes that multiplies the results of shadowmap into color of direct lights.\n\n  // COMPAT: pre-r156 uses a struct GeometricContext\n  #if THREE_VRM_THREE_REVISION >= 157\n    vec3 geometryPosition = - vViewPosition;\n    vec3 geometryNormal = normal;\n    vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    vec3 geometryClearcoatNormal;\n\n    #ifdef USE_CLEARCOAT\n\n      geometryClearcoatNormal = clearcoatNormal;\n\n    #endif\n  #else\n    GeometricContext geometry;\n\n    geometry.position = - vViewPosition;\n    geometry.normal = normal;\n    geometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n    #ifdef USE_CLEARCOAT\n\n      geometry.clearcoatNormal = clearcoatNormal;\n\n    #endif\n  #endif\n\n  IncidentLight directLight;\n\n  // since these variables will be used in unrolled loop, we have to define in prior\n  float shadow;\n\n  #if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    PointLight pointLight;\n    #if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n    PointLightShadow pointLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n      pointLight = pointLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getPointLightInfo( pointLight, geometryPosition, directLight );\n      #else\n        getPointLightInfo( pointLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n      pointLightShadow = pointLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n    SpotLight spotLight;\n    // COMPAT: pre-r144 uses NUM_SPOT_LIGHT_SHADOWS, r144+ uses NUM_SPOT_LIGHT_COORDS\n    #if THREE_VRM_THREE_REVISION >= 144\n      #if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_COORDS > 0\n      SpotLightShadow spotLightShadow;\n      #endif\n    #elif defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n    SpotLightShadow spotLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n      spotLight = spotLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getSpotLightInfo( spotLight, geometryPosition, directLight );\n      #else\n        getSpotLightInfo( spotLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      // COMPAT: pre-r144 uses NUM_SPOT_LIGHT_SHADOWS and vSpotShadowCoord, r144+ uses NUM_SPOT_LIGHT_COORDS and vSpotLightCoord\n      // COMPAT: pre-r166 does not have shadowIntensity, r166+ has shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_COORDS )\n        spotLightShadow = spotLightShadows[ i ];\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n        #endif\n      #elif THREE_VRM_THREE_REVISION >= 144\n        #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_COORDS )\n        spotLightShadow = spotLightShadows[ i ];\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n        #endif\n      #elif defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n      spotLightShadow = spotLightShadows[ i ];\n      shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  #if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n    DirectionalLight directionalLight;\n    #if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n    DirectionalLightShadow directionalLightShadow;\n    #endif\n\n    #pragma unroll_loop_start\n    for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n      directionalLight = directionalLights[ i ];\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        getDirectionalLightInfo( directionalLight, directLight );\n      #else\n        getDirectionalLightInfo( directionalLight, geometry, directLight );\n      #endif\n\n      shadow = 1.0;\n      #if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n      directionalLightShadow = directionalLightShadows[ i ];\n      // COMPAT: pre-r166\n      // r166 introduced shadowIntensity\n      #if THREE_VRM_THREE_REVISION >= 166\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #else\n        shadow = all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n      #endif\n      #endif\n\n      // COMPAT: pre-r156 uses a struct GeometricContext\n      #if THREE_VRM_THREE_REVISION >= 157\n        RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, shadow, reflectedLight );\n      #else\n        RE_Direct( directLight, geometry, material, shadow, reflectedLight );\n      #endif\n\n    }\n    #pragma unroll_loop_end\n\n  #endif\n\n  // #if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\n  //   RectAreaLight rectAreaLight;\n\n  //   #pragma unroll_loop_start\n  //   for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n  //     rectAreaLight = rectAreaLights[ i ];\n  //     RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n  //   }\n  //   #pragma unroll_loop_end\n\n  // #endif\n\n  #if defined( RE_IndirectDiffuse )\n\n    vec3 iblIrradiance = vec3( 0.0 );\n\n    vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n    // COMPAT: pre-r156 uses a struct GeometricContext\n    // COMPAT: pre-r156 doesn't have a define USE_LIGHT_PROBES\n    #if THREE_VRM_THREE_REVISION >= 157\n      #if defined( USE_LIGHT_PROBES )\n        irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );\n      #endif\n    #else\n      irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n    #endif\n\n    #if ( NUM_HEMI_LIGHTS > 0 )\n\n      #pragma unroll_loop_start\n      for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n        // COMPAT: pre-r156 uses a struct GeometricContext\n        #if THREE_VRM_THREE_REVISION >= 157\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );\n        #else\n          irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n        #endif\n\n      }\n      #pragma unroll_loop_end\n\n    #endif\n\n  #endif\n\n  // #if defined( RE_IndirectSpecular )\n\n  //   vec3 radiance = vec3( 0.0 );\n  //   vec3 clearcoatRadiance = vec3( 0.0 );\n\n  // #endif\n\n  #include <lights_fragment_maps>\n  #include <lights_fragment_end>\n\n  // modulation\n  #include <aomap_fragment>\n\n  vec3 col = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\n  #ifdef DEBUG_LITSHADERATE\n    gl_FragColor = vec4( col, diffuseColor.a );\n    postCorrection();\n    return;\n  #endif\n\n  // -- MToon: rim lighting -----------------------------------------\n  vec3 viewDir = normalize( vViewPosition );\n\n  #ifndef PHYSICALLY_CORRECT_LIGHTS\n    reflectedLight.directSpecular /= PI;\n  #endif\n  vec3 rimMix = mix( vec3( 1.0 ), reflectedLight.directSpecular, 1.0 );\n\n  vec3 rim = parametricRimColorFactor * pow( saturate( 1.0 - dot( viewDir, normal ) + parametricRimLiftFactor ), parametricRimFresnelPowerFactor );\n\n  #ifdef USE_MATCAPTEXTURE\n    {\n      vec3 x = normalize( vec3( viewDir.z, 0.0, -viewDir.x ) );\n      vec3 y = cross( viewDir, x ); // guaranteed to be normalized\n      vec2 sphereUv = 0.5 + 0.5 * vec2( dot( x, normal ), -dot( y, normal ) );\n      sphereUv = ( matcapTextureUvTransform * vec3( sphereUv, 1 ) ).xy;\n      vec3 matcap = texture2D( matcapTexture, sphereUv ).rgb;\n      rim += matcapFactor * matcap;\n    }\n  #endif\n\n  #ifdef USE_RIMMULTIPLYTEXTURE\n    vec2 rimMultiplyTextureUv = ( rimMultiplyTextureUvTransform * vec3( uv, 1 ) ).xy;\n    rim *= texture2D( rimMultiplyTexture, rimMultiplyTextureUv ).rgb;\n  #endif\n\n  col += rimMix * rim;\n\n  // -- MToon: Emission --------------------------------------------------------\n  col += totalEmissiveRadiance;\n\n  // #include <envmap_fragment>\n\n  // -- Almost done! -----------------------------------------------------------\n  #if defined( OUTLINE )\n    col = outlineColorFactor.rgb * mix( vec3( 1.0 ), col, outlineLightingMixFactor );\n  #endif\n\n  #ifdef OPAQUE\n    diffuseColor.a = 1.0;\n  #endif\n\n  gl_FragColor = vec4( col, diffuseColor.a );\n  postCorrection();\n}\n";
var MToonMaterialDebugMode = {
  /**
   * Render normally.
   */
  None: "none",
  /**
   * Visualize normals of the surface.
   */
  Normal: "normal",
  /**
   * Visualize lit/shade of the surface.
   */
  LitShadeRate: "litShadeRate",
  /**
   * Visualize UV of the surface.
   */
  UV: "uv"
};
var MToonMaterialOutlineWidthMode = {
  None: "none",
  WorldCoordinates: "worldCoordinates",
  ScreenCoordinates: "screenCoordinates"
};
var encodingColorSpaceMap = {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  3e3: "",
  // eslint-disable-next-line @typescript-eslint/naming-convention
  3001: "srgb"
};
function getTextureColorSpace(texture) {
  if (parseInt(REVISION, 10) >= 152) {
    return texture.colorSpace;
  } else {
    return encodingColorSpaceMap[texture.encoding];
  }
}
var MToonMaterial = class extends ShaderMaterial {
  constructor(parameters = {}) {
    var _a2;
    super({ vertexShader: mtoon_default, fragmentShader: mtoon_default2 });
    this.uvAnimationScrollXSpeedFactor = 0;
    this.uvAnimationScrollYSpeedFactor = 0;
    this.uvAnimationRotationSpeedFactor = 0;
    this.fog = true;
    this.normalMapType = TangentSpaceNormalMap;
    this._ignoreVertexColor = true;
    this._v0CompatShade = false;
    this._debugMode = MToonMaterialDebugMode.None;
    this._outlineWidthMode = MToonMaterialOutlineWidthMode.None;
    this._isOutline = false;
    if (parameters.transparentWithZWrite) {
      parameters.depthWrite = true;
    }
    delete parameters.transparentWithZWrite;
    parameters.fog = true;
    parameters.lights = true;
    parameters.clipping = true;
    this.uniforms = UniformsUtils.merge([
      UniformsLib.common,
      // map
      UniformsLib.normalmap,
      // normalMap
      UniformsLib.emissivemap,
      // emissiveMap
      UniformsLib.fog,
      UniformsLib.lights,
      {
        litFactor: { value: new Color(1, 1, 1) },
        mapUvTransform: { value: new Matrix3() },
        colorAlpha: { value: 1 },
        normalMapUvTransform: { value: new Matrix3() },
        shadeColorFactor: { value: new Color(0, 0, 0) },
        shadeMultiplyTexture: { value: null },
        shadeMultiplyTextureUvTransform: { value: new Matrix3() },
        shadingShiftFactor: { value: 0 },
        shadingShiftTexture: { value: null },
        shadingShiftTextureUvTransform: { value: new Matrix3() },
        shadingShiftTextureScale: { value: 1 },
        shadingToonyFactor: { value: 0.9 },
        giEqualizationFactor: { value: 0.9 },
        matcapFactor: { value: new Color(1, 1, 1) },
        matcapTexture: { value: null },
        matcapTextureUvTransform: { value: new Matrix3() },
        parametricRimColorFactor: { value: new Color(0, 0, 0) },
        rimMultiplyTexture: { value: null },
        rimMultiplyTextureUvTransform: { value: new Matrix3() },
        rimLightingMixFactor: { value: 1 },
        parametricRimFresnelPowerFactor: { value: 5 },
        parametricRimLiftFactor: { value: 0 },
        emissive: { value: new Color(0, 0, 0) },
        emissiveIntensity: { value: 1 },
        emissiveMapUvTransform: { value: new Matrix3() },
        outlineWidthMultiplyTexture: { value: null },
        outlineWidthMultiplyTextureUvTransform: { value: new Matrix3() },
        outlineWidthFactor: { value: 0 },
        outlineColorFactor: { value: new Color(0, 0, 0) },
        outlineLightingMixFactor: { value: 1 },
        uvAnimationMaskTexture: { value: null },
        uvAnimationMaskTextureUvTransform: { value: new Matrix3() },
        uvAnimationScrollXOffset: { value: 0 },
        uvAnimationScrollYOffset: { value: 0 },
        uvAnimationRotationPhase: { value: 0 }
      },
      (_a2 = parameters.uniforms) != null ? _a2 : {}
    ]);
    this.setValues(parameters);
    this._uploadUniformsWorkaround();
    this.customProgramCacheKey = () => [
      ...Object.entries(this._generateDefines()).map(([token, macro]) => `${token}:${macro}`),
      this.matcapTexture ? `matcapTextureColorSpace:${getTextureColorSpace(this.matcapTexture)}` : "",
      this.shadeMultiplyTexture ? `shadeMultiplyTextureColorSpace:${getTextureColorSpace(this.shadeMultiplyTexture)}` : "",
      this.rimMultiplyTexture ? `rimMultiplyTextureColorSpace:${getTextureColorSpace(this.rimMultiplyTexture)}` : ""
    ].join(",");
    this.onBeforeCompile = (shader) => {
      const threeRevision = parseInt(REVISION, 10);
      const defines = Object.entries(__spreadValues(__spreadValues({}, this._generateDefines()), this.defines)).filter(([token, macro]) => !!macro).map(([token, macro]) => `#define ${token} ${macro}`).join("\n") + "\n";
      shader.vertexShader = defines + shader.vertexShader;
      shader.fragmentShader = defines + shader.fragmentShader;
      if (threeRevision < 154) {
        shader.fragmentShader = shader.fragmentShader.replace(
          "#include <colorspace_fragment>",
          "#include <encodings_fragment>"
        );
      }
    };
  }
  get color() {
    return this.uniforms.litFactor.value;
  }
  set color(value) {
    this.uniforms.litFactor.value = value;
  }
  get map() {
    return this.uniforms.map.value;
  }
  set map(value) {
    this.uniforms.map.value = value;
  }
  get normalMap() {
    return this.uniforms.normalMap.value;
  }
  set normalMap(value) {
    this.uniforms.normalMap.value = value;
  }
  get normalScale() {
    return this.uniforms.normalScale.value;
  }
  set normalScale(value) {
    this.uniforms.normalScale.value = value;
  }
  get emissive() {
    return this.uniforms.emissive.value;
  }
  set emissive(value) {
    this.uniforms.emissive.value = value;
  }
  get emissiveIntensity() {
    return this.uniforms.emissiveIntensity.value;
  }
  set emissiveIntensity(value) {
    this.uniforms.emissiveIntensity.value = value;
  }
  get emissiveMap() {
    return this.uniforms.emissiveMap.value;
  }
  set emissiveMap(value) {
    this.uniforms.emissiveMap.value = value;
  }
  get shadeColorFactor() {
    return this.uniforms.shadeColorFactor.value;
  }
  set shadeColorFactor(value) {
    this.uniforms.shadeColorFactor.value = value;
  }
  get shadeMultiplyTexture() {
    return this.uniforms.shadeMultiplyTexture.value;
  }
  set shadeMultiplyTexture(value) {
    this.uniforms.shadeMultiplyTexture.value = value;
  }
  get shadingShiftFactor() {
    return this.uniforms.shadingShiftFactor.value;
  }
  set shadingShiftFactor(value) {
    this.uniforms.shadingShiftFactor.value = value;
  }
  get shadingShiftTexture() {
    return this.uniforms.shadingShiftTexture.value;
  }
  set shadingShiftTexture(value) {
    this.uniforms.shadingShiftTexture.value = value;
  }
  get shadingShiftTextureScale() {
    return this.uniforms.shadingShiftTextureScale.value;
  }
  set shadingShiftTextureScale(value) {
    this.uniforms.shadingShiftTextureScale.value = value;
  }
  get shadingToonyFactor() {
    return this.uniforms.shadingToonyFactor.value;
  }
  set shadingToonyFactor(value) {
    this.uniforms.shadingToonyFactor.value = value;
  }
  get giEqualizationFactor() {
    return this.uniforms.giEqualizationFactor.value;
  }
  set giEqualizationFactor(value) {
    this.uniforms.giEqualizationFactor.value = value;
  }
  get matcapFactor() {
    return this.uniforms.matcapFactor.value;
  }
  set matcapFactor(value) {
    this.uniforms.matcapFactor.value = value;
  }
  get matcapTexture() {
    return this.uniforms.matcapTexture.value;
  }
  set matcapTexture(value) {
    this.uniforms.matcapTexture.value = value;
  }
  get parametricRimColorFactor() {
    return this.uniforms.parametricRimColorFactor.value;
  }
  set parametricRimColorFactor(value) {
    this.uniforms.parametricRimColorFactor.value = value;
  }
  get rimMultiplyTexture() {
    return this.uniforms.rimMultiplyTexture.value;
  }
  set rimMultiplyTexture(value) {
    this.uniforms.rimMultiplyTexture.value = value;
  }
  get rimLightingMixFactor() {
    return this.uniforms.rimLightingMixFactor.value;
  }
  set rimLightingMixFactor(value) {
    this.uniforms.rimLightingMixFactor.value = value;
  }
  get parametricRimFresnelPowerFactor() {
    return this.uniforms.parametricRimFresnelPowerFactor.value;
  }
  set parametricRimFresnelPowerFactor(value) {
    this.uniforms.parametricRimFresnelPowerFactor.value = value;
  }
  get parametricRimLiftFactor() {
    return this.uniforms.parametricRimLiftFactor.value;
  }
  set parametricRimLiftFactor(value) {
    this.uniforms.parametricRimLiftFactor.value = value;
  }
  get outlineWidthMultiplyTexture() {
    return this.uniforms.outlineWidthMultiplyTexture.value;
  }
  set outlineWidthMultiplyTexture(value) {
    this.uniforms.outlineWidthMultiplyTexture.value = value;
  }
  get outlineWidthFactor() {
    return this.uniforms.outlineWidthFactor.value;
  }
  set outlineWidthFactor(value) {
    this.uniforms.outlineWidthFactor.value = value;
  }
  get outlineColorFactor() {
    return this.uniforms.outlineColorFactor.value;
  }
  set outlineColorFactor(value) {
    this.uniforms.outlineColorFactor.value = value;
  }
  get outlineLightingMixFactor() {
    return this.uniforms.outlineLightingMixFactor.value;
  }
  set outlineLightingMixFactor(value) {
    this.uniforms.outlineLightingMixFactor.value = value;
  }
  get uvAnimationMaskTexture() {
    return this.uniforms.uvAnimationMaskTexture.value;
  }
  set uvAnimationMaskTexture(value) {
    this.uniforms.uvAnimationMaskTexture.value = value;
  }
  get uvAnimationScrollXOffset() {
    return this.uniforms.uvAnimationScrollXOffset.value;
  }
  set uvAnimationScrollXOffset(value) {
    this.uniforms.uvAnimationScrollXOffset.value = value;
  }
  get uvAnimationScrollYOffset() {
    return this.uniforms.uvAnimationScrollYOffset.value;
  }
  set uvAnimationScrollYOffset(value) {
    this.uniforms.uvAnimationScrollYOffset.value = value;
  }
  get uvAnimationRotationPhase() {
    return this.uniforms.uvAnimationRotationPhase.value;
  }
  set uvAnimationRotationPhase(value) {
    this.uniforms.uvAnimationRotationPhase.value = value;
  }
  /**
   * When this is `true`, vertex colors will be ignored.
   * `true` by default.
   */
  get ignoreVertexColor() {
    return this._ignoreVertexColor;
  }
  set ignoreVertexColor(value) {
    this._ignoreVertexColor = value;
    this.needsUpdate = true;
  }
  /**
   * There is a line of the shader called "comment out if you want to PBR absolutely" in VRM0.0 MToon.
   * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.
   * Usually not recommended to turn this on.
   * `false` by default.
   */
  get v0CompatShade() {
    return this._v0CompatShade;
  }
  /**
   * There is a line of the shader called "comment out if you want to PBR absolutely" in VRM0.0 MToon.
   * When this is true, the material enables the line to make it compatible with the legacy rendering of VRM.
   * Usually not recommended to turn this on.
   * `false` by default.
   */
  set v0CompatShade(v2) {
    this._v0CompatShade = v2;
    this.needsUpdate = true;
  }
  /**
   * Debug mode for the material.
   * You can visualize several components for diagnosis using debug mode.
   *
   * See: {@link MToonMaterialDebugMode}
   */
  get debugMode() {
    return this._debugMode;
  }
  /**
   * Debug mode for the material.
   * You can visualize several components for diagnosis using debug mode.
   *
   * See: {@link MToonMaterialDebugMode}
   */
  set debugMode(m2) {
    this._debugMode = m2;
    this.needsUpdate = true;
  }
  get outlineWidthMode() {
    return this._outlineWidthMode;
  }
  set outlineWidthMode(m2) {
    this._outlineWidthMode = m2;
    this.needsUpdate = true;
  }
  get isOutline() {
    return this._isOutline;
  }
  set isOutline(b2) {
    this._isOutline = b2;
    this.needsUpdate = true;
  }
  /**
   * Readonly boolean that indicates this is a {@link MToonMaterial}.
   */
  get isMToonMaterial() {
    return true;
  }
  /**
   * Update this material.
   *
   * @param delta deltaTime since last update
   */
  update(delta) {
    this._uploadUniformsWorkaround();
    this._updateUVAnimation(delta);
  }
  copy(source) {
    super.copy(source);
    this.map = source.map;
    this.normalMap = source.normalMap;
    this.emissiveMap = source.emissiveMap;
    this.shadeMultiplyTexture = source.shadeMultiplyTexture;
    this.shadingShiftTexture = source.shadingShiftTexture;
    this.matcapTexture = source.matcapTexture;
    this.rimMultiplyTexture = source.rimMultiplyTexture;
    this.outlineWidthMultiplyTexture = source.outlineWidthMultiplyTexture;
    this.uvAnimationMaskTexture = source.uvAnimationMaskTexture;
    this.normalMapType = source.normalMapType;
    this.uvAnimationScrollXSpeedFactor = source.uvAnimationScrollXSpeedFactor;
    this.uvAnimationScrollYSpeedFactor = source.uvAnimationScrollYSpeedFactor;
    this.uvAnimationRotationSpeedFactor = source.uvAnimationRotationSpeedFactor;
    this.ignoreVertexColor = source.ignoreVertexColor;
    this.v0CompatShade = source.v0CompatShade;
    this.debugMode = source.debugMode;
    this.outlineWidthMode = source.outlineWidthMode;
    this.isOutline = source.isOutline;
    this.needsUpdate = true;
    return this;
  }
  /**
   * Update UV animation state.
   * Intended to be called via {@link update}.
   * @param delta deltaTime
   */
  _updateUVAnimation(delta) {
    this.uniforms.uvAnimationScrollXOffset.value += delta * this.uvAnimationScrollXSpeedFactor;
    this.uniforms.uvAnimationScrollYOffset.value += delta * this.uvAnimationScrollYSpeedFactor;
    this.uniforms.uvAnimationRotationPhase.value += delta * this.uvAnimationRotationSpeedFactor;
    this.uniforms.alphaTest.value = this.alphaTest;
    this.uniformsNeedUpdate = true;
  }
  /**
   * Upload uniforms that need to upload but doesn't automatically because of reasons.
   * Intended to be called via {@link constructor} and {@link update}.
   */
  _uploadUniformsWorkaround() {
    this.uniforms.opacity.value = this.opacity;
    this._updateTextureMatrix(this.uniforms.map, this.uniforms.mapUvTransform);
    this._updateTextureMatrix(this.uniforms.normalMap, this.uniforms.normalMapUvTransform);
    this._updateTextureMatrix(this.uniforms.emissiveMap, this.uniforms.emissiveMapUvTransform);
    this._updateTextureMatrix(this.uniforms.shadeMultiplyTexture, this.uniforms.shadeMultiplyTextureUvTransform);
    this._updateTextureMatrix(this.uniforms.shadingShiftTexture, this.uniforms.shadingShiftTextureUvTransform);
    this._updateTextureMatrix(this.uniforms.matcapTexture, this.uniforms.matcapTextureUvTransform);
    this._updateTextureMatrix(this.uniforms.rimMultiplyTexture, this.uniforms.rimMultiplyTextureUvTransform);
    this._updateTextureMatrix(
      this.uniforms.outlineWidthMultiplyTexture,
      this.uniforms.outlineWidthMultiplyTextureUvTransform
    );
    this._updateTextureMatrix(this.uniforms.uvAnimationMaskTexture, this.uniforms.uvAnimationMaskTextureUvTransform);
    this.uniformsNeedUpdate = true;
  }
  /**
   * Returns a map object of preprocessor token and macro of the shader program.
   */
  _generateDefines() {
    const threeRevision = parseInt(REVISION, 10);
    const useUvInVert = this.outlineWidthMultiplyTexture !== null;
    const useUvInFrag = this.map !== null || this.normalMap !== null || this.emissiveMap !== null || this.shadeMultiplyTexture !== null || this.shadingShiftTexture !== null || this.rimMultiplyTexture !== null || this.uvAnimationMaskTexture !== null;
    return {
      // Temporary compat against shader change @ Three.js r126
      // See: #21205, #21307, #21299
      THREE_VRM_THREE_REVISION: threeRevision,
      OUTLINE: this._isOutline,
      MTOON_USE_UV: useUvInVert || useUvInFrag,
      // we can't use `USE_UV` , it will be redefined in WebGLProgram.js
      MTOON_UVS_VERTEX_ONLY: useUvInVert && !useUvInFrag,
      V0_COMPAT_SHADE: this._v0CompatShade,
      USE_SHADEMULTIPLYTEXTURE: this.shadeMultiplyTexture !== null,
      USE_SHADINGSHIFTTEXTURE: this.shadingShiftTexture !== null,
      USE_MATCAPTEXTURE: this.matcapTexture !== null,
      USE_RIMMULTIPLYTEXTURE: this.rimMultiplyTexture !== null,
      USE_OUTLINEWIDTHMULTIPLYTEXTURE: this._isOutline && this.outlineWidthMultiplyTexture !== null,
      USE_UVANIMATIONMASKTEXTURE: this.uvAnimationMaskTexture !== null,
      IGNORE_VERTEX_COLOR: this._ignoreVertexColor === true,
      DEBUG_NORMAL: this._debugMode === "normal",
      DEBUG_LITSHADERATE: this._debugMode === "litShadeRate",
      DEBUG_UV: this._debugMode === "uv",
      OUTLINE_WIDTH_SCREEN: this._isOutline && this._outlineWidthMode === MToonMaterialOutlineWidthMode.ScreenCoordinates
    };
  }
  _updateTextureMatrix(src, dst) {
    if (src.value) {
      if (src.value.matrixAutoUpdate) {
        src.value.updateMatrix();
      }
      dst.value.copy(src.value.matrix);
    }
  }
};
var POSSIBLE_SPEC_VERSIONS6 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var _MToonMaterialLoaderPlugin = class _MToonMaterialLoaderPlugin2 {
  get name() {
    return _MToonMaterialLoaderPlugin2.EXTENSION_NAME;
  }
  constructor(parser, options = {}) {
    var _a2, _b, _c2, _d;
    this.parser = parser;
    this.materialType = (_a2 = options.materialType) != null ? _a2 : MToonMaterial;
    this.renderOrderOffset = (_b = options.renderOrderOffset) != null ? _b : 0;
    this.v0CompatShade = (_c2 = options.v0CompatShade) != null ? _c2 : false;
    this.debugMode = (_d = options.debugMode) != null ? _d : "none";
    this._mToonMaterialSet = /* @__PURE__ */ new Set();
  }
  beforeRoot() {
    return __async3(this, null, function* () {
      this._removeUnlitExtensionIfMToonExists();
    });
  }
  afterRoot(gltf) {
    return __async3(this, null, function* () {
      gltf.userData.vrmMToonMaterials = Array.from(this._mToonMaterialSet);
    });
  }
  getMaterialType(materialIndex) {
    const v1Extension = this._getMToonExtension(materialIndex);
    if (v1Extension) {
      return this.materialType;
    }
    return null;
  }
  extendMaterialParams(materialIndex, materialParams) {
    const extension = this._getMToonExtension(materialIndex);
    if (extension) {
      return this._extendMaterialParams(extension, materialParams);
    }
    return null;
  }
  loadMesh(meshIndex) {
    return __async3(this, null, function* () {
      var _a2;
      const parser = this.parser;
      const json = parser.json;
      const meshDef = (_a2 = json.meshes) == null ? void 0 : _a2[meshIndex];
      if (meshDef == null) {
        throw new Error(
          `MToonMaterialLoaderPlugin: Attempt to use meshes[${meshIndex}] of glTF but the mesh doesn't exist`
        );
      }
      const primitivesDef = meshDef.primitives;
      const meshOrGroup = yield parser.loadMesh(meshIndex);
      if (primitivesDef.length === 1) {
        const mesh = meshOrGroup;
        const materialIndex = primitivesDef[0].material;
        if (materialIndex != null) {
          this._setupPrimitive(mesh, materialIndex);
        }
      } else {
        const group = meshOrGroup;
        for (let i2 = 0; i2 < primitivesDef.length; i2++) {
          const mesh = group.children[i2];
          const materialIndex = primitivesDef[i2].material;
          if (materialIndex != null) {
            this._setupPrimitive(mesh, materialIndex);
          }
        }
      }
      return meshOrGroup;
    });
  }
  /**
   * Delete use of `KHR_materials_unlit` from its `materials` if the material is using MToon.
   *
   * Since GLTFLoader have so many hardcoded procedure related to `KHR_materials_unlit`
   * we have to delete the extension before we start to parse the glTF.
   */
  _removeUnlitExtensionIfMToonExists() {
    const parser = this.parser;
    const json = parser.json;
    const materialDefs = json.materials;
    materialDefs == null ? void 0 : materialDefs.map((materialDef, iMaterial) => {
      var _a2;
      const extension = this._getMToonExtension(iMaterial);
      if (extension && ((_a2 = materialDef.extensions) == null ? void 0 : _a2["KHR_materials_unlit"])) {
        delete materialDef.extensions["KHR_materials_unlit"];
      }
    });
  }
  _getMToonExtension(materialIndex) {
    var _a2, _b;
    const parser = this.parser;
    const json = parser.json;
    const materialDef = (_a2 = json.materials) == null ? void 0 : _a2[materialIndex];
    if (materialDef == null) {
      console.warn(
        `MToonMaterialLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
      );
      return void 0;
    }
    const extension = (_b = materialDef.extensions) == null ? void 0 : _b[_MToonMaterialLoaderPlugin2.EXTENSION_NAME];
    if (extension == null) {
      return void 0;
    }
    const specVersion = extension.specVersion;
    if (!POSSIBLE_SPEC_VERSIONS6.has(specVersion)) {
      console.warn(
        `MToonMaterialLoaderPlugin: Unknown ${_MToonMaterialLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
      );
      return void 0;
    }
    return extension;
  }
  _extendMaterialParams(extension, materialParams) {
    return __async3(this, null, function* () {
      var _a2;
      delete materialParams.metalness;
      delete materialParams.roughness;
      const assignHelper = new GLTFMToonMaterialParamsAssignHelper(this.parser, materialParams);
      assignHelper.assignPrimitive("transparentWithZWrite", extension.transparentWithZWrite);
      assignHelper.assignColor("shadeColorFactor", extension.shadeColorFactor);
      assignHelper.assignTexture("shadeMultiplyTexture", extension.shadeMultiplyTexture, true);
      assignHelper.assignPrimitive("shadingShiftFactor", extension.shadingShiftFactor);
      assignHelper.assignTexture("shadingShiftTexture", extension.shadingShiftTexture, true);
      assignHelper.assignPrimitive("shadingShiftTextureScale", (_a2 = extension.shadingShiftTexture) == null ? void 0 : _a2.scale);
      assignHelper.assignPrimitive("shadingToonyFactor", extension.shadingToonyFactor);
      assignHelper.assignPrimitive("giEqualizationFactor", extension.giEqualizationFactor);
      assignHelper.assignColor("matcapFactor", extension.matcapFactor);
      assignHelper.assignTexture("matcapTexture", extension.matcapTexture, true);
      assignHelper.assignColor("parametricRimColorFactor", extension.parametricRimColorFactor);
      assignHelper.assignTexture("rimMultiplyTexture", extension.rimMultiplyTexture, true);
      assignHelper.assignPrimitive("rimLightingMixFactor", extension.rimLightingMixFactor);
      assignHelper.assignPrimitive("parametricRimFresnelPowerFactor", extension.parametricRimFresnelPowerFactor);
      assignHelper.assignPrimitive("parametricRimLiftFactor", extension.parametricRimLiftFactor);
      assignHelper.assignPrimitive("outlineWidthMode", extension.outlineWidthMode);
      assignHelper.assignPrimitive("outlineWidthFactor", extension.outlineWidthFactor);
      assignHelper.assignTexture("outlineWidthMultiplyTexture", extension.outlineWidthMultiplyTexture, false);
      assignHelper.assignColor("outlineColorFactor", extension.outlineColorFactor);
      assignHelper.assignPrimitive("outlineLightingMixFactor", extension.outlineLightingMixFactor);
      assignHelper.assignTexture("uvAnimationMaskTexture", extension.uvAnimationMaskTexture, false);
      assignHelper.assignPrimitive("uvAnimationScrollXSpeedFactor", extension.uvAnimationScrollXSpeedFactor);
      assignHelper.assignPrimitive("uvAnimationScrollYSpeedFactor", extension.uvAnimationScrollYSpeedFactor);
      assignHelper.assignPrimitive("uvAnimationRotationSpeedFactor", extension.uvAnimationRotationSpeedFactor);
      assignHelper.assignPrimitive("v0CompatShade", this.v0CompatShade);
      assignHelper.assignPrimitive("debugMode", this.debugMode);
      yield assignHelper.pending;
    });
  }
  /**
   * This will do two processes that is required to render MToon properly.
   *
   * - Set render order
   * - Generate outline
   *
   * @param mesh A target GLTF primitive
   * @param materialIndex The material index of the primitive
   */
  _setupPrimitive(mesh, materialIndex) {
    const extension = this._getMToonExtension(materialIndex);
    if (extension) {
      const renderOrder = this._parseRenderOrder(extension);
      mesh.renderOrder = renderOrder + this.renderOrderOffset;
      this._generateOutline(mesh);
      this._addToMaterialSet(mesh);
      return;
    }
  }
  /**
   * Check whether the material should generate outline or not.
   * @param surfaceMaterial The material to check
   * @returns True if the material should generate outline
   */
  _shouldGenerateOutline(surfaceMaterial) {
    return typeof surfaceMaterial.outlineWidthMode === "string" && surfaceMaterial.outlineWidthMode !== "none" && typeof surfaceMaterial.outlineWidthFactor === "number" && surfaceMaterial.outlineWidthFactor > 0;
  }
  /**
   * Generate outline for the given mesh, if it needs.
   *
   * @param mesh The target mesh
   */
  _generateOutline(mesh) {
    const surfaceMaterial = mesh.material;
    if (!(surfaceMaterial instanceof Material)) {
      return;
    }
    if (!this._shouldGenerateOutline(surfaceMaterial)) {
      return;
    }
    mesh.material = [surfaceMaterial];
    const outlineMaterial = surfaceMaterial.clone();
    outlineMaterial.name += " (Outline)";
    outlineMaterial.isOutline = true;
    outlineMaterial.side = BackSide;
    mesh.material.push(outlineMaterial);
    const geometry = mesh.geometry;
    const primitiveVertices = geometry.index ? geometry.index.count : geometry.attributes.position.count / 3;
    geometry.addGroup(0, primitiveVertices, 0);
    geometry.addGroup(0, primitiveVertices, 1);
  }
  _addToMaterialSet(mesh) {
    const materialOrMaterials = mesh.material;
    const materialSet = /* @__PURE__ */ new Set();
    if (Array.isArray(materialOrMaterials)) {
      materialOrMaterials.forEach((material) => materialSet.add(material));
    } else {
      materialSet.add(materialOrMaterials);
    }
    for (const material of materialSet) {
      this._mToonMaterialSet.add(material);
    }
  }
  _parseRenderOrder(extension) {
    var _a2;
    const enabledZWrite = extension.transparentWithZWrite;
    return (enabledZWrite ? 0 : 19) + ((_a2 = extension.renderQueueOffsetNumber) != null ? _a2 : 0);
  }
};
_MToonMaterialLoaderPlugin.EXTENSION_NAME = "VRMC_materials_mtoon";
var MToonMaterialLoaderPlugin = _MToonMaterialLoaderPlugin;
var __async4 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var _VRMMaterialsHDREmissiveMultiplierLoaderPlugin = class _VRMMaterialsHDREmissiveMultiplierLoaderPlugin2 {
  get name() {
    return _VRMMaterialsHDREmissiveMultiplierLoaderPlugin2.EXTENSION_NAME;
  }
  constructor(parser) {
    this.parser = parser;
  }
  extendMaterialParams(materialIndex, materialParams) {
    return __async4(this, null, function* () {
      const extension = this._getHDREmissiveMultiplierExtension(materialIndex);
      if (extension == null) {
        return;
      }
      console.warn(
        "VRMMaterialsHDREmissiveMultiplierLoaderPlugin: `VRMC_materials_hdr_emissiveMultiplier` is archived. Use `KHR_materials_emissive_strength` instead."
      );
      const emissiveMultiplier = extension.emissiveMultiplier;
      materialParams.emissiveIntensity = emissiveMultiplier;
    });
  }
  _getHDREmissiveMultiplierExtension(materialIndex) {
    var _a2, _b;
    const parser = this.parser;
    const json = parser.json;
    const materialDef = (_a2 = json.materials) == null ? void 0 : _a2[materialIndex];
    if (materialDef == null) {
      console.warn(
        `VRMMaterialsHDREmissiveMultiplierLoaderPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
      );
      return void 0;
    }
    const extension = (_b = materialDef.extensions) == null ? void 0 : _b[_VRMMaterialsHDREmissiveMultiplierLoaderPlugin2.EXTENSION_NAME];
    if (extension == null) {
      return void 0;
    }
    return extension;
  }
};
_VRMMaterialsHDREmissiveMultiplierLoaderPlugin.EXTENSION_NAME = "VRMC_materials_hdr_emissiveMultiplier";
var VRMMaterialsHDREmissiveMultiplierLoaderPlugin = _VRMMaterialsHDREmissiveMultiplierLoaderPlugin;
var __defProp22 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols2 = Object.getOwnPropertySymbols;
var __hasOwnProp22 = Object.prototype.hasOwnProperty;
var __propIsEnum2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp22(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues2 = (a2, b2) => {
  for (var prop in b2 || (b2 = {}))
    if (__hasOwnProp22.call(b2, prop))
      __defNormalProp2(a2, prop, b2[prop]);
  if (__getOwnPropSymbols2)
    for (var prop of __getOwnPropSymbols2(b2)) {
      if (__propIsEnum2.call(b2, prop))
        __defNormalProp2(a2, prop, b2[prop]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __async5 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
function gammaEOTF(e2) {
  return Math.pow(e2, 2.2);
}
var VRMMaterialsV0CompatPlugin = class {
  get name() {
    return "VRMMaterialsV0CompatPlugin";
  }
  constructor(parser) {
    var _a2;
    this.parser = parser;
    this._renderQueueMapTransparent = /* @__PURE__ */ new Map();
    this._renderQueueMapTransparentZWrite = /* @__PURE__ */ new Map();
    const json = this.parser.json;
    json.extensionsUsed = (_a2 = json.extensionsUsed) != null ? _a2 : [];
    if (json.extensionsUsed.indexOf("KHR_texture_transform") === -1) {
      json.extensionsUsed.push("KHR_texture_transform");
    }
  }
  beforeRoot() {
    return __async5(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const v0VRMExtension = (_a2 = json.extensions) == null ? void 0 : _a2["VRM"];
      const v0MaterialProperties = v0VRMExtension == null ? void 0 : v0VRMExtension.materialProperties;
      if (!v0MaterialProperties) {
        return;
      }
      this._populateRenderQueueMap(v0MaterialProperties);
      v0MaterialProperties.forEach((materialProperties, materialIndex) => {
        var _a22, _b;
        const materialDef = (_a22 = json.materials) == null ? void 0 : _a22[materialIndex];
        if (materialDef == null) {
          console.warn(
            `VRMMaterialsV0CompatPlugin: Attempt to use materials[${materialIndex}] of glTF but the material doesn't exist`
          );
          return;
        }
        if (materialProperties.shader === "VRM/MToon") {
          const material = this._parseV0MToonProperties(materialProperties, materialDef);
          json.materials[materialIndex] = material;
        } else if ((_b = materialProperties.shader) == null ? void 0 : _b.startsWith("VRM/Unlit")) {
          const material = this._parseV0UnlitProperties(materialProperties, materialDef);
          json.materials[materialIndex] = material;
        } else if (materialProperties.shader === "VRM_USE_GLTFSHADER") {
        } else {
          console.warn(`VRMMaterialsV0CompatPlugin: Unknown shader: ${materialProperties.shader}`);
        }
      });
    });
  }
  _parseV0MToonProperties(materialProperties, schemaMaterial) {
    var _a2, _b, _c2, _d, _e2, _f, _g, _h, _i2, _j, _k, _l, _m, _n2, _o2, _p, _q, _r2, _s2, _t2, _u, _v, _w, _x2, _y2, _z2, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa;
    const isTransparent = (_b = (_a2 = materialProperties.keywordMap) == null ? void 0 : _a2["_ALPHABLEND_ON"]) != null ? _b : false;
    const enabledZWrite = ((_c2 = materialProperties.floatProperties) == null ? void 0 : _c2["_ZWrite"]) === 1;
    const transparentWithZWrite = enabledZWrite && isTransparent;
    const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);
    const isCutoff = (_e2 = (_d = materialProperties.keywordMap) == null ? void 0 : _d["_ALPHATEST_ON"]) != null ? _e2 : false;
    const alphaMode = isTransparent ? "BLEND" : isCutoff ? "MASK" : "OPAQUE";
    const alphaCutoff = isCutoff ? (_g = (_f = materialProperties.floatProperties) == null ? void 0 : _f["_Cutoff"]) != null ? _g : 0.5 : void 0;
    const cullMode = (_i2 = (_h = materialProperties.floatProperties) == null ? void 0 : _h["_CullMode"]) != null ? _i2 : 2;
    const doubleSided = cullMode === 0;
    const textureTransformExt = this._portTextureTransform(materialProperties);
    const baseColorFactor = ((_k = (_j = materialProperties.vectorProperties) == null ? void 0 : _j["_Color"]) != null ? _k : [1, 1, 1, 1]).map(
      (v2, i2) => i2 === 3 ? v2 : gammaEOTF(v2)
      // alpha channel is stored in linear
    );
    const baseColorTextureIndex = (_l = materialProperties.textureProperties) == null ? void 0 : _l["_MainTex"];
    const baseColorTexture = baseColorTextureIndex != null ? {
      index: baseColorTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const normalTextureScale = (_n2 = (_m = materialProperties.floatProperties) == null ? void 0 : _m["_BumpScale"]) != null ? _n2 : 1;
    const normalTextureIndex = (_o2 = materialProperties.textureProperties) == null ? void 0 : _o2["_BumpMap"];
    const normalTexture = normalTextureIndex != null ? {
      index: normalTextureIndex,
      scale: normalTextureScale,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const emissiveFactor = ((_q = (_p = materialProperties.vectorProperties) == null ? void 0 : _p["_EmissionColor"]) != null ? _q : [0, 0, 0, 1]).map(
      gammaEOTF
    );
    const emissiveTextureIndex = (_r2 = materialProperties.textureProperties) == null ? void 0 : _r2["_EmissionMap"];
    const emissiveTexture = emissiveTextureIndex != null ? {
      index: emissiveTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const shadeColorFactor = ((_t2 = (_s2 = materialProperties.vectorProperties) == null ? void 0 : _s2["_ShadeColor"]) != null ? _t2 : [0.97, 0.81, 0.86, 1]).map(
      gammaEOTF
    );
    const shadeMultiplyTextureIndex = (_u = materialProperties.textureProperties) == null ? void 0 : _u["_ShadeTexture"];
    const shadeMultiplyTexture = shadeMultiplyTextureIndex != null ? {
      index: shadeMultiplyTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    let shadingShiftFactor = (_w = (_v = materialProperties.floatProperties) == null ? void 0 : _v["_ShadeShift"]) != null ? _w : 0;
    let shadingToonyFactor = (_y2 = (_x2 = materialProperties.floatProperties) == null ? void 0 : _x2["_ShadeToony"]) != null ? _y2 : 0.9;
    shadingToonyFactor = MathUtils.lerp(shadingToonyFactor, 1, 0.5 + 0.5 * shadingShiftFactor);
    shadingShiftFactor = -shadingShiftFactor - (1 - shadingToonyFactor);
    const giIntensityFactor = (_A = (_z2 = materialProperties.floatProperties) == null ? void 0 : _z2["_IndirectLightIntensity"]) != null ? _A : 0.1;
    const giEqualizationFactor = giIntensityFactor ? 1 - giIntensityFactor : void 0;
    const matcapTextureIndex = (_B = materialProperties.textureProperties) == null ? void 0 : _B["_SphereAdd"];
    const matcapFactor = matcapTextureIndex != null ? [1, 1, 1] : void 0;
    const matcapTexture = matcapTextureIndex != null ? {
      index: matcapTextureIndex
    } : void 0;
    const rimLightingMixFactor = (_D = (_C = materialProperties.floatProperties) == null ? void 0 : _C["_RimLightingMix"]) != null ? _D : 0;
    const rimMultiplyTextureIndex = (_E = materialProperties.textureProperties) == null ? void 0 : _E["_RimTexture"];
    const rimMultiplyTexture = rimMultiplyTextureIndex != null ? {
      index: rimMultiplyTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const parametricRimColorFactor = ((_G = (_F = materialProperties.vectorProperties) == null ? void 0 : _F["_RimColor"]) != null ? _G : [0, 0, 0, 1]).map(
      gammaEOTF
    );
    const parametricRimFresnelPowerFactor = (_I = (_H = materialProperties.floatProperties) == null ? void 0 : _H["_RimFresnelPower"]) != null ? _I : 1;
    const parametricRimLiftFactor = (_K = (_J = materialProperties.floatProperties) == null ? void 0 : _J["_RimLift"]) != null ? _K : 0;
    const outlineWidthMode = ["none", "worldCoordinates", "screenCoordinates"][(_M = (_L = materialProperties.floatProperties) == null ? void 0 : _L["_OutlineWidthMode"]) != null ? _M : 0];
    let outlineWidthFactor = (_O = (_N = materialProperties.floatProperties) == null ? void 0 : _N["_OutlineWidth"]) != null ? _O : 0;
    outlineWidthFactor = 0.01 * outlineWidthFactor;
    const outlineWidthMultiplyTextureIndex = (_P = materialProperties.textureProperties) == null ? void 0 : _P["_OutlineWidthTexture"];
    const outlineWidthMultiplyTexture = outlineWidthMultiplyTextureIndex != null ? {
      index: outlineWidthMultiplyTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const outlineColorFactor = ((_R = (_Q = materialProperties.vectorProperties) == null ? void 0 : _Q["_OutlineColor"]) != null ? _R : [0, 0, 0]).map(
      gammaEOTF
    );
    const outlineColorMode = (_T = (_S = materialProperties.floatProperties) == null ? void 0 : _S["_OutlineColorMode"]) != null ? _T : 0;
    const outlineLightingMixFactor = outlineColorMode === 1 ? (_V = (_U = materialProperties.floatProperties) == null ? void 0 : _U["_OutlineLightingMix"]) != null ? _V : 1 : 0;
    const uvAnimationMaskTextureIndex = (_W = materialProperties.textureProperties) == null ? void 0 : _W["_UvAnimMaskTexture"];
    const uvAnimationMaskTexture = uvAnimationMaskTextureIndex != null ? {
      index: uvAnimationMaskTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const uvAnimationScrollXSpeedFactor = (_Y = (_X = materialProperties.floatProperties) == null ? void 0 : _X["_UvAnimScrollX"]) != null ? _Y : 0;
    let uvAnimationScrollYSpeedFactor = (__ = (_Z = materialProperties.floatProperties) == null ? void 0 : _Z["_UvAnimScrollY"]) != null ? __ : 0;
    if (uvAnimationScrollYSpeedFactor != null) {
      uvAnimationScrollYSpeedFactor = -uvAnimationScrollYSpeedFactor;
    }
    const uvAnimationRotationSpeedFactor = (_aa = (_$ = materialProperties.floatProperties) == null ? void 0 : _$["_UvAnimRotation"]) != null ? _aa : 0;
    const mtoonExtension = {
      specVersion: "1.0",
      transparentWithZWrite,
      renderQueueOffsetNumber,
      shadeColorFactor,
      shadeMultiplyTexture,
      shadingShiftFactor,
      shadingToonyFactor,
      giEqualizationFactor,
      matcapFactor,
      matcapTexture,
      rimLightingMixFactor,
      rimMultiplyTexture,
      parametricRimColorFactor,
      parametricRimFresnelPowerFactor,
      parametricRimLiftFactor,
      outlineWidthMode,
      outlineWidthFactor,
      outlineWidthMultiplyTexture,
      outlineColorFactor,
      outlineLightingMixFactor,
      uvAnimationMaskTexture,
      uvAnimationScrollXSpeedFactor,
      uvAnimationScrollYSpeedFactor,
      uvAnimationRotationSpeedFactor
    };
    return __spreadProps(__spreadValues2({}, schemaMaterial), {
      pbrMetallicRoughness: {
        baseColorFactor,
        baseColorTexture
      },
      normalTexture,
      emissiveTexture,
      emissiveFactor,
      alphaMode,
      alphaCutoff,
      doubleSided,
      extensions: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        VRMC_materials_mtoon: mtoonExtension
      }
    });
  }
  _parseV0UnlitProperties(materialProperties, schemaMaterial) {
    var _a2, _b, _c2, _d, _e2;
    const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
    const isTransparent = materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
    const renderQueueOffsetNumber = this._v0ParseRenderQueue(materialProperties);
    const isCutoff = materialProperties.shader === "VRM/UnlitCutout";
    const alphaMode = isTransparent ? "BLEND" : isCutoff ? "MASK" : "OPAQUE";
    const alphaCutoff = isCutoff ? (_b = (_a2 = materialProperties.floatProperties) == null ? void 0 : _a2["_Cutoff"]) != null ? _b : 0.5 : void 0;
    const textureTransformExt = this._portTextureTransform(materialProperties);
    const baseColorFactor = ((_d = (_c2 = materialProperties.vectorProperties) == null ? void 0 : _c2["_Color"]) != null ? _d : [1, 1, 1, 1]).map(gammaEOTF);
    const baseColorTextureIndex = (_e2 = materialProperties.textureProperties) == null ? void 0 : _e2["_MainTex"];
    const baseColorTexture = baseColorTextureIndex != null ? {
      index: baseColorTextureIndex,
      extensions: __spreadValues2({}, textureTransformExt)
    } : void 0;
    const mtoonExtension = {
      specVersion: "1.0",
      transparentWithZWrite: isTransparentZWrite,
      renderQueueOffsetNumber,
      shadeColorFactor: baseColorFactor,
      shadeMultiplyTexture: baseColorTexture
    };
    return __spreadProps(__spreadValues2({}, schemaMaterial), {
      pbrMetallicRoughness: {
        baseColorFactor,
        baseColorTexture
      },
      alphaMode,
      alphaCutoff,
      extensions: {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        VRMC_materials_mtoon: mtoonExtension
      }
    });
  }
  /**
   * Create a glTF `KHR_texture_transform` extension from v0 texture transform info.
   */
  _portTextureTransform(materialProperties) {
    var _a2, _b, _c2, _d, _e2;
    const textureTransform = (_a2 = materialProperties.vectorProperties) == null ? void 0 : _a2["_MainTex"];
    if (textureTransform == null) {
      return {};
    }
    const offset = [(_b = textureTransform == null ? void 0 : textureTransform[0]) != null ? _b : 0, (_c2 = textureTransform == null ? void 0 : textureTransform[1]) != null ? _c2 : 0];
    const scale = [(_d = textureTransform == null ? void 0 : textureTransform[2]) != null ? _d : 1, (_e2 = textureTransform == null ? void 0 : textureTransform[3]) != null ? _e2 : 1];
    offset[1] = 1 - scale[1] - offset[1];
    return {
      // eslint-disable-next-line @typescript-eslint/naming-convention
      KHR_texture_transform: { offset, scale }
    };
  }
  /**
   * Convert v0 render order into v1 render order.
   * This uses a map from v0 render queue to v1 compliant render queue offset which is generated in {@link _populateRenderQueueMap}.
   */
  _v0ParseRenderQueue(materialProperties) {
    var _a2, _b;
    const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
    const isTransparent = ((_a2 = materialProperties.keywordMap) == null ? void 0 : _a2["_ALPHABLEND_ON"]) != void 0 || materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
    const enabledZWrite = ((_b = materialProperties.floatProperties) == null ? void 0 : _b["_ZWrite"]) === 1 || isTransparentZWrite;
    let offset = 0;
    if (isTransparent) {
      const v0Queue = materialProperties.renderQueue;
      if (v0Queue != null) {
        if (enabledZWrite) {
          offset = this._renderQueueMapTransparentZWrite.get(v0Queue);
        } else {
          offset = this._renderQueueMapTransparent.get(v0Queue);
        }
      }
    }
    return offset;
  }
  /**
   * Create a map which maps v0 render queue to v1 compliant render queue offset.
   * This lists up all render queues the model use and creates a map to new render queue offsets in the same order.
   */
  _populateRenderQueueMap(materialPropertiesList) {
    const renderQueuesTransparent = /* @__PURE__ */ new Set();
    const renderQueuesTransparentZWrite = /* @__PURE__ */ new Set();
    materialPropertiesList.forEach((materialProperties) => {
      var _a2, _b;
      const isTransparentZWrite = materialProperties.shader === "VRM/UnlitTransparentZWrite";
      const isTransparent = ((_a2 = materialProperties.keywordMap) == null ? void 0 : _a2["_ALPHABLEND_ON"]) != void 0 || materialProperties.shader === "VRM/UnlitTransparent" || isTransparentZWrite;
      const enabledZWrite = ((_b = materialProperties.floatProperties) == null ? void 0 : _b["_ZWrite"]) === 1 || isTransparentZWrite;
      if (isTransparent) {
        const v0Queue = materialProperties.renderQueue;
        if (v0Queue != null) {
          if (enabledZWrite) {
            renderQueuesTransparentZWrite.add(v0Queue);
          } else {
            renderQueuesTransparent.add(v0Queue);
          }
        }
      }
    });
    if (renderQueuesTransparent.size > 10) {
      console.warn(
        `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparent.size} render queues for Transparent materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`
      );
    }
    if (renderQueuesTransparentZWrite.size > 10) {
      console.warn(
        `VRMMaterialsV0CompatPlugin: This VRM uses ${renderQueuesTransparentZWrite.size} render queues for TransparentZWrite materials while VRM 1.0 only supports up to 10 render queues. The model might not be rendered correctly.`
      );
    }
    Array.from(renderQueuesTransparent).sort().forEach((queue, i2) => {
      const newQueueOffset = Math.min(Math.max(i2 - renderQueuesTransparent.size + 1, -9), 0);
      this._renderQueueMapTransparent.set(queue, newQueueOffset);
    });
    Array.from(renderQueuesTransparentZWrite).sort().forEach((queue, i2) => {
      const newQueueOffset = Math.min(Math.max(i2, 0), 9);
      this._renderQueueMapTransparentZWrite.set(queue, newQueueOffset);
    });
  }
};
var __async6 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var _v3A6 = new Vector3();
var VRMNodeConstraintHelper = class extends Group {
  constructor(constraint) {
    super();
    this._attrPosition = new BufferAttribute(new Float32Array([0, 0, 0, 0, 0, 0]), 3);
    this._attrPosition.setUsage(DynamicDrawUsage);
    const geometry = new BufferGeometry();
    geometry.setAttribute("position", this._attrPosition);
    const material = new LineBasicMaterial({
      color: 16711935,
      depthTest: false,
      depthWrite: false
    });
    this._line = new Line(geometry, material);
    this.add(this._line);
    this.constraint = constraint;
  }
  updateMatrixWorld(force) {
    _v3A6.setFromMatrixPosition(this.constraint.destination.matrixWorld);
    this._attrPosition.setXYZ(0, _v3A6.x, _v3A6.y, _v3A6.z);
    if (this.constraint.source) {
      _v3A6.setFromMatrixPosition(this.constraint.source.matrixWorld);
    }
    this._attrPosition.setXYZ(1, _v3A6.x, _v3A6.y, _v3A6.z);
    this._attrPosition.needsUpdate = true;
    super.updateMatrixWorld(force);
  }
};
function decomposePosition(matrix, target) {
  return target.set(matrix.elements[12], matrix.elements[13], matrix.elements[14]);
}
var _v3A22 = new Vector3();
var _v3B4 = new Vector3();
function decomposeRotation(matrix, target) {
  matrix.decompose(_v3A22, target, _v3B4);
  return target;
}
function quatInvertCompat2(target) {
  if (target.invert) {
    target.invert();
  } else {
    target.inverse();
  }
  return target;
}
var VRMNodeConstraint = class {
  /**
   * @param destination The destination object
   * @param source The source object
   */
  constructor(destination, source) {
    this.destination = destination;
    this.source = source;
    this.weight = 1;
  }
};
var _v3A32 = new Vector3();
var _v3B22 = new Vector3();
var _v3C2 = new Vector3();
var _quatA7 = new Quaternion();
var _quatB4 = new Quaternion();
var _quatC2 = new Quaternion();
var VRMAimConstraint = class extends VRMNodeConstraint {
  /**
   * The aim axis of the constraint.
   */
  get aimAxis() {
    return this._aimAxis;
  }
  /**
   * The aim axis of the constraint.
   */
  set aimAxis(aimAxis) {
    this._aimAxis = aimAxis;
    this._v3AimAxis.set(
      aimAxis === "PositiveX" ? 1 : aimAxis === "NegativeX" ? -1 : 0,
      aimAxis === "PositiveY" ? 1 : aimAxis === "NegativeY" ? -1 : 0,
      aimAxis === "PositiveZ" ? 1 : aimAxis === "NegativeZ" ? -1 : 0
    );
  }
  get dependencies() {
    const set = /* @__PURE__ */ new Set([this.source]);
    if (this.destination.parent) {
      set.add(this.destination.parent);
    }
    return set;
  }
  constructor(destination, source) {
    super(destination, source);
    this._aimAxis = "PositiveX";
    this._v3AimAxis = new Vector3(1, 0, 0);
    this._dstRestQuat = new Quaternion();
  }
  setInitState() {
    this._dstRestQuat.copy(this.destination.quaternion);
  }
  update() {
    this.destination.updateWorldMatrix(true, false);
    this.source.updateWorldMatrix(true, false);
    const dstParentWorldQuat = _quatA7.identity();
    const invDstParentWorldQuat = _quatB4.identity();
    if (this.destination.parent) {
      decomposeRotation(this.destination.parent.matrixWorld, dstParentWorldQuat);
      quatInvertCompat2(invDstParentWorldQuat.copy(dstParentWorldQuat));
    }
    const a0 = _v3A32.copy(this._v3AimAxis).applyQuaternion(this._dstRestQuat).applyQuaternion(dstParentWorldQuat);
    const a1 = decomposePosition(this.source.matrixWorld, _v3B22).sub(decomposePosition(this.destination.matrixWorld, _v3C2)).normalize();
    const targetQuat = _quatC2.setFromUnitVectors(a0, a1).premultiply(invDstParentWorldQuat).multiply(dstParentWorldQuat).multiply(this._dstRestQuat);
    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
  }
};
function traverseAncestorsFromRoot(object, callback) {
  const ancestors = [object];
  let head = object.parent;
  while (head !== null) {
    ancestors.unshift(head);
    head = head.parent;
  }
  ancestors.forEach((ancestor) => {
    callback(ancestor);
  });
}
var VRMNodeConstraintManager = class {
  constructor() {
    this._constraints = /* @__PURE__ */ new Set();
    this._objectConstraintsMap = /* @__PURE__ */ new Map();
  }
  get constraints() {
    return this._constraints;
  }
  addConstraint(constraint) {
    this._constraints.add(constraint);
    let objectSet = this._objectConstraintsMap.get(constraint.destination);
    if (objectSet == null) {
      objectSet = /* @__PURE__ */ new Set();
      this._objectConstraintsMap.set(constraint.destination, objectSet);
    }
    objectSet.add(constraint);
  }
  deleteConstraint(constraint) {
    this._constraints.delete(constraint);
    const objectSet = this._objectConstraintsMap.get(constraint.destination);
    objectSet.delete(constraint);
  }
  setInitState() {
    const constraintsTried = /* @__PURE__ */ new Set();
    const constraintsDone = /* @__PURE__ */ new Set();
    for (const constraint of this._constraints) {
      this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint2) => constraint2.setInitState());
    }
  }
  update() {
    const constraintsTried = /* @__PURE__ */ new Set();
    const constraintsDone = /* @__PURE__ */ new Set();
    for (const constraint of this._constraints) {
      this._processConstraint(constraint, constraintsTried, constraintsDone, (constraint2) => constraint2.update());
    }
  }
  /**
   * Update a constraint.
   * If there are other constraints that are dependant, it will try to update them recursively.
   * It might throw an error if there are circular dependencies.
   *
   * Intended to be used in {@link update} and {@link _processConstraint} itself recursively.
   *
   * @param constraint A constraint you want to update
   * @param constraintsTried Set of constraints that are already tried to be updated
   * @param constraintsDone Set of constraints that are already up to date
   */
  _processConstraint(constraint, constraintsTried, constraintsDone, callback) {
    if (constraintsDone.has(constraint)) {
      return;
    }
    if (constraintsTried.has(constraint)) {
      throw new Error("VRMNodeConstraintManager: Circular dependency detected while updating constraints");
    }
    constraintsTried.add(constraint);
    const depObjects = constraint.dependencies;
    for (const depObject of depObjects) {
      traverseAncestorsFromRoot(depObject, (depObjectAncestor) => {
        const objectSet = this._objectConstraintsMap.get(depObjectAncestor);
        if (objectSet) {
          for (const depConstraint of objectSet) {
            this._processConstraint(depConstraint, constraintsTried, constraintsDone, callback);
          }
        }
      });
    }
    callback(constraint);
    constraintsDone.add(constraint);
  }
};
var _quatA22 = new Quaternion();
var _quatB22 = new Quaternion();
var VRMRotationConstraint = class extends VRMNodeConstraint {
  get dependencies() {
    return /* @__PURE__ */ new Set([this.source]);
  }
  constructor(destination, source) {
    super(destination, source);
    this._dstRestQuat = new Quaternion();
    this._invSrcRestQuat = new Quaternion();
  }
  setInitState() {
    this._dstRestQuat.copy(this.destination.quaternion);
    quatInvertCompat2(this._invSrcRestQuat.copy(this.source.quaternion));
  }
  update() {
    const srcDeltaQuat = _quatA22.copy(this._invSrcRestQuat).multiply(this.source.quaternion);
    const targetQuat = _quatB22.copy(this._dstRestQuat).multiply(srcDeltaQuat);
    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
  }
};
var _v3A42 = new Vector3();
var _quatA32 = new Quaternion();
var _quatB32 = new Quaternion();
var VRMRollConstraint = class extends VRMNodeConstraint {
  /**
   * The roll axis of the constraint.
   */
  get rollAxis() {
    return this._rollAxis;
  }
  /**
   * The roll axis of the constraint.
   */
  set rollAxis(rollAxis) {
    this._rollAxis = rollAxis;
    this._v3RollAxis.set(rollAxis === "X" ? 1 : 0, rollAxis === "Y" ? 1 : 0, rollAxis === "Z" ? 1 : 0);
  }
  get dependencies() {
    return /* @__PURE__ */ new Set([this.source]);
  }
  constructor(destination, source) {
    super(destination, source);
    this._rollAxis = "X";
    this._v3RollAxis = new Vector3(1, 0, 0);
    this._dstRestQuat = new Quaternion();
    this._invDstRestQuat = new Quaternion();
    this._invSrcRestQuatMulDstRestQuat = new Quaternion();
  }
  setInitState() {
    this._dstRestQuat.copy(this.destination.quaternion);
    quatInvertCompat2(this._invDstRestQuat.copy(this._dstRestQuat));
    quatInvertCompat2(this._invSrcRestQuatMulDstRestQuat.copy(this.source.quaternion)).multiply(this._dstRestQuat);
  }
  update() {
    const quatDelta = _quatA32.copy(this._invDstRestQuat).multiply(this.source.quaternion).multiply(this._invSrcRestQuatMulDstRestQuat);
    const n1 = _v3A42.copy(this._v3RollAxis).applyQuaternion(quatDelta);
    const quatFromTo = _quatB32.setFromUnitVectors(n1, this._v3RollAxis);
    const targetQuat = quatFromTo.premultiply(this._dstRestQuat).multiply(quatDelta);
    this.destination.quaternion.copy(this._dstRestQuat).slerp(targetQuat, this.weight);
  }
};
var POSSIBLE_SPEC_VERSIONS7 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var _VRMNodeConstraintLoaderPlugin = class _VRMNodeConstraintLoaderPlugin2 {
  get name() {
    return _VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME;
  }
  constructor(parser, options) {
    this.parser = parser;
    this.helperRoot = options == null ? void 0 : options.helperRoot;
  }
  afterRoot(gltf) {
    return __async6(this, null, function* () {
      gltf.userData.vrmNodeConstraintManager = yield this._import(gltf);
    });
  }
  /**
   * Import constraints from a GLTF and returns a {@link VRMNodeConstraintManager}.
   * It might return `null` instead when it does not need to be created or something go wrong.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   */
  _import(gltf) {
    return __async6(this, null, function* () {
      var _a2;
      const json = this.parser.json;
      const isConstraintsUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf(_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME)) !== -1;
      if (!isConstraintsUsed) {
        return null;
      }
      const manager = new VRMNodeConstraintManager();
      const threeNodes = yield this.parser.getDependencies("node");
      threeNodes.forEach((node, nodeIndex) => {
        var _a22;
        const schemaNode = json.nodes[nodeIndex];
        const extension = (_a22 = schemaNode == null ? void 0 : schemaNode.extensions) == null ? void 0 : _a22[_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME];
        if (extension == null) {
          return;
        }
        const specVersion = extension.specVersion;
        if (!POSSIBLE_SPEC_VERSIONS7.has(specVersion)) {
          console.warn(
            `VRMNodeConstraintLoaderPlugin: Unknown ${_VRMNodeConstraintLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
          );
          return;
        }
        const constraintDef = extension.constraint;
        if (constraintDef.roll != null) {
          const constraint = this._importRollConstraint(node, threeNodes, constraintDef.roll);
          manager.addConstraint(constraint);
        } else if (constraintDef.aim != null) {
          const constraint = this._importAimConstraint(node, threeNodes, constraintDef.aim);
          manager.addConstraint(constraint);
        } else if (constraintDef.rotation != null) {
          const constraint = this._importRotationConstraint(node, threeNodes, constraintDef.rotation);
          manager.addConstraint(constraint);
        }
      });
      gltf.scene.updateMatrixWorld();
      manager.setInitState();
      return manager;
    });
  }
  _importRollConstraint(destination, nodes, rollConstraintDef) {
    const { source: sourceIndex, rollAxis, weight } = rollConstraintDef;
    const source = nodes[sourceIndex];
    const constraint = new VRMRollConstraint(destination, source);
    if (rollAxis != null) {
      constraint.rollAxis = rollAxis;
    }
    if (weight != null) {
      constraint.weight = weight;
    }
    if (this.helperRoot) {
      const helper = new VRMNodeConstraintHelper(constraint);
      this.helperRoot.add(helper);
    }
    return constraint;
  }
  _importAimConstraint(destination, nodes, aimConstraintDef) {
    const { source: sourceIndex, aimAxis, weight } = aimConstraintDef;
    const source = nodes[sourceIndex];
    const constraint = new VRMAimConstraint(destination, source);
    if (aimAxis != null) {
      constraint.aimAxis = aimAxis;
    }
    if (weight != null) {
      constraint.weight = weight;
    }
    if (this.helperRoot) {
      const helper = new VRMNodeConstraintHelper(constraint);
      this.helperRoot.add(helper);
    }
    return constraint;
  }
  _importRotationConstraint(destination, nodes, rotationConstraintDef) {
    const { source: sourceIndex, weight } = rotationConstraintDef;
    const source = nodes[sourceIndex];
    const constraint = new VRMRotationConstraint(destination, source);
    if (weight != null) {
      constraint.weight = weight;
    }
    if (this.helperRoot) {
      const helper = new VRMNodeConstraintHelper(constraint);
      this.helperRoot.add(helper);
    }
    return constraint;
  }
};
_VRMNodeConstraintLoaderPlugin.EXTENSION_NAME = "VRMC_node_constraint";
var VRMNodeConstraintLoaderPlugin = _VRMNodeConstraintLoaderPlugin;
var __async7 = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e2) {
        reject(e2);
      }
    };
    var step = (x2) => x2.done ? resolve(x2.value) : Promise.resolve(x2.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var VRMSpringBoneColliderShape = class {
};
var _v3A7 = new Vector3();
var _v3B5 = new Vector3();
var VRMSpringBoneColliderShapeCapsule = class extends VRMSpringBoneColliderShape {
  get type() {
    return "capsule";
  }
  constructor(params) {
    var _a2, _b, _c2, _d;
    super();
    this.offset = (_a2 = params == null ? void 0 : params.offset) != null ? _a2 : new Vector3(0, 0, 0);
    this.tail = (_b = params == null ? void 0 : params.tail) != null ? _b : new Vector3(0, 0, 0);
    this.radius = (_c2 = params == null ? void 0 : params.radius) != null ? _c2 : 0;
    this.inside = (_d = params == null ? void 0 : params.inside) != null ? _d : false;
  }
  calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
    _v3A7.setFromMatrixPosition(colliderMatrix);
    _v3B5.subVectors(this.tail, this.offset).applyMatrix4(colliderMatrix);
    _v3B5.sub(_v3A7);
    const lengthSqCapsule = _v3B5.lengthSq();
    target.copy(objectPosition).sub(_v3A7);
    const dot = _v3B5.dot(target);
    if (dot <= 0) {
    } else if (lengthSqCapsule <= dot) {
      target.sub(_v3B5);
    } else {
      _v3B5.multiplyScalar(dot / lengthSqCapsule);
      target.sub(_v3B5);
    }
    const length = target.length();
    const distance = this.inside ? this.radius - objectRadius - length : length - objectRadius - this.radius;
    if (distance < 0) {
      target.multiplyScalar(1 / length);
      if (this.inside) {
        target.negate();
      }
    }
    return distance;
  }
};
var _v3A23 = new Vector3();
var _mat3A = new Matrix3();
var VRMSpringBoneColliderShapePlane = class extends VRMSpringBoneColliderShape {
  get type() {
    return "plane";
  }
  constructor(params) {
    var _a2, _b;
    super();
    this.offset = (_a2 = params == null ? void 0 : params.offset) != null ? _a2 : new Vector3(0, 0, 0);
    this.normal = (_b = params == null ? void 0 : params.normal) != null ? _b : new Vector3(0, 0, 1);
  }
  calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
    target.setFromMatrixPosition(colliderMatrix);
    target.negate().add(objectPosition);
    _mat3A.getNormalMatrix(colliderMatrix);
    _v3A23.copy(this.normal).applyNormalMatrix(_mat3A).normalize();
    const distance = target.dot(_v3A23) - objectRadius;
    target.copy(_v3A23);
    return distance;
  }
};
var _v3A33 = new Vector3();
var VRMSpringBoneColliderShapeSphere = class extends VRMSpringBoneColliderShape {
  get type() {
    return "sphere";
  }
  constructor(params) {
    var _a2, _b, _c2;
    super();
    this.offset = (_a2 = params == null ? void 0 : params.offset) != null ? _a2 : new Vector3(0, 0, 0);
    this.radius = (_b = params == null ? void 0 : params.radius) != null ? _b : 0;
    this.inside = (_c2 = params == null ? void 0 : params.inside) != null ? _c2 : false;
  }
  calculateCollision(colliderMatrix, objectPosition, objectRadius, target) {
    target.subVectors(objectPosition, _v3A33.setFromMatrixPosition(colliderMatrix));
    const length = target.length();
    const distance = this.inside ? this.radius - objectRadius - length : length - objectRadius - this.radius;
    if (distance < 0) {
      target.multiplyScalar(1 / length);
      if (this.inside) {
        target.negate();
      }
    }
    return distance;
  }
};
var _v3A43 = new Vector3();
var ColliderShapeCapsuleBufferGeometry = class extends BufferGeometry {
  constructor(shape) {
    super();
    this.worldScale = 1;
    this._currentRadius = 0;
    this._currentOffset = new Vector3();
    this._currentTail = new Vector3();
    this._shape = shape;
    this._attrPos = new BufferAttribute(new Float32Array(396), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(264), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    const radius = this._shape.radius / this.worldScale;
    if (this._currentRadius !== radius) {
      this._currentRadius = radius;
      shouldUpdateGeometry = true;
    }
    if (!this._currentOffset.equals(this._shape.offset)) {
      this._currentOffset.copy(this._shape.offset);
      shouldUpdateGeometry = true;
    }
    const tail = _v3A43.copy(this._shape.tail).divideScalar(this.worldScale);
    if (this._currentTail.distanceToSquared(tail) > 1e-10) {
      this._currentTail.copy(tail);
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    _v3A43.copy(this._currentTail).sub(this._currentOffset);
    const l2 = _v3A43.length() / this._currentRadius;
    for (let i2 = 0; i2 <= 16; i2++) {
      const t2 = i2 / 16 * Math.PI;
      this._attrPos.setXYZ(i2, -Math.sin(t2), -Math.cos(t2), 0);
      this._attrPos.setXYZ(17 + i2, l2 + Math.sin(t2), Math.cos(t2), 0);
      this._attrPos.setXYZ(34 + i2, -Math.sin(t2), 0, -Math.cos(t2));
      this._attrPos.setXYZ(51 + i2, l2 + Math.sin(t2), 0, Math.cos(t2));
    }
    for (let i2 = 0; i2 < 32; i2++) {
      const t2 = i2 / 16 * Math.PI;
      this._attrPos.setXYZ(68 + i2, 0, Math.sin(t2), Math.cos(t2));
      this._attrPos.setXYZ(100 + i2, l2, Math.sin(t2), Math.cos(t2));
    }
    const theta = Math.atan2(_v3A43.y, Math.sqrt(_v3A43.x * _v3A43.x + _v3A43.z * _v3A43.z));
    const phi = -Math.atan2(_v3A43.z, _v3A43.x);
    this.rotateZ(theta);
    this.rotateY(phi);
    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    for (let i2 = 0; i2 < 34; i2++) {
      const i1 = (i2 + 1) % 34;
      this._attrIndex.setXY(i2 * 2, i2, i1);
      this._attrIndex.setXY(68 + i2 * 2, 34 + i2, 34 + i1);
    }
    for (let i2 = 0; i2 < 32; i2++) {
      const i1 = (i2 + 1) % 32;
      this._attrIndex.setXY(136 + i2 * 2, 68 + i2, 68 + i1);
      this._attrIndex.setXY(200 + i2 * 2, 100 + i2, 100 + i1);
    }
    this._attrIndex.needsUpdate = true;
  }
};
var ColliderShapePlaneBufferGeometry = class extends BufferGeometry {
  constructor(shape) {
    super();
    this.worldScale = 1;
    this._currentOffset = new Vector3();
    this._currentNormal = new Vector3();
    this._shape = shape;
    this._attrPos = new BufferAttribute(new Float32Array(6 * 3), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(10), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    if (!this._currentOffset.equals(this._shape.offset)) {
      this._currentOffset.copy(this._shape.offset);
      shouldUpdateGeometry = true;
    }
    if (!this._currentNormal.equals(this._shape.normal)) {
      this._currentNormal.copy(this._shape.normal);
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    this._attrPos.setXYZ(0, -0.5, -0.5, 0);
    this._attrPos.setXYZ(1, 0.5, -0.5, 0);
    this._attrPos.setXYZ(2, 0.5, 0.5, 0);
    this._attrPos.setXYZ(3, -0.5, 0.5, 0);
    this._attrPos.setXYZ(4, 0, 0, 0);
    this._attrPos.setXYZ(5, 0, 0, 0.25);
    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
    this.lookAt(this._currentNormal);
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    this._attrIndex.setXY(0, 0, 1);
    this._attrIndex.setXY(2, 1, 2);
    this._attrIndex.setXY(4, 2, 3);
    this._attrIndex.setXY(6, 3, 0);
    this._attrIndex.setXY(8, 4, 5);
    this._attrIndex.needsUpdate = true;
  }
};
var ColliderShapeSphereBufferGeometry = class extends BufferGeometry {
  constructor(shape) {
    super();
    this.worldScale = 1;
    this._currentRadius = 0;
    this._currentOffset = new Vector3();
    this._shape = shape;
    this._attrPos = new BufferAttribute(new Float32Array(32 * 3 * 3), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(64 * 3), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    const radius = this._shape.radius / this.worldScale;
    if (this._currentRadius !== radius) {
      this._currentRadius = radius;
      shouldUpdateGeometry = true;
    }
    if (!this._currentOffset.equals(this._shape.offset)) {
      this._currentOffset.copy(this._shape.offset);
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    for (let i2 = 0; i2 < 32; i2++) {
      const t2 = i2 / 16 * Math.PI;
      this._attrPos.setXYZ(i2, Math.cos(t2), Math.sin(t2), 0);
      this._attrPos.setXYZ(32 + i2, 0, Math.cos(t2), Math.sin(t2));
      this._attrPos.setXYZ(64 + i2, Math.sin(t2), 0, Math.cos(t2));
    }
    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
    this.translate(this._currentOffset.x, this._currentOffset.y, this._currentOffset.z);
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    for (let i2 = 0; i2 < 32; i2++) {
      const i1 = (i2 + 1) % 32;
      this._attrIndex.setXY(i2 * 2, i2, i1);
      this._attrIndex.setXY(64 + i2 * 2, 32 + i2, 32 + i1);
      this._attrIndex.setXY(128 + i2 * 2, 64 + i2, 64 + i1);
    }
    this._attrIndex.needsUpdate = true;
  }
};
var _v3A52 = new Vector3();
var VRMSpringBoneColliderHelper = class extends Group {
  constructor(collider) {
    super();
    this.matrixAutoUpdate = false;
    this.collider = collider;
    if (this.collider.shape instanceof VRMSpringBoneColliderShapeSphere) {
      this._geometry = new ColliderShapeSphereBufferGeometry(this.collider.shape);
    } else if (this.collider.shape instanceof VRMSpringBoneColliderShapeCapsule) {
      this._geometry = new ColliderShapeCapsuleBufferGeometry(this.collider.shape);
    } else if (this.collider.shape instanceof VRMSpringBoneColliderShapePlane) {
      this._geometry = new ColliderShapePlaneBufferGeometry(this.collider.shape);
    } else {
      throw new Error("VRMSpringBoneColliderHelper: Unknown collider shape type detected");
    }
    const material = new LineBasicMaterial({
      color: 16711935,
      depthTest: false,
      depthWrite: false
    });
    this._line = new LineSegments(this._geometry, material);
    this.add(this._line);
  }
  dispose() {
    this._geometry.dispose();
  }
  updateMatrixWorld(force) {
    this.collider.updateWorldMatrix(true, false);
    this.matrix.copy(this.collider.matrixWorld);
    const matrixWorldElements = this.matrix.elements;
    this._geometry.worldScale = _v3A52.set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2]).length();
    this._geometry.update();
    super.updateMatrixWorld(force);
  }
};
var SpringBoneBufferGeometry = class extends BufferGeometry {
  constructor(springBone) {
    super();
    this.worldScale = 1;
    this._currentRadius = 0;
    this._currentTail = new Vector3();
    this._springBone = springBone;
    this._attrPos = new BufferAttribute(new Float32Array(294), 3);
    this.setAttribute("position", this._attrPos);
    this._attrIndex = new BufferAttribute(new Uint16Array(194), 1);
    this.setIndex(this._attrIndex);
    this._buildIndex();
    this.update();
  }
  update() {
    let shouldUpdateGeometry = false;
    const radius = this._springBone.settings.hitRadius / this.worldScale;
    if (this._currentRadius !== radius) {
      this._currentRadius = radius;
      shouldUpdateGeometry = true;
    }
    if (!this._currentTail.equals(this._springBone.initialLocalChildPosition)) {
      this._currentTail.copy(this._springBone.initialLocalChildPosition);
      shouldUpdateGeometry = true;
    }
    if (shouldUpdateGeometry) {
      this._buildPosition();
    }
  }
  _buildPosition() {
    for (let i2 = 0; i2 < 32; i2++) {
      const t2 = i2 / 16 * Math.PI;
      this._attrPos.setXYZ(i2, Math.cos(t2), Math.sin(t2), 0);
      this._attrPos.setXYZ(32 + i2, 0, Math.cos(t2), Math.sin(t2));
      this._attrPos.setXYZ(64 + i2, Math.sin(t2), 0, Math.cos(t2));
    }
    this.scale(this._currentRadius, this._currentRadius, this._currentRadius);
    this.translate(this._currentTail.x, this._currentTail.y, this._currentTail.z);
    this._attrPos.setXYZ(96, 0, 0, 0);
    this._attrPos.setXYZ(97, this._currentTail.x, this._currentTail.y, this._currentTail.z);
    this._attrPos.needsUpdate = true;
  }
  _buildIndex() {
    for (let i2 = 0; i2 < 32; i2++) {
      const i1 = (i2 + 1) % 32;
      this._attrIndex.setXY(i2 * 2, i2, i1);
      this._attrIndex.setXY(64 + i2 * 2, 32 + i2, 32 + i1);
      this._attrIndex.setXY(128 + i2 * 2, 64 + i2, 64 + i1);
    }
    this._attrIndex.setXY(192, 96, 97);
    this._attrIndex.needsUpdate = true;
  }
};
var _v3A62 = new Vector3();
var VRMSpringBoneJointHelper = class extends Group {
  constructor(springBone) {
    super();
    this.matrixAutoUpdate = false;
    this.springBone = springBone;
    this._geometry = new SpringBoneBufferGeometry(this.springBone);
    const material = new LineBasicMaterial({
      color: 16776960,
      depthTest: false,
      depthWrite: false
    });
    this._line = new LineSegments(this._geometry, material);
    this.add(this._line);
  }
  dispose() {
    this._geometry.dispose();
  }
  updateMatrixWorld(force) {
    this.springBone.bone.updateWorldMatrix(true, false);
    this.matrix.copy(this.springBone.bone.matrixWorld);
    const matrixWorldElements = this.matrix.elements;
    this._geometry.worldScale = _v3A62.set(matrixWorldElements[0], matrixWorldElements[1], matrixWorldElements[2]).length();
    this._geometry.update();
    super.updateMatrixWorld(force);
  }
};
var VRMSpringBoneCollider = class extends Object3D {
  constructor(shape) {
    super();
    this.colliderMatrix = new Matrix4();
    this.shape = shape;
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren);
    updateColliderMatrix(this.colliderMatrix, this.matrixWorld, this.shape.offset);
  }
};
function updateColliderMatrix(colliderMatrix, matrixWorld, offset) {
  const me2 = matrixWorld.elements;
  colliderMatrix.copy(matrixWorld);
  if (offset) {
    colliderMatrix.elements[12] = me2[0] * offset.x + me2[4] * offset.y + me2[8] * offset.z + me2[12];
    colliderMatrix.elements[13] = me2[1] * offset.x + me2[5] * offset.y + me2[9] * offset.z + me2[13];
    colliderMatrix.elements[14] = me2[2] * offset.x + me2[6] * offset.y + me2[10] * offset.z + me2[14];
  }
}
var _matA = new Matrix4();
function mat4InvertCompat(target) {
  if (target.invert) {
    target.invert();
  } else {
    target.getInverse(_matA.copy(target));
  }
  return target;
}
var Matrix4InverseCache = class {
  constructor(matrix) {
    this._inverseCache = new Matrix4();
    this._shouldUpdateInverse = true;
    this.matrix = matrix;
    const handler = {
      set: (obj, prop, newVal) => {
        this._shouldUpdateInverse = true;
        obj[prop] = newVal;
        return true;
      }
    };
    this._originalElements = matrix.elements;
    matrix.elements = new Proxy(matrix.elements, handler);
  }
  /**
   * Inverse of given matrix.
   * Note that it will return its internal private instance.
   * Make sure copying this before mutate this.
   */
  get inverse() {
    if (this._shouldUpdateInverse) {
      mat4InvertCompat(this._inverseCache.copy(this.matrix));
      this._shouldUpdateInverse = false;
    }
    return this._inverseCache;
  }
  revert() {
    this.matrix.elements = this._originalElements;
  }
};
var IDENTITY_MATRIX4 = new Matrix4();
var _v3A72 = new Vector3();
var _v3B23 = new Vector3();
var _worldSpacePosition = new Vector3();
var _nextTail = new Vector3();
var _matA2 = new Matrix4();
var VRMSpringBoneJoint = class {
  /**
   * Create a new VRMSpringBone.
   *
   * @param bone An Object3D that will be attached to this bone
   * @param child An Object3D that will be used as a tail of this spring bone. It can be null when the spring bone is imported from VRM 0.0
   * @param settings Several parameters related to behavior of the spring bone
   * @param colliderGroups Collider groups that will be collided with this spring bone
   */
  constructor(bone, child, settings = {}, colliderGroups = []) {
    this._currentTail = new Vector3();
    this._prevTail = new Vector3();
    this._boneAxis = new Vector3();
    this._worldSpaceBoneLength = 0;
    this._center = null;
    this._initialLocalMatrix = new Matrix4();
    this._initialLocalRotation = new Quaternion();
    this._initialLocalChildPosition = new Vector3();
    var _a2, _b, _c2, _d, _e2, _f;
    this.bone = bone;
    this.bone.matrixAutoUpdate = false;
    this.child = child;
    this.settings = {
      hitRadius: (_a2 = settings.hitRadius) != null ? _a2 : 0,
      stiffness: (_b = settings.stiffness) != null ? _b : 1,
      gravityPower: (_c2 = settings.gravityPower) != null ? _c2 : 0,
      gravityDir: (_e2 = (_d = settings.gravityDir) == null ? void 0 : _d.clone()) != null ? _e2 : new Vector3(0, -1, 0),
      dragForce: (_f = settings.dragForce) != null ? _f : 0.4
    };
    this.colliderGroups = colliderGroups;
  }
  /**
   * Set of dependencies that need to be updated before this joint.
   */
  get dependencies() {
    const set = /* @__PURE__ */ new Set();
    const parent = this.bone.parent;
    if (parent) {
      set.add(parent);
    }
    for (let cg = 0; cg < this.colliderGroups.length; cg++) {
      for (let c2 = 0; c2 < this.colliderGroups[cg].colliders.length; c2++) {
        set.add(this.colliderGroups[cg].colliders[c2]);
      }
    }
    return set;
  }
  get center() {
    return this._center;
  }
  set center(center) {
    var _a2;
    if ((_a2 = this._center) == null ? void 0 : _a2.userData.inverseCacheProxy) {
      this._center.userData.inverseCacheProxy.revert();
      delete this._center.userData.inverseCacheProxy;
    }
    this._center = center;
    if (this._center) {
      if (!this._center.userData.inverseCacheProxy) {
        this._center.userData.inverseCacheProxy = new Matrix4InverseCache(this._center.matrixWorld);
      }
    }
  }
  get initialLocalChildPosition() {
    return this._initialLocalChildPosition;
  }
  /**
   * Returns the world matrix of its parent object.
   * Note that it returns a reference to the matrix. Don't mutate this directly!
   */
  get _parentMatrixWorld() {
    return this.bone.parent ? this.bone.parent.matrixWorld : IDENTITY_MATRIX4;
  }
  /**
   * Set the initial state of this spring bone.
   * You might want to call {@link VRMSpringBoneManager.setInitState} instead.
   */
  setInitState() {
    this._initialLocalMatrix.copy(this.bone.matrix);
    this._initialLocalRotation.copy(this.bone.quaternion);
    if (this.child) {
      this._initialLocalChildPosition.copy(this.child.position);
    } else {
      this._initialLocalChildPosition.copy(this.bone.position).normalize().multiplyScalar(0.07);
    }
    const matrixWorldToCenter = this._getMatrixWorldToCenter();
    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);
    this._prevTail.copy(this._currentTail);
    this._boneAxis.copy(this._initialLocalChildPosition).normalize();
  }
  /**
   * Reset the state of this bone.
   * You might want to call {@link VRMSpringBoneManager.reset} instead.
   */
  reset() {
    this.bone.quaternion.copy(this._initialLocalRotation);
    this.bone.updateMatrix();
    this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);
    const matrixWorldToCenter = this._getMatrixWorldToCenter();
    this.bone.localToWorld(this._currentTail.copy(this._initialLocalChildPosition)).applyMatrix4(matrixWorldToCenter);
    this._prevTail.copy(this._currentTail);
  }
  /**
   * Update the state of this bone.
   * You might want to call {@link VRMSpringBoneManager.update} instead.
   *
   * @param delta deltaTime
   */
  update(delta) {
    if (delta <= 0) return;
    this._calcWorldSpaceBoneLength();
    const worldSpaceBoneAxis = _v3B23.copy(this._boneAxis).transformDirection(this._initialLocalMatrix).transformDirection(this._parentMatrixWorld);
    _nextTail.copy(this._currentTail).add(_v3A72.subVectors(this._currentTail, this._prevTail).multiplyScalar(1 - this.settings.dragForce)).applyMatrix4(this._getMatrixCenterToWorld()).addScaledVector(worldSpaceBoneAxis, this.settings.stiffness * delta).addScaledVector(this.settings.gravityDir, this.settings.gravityPower * delta);
    _worldSpacePosition.setFromMatrixPosition(this.bone.matrixWorld);
    _nextTail.sub(_worldSpacePosition).normalize().multiplyScalar(this._worldSpaceBoneLength).add(_worldSpacePosition);
    this._collision(_nextTail);
    this._prevTail.copy(this._currentTail);
    this._currentTail.copy(_nextTail).applyMatrix4(this._getMatrixWorldToCenter());
    const worldSpaceInitialMatrixInv = _matA2.multiplyMatrices(this._parentMatrixWorld, this._initialLocalMatrix).invert();
    this.bone.quaternion.setFromUnitVectors(this._boneAxis, _v3A72.copy(_nextTail).applyMatrix4(worldSpaceInitialMatrixInv).normalize()).premultiply(this._initialLocalRotation);
    this.bone.updateMatrix();
    this.bone.matrixWorld.multiplyMatrices(this._parentMatrixWorld, this.bone.matrix);
  }
  /**
   * Do collision math against every colliders attached to this bone.
   *
   * @param tail The tail you want to process
   */
  _collision(tail) {
    for (let cg = 0; cg < this.colliderGroups.length; cg++) {
      for (let c2 = 0; c2 < this.colliderGroups[cg].colliders.length; c2++) {
        const collider = this.colliderGroups[cg].colliders[c2];
        const dist = collider.shape.calculateCollision(collider.colliderMatrix, tail, this.settings.hitRadius, _v3A72);
        if (dist < 0) {
          tail.addScaledVector(_v3A72, -dist);
          tail.sub(_worldSpacePosition);
          const length = tail.length();
          tail.multiplyScalar(this._worldSpaceBoneLength / length).add(_worldSpacePosition);
        }
      }
    }
  }
  /**
   * Calculate the {@link _worldSpaceBoneLength}.
   * Intended to be used in {@link update}.
   */
  _calcWorldSpaceBoneLength() {
    _v3A72.setFromMatrixPosition(this.bone.matrixWorld);
    if (this.child) {
      _v3B23.setFromMatrixPosition(this.child.matrixWorld);
    } else {
      _v3B23.copy(this._initialLocalChildPosition);
      _v3B23.applyMatrix4(this.bone.matrixWorld);
    }
    this._worldSpaceBoneLength = _v3A72.sub(_v3B23).length();
  }
  /**
   * Create a matrix that converts center space into world space.
   */
  _getMatrixCenterToWorld() {
    return this._center ? this._center.matrixWorld : IDENTITY_MATRIX4;
  }
  /**
   * Create a matrix that converts world space into center space.
   */
  _getMatrixWorldToCenter() {
    return this._center ? this._center.userData.inverseCacheProxy.inverse : IDENTITY_MATRIX4;
  }
};
function traverseAncestorsFromRoot2(object, callback) {
  const ancestors = [];
  let head = object;
  while (head !== null) {
    ancestors.unshift(head);
    head = head.parent;
  }
  ancestors.forEach((ancestor) => {
    callback(ancestor);
  });
}
function traverseChildrenUntilConditionMet(object, callback) {
  object.children.forEach((child) => {
    const result = callback(child);
    if (!result) {
      traverseChildrenUntilConditionMet(child, callback);
    }
  });
}
function lowestCommonAncestor(objects) {
  var _a2;
  const sharedAncestors = /* @__PURE__ */ new Map();
  for (const object of objects) {
    let current = object;
    do {
      const newValue = ((_a2 = sharedAncestors.get(current)) != null ? _a2 : 0) + 1;
      if (newValue === objects.size) {
        return current;
      }
      sharedAncestors.set(current, newValue);
      current = current.parent;
    } while (current !== null);
  }
  return null;
}
var VRMSpringBoneManager = class {
  constructor() {
    this._joints = /* @__PURE__ */ new Set();
    this._sortedJoints = [];
    this._hasWarnedCircularDependency = false;
    this._ancestors = [];
    this._objectSpringBonesMap = /* @__PURE__ */ new Map();
    this._isSortedJointsDirty = false;
    this._relevantChildrenUpdated = this._relevantChildrenUpdated.bind(this);
  }
  get joints() {
    return this._joints;
  }
  /**
   * @deprecated Use {@link joints} instead.
   */
  get springBones() {
    console.warn("VRMSpringBoneManager: springBones is deprecated. use joints instead.");
    return this._joints;
  }
  get colliderGroups() {
    const set = /* @__PURE__ */ new Set();
    this._joints.forEach((springBone) => {
      springBone.colliderGroups.forEach((colliderGroup) => {
        set.add(colliderGroup);
      });
    });
    return Array.from(set);
  }
  get colliders() {
    const set = /* @__PURE__ */ new Set();
    this.colliderGroups.forEach((colliderGroup) => {
      colliderGroup.colliders.forEach((collider) => {
        set.add(collider);
      });
    });
    return Array.from(set);
  }
  addJoint(joint) {
    this._joints.add(joint);
    let objectSet = this._objectSpringBonesMap.get(joint.bone);
    if (objectSet == null) {
      objectSet = /* @__PURE__ */ new Set();
      this._objectSpringBonesMap.set(joint.bone, objectSet);
    }
    objectSet.add(joint);
    this._isSortedJointsDirty = true;
  }
  /**
   * @deprecated Use {@link addJoint} instead.
   */
  addSpringBone(joint) {
    console.warn("VRMSpringBoneManager: addSpringBone() is deprecated. use addJoint() instead.");
    this.addJoint(joint);
  }
  deleteJoint(joint) {
    this._joints.delete(joint);
    const objectSet = this._objectSpringBonesMap.get(joint.bone);
    objectSet.delete(joint);
    this._isSortedJointsDirty = true;
  }
  /**
   * @deprecated Use {@link deleteJoint} instead.
   */
  deleteSpringBone(joint) {
    console.warn("VRMSpringBoneManager: deleteSpringBone() is deprecated. use deleteJoint() instead.");
    this.deleteJoint(joint);
  }
  setInitState() {
    this._sortJoints();
    for (let i2 = 0; i2 < this._sortedJoints.length; i2++) {
      const springBone = this._sortedJoints[i2];
      springBone.bone.updateMatrix();
      springBone.bone.updateWorldMatrix(false, false);
      springBone.setInitState();
    }
  }
  reset() {
    this._sortJoints();
    for (let i2 = 0; i2 < this._sortedJoints.length; i2++) {
      const springBone = this._sortedJoints[i2];
      springBone.bone.updateMatrix();
      springBone.bone.updateWorldMatrix(false, false);
      springBone.reset();
    }
  }
  update(delta) {
    this._sortJoints();
    for (let i2 = 0; i2 < this._ancestors.length; i2++) {
      this._ancestors[i2].updateWorldMatrix(i2 === 0, false);
    }
    for (let i2 = 0; i2 < this._sortedJoints.length; i2++) {
      const springBone = this._sortedJoints[i2];
      springBone.bone.updateMatrix();
      springBone.bone.updateWorldMatrix(false, false);
      springBone.update(delta);
      traverseChildrenUntilConditionMet(springBone.bone, this._relevantChildrenUpdated);
    }
  }
  /**
   * Sorts the joints ensuring they are updated in the correct order taking dependencies into account.
   *
   * This method updates {@link _sortedJoints} and {@link _ancestors}.
   * Make sure to call this before using them.
   */
  _sortJoints() {
    if (!this._isSortedJointsDirty) {
      return;
    }
    const springBoneOrder = [];
    const springBonesTried = /* @__PURE__ */ new Set();
    const springBonesDone = /* @__PURE__ */ new Set();
    const ancestors = /* @__PURE__ */ new Set();
    for (const springBone of this._joints) {
      this._insertJointSort(springBone, springBonesTried, springBonesDone, springBoneOrder, ancestors);
    }
    this._sortedJoints = springBoneOrder;
    const lca = lowestCommonAncestor(ancestors);
    this._ancestors = [];
    if (lca) {
      this._ancestors.push(lca);
      traverseChildrenUntilConditionMet(lca, (object) => {
        var _a2, _b;
        if (((_b = (_a2 = this._objectSpringBonesMap.get(object)) == null ? void 0 : _a2.size) != null ? _b : 0) > 0) {
          return true;
        }
        this._ancestors.push(object);
        return false;
      });
    }
    this._isSortedJointsDirty = false;
  }
  _insertJointSort(springBone, springBonesTried, springBonesDone, springBoneOrder, ancestors) {
    if (springBonesDone.has(springBone)) {
      return;
    }
    if (springBonesTried.has(springBone)) {
      if (!this._hasWarnedCircularDependency) {
        console.warn("VRMSpringBoneManager: Circular dependency detected");
        this._hasWarnedCircularDependency = true;
      }
      return;
    }
    springBonesTried.add(springBone);
    const depObjects = springBone.dependencies;
    for (const depObject of depObjects) {
      let encounteredSpringBone = false;
      let ancestor = null;
      traverseAncestorsFromRoot2(depObject, (depObjectAncestor) => {
        const objectSet = this._objectSpringBonesMap.get(depObjectAncestor);
        if (objectSet) {
          for (const depSpringBone of objectSet) {
            encounteredSpringBone = true;
            this._insertJointSort(depSpringBone, springBonesTried, springBonesDone, springBoneOrder, ancestors);
          }
        } else if (!encounteredSpringBone) {
          ancestor = depObjectAncestor;
        }
      });
      if (ancestor) {
        ancestors.add(ancestor);
      }
    }
    springBoneOrder.push(springBone);
    springBonesDone.add(springBone);
  }
  _relevantChildrenUpdated(object) {
    var _a2, _b;
    if (((_b = (_a2 = this._objectSpringBonesMap.get(object)) == null ? void 0 : _a2.size) != null ? _b : 0) > 0) {
      return true;
    }
    object.updateWorldMatrix(false, false);
    return false;
  }
};
var EXTENSION_NAME_EXTENDED_COLLIDER = "VRMC_springBone_extended_collider";
var POSSIBLE_SPEC_VERSIONS8 = /* @__PURE__ */ new Set(["1.0", "1.0-beta"]);
var POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS = /* @__PURE__ */ new Set(["1.0"]);
var _VRMSpringBoneLoaderPlugin = class _VRMSpringBoneLoaderPlugin2 {
  get name() {
    return _VRMSpringBoneLoaderPlugin2.EXTENSION_NAME;
  }
  constructor(parser, options) {
    var _a2;
    this.parser = parser;
    this.jointHelperRoot = options == null ? void 0 : options.jointHelperRoot;
    this.colliderHelperRoot = options == null ? void 0 : options.colliderHelperRoot;
    this.useExtendedColliders = (_a2 = options == null ? void 0 : options.useExtendedColliders) != null ? _a2 : true;
  }
  afterRoot(gltf) {
    return __async7(this, null, function* () {
      gltf.userData.vrmSpringBoneManager = yield this._import(gltf);
    });
  }
  /**
   * Import spring bones from a GLTF and return a {@link VRMSpringBoneManager}.
   * It might return `null` instead when it does not need to be created or something go wrong.
   *
   * @param gltf A parsed result of GLTF taken from GLTFLoader
   */
  _import(gltf) {
    return __async7(this, null, function* () {
      const v1Result = yield this._v1Import(gltf);
      if (v1Result != null) {
        return v1Result;
      }
      const v0Result = yield this._v0Import(gltf);
      if (v0Result != null) {
        return v0Result;
      }
      return null;
    });
  }
  _v1Import(gltf) {
    return __async7(this, null, function* () {
      var _a2, _b, _c2, _d, _e2;
      const json = gltf.parser.json;
      const isSpringBoneUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf(_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME)) !== -1;
      if (!isSpringBoneUsed) {
        return null;
      }
      const manager = new VRMSpringBoneManager();
      const threeNodes = yield gltf.parser.getDependencies("node");
      const extension = (_b = json.extensions) == null ? void 0 : _b[_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME];
      if (!extension) {
        return null;
      }
      const specVersion = extension.specVersion;
      if (!POSSIBLE_SPEC_VERSIONS8.has(specVersion)) {
        console.warn(
          `VRMSpringBoneLoaderPlugin: Unknown ${_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME} specVersion "${specVersion}"`
        );
        return null;
      }
      const colliders = (_c2 = extension.colliders) == null ? void 0 : _c2.map((schemaCollider, iCollider) => {
        var _a22, _b2, _c22, _d2, _e22, _f, _g, _h, _i2, _j, _k, _l, _m, _n2, _o2;
        const node = threeNodes[schemaCollider.node];
        if (node == null) {
          console.warn(
            `VRMSpringBoneLoaderPlugin: The collider #${iCollider} attempted to use the node #${schemaCollider.node} but not found`
          );
          return null;
        }
        const schemaShape = schemaCollider.shape;
        const schemaExCollider = (_a22 = schemaCollider.extensions) == null ? void 0 : _a22[EXTENSION_NAME_EXTENDED_COLLIDER];
        if (this.useExtendedColliders && schemaExCollider != null) {
          const specVersionExCollider = schemaExCollider.specVersion;
          if (!POSSIBLE_SPEC_VERSIONS_EXTENDED_COLLIDERS.has(specVersionExCollider)) {
            console.warn(
              `VRMSpringBoneLoaderPlugin: Unknown ${EXTENSION_NAME_EXTENDED_COLLIDER} specVersion "${specVersionExCollider}". Fallbacking to the ${_VRMSpringBoneLoaderPlugin2.EXTENSION_NAME} definition`
            );
          } else {
            const schemaExShape = schemaExCollider.shape;
            if (schemaExShape.sphere) {
              return this._importSphereCollider(node, {
                offset: new Vector3().fromArray((_b2 = schemaExShape.sphere.offset) != null ? _b2 : [0, 0, 0]),
                radius: (_c22 = schemaExShape.sphere.radius) != null ? _c22 : 0,
                inside: (_d2 = schemaExShape.sphere.inside) != null ? _d2 : false
              });
            } else if (schemaExShape.capsule) {
              return this._importCapsuleCollider(node, {
                offset: new Vector3().fromArray((_e22 = schemaExShape.capsule.offset) != null ? _e22 : [0, 0, 0]),
                radius: (_f = schemaExShape.capsule.radius) != null ? _f : 0,
                tail: new Vector3().fromArray((_g = schemaExShape.capsule.tail) != null ? _g : [0, 0, 0]),
                inside: (_h = schemaExShape.capsule.inside) != null ? _h : false
              });
            } else if (schemaExShape.plane) {
              return this._importPlaneCollider(node, {
                offset: new Vector3().fromArray((_i2 = schemaExShape.plane.offset) != null ? _i2 : [0, 0, 0]),
                normal: new Vector3().fromArray((_j = schemaExShape.plane.normal) != null ? _j : [0, 0, 1])
              });
            }
          }
        }
        if (schemaShape.sphere) {
          return this._importSphereCollider(node, {
            offset: new Vector3().fromArray((_k = schemaShape.sphere.offset) != null ? _k : [0, 0, 0]),
            radius: (_l = schemaShape.sphere.radius) != null ? _l : 0,
            inside: false
          });
        } else if (schemaShape.capsule) {
          return this._importCapsuleCollider(node, {
            offset: new Vector3().fromArray((_m = schemaShape.capsule.offset) != null ? _m : [0, 0, 0]),
            radius: (_n2 = schemaShape.capsule.radius) != null ? _n2 : 0,
            tail: new Vector3().fromArray((_o2 = schemaShape.capsule.tail) != null ? _o2 : [0, 0, 0]),
            inside: false
          });
        }
        throw new Error(`VRMSpringBoneLoaderPlugin: The collider #${iCollider} has no valid shape`);
      });
      const colliderGroups = (_d = extension.colliderGroups) == null ? void 0 : _d.map(
        (schemaColliderGroup, iColliderGroup) => {
          var _a22;
          const cols = ((_a22 = schemaColliderGroup.colliders) != null ? _a22 : []).flatMap((iCollider) => {
            const col = colliders == null ? void 0 : colliders[iCollider];
            if (col == null) {
              console.warn(
                `VRMSpringBoneLoaderPlugin: The colliderGroup #${iColliderGroup} attempted to use a collider #${iCollider} but not found`
              );
              return [];
            }
            return col;
          });
          return {
            colliders: cols,
            name: schemaColliderGroup.name
          };
        }
      );
      (_e2 = extension.springs) == null ? void 0 : _e2.forEach((schemaSpring, iSpring) => {
        var _a22;
        const schemaJoints = schemaSpring.joints;
        const colliderGroupsForSpring = (_a22 = schemaSpring.colliderGroups) == null ? void 0 : _a22.map((iColliderGroup) => {
          const group = colliderGroups == null ? void 0 : colliderGroups[iColliderGroup];
          if (group == null) {
            throw new Error(
              `VRMSpringBoneLoaderPlugin: The spring #${iSpring} attempted to use a colliderGroup ${iColliderGroup} but not found`
            );
          }
          return group;
        });
        const center = schemaSpring.center != null ? threeNodes[schemaSpring.center] : void 0;
        let prevSchemaJoint;
        schemaJoints.forEach((schemaJoint) => {
          if (prevSchemaJoint) {
            const nodeIndex = prevSchemaJoint.node;
            const node = threeNodes[nodeIndex];
            const childIndex = schemaJoint.node;
            const child = threeNodes[childIndex];
            const setting = {
              hitRadius: prevSchemaJoint.hitRadius,
              dragForce: prevSchemaJoint.dragForce,
              gravityPower: prevSchemaJoint.gravityPower,
              stiffness: prevSchemaJoint.stiffness,
              gravityDir: prevSchemaJoint.gravityDir != null ? new Vector3().fromArray(prevSchemaJoint.gravityDir) : void 0
            };
            const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);
            if (center) {
              joint.center = center;
            }
            manager.addJoint(joint);
          }
          prevSchemaJoint = schemaJoint;
        });
      });
      manager.setInitState();
      return manager;
    });
  }
  _v0Import(gltf) {
    return __async7(this, null, function* () {
      var _a2, _b, _c2;
      const json = gltf.parser.json;
      const isVRMUsed = ((_a2 = json.extensionsUsed) == null ? void 0 : _a2.indexOf("VRM")) !== -1;
      if (!isVRMUsed) {
        return null;
      }
      const extension = (_b = json.extensions) == null ? void 0 : _b["VRM"];
      const schemaSecondaryAnimation = extension == null ? void 0 : extension.secondaryAnimation;
      if (!schemaSecondaryAnimation) {
        return null;
      }
      const schemaBoneGroups = schemaSecondaryAnimation == null ? void 0 : schemaSecondaryAnimation.boneGroups;
      if (!schemaBoneGroups) {
        return null;
      }
      const manager = new VRMSpringBoneManager();
      const threeNodes = yield gltf.parser.getDependencies("node");
      const colliderGroups = (_c2 = schemaSecondaryAnimation.colliderGroups) == null ? void 0 : _c2.map(
        (schemaColliderGroup) => {
          var _a22;
          const node = threeNodes[schemaColliderGroup.node];
          const colliders = ((_a22 = schemaColliderGroup.colliders) != null ? _a22 : []).map((schemaCollider, iCollider) => {
            var _a3, _b2, _c22;
            const offset = new Vector3(0, 0, 0);
            if (schemaCollider.offset) {
              offset.set(
                (_a3 = schemaCollider.offset.x) != null ? _a3 : 0,
                (_b2 = schemaCollider.offset.y) != null ? _b2 : 0,
                schemaCollider.offset.z ? -schemaCollider.offset.z : 0
                // z is opposite in VRM0.0
              );
            }
            return this._importSphereCollider(node, {
              offset,
              radius: (_c22 = schemaCollider.radius) != null ? _c22 : 0,
              inside: false
            });
          });
          return { colliders };
        }
      );
      schemaBoneGroups == null ? void 0 : schemaBoneGroups.forEach((schemaBoneGroup, iBoneGroup) => {
        const rootIndices = schemaBoneGroup.bones;
        if (!rootIndices) {
          return;
        }
        rootIndices.forEach((rootIndex) => {
          var _a22, _b2, _c22, _d;
          const root = threeNodes[rootIndex];
          const gravityDir = new Vector3();
          if (schemaBoneGroup.gravityDir) {
            gravityDir.set(
              (_a22 = schemaBoneGroup.gravityDir.x) != null ? _a22 : 0,
              (_b2 = schemaBoneGroup.gravityDir.y) != null ? _b2 : 0,
              (_c22 = schemaBoneGroup.gravityDir.z) != null ? _c22 : 0
            );
          } else {
            gravityDir.set(0, -1, 0);
          }
          const center = schemaBoneGroup.center != null ? threeNodes[schemaBoneGroup.center] : void 0;
          const setting = {
            hitRadius: schemaBoneGroup.hitRadius,
            dragForce: schemaBoneGroup.dragForce,
            gravityPower: schemaBoneGroup.gravityPower,
            stiffness: schemaBoneGroup.stiffiness,
            gravityDir
          };
          const colliderGroupsForSpring = (_d = schemaBoneGroup.colliderGroups) == null ? void 0 : _d.map((iColliderGroup) => {
            const group = colliderGroups == null ? void 0 : colliderGroups[iColliderGroup];
            if (group == null) {
              throw new Error(
                `VRMSpringBoneLoaderPlugin: The spring #${iBoneGroup} attempted to use a colliderGroup ${iColliderGroup} but not found`
              );
            }
            return group;
          });
          root.traverse((node) => {
            var _a3;
            const child = (_a3 = node.children[0]) != null ? _a3 : null;
            const joint = this._importJoint(node, child, setting, colliderGroupsForSpring);
            if (center) {
              joint.center = center;
            }
            manager.addJoint(joint);
          });
        });
      });
      gltf.scene.updateMatrixWorld();
      manager.setInitState();
      return manager;
    });
  }
  _importJoint(node, child, setting, colliderGroupsForSpring) {
    const springBone = new VRMSpringBoneJoint(node, child, setting, colliderGroupsForSpring);
    if (this.jointHelperRoot) {
      const helper = new VRMSpringBoneJointHelper(springBone);
      this.jointHelperRoot.add(helper);
      helper.renderOrder = this.jointHelperRoot.renderOrder;
    }
    return springBone;
  }
  _importSphereCollider(destination, params) {
    const shape = new VRMSpringBoneColliderShapeSphere(params);
    const collider = new VRMSpringBoneCollider(shape);
    destination.add(collider);
    if (this.colliderHelperRoot) {
      const helper = new VRMSpringBoneColliderHelper(collider);
      this.colliderHelperRoot.add(helper);
      helper.renderOrder = this.colliderHelperRoot.renderOrder;
    }
    return collider;
  }
  _importCapsuleCollider(destination, params) {
    const shape = new VRMSpringBoneColliderShapeCapsule(params);
    const collider = new VRMSpringBoneCollider(shape);
    destination.add(collider);
    if (this.colliderHelperRoot) {
      const helper = new VRMSpringBoneColliderHelper(collider);
      this.colliderHelperRoot.add(helper);
      helper.renderOrder = this.colliderHelperRoot.renderOrder;
    }
    return collider;
  }
  _importPlaneCollider(destination, params) {
    const shape = new VRMSpringBoneColliderShapePlane(params);
    const collider = new VRMSpringBoneCollider(shape);
    destination.add(collider);
    if (this.colliderHelperRoot) {
      const helper = new VRMSpringBoneColliderHelper(collider);
      this.colliderHelperRoot.add(helper);
      helper.renderOrder = this.colliderHelperRoot.renderOrder;
    }
    return collider;
  }
};
_VRMSpringBoneLoaderPlugin.EXTENSION_NAME = "VRMC_springBone";
var VRMSpringBoneLoaderPlugin = _VRMSpringBoneLoaderPlugin;
var VRMLoaderPlugin = class {
  get name() {
    return "VRMLoaderPlugin";
  }
  constructor(parser, options) {
    var _a2, _b, _c2, _d, _e2, _f, _g, _h, _i2, _j;
    this.parser = parser;
    const helperRoot = options == null ? void 0 : options.helperRoot;
    const autoUpdateHumanBones = options == null ? void 0 : options.autoUpdateHumanBones;
    this.expressionPlugin = (_a2 = options == null ? void 0 : options.expressionPlugin) != null ? _a2 : new VRMExpressionLoaderPlugin(parser);
    this.firstPersonPlugin = (_b = options == null ? void 0 : options.firstPersonPlugin) != null ? _b : new VRMFirstPersonLoaderPlugin(parser);
    this.humanoidPlugin = (_c2 = options == null ? void 0 : options.humanoidPlugin) != null ? _c2 : new VRMHumanoidLoaderPlugin(parser, {
      helperRoot,
      autoUpdateHumanBones
    });
    this.lookAtPlugin = (_d = options == null ? void 0 : options.lookAtPlugin) != null ? _d : new VRMLookAtLoaderPlugin(parser, { helperRoot });
    this.metaPlugin = (_e2 = options == null ? void 0 : options.metaPlugin) != null ? _e2 : new VRMMetaLoaderPlugin(parser);
    this.mtoonMaterialPlugin = (_f = options == null ? void 0 : options.mtoonMaterialPlugin) != null ? _f : new MToonMaterialLoaderPlugin(parser);
    this.materialsHDREmissiveMultiplierPlugin = (_g = options == null ? void 0 : options.materialsHDREmissiveMultiplierPlugin) != null ? _g : new VRMMaterialsHDREmissiveMultiplierLoaderPlugin(parser);
    this.materialsV0CompatPlugin = (_h = options == null ? void 0 : options.materialsV0CompatPlugin) != null ? _h : new VRMMaterialsV0CompatPlugin(parser);
    this.springBonePlugin = (_i2 = options == null ? void 0 : options.springBonePlugin) != null ? _i2 : new VRMSpringBoneLoaderPlugin(parser, {
      colliderHelperRoot: helperRoot,
      jointHelperRoot: helperRoot
    });
    this.nodeConstraintPlugin = (_j = options == null ? void 0 : options.nodeConstraintPlugin) != null ? _j : new VRMNodeConstraintLoaderPlugin(parser, { helperRoot });
  }
  beforeRoot() {
    return __async(this, null, function* () {
      yield this.materialsV0CompatPlugin.beforeRoot();
      yield this.mtoonMaterialPlugin.beforeRoot();
    });
  }
  loadMesh(meshIndex) {
    return __async(this, null, function* () {
      return yield this.mtoonMaterialPlugin.loadMesh(meshIndex);
    });
  }
  getMaterialType(materialIndex) {
    const mtoonType = this.mtoonMaterialPlugin.getMaterialType(materialIndex);
    if (mtoonType != null) {
      return mtoonType;
    }
    return null;
  }
  extendMaterialParams(materialIndex, materialParams) {
    return __async(this, null, function* () {
      yield this.materialsHDREmissiveMultiplierPlugin.extendMaterialParams(materialIndex, materialParams);
      yield this.mtoonMaterialPlugin.extendMaterialParams(materialIndex, materialParams);
    });
  }
  afterRoot(gltf) {
    return __async(this, null, function* () {
      yield this.metaPlugin.afterRoot(gltf);
      yield this.humanoidPlugin.afterRoot(gltf);
      yield this.expressionPlugin.afterRoot(gltf);
      yield this.lookAtPlugin.afterRoot(gltf);
      yield this.firstPersonPlugin.afterRoot(gltf);
      yield this.springBonePlugin.afterRoot(gltf);
      yield this.nodeConstraintPlugin.afterRoot(gltf);
      yield this.mtoonMaterialPlugin.afterRoot(gltf);
      const meta = gltf.userData.vrmMeta;
      const humanoid = gltf.userData.vrmHumanoid;
      if (meta && humanoid) {
        const vrm = new VRM({
          scene: gltf.scene,
          expressionManager: gltf.userData.vrmExpressionManager,
          firstPerson: gltf.userData.vrmFirstPerson,
          humanoid,
          lookAt: gltf.userData.vrmLookAt,
          meta,
          materials: gltf.userData.vrmMToonMaterials,
          springBoneManager: gltf.userData.vrmSpringBoneManager,
          nodeConstraintManager: gltf.userData.vrmNodeConstraintManager
        });
        gltf.userData.vrm = vrm;
      }
    });
  }
};
function collectMeshes(scene) {
  const meshes = /* @__PURE__ */ new Set();
  scene.traverse((obj) => {
    if (!obj.isMesh) {
      return;
    }
    const mesh = obj;
    meshes.add(mesh);
  });
  return meshes;
}
function combineMorph(positionAttributes, binds, morphTargetsRelative) {
  if (binds.size === 1) {
    const bind2 = binds.values().next().value;
    if (bind2.weight === 1) {
      return positionAttributes[bind2.index];
    }
  }
  const newArray = new Float32Array(positionAttributes[0].count * 3);
  let weightSum = 0;
  if (morphTargetsRelative) {
    weightSum = 1;
  } else {
    for (const bind2 of binds) {
      weightSum += bind2.weight;
    }
  }
  for (const bind2 of binds) {
    const src = positionAttributes[bind2.index];
    const weight = bind2.weight / weightSum;
    for (let i2 = 0; i2 < src.count; i2++) {
      newArray[i2 * 3 + 0] += src.getX(i2) * weight;
      newArray[i2 * 3 + 1] += src.getY(i2) * weight;
      newArray[i2 * 3 + 2] += src.getZ(i2) * weight;
    }
  }
  const newAttribute = new BufferAttribute(newArray, 3);
  return newAttribute;
}
function combineMorphs(vrm) {
  var _a2;
  const meshes = collectMeshes(vrm.scene);
  const meshNameBindSetMapMap = /* @__PURE__ */ new Map();
  const expressionMap = (_a2 = vrm.expressionManager) == null ? void 0 : _a2.expressionMap;
  if (expressionMap != null) {
    for (const [expressionName, expression] of Object.entries(expressionMap)) {
      const bindsToDeleteSet = /* @__PURE__ */ new Set();
      for (const bind2 of expression.binds) {
        if (bind2 instanceof VRMExpressionMorphTargetBind) {
          if (bind2.weight !== 0) {
            for (const mesh of bind2.primitives) {
              let nameBindSetMap = meshNameBindSetMapMap.get(mesh);
              if (nameBindSetMap == null) {
                nameBindSetMap = /* @__PURE__ */ new Map();
                meshNameBindSetMapMap.set(mesh, nameBindSetMap);
              }
              let bindSet = nameBindSetMap.get(expressionName);
              if (bindSet == null) {
                bindSet = /* @__PURE__ */ new Set();
                nameBindSetMap.set(expressionName, bindSet);
              }
              bindSet.add(bind2);
            }
          }
          bindsToDeleteSet.add(bind2);
        }
      }
      for (const bind2 of bindsToDeleteSet) {
        expression.deleteBind(bind2);
      }
    }
  }
  for (const mesh of meshes) {
    const nameBindSetMap = meshNameBindSetMapMap.get(mesh);
    if (nameBindSetMap == null) {
      continue;
    }
    const originalMorphAttributes = mesh.geometry.morphAttributes;
    mesh.geometry.morphAttributes = {};
    const geometry = mesh.geometry.clone();
    mesh.geometry = geometry;
    const morphTargetsRelative = geometry.morphTargetsRelative;
    const hasPMorph = originalMorphAttributes.position != null;
    const hasNMorph = originalMorphAttributes.normal != null;
    const morphAttributes = {};
    const morphTargetDictionary = {};
    const morphTargetInfluences = [];
    if (hasPMorph || hasNMorph) {
      if (hasPMorph) {
        morphAttributes.position = [];
      }
      if (hasNMorph) {
        morphAttributes.normal = [];
      }
      let i2 = 0;
      for (const [name, bindSet] of nameBindSetMap) {
        if (hasPMorph) {
          morphAttributes.position[i2] = combineMorph(originalMorphAttributes.position, bindSet, morphTargetsRelative);
        }
        if (hasNMorph) {
          morphAttributes.normal[i2] = combineMorph(originalMorphAttributes.normal, bindSet, morphTargetsRelative);
        }
        expressionMap == null ? void 0 : expressionMap[name].addBind(
          new VRMExpressionMorphTargetBind({
            index: i2,
            weight: 1,
            primitives: [mesh]
          })
        );
        morphTargetDictionary[name] = i2;
        morphTargetInfluences.push(0);
        i2++;
      }
    }
    geometry.morphAttributes = morphAttributes;
    mesh.morphTargetDictionary = morphTargetDictionary;
    mesh.morphTargetInfluences = morphTargetInfluences;
  }
}
function attributeGetComponentCompat(attribute, index, component) {
  if (attribute.getComponent) {
    return attribute.getComponent(index, component);
  } else {
    let value = attribute.array[index * attribute.itemSize + component];
    if (attribute.normalized) {
      value = MathUtils.denormalize(value, attribute.array);
    }
    return value;
  }
}
function attributeSetComponentCompat(attribute, index, component, value) {
  if (attribute.setComponent) {
    attribute.setComponent(index, component, value);
  } else {
    if (attribute.normalized) {
      value = MathUtils.normalize(value, attribute.array);
    }
    attribute.array[index * attribute.itemSize + component] = value;
  }
}
function combineSkeletons(root) {
  var _a2;
  const skinnedMeshes = collectSkinnedMeshes(root);
  const geometries = /* @__PURE__ */ new Set();
  for (const mesh of skinnedMeshes) {
    if (geometries.has(mesh.geometry)) {
      mesh.geometry = shallowCloneBufferGeometry(mesh.geometry);
    }
    geometries.add(mesh.geometry);
  }
  const attributeUsedIndexSetMap = /* @__PURE__ */ new Map();
  for (const geometry of geometries) {
    const skinIndexAttr = geometry.getAttribute("skinIndex");
    const skinIndexMap = (_a2 = attributeUsedIndexSetMap.get(skinIndexAttr)) != null ? _a2 : /* @__PURE__ */ new Map();
    attributeUsedIndexSetMap.set(skinIndexAttr, skinIndexMap);
    const skinWeightAttr = geometry.getAttribute("skinWeight");
    const usedIndicesSet = listUsedIndices(skinIndexAttr, skinWeightAttr);
    skinIndexMap.set(skinWeightAttr, usedIndicesSet);
  }
  const meshBoneInverseMapMap = /* @__PURE__ */ new Map();
  for (const mesh of skinnedMeshes) {
    const boneInverseMap = listUsedBones(mesh, attributeUsedIndexSetMap);
    meshBoneInverseMapMap.set(mesh, boneInverseMap);
  }
  const groups = [];
  for (const [mesh, boneInverseMap] of meshBoneInverseMapMap) {
    let foundMergeableGroup = false;
    for (const candidate of groups) {
      const isMergeable = boneInverseMapIsMergeable(boneInverseMap, candidate.boneInverseMap);
      if (isMergeable) {
        foundMergeableGroup = true;
        candidate.meshes.add(mesh);
        for (const [bone, boneInverse] of boneInverseMap) {
          candidate.boneInverseMap.set(bone, boneInverse);
        }
        break;
      }
    }
    if (!foundMergeableGroup) {
      groups.push({ boneInverseMap, meshes: /* @__PURE__ */ new Set([mesh]) });
    }
  }
  const cache = /* @__PURE__ */ new Map();
  const skinIndexDispatcher = new ObjectIndexDispatcher();
  const skeletonDispatcher = new ObjectIndexDispatcher();
  const boneDispatcher = new ObjectIndexDispatcher();
  for (const group of groups) {
    const { boneInverseMap, meshes } = group;
    const newBones = Array.from(boneInverseMap.keys());
    const newBoneInverses = Array.from(boneInverseMap.values());
    const newSkeleton = new Skeleton(newBones, newBoneInverses);
    const skeletonKey = skeletonDispatcher.getOrCreate(newSkeleton);
    for (const mesh of meshes) {
      const skinIndexAttr = mesh.geometry.getAttribute("skinIndex");
      const skinIndexKey = skinIndexDispatcher.getOrCreate(skinIndexAttr);
      const bones = mesh.skeleton.bones;
      const bonesKey = bones.map((bone) => boneDispatcher.getOrCreate(bone)).join(",");
      const key = `${skinIndexKey};${skeletonKey};${bonesKey}`;
      let newSkinIndexAttr = cache.get(key);
      if (newSkinIndexAttr == null) {
        newSkinIndexAttr = skinIndexAttr.clone();
        remapSkinIndexAttribute(newSkinIndexAttr, bones, newBones);
        cache.set(key, newSkinIndexAttr);
      }
      mesh.geometry.setAttribute("skinIndex", newSkinIndexAttr);
    }
    for (const mesh of meshes) {
      mesh.bind(newSkeleton, new Matrix4());
    }
  }
}
function collectSkinnedMeshes(scene) {
  const skinnedMeshes = /* @__PURE__ */ new Set();
  scene.traverse((obj) => {
    if (!obj.isSkinnedMesh) {
      return;
    }
    const skinnedMesh = obj;
    skinnedMeshes.add(skinnedMesh);
  });
  return skinnedMeshes;
}
function listUsedIndices(skinIndexAttr, skinWeightAttr) {
  const usedIndices = /* @__PURE__ */ new Set();
  for (let i2 = 0; i2 < skinIndexAttr.count; i2++) {
    for (let j2 = 0; j2 < skinIndexAttr.itemSize; j2++) {
      const index = attributeGetComponentCompat(skinIndexAttr, i2, j2);
      const weight = attributeGetComponentCompat(skinWeightAttr, i2, j2);
      if (weight !== 0) {
        usedIndices.add(index);
      }
    }
  }
  return usedIndices;
}
function listUsedBones(mesh, attributeUsedIndexSetMap) {
  const boneInverseMap = /* @__PURE__ */ new Map();
  const skeleton = mesh.skeleton;
  const geometry = mesh.geometry;
  const skinIndexAttr = geometry.getAttribute("skinIndex");
  const skinWeightAttr = geometry.getAttribute("skinWeight");
  const skinIndexMap = attributeUsedIndexSetMap.get(skinIndexAttr);
  const usedIndicesSet = skinIndexMap == null ? void 0 : skinIndexMap.get(skinWeightAttr);
  if (!usedIndicesSet) {
    throw new Error(
      "Unreachable. attributeUsedIndexSetMap does not know the skin index attribute or the skin weight attribute."
    );
  }
  for (const index of usedIndicesSet) {
    boneInverseMap.set(skeleton.bones[index], skeleton.boneInverses[index]);
  }
  return boneInverseMap;
}
function boneInverseMapIsMergeable(toCheck, candidate) {
  for (const [bone, boneInverse] of toCheck.entries()) {
    const candidateBoneInverse = candidate.get(bone);
    if (candidateBoneInverse != null) {
      if (!matrixEquals(boneInverse, candidateBoneInverse)) {
        return false;
      }
    }
  }
  return true;
}
function remapSkinIndexAttribute(attribute, oldBones, newBones) {
  const boneOldIndexMap = /* @__PURE__ */ new Map();
  for (const bone of oldBones) {
    boneOldIndexMap.set(bone, boneOldIndexMap.size);
  }
  const oldToNew = /* @__PURE__ */ new Map();
  for (const [i2, bone] of newBones.entries()) {
    const oldIndex = boneOldIndexMap.get(bone);
    oldToNew.set(oldIndex, i2);
  }
  for (let i2 = 0; i2 < attribute.count; i2++) {
    for (let j2 = 0; j2 < attribute.itemSize; j2++) {
      const oldIndex = attributeGetComponentCompat(attribute, i2, j2);
      const newIndex = oldToNew.get(oldIndex);
      attributeSetComponentCompat(attribute, i2, j2, newIndex);
    }
  }
  attribute.needsUpdate = true;
}
function matrixEquals(a2, b2, tolerance) {
  tolerance = tolerance || 1e-4;
  if (a2.elements.length != b2.elements.length) {
    return false;
  }
  for (let i2 = 0, il = a2.elements.length; i2 < il; i2++) {
    const delta = Math.abs(a2.elements[i2] - b2.elements[i2]);
    if (delta > tolerance) {
      return false;
    }
  }
  return true;
}
var ObjectIndexDispatcher = class {
  constructor() {
    this._objectIndexMap = /* @__PURE__ */ new Map();
    this._index = 0;
  }
  get(obj) {
    return this._objectIndexMap.get(obj);
  }
  getOrCreate(obj) {
    let index = this._objectIndexMap.get(obj);
    if (index == null) {
      index = this._index;
      this._objectIndexMap.set(obj, index);
      this._index++;
    }
    return index;
  }
};
function shallowCloneBufferGeometry(geometry) {
  var _a2, _b, _c2, _d;
  const clone = new BufferGeometry();
  clone.name = geometry.name;
  clone.setIndex(geometry.index);
  for (const [name, attribute] of Object.entries(geometry.attributes)) {
    clone.setAttribute(name, attribute);
  }
  for (const [key, morphAttributes] of Object.entries(geometry.morphAttributes)) {
    const attributeName = key;
    clone.morphAttributes[attributeName] = morphAttributes.concat();
  }
  clone.morphTargetsRelative = geometry.morphTargetsRelative;
  clone.groups = [];
  for (const group of geometry.groups) {
    clone.addGroup(group.start, group.count, group.materialIndex);
  }
  clone.boundingSphere = (_b = (_a2 = geometry.boundingSphere) == null ? void 0 : _a2.clone()) != null ? _b : null;
  clone.boundingBox = (_d = (_c2 = geometry.boundingBox) == null ? void 0 : _c2.clone()) != null ? _d : null;
  clone.drawRange.start = geometry.drawRange.start;
  clone.drawRange.count = geometry.drawRange.count;
  clone.userData = geometry.userData;
  return clone;
}
function disposeMaterial(material) {
  Object.values(material).forEach((value) => {
    if (value == null ? void 0 : value.isTexture) {
      const texture = value;
      texture.dispose();
    }
  });
  if (material.isShaderMaterial) {
    const uniforms = material.uniforms;
    if (uniforms) {
      Object.values(uniforms).forEach((uniform) => {
        const value = uniform.value;
        if (value == null ? void 0 : value.isTexture) {
          const texture = value;
          texture.dispose();
        }
      });
    }
  }
  material.dispose();
}
function dispose(object3D) {
  const geometry = object3D.geometry;
  if (geometry) {
    geometry.dispose();
  }
  const skeleton = object3D.skeleton;
  if (skeleton) {
    skeleton.dispose();
  }
  const material = object3D.material;
  if (material) {
    if (Array.isArray(material)) {
      material.forEach((material2) => disposeMaterial(material2));
    } else if (material) {
      disposeMaterial(material);
    }
  }
}
function deepDispose(object3D) {
  object3D.traverse(dispose);
}
function removeUnnecessaryJoints(root, options) {
  var _a2, _b;
  console.warn(
    "VRMUtils.removeUnnecessaryJoints: removeUnnecessaryJoints is deprecated. Use combineSkeletons instead. combineSkeletons contributes more to the performance improvement. This function will be removed in the next major version."
  );
  const experimentalSameBoneCounts = (_a2 = options == null ? void 0 : options.experimentalSameBoneCounts) != null ? _a2 : false;
  const skinnedMeshes = [];
  root.traverse((obj) => {
    if (obj.type !== "SkinnedMesh") {
      return;
    }
    skinnedMeshes.push(obj);
  });
  const attributeToBoneIndexMapMap = /* @__PURE__ */ new Map();
  let maxBones = 0;
  for (const mesh of skinnedMeshes) {
    const geometry = mesh.geometry;
    const attribute = geometry.getAttribute("skinIndex");
    if (attributeToBoneIndexMapMap.has(attribute)) {
      continue;
    }
    const oldToNew = /* @__PURE__ */ new Map();
    const newToOld = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < attribute.count; i2++) {
      for (let j2 = 0; j2 < attribute.itemSize; j2++) {
        const oldIndex = attributeGetComponentCompat(attribute, i2, j2);
        let newIndex = oldToNew.get(oldIndex);
        if (newIndex == null) {
          newIndex = oldToNew.size;
          oldToNew.set(oldIndex, newIndex);
          newToOld.set(newIndex, oldIndex);
        }
        attributeSetComponentCompat(attribute, i2, j2, newIndex);
      }
    }
    attribute.needsUpdate = true;
    attributeToBoneIndexMapMap.set(attribute, newToOld);
    maxBones = Math.max(maxBones, oldToNew.size);
  }
  for (const mesh of skinnedMeshes) {
    const geometry = mesh.geometry;
    const attribute = geometry.getAttribute("skinIndex");
    const newToOld = attributeToBoneIndexMapMap.get(attribute);
    const bones = [];
    const boneInverses = [];
    const nBones = experimentalSameBoneCounts ? maxBones : newToOld.size;
    for (let newIndex = 0; newIndex < nBones; newIndex++) {
      const oldIndex = (_b = newToOld.get(newIndex)) != null ? _b : 0;
      bones.push(mesh.skeleton.bones[oldIndex]);
      boneInverses.push(mesh.skeleton.boneInverses[oldIndex]);
    }
    const skeleton = new Skeleton(bones, boneInverses);
    mesh.bind(skeleton, new Matrix4());
  }
}
function removeUnnecessaryVertices(root) {
  const geometryMap = /* @__PURE__ */ new Map();
  root.traverse((obj) => {
    var _a2, _b, _c2, _d;
    if (!obj.isMesh) {
      return;
    }
    const mesh = obj;
    const geometry = mesh.geometry;
    const originalIndex = geometry.index;
    if (originalIndex == null) {
      return;
    }
    const newGeometryAlreadyExisted = geometryMap.get(geometry);
    if (newGeometryAlreadyExisted != null) {
      mesh.geometry = newGeometryAlreadyExisted;
      return;
    }
    const vertexCount = Object.values(geometry.attributes)[0].count;
    const vertexInUse = new Array(vertexCount);
    let verticesUsed = 0;
    const originalIndexArray = originalIndex.array;
    for (let i2 = 0; i2 < originalIndexArray.length; i2++) {
      const index = originalIndexArray[i2];
      if (!vertexInUse[index]) {
        vertexInUse[index] = true;
        verticesUsed++;
      }
    }
    if (verticesUsed === vertexCount) {
      return;
    }
    const originalIndexNewIndexMap = [];
    const newIndexOriginalIndexMap = [];
    let indexHead = 0;
    for (let i2 = 0; i2 < vertexInUse.length; i2++) {
      if (vertexInUse[i2]) {
        const newIndex = indexHead++;
        originalIndexNewIndexMap[i2] = newIndex;
        newIndexOriginalIndexMap[newIndex] = i2;
      }
    }
    const newGeometry = new BufferGeometry();
    newGeometry.name = geometry.name;
    newGeometry.morphTargetsRelative = geometry.morphTargetsRelative;
    geometry.groups.forEach((group) => {
      newGeometry.addGroup(group.start, group.count, group.materialIndex);
    });
    newGeometry.boundingBox = (_b = (_a2 = geometry.boundingBox) == null ? void 0 : _a2.clone()) != null ? _b : null;
    newGeometry.boundingSphere = (_d = (_c2 = geometry.boundingSphere) == null ? void 0 : _c2.clone()) != null ? _d : null;
    newGeometry.setDrawRange(geometry.drawRange.start, geometry.drawRange.count);
    newGeometry.userData = geometry.userData;
    geometryMap.set(geometry, newGeometry);
    {
      const originalIndexArray2 = originalIndex.array;
      const newIndexArray = new originalIndexArray2.constructor(originalIndexArray2.length);
      for (let i2 = 0; i2 < originalIndexArray2.length; i2++) {
        const originalIndex2 = originalIndexArray2[i2];
        const newIndex = originalIndexNewIndexMap[originalIndex2];
        newIndexArray[i2] = newIndex;
      }
      newGeometry.setIndex(new BufferAttribute(newIndexArray, 1, false));
    }
    Object.keys(geometry.attributes).forEach((attributeName) => {
      const originalAttribute = geometry.attributes[attributeName];
      if (originalAttribute.isInterleavedBufferAttribute) {
        throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
      }
      const originalAttributeArray = originalAttribute.array;
      const { itemSize, normalized } = originalAttribute;
      const newAttributeArray = new originalAttributeArray.constructor(
        newIndexOriginalIndexMap.length * itemSize
      );
      newIndexOriginalIndexMap.forEach((originalIndex2, i2) => {
        for (let j2 = 0; j2 < itemSize; j2++) {
          newAttributeArray[i2 * itemSize + j2] = originalAttributeArray[originalIndex2 * itemSize + j2];
        }
      });
      newGeometry.setAttribute(attributeName, new BufferAttribute(newAttributeArray, itemSize, normalized));
    });
    let isNullMorph = true;
    for (const [key, morphAttributes] of Object.entries(geometry.morphAttributes)) {
      const attributeName = key;
      newGeometry.morphAttributes[attributeName] = [];
      for (let iMorph = 0; iMorph < morphAttributes.length; iMorph++) {
        const originalAttribute = morphAttributes[iMorph];
        if (originalAttribute.isInterleavedBufferAttribute) {
          throw new Error("removeUnnecessaryVertices: InterleavedBufferAttribute is not supported");
        }
        const originalAttributeArray = originalAttribute.array;
        const { itemSize, normalized } = originalAttribute;
        const newAttributeArray = new originalAttributeArray.constructor(
          newIndexOriginalIndexMap.length * itemSize
        );
        newIndexOriginalIndexMap.forEach((originalIndex2, i2) => {
          for (let j2 = 0; j2 < itemSize; j2++) {
            newAttributeArray[i2 * itemSize + j2] = originalAttributeArray[originalIndex2 * itemSize + j2];
          }
        });
        isNullMorph = isNullMorph && newAttributeArray.every((v2) => v2 === 0);
        newGeometry.morphAttributes[attributeName][iMorph] = new BufferAttribute(
          newAttributeArray,
          itemSize,
          normalized
        );
      }
    }
    if (isNullMorph) {
      newGeometry.morphAttributes = {};
    }
    mesh.geometry = newGeometry;
  });
  Array.from(geometryMap.keys()).forEach((originalGeometry) => {
    originalGeometry.dispose();
  });
}
function rotateVRM0(vrm) {
  var _a2;
  if (((_a2 = vrm.meta) == null ? void 0 : _a2.metaVersion) === "0") {
    vrm.scene.rotation.y = Math.PI;
  }
}
var VRMUtils = class {
  constructor() {
  }
};
VRMUtils.combineMorphs = combineMorphs;
VRMUtils.combineSkeletons = combineSkeletons;
VRMUtils.deepDispose = deepDispose;
VRMUtils.removeUnnecessaryJoints = removeUnnecessaryJoints;
VRMUtils.removeUnnecessaryVertices = removeUnnecessaryVertices;
VRMUtils.rotateVRM0 = rotateVRM0;

// src/webrtc/MeetingPage.js
var ICE_SERVERS = [
  { urls: "stun:stun.l.google.com:19302" },
  {
    urls: [
      "turn:onsil.study:3478?transport=udp",
      "turn:onsil.study:3478?transport=tcp"
    ],
    username: "test",
    credential: "test"
  }
];
var SFU_WS_BASE = process.env.REACT_APP_SFU_WS_HOST || "";
function getSfuWsUrl() {
  const protocol = window.location.protocol === "https:" ? "wss" : "ws";
  const host = SFU_WS_BASE || window.location.hostname;
  const port = SFU_WS_BASE ? "" : window.location.port ? `:${window.location.port}` : "";
  return `${protocol}://${host}${port}/sfu/`;
}
function getSfuLeaveBeaconUrl() {
  const wsUrl = getSfuWsUrl();
  const httpUrl = wsUrl.replace(/^ws/i, "http");
  return `${httpUrl.replace(/\/$/, "")}/leave`;
}
function sendSfuLeaveBeacon(roomId, peerId) {
  if (!roomId || !peerId) return false;
  if (typeof navigator === "undefined" || typeof navigator.sendBeacon !== "function") return false;
  try {
    const body = JSON.stringify({ roomId, peerId });
    const blob = new Blob([body], { type: "application/json" });
    return navigator.sendBeacon(getSfuLeaveBeaconUrl(), blob);
  } catch {
    return false;
  }
}
var PARTICIPANTS_SNAPSHOT_KEY_PREFIX = "meeting.participants.snapshot.";
var PARTICIPANTS_SNAPSHOT_TTL_MS = 5 * 60 * 1e3;
var PARTICIPANT_MEDIA_STATE_KEY_PREFIX = "meeting.participants.media-state.";
var PARTICIPANT_MEDIA_STATE_TTL_MS = 30 * 60 * 1e3;
function getParticipantsSnapshotKey(roomId) {
  return `${PARTICIPANTS_SNAPSHOT_KEY_PREFIX}${roomId || ""}`;
}
function loadParticipantsSnapshot(roomId) {
  if (!roomId) return [];
  try {
    const raw = sessionStorage.getItem(getParticipantsSnapshotKey(roomId));
    if (!raw) return [];
    const parsed = JSON.parse(raw);
    const savedAt = Number(parsed?.savedAt || 0);
    if (!savedAt || Date.now() - savedAt > PARTICIPANTS_SNAPSHOT_TTL_MS) {
      sessionStorage.removeItem(getParticipantsSnapshotKey(roomId));
      return [];
    }
    const list = Array.isArray(parsed?.participants) ? parsed.participants : [];
    return list.filter((p2) => p2 && p2.id != null).map((p2) => ({
      id: String(p2.id),
      userId: p2.userId != null ? String(p2.userId) : String(p2.id),
      name: p2.name || "\uCC38\uC5EC\uC790",
      email: p2.email || "",
      joinAt: Number(p2.joinAt || Date.now()),
      isMe: !!p2.isMe,
      isHost: !!p2.isHost,
      muted: !!p2.muted,
      cameraOff: !!p2.cameraOff,
      mutedByHost: !!p2.mutedByHost,
      cameraOffByHost: !!p2.cameraOffByHost,
      faceEmoji: p2.faceEmoji ?? null,
      bgRemove: !!p2.bgRemove,
      speaking: false,
      reaction: null,
      stream: null,
      screenStream: null,
      isScreenSharing: false,
      isJoining: false,
      isReconnecting: true,
      isLoading: true,
      reconnectStartedAt: Date.now(),
      lastUpdate: Date.now()
    }));
  } catch {
    return [];
  }
}
function getParticipantMediaStateKey(roomId) {
  return `${PARTICIPANT_MEDIA_STATE_KEY_PREFIX}${roomId || ""}`;
}
function loadParticipantMediaStateCache(roomId) {
  if (!roomId) return {};
  try {
    const raw = sessionStorage.getItem(getParticipantMediaStateKey(roomId));
    if (!raw) return {};
    const parsed = JSON.parse(raw);
    const savedAt = Number(parsed?.savedAt || 0);
    if (!savedAt || Date.now() - savedAt > PARTICIPANT_MEDIA_STATE_TTL_MS) {
      sessionStorage.removeItem(getParticipantMediaStateKey(roomId));
      return {};
    }
    const rawState = parsed?.state && typeof parsed.state === "object" ? parsed.state : {};
    const normalized = {};
    for (const [peerId, value] of Object.entries(rawState)) {
      if (!peerId || !value || typeof value !== "object") continue;
      const entry = {};
      if (typeof value.muted === "boolean") entry.muted = value.muted;
      if (typeof value.cameraOff === "boolean") entry.cameraOff = value.cameraOff;
      if (!Object.prototype.hasOwnProperty.call(entry, "muted") && !Object.prototype.hasOwnProperty.call(entry, "cameraOff")) {
        continue;
      }
      entry.updatedAt = Number(value.updatedAt || savedAt || Date.now());
      normalized[String(peerId)] = entry;
    }
    return normalized;
  } catch {
    return {};
  }
}
function persistParticipantMediaStateCache(roomId, stateMap) {
  if (!roomId) return;
  try {
    sessionStorage.setItem(
      getParticipantMediaStateKey(roomId),
      JSON.stringify({
        savedAt: Date.now(),
        state: stateMap || {}
      })
    );
  } catch {
  }
}
function getParticipantMediaEmailKey(email) {
  const normalized = String(email || "").trim().toLowerCase();
  return normalized ? `email:${normalized}` : "";
}
function resolveRemoteMutedState(incomingMuted, prevMuted, rememberedMuted) {
  if (incomingMuted === true) return true;
  if (incomingMuted === false) {
    if (prevMuted === true || rememberedMuted === true) return true;
    return false;
  }
  if (typeof prevMuted === "boolean") return prevMuted;
  if (typeof rememberedMuted === "boolean") return rememberedMuted;
  return false;
}
var _sharedAudioCtx = null;
var _audioCtxLocked = false;
function getSharedAudioContext() {
  if (_audioCtxLocked) return null;
  const AudioContext2 = window.AudioContext || window.webkitAudioContext;
  if (!AudioContext2) return null;
  if (!_sharedAudioCtx || _sharedAudioCtx.state === "closed") {
    _sharedAudioCtx = new AudioContext2();
  }
  if (_sharedAudioCtx.state === "suspended") {
    _sharedAudioCtx.resume().catch(() => {
    });
  }
  return _sharedAudioCtx;
}
function closeSharedAudioContext() {
  _audioCtxLocked = true;
  if (_sharedAudioCtx && _sharedAudioCtx.state !== "closed") {
    try {
      _sharedAudioCtx.close();
    } catch {
    }
  }
  _sharedAudioCtx = null;
}
function unlockSharedAudioContext() {
  _audioCtxLocked = false;
}
var ButtonControl = ({ active, danger, disabled, icon: Icon2, onClick, label }) => /* @__PURE__ */ React.createElement(
  "button",
  {
    onClick,
    disabled,
    className: `btn-control ${danger ? "danger" : ""} ${active ? "active" : ""} ${disabled ? "disabled" : ""}`,
    title: label
  },
  /* @__PURE__ */ React.createElement(Icon2, { size: 20, strokeWidth: 2.5 }),
  /* @__PURE__ */ React.createElement("span", { className: "tooltip" }, label)
);
var UserAvatar = ({ name, size = "md", src }) => {
  const initials = (name || "?").split(" ").map((n2) => n2[0]).join("").substring(0, 2);
  if (src) return /* @__PURE__ */ React.createElement("img", { src, alt: name, className: `user-avatar ${size}` });
  return /* @__PURE__ */ React.createElement("div", { className: `user-avatar ${size} placeholder` }, initials);
};
var globalFrameCache = /* @__PURE__ */ new Map();
var VideoTile = ({ user, isMain = false, stream, isScreen, reaction, roomReconnecting = false, videoRef, isFilterPreparing = false, isBrowserPipMode = false, onSpeakingChange }) => {
  const internalVideoRef = (0, import_react6.useRef)(null);
  const videoEl = internalVideoRef;
  const setVideoRef = (el) => {
    internalVideoRef.current = el;
    if (videoRef) videoRef.current = el;
  };
  const displayCanvasRef = (0, import_react6.useRef)(null);
  const canvasCtxRef = (0, import_react6.useRef)(null);
  const rafIdRef = (0, import_react6.useRef)(null);
  const lastValidFrameRef = (0, import_react6.useRef)(false);
  const lastFrameImageDataRef = (0, import_react6.useRef)(null);
  const lastCanvasSizeRef = (0, import_react6.useRef)({ width: 0, height: 0 });
  const safeUser = user ?? {
    id: "",
    name: "\uB300\uAE30 \uC911",
    isMe: false,
    muted: true,
    cameraOff: true,
    speaking: false,
    isLoading: false
  };
  const [trackVersion, setTrackVersion] = (0, import_react6.useState)(0);
  const hasLiveVideoTrack = (0, import_react6.useMemo)(() => {
    return stream?.getVideoTracks().some((t2) => t2.readyState === "live" && !t2.muted) ?? false;
  }, [stream, trackVersion]);
  (0, import_react6.useEffect)(() => {
    const track = stream?.getVideoTracks()[0];
    if (!track) return;
    const handleTrackChange = () => setTrackVersion((v2) => v2 + 1);
    track.addEventListener("mute", handleTrackChange);
    track.addEventListener("unmute", handleTrackChange);
    track.addEventListener("ended", handleTrackChange);
    return () => {
      track.removeEventListener("mute", handleTrackChange);
      track.removeEventListener("unmute", handleTrackChange);
      track.removeEventListener("ended", handleTrackChange);
    };
  }, [stream]);
  const showVideoOffIcon = !isScreen && !!safeUser.cameraOff;
  const canShowVideo = (0, import_react6.useMemo)(() => {
    if (!stream) return false;
    if (isScreen) return stream.getVideoTracks().length > 0;
    if (safeUser.isMe) return hasLiveVideoTrack;
    return hasLiveVideoTrack;
  }, [stream, isScreen, hasLiveVideoTrack, safeUser.isMe]);
  const shouldRenderVideo = (0, import_react6.useMemo)(() => {
    if (!stream) return false;
    if (isScreen) return stream.getVideoTracks().length > 0;
    if (safeUser.cameraOff) return false;
    const hasLiveTrack = stream.getVideoTracks().some((t2) => t2.readyState === "live");
    if (hasLiveTrack) return true;
    if (stream.getVideoTracks().length > 0) return true;
    return canShowVideo;
  }, [stream, isScreen, safeUser.cameraOff, safeUser.isMe, isFilterPreparing, canShowVideo]);
  const streamIdRef = (0, import_react6.useRef)(null);
  const currentStreamId = stream?.id ?? null;
  const lastDisplayStreamRef = (0, import_react6.useRef)(null);
  const displayStream = (0, import_react6.useMemo)(() => {
    const vid = stream?.getVideoTracks?.()?.[0];
    const lastVid = lastDisplayStreamRef.current?.getVideoTracks?.()?.[0];
    if (!stream) {
      lastDisplayStreamRef.current = null;
      return null;
    }
    if (vid && lastVid && vid.id === lastVid.id && lastDisplayStreamRef.current) {
      return lastDisplayStreamRef.current;
    }
    lastDisplayStreamRef.current = stream;
    return stream;
  }, [stream, stream?.getVideoTracks?.()?.[0]?.id]);
  const displayStreamId = displayStream?.id ?? null;
  (0, import_react6.useLayoutEffect)(() => {
    const v2 = videoEl.current;
    const canvas = displayCanvasRef.current;
    const cacheKey = (safeUser?.id != null ? String(safeUser.id) : "") || `stream_${displayStreamId}`;
    if (!v2 || !canvas) return;
    if (!shouldRenderVideo) {
      if (rafIdRef.current) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
      return;
    }
    if (!canvasCtxRef.current || canvasCtxRef.current.canvas !== canvas) {
      canvasCtxRef.current = canvas.getContext("2d", { willReadFrequently: true });
    }
    const ctx = canvasCtxRef.current;
    if (!ctx) return;
    let isActive = true;
    let frameCount = 0;
    const restoreFromCache = () => {
      const cached = globalFrameCache.get(cacheKey);
      if (cached && cached.imageData && cached.width > 0 && cached.height > 0) {
        if (canvas.width === 0 || canvas.height === 0) {
          canvas.width = cached.width;
          canvas.height = cached.height;
        }
        try {
          if (canvas.width === cached.width && canvas.height === cached.height) {
            ctx.putImageData(cached.imageData, 0, 0);
          } else {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = cached.width;
            tempCanvas.height = cached.height;
            const tempCtx = tempCanvas.getContext("2d");
            if (tempCtx) {
              tempCtx.putImageData(cached.imageData, 0, 0);
              ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
            }
          }
          return true;
        } catch (e2) {
        }
      }
      return false;
    };
    const saveToCache = () => {
      if (canvas.width > 0 && canvas.height > 0) {
        try {
          const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
          globalFrameCache.set(cacheKey, {
            imageData,
            width: canvas.width,
            height: canvas.height,
            timestamp: Date.now()
          });
          lastFrameImageDataRef.current = imageData;
          lastCanvasSizeRef.current = { width: canvas.width, height: canvas.height };
        } catch (e2) {
        }
      }
    };
    const drawFrame = () => {
      if (!isActive) return;
      const hasValidFrame = v2.readyState >= 2 && v2.videoWidth > 0 && v2.videoHeight > 0 && !v2.paused;
      if (hasValidFrame) {
        const needsResize = canvas.width !== v2.videoWidth || canvas.height !== v2.videoHeight;
        if (needsResize) {
          if (canvas.width > 0 && canvas.height > 0 && lastValidFrameRef.current) {
            saveToCache();
          }
          canvas.width = v2.videoWidth;
          canvas.height = v2.videoHeight;
          restoreFromCache();
        }
        try {
          ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
          lastValidFrameRef.current = true;
          frameCount++;
          if (frameCount % 15 === 0) {
            saveToCache();
          }
        } catch (e2) {
        }
      } else {
        restoreFromCache();
      }
      rafIdRef.current = requestAnimationFrame(drawFrame);
    };
    const cachedRestored = restoreFromCache();
    if (!cachedRestored && lastFrameImageDataRef.current && lastCanvasSizeRef.current.width > 0) {
      if (canvas.width === 0 || canvas.height === 0) {
        canvas.width = lastCanvasSizeRef.current.width;
        canvas.height = lastCanvasSizeRef.current.height;
      }
      try {
        if (canvas.width === lastCanvasSizeRef.current.width && canvas.height === lastCanvasSizeRef.current.height) {
          ctx.putImageData(lastFrameImageDataRef.current, 0, 0);
        } else {
          const tempCanvas = document.createElement("canvas");
          tempCanvas.width = lastCanvasSizeRef.current.width;
          tempCanvas.height = lastCanvasSizeRef.current.height;
          const tempCtx = tempCanvas.getContext("2d");
          if (tempCtx) {
            tempCtx.putImageData(lastFrameImageDataRef.current, 0, 0);
            ctx.drawImage(tempCanvas, 0, 0, canvas.width, canvas.height);
          }
        }
      } catch (e2) {
      }
    }
    drawFrame();
    return () => {
      isActive = false;
      if (rafIdRef.current) {
        cancelAnimationFrame(rafIdRef.current);
        rafIdRef.current = null;
      }
    };
  }, [displayStream, shouldRenderVideo]);
  (0, import_react6.useEffect)(() => {
    const v2 = videoEl.current;
    if (!v2) return;
    const hasLiveStream = (displayStream || stream) && (displayStream || stream).getVideoTracks().some((t2) => t2.readyState === "live");
    if (!shouldRenderVideo) {
      if (hasLiveStream && v2.srcObject && v2.paused) {
        v2.play().catch(() => {
        });
      }
      return;
    }
    const needsUpdate = displayStream && (streamIdRef.current !== displayStreamId || v2.srcObject !== displayStream || !v2.srcObject);
    if (displayStream && needsUpdate) {
      try {
        v2.srcObject = displayStream;
        streamIdRef.current = displayStreamId;
      } catch (e2) {
        console.warn("[VideoTile] srcObject \uC5C5\uB370\uC774\uD2B8 \uC2E4\uD328:", e2);
      }
    }
    v2.muted = true;
    const ensurePlay = async () => {
      if (!v2 || !v2.srcObject) return;
      if (!shouldRenderVideo && !hasLiveStream) return;
      try {
        if (v2.paused || v2.readyState < 2) {
          await v2.play();
        }
      } catch (err) {
        setTimeout(() => {
          if (v2 && v2.srcObject && (shouldRenderVideo || hasLiveStream)) {
            v2.play().catch(() => {
            });
          }
        }, 50);
      }
    };
    ensurePlay();
    const playRetryInterval = setInterval(() => {
      if (!v2 || !v2.srcObject) {
        if (hasLiveStream && v2 && displayStream) {
          v2.srcObject = displayStream;
          v2.play().catch(() => {
          });
        } else {
          clearInterval(playRetryInterval);
          return;
        }
      }
      if (!shouldRenderVideo && !hasLiveStream) {
        clearInterval(playRetryInterval);
        return;
      }
      const hasLiveTrack = displayStream && displayStream.getVideoTracks().some((t2) => t2.readyState === "live");
      if (hasLiveTrack && (v2.paused || v2.readyState < 2)) {
        v2.play().catch(() => {
        });
      } else if (hasLiveTrack && !v2.paused) {
        clearInterval(playRetryInterval);
      }
    }, 500);
    const handleVisibilityChange = () => {
      if (!document.hidden && v2 && v2.srcObject && shouldRenderVideo) {
        console.log("[VideoTile] \uD0ED\uC774 \uB2E4\uC2DC \uBCF4\uC784, \uBE44\uB514\uC624 \uC7AC\uC0DD \uC2DC\uB3C4");
        ensurePlay();
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    const handlePipLeave = () => {
      console.log("[VideoTile] PIP \uBAA8\uB4DC \uC885\uB8CC \uAC10\uC9C0, \uBE44\uB514\uC624 \uC7AC\uC0DD \uC2DC\uB3C4");
      if (v2 && displayStream) {
        const forceReconnect = () => {
          try {
            if (!v2.srcObject || v2.srcObject !== displayStream) {
              v2.srcObject = displayStream;
              streamIdRef.current = displayStreamId;
              console.log("[VideoTile] \u2705 PIP \uC885\uB8CC \uD6C4 srcObject \uC7AC\uC124\uC815 \uC644\uB8CC");
            }
          } catch (e2) {
            console.warn("[VideoTile] PIP \uC885\uB8CC \uC2DC srcObject \uC124\uC815 \uC2E4\uD328:", e2);
          }
        };
        forceReconnect();
        const retryPlay = async (attempt = 0) => {
          if (attempt > 15) return;
          if (!v2 || !displayStream) return;
          forceReconnect();
          const hasLive = displayStream.getVideoTracks().some((t2) => t2.readyState === "live");
          if (!hasLive && attempt < 5) {
            setTimeout(() => retryPlay(attempt + 1), 100);
            return;
          }
          try {
            if (v2.paused || v2.readyState < 2) {
              await v2.play();
              console.log("[VideoTile] \u2705 PIP \uC885\uB8CC \uD6C4 \uBE44\uB514\uC624 \uC7AC\uC0DD \uC131\uACF5 (\uC2DC\uB3C4:", attempt + 1, ")");
            } else {
              console.log("[VideoTile] \u2705 PIP \uC885\uB8CC \uD6C4 \uBE44\uB514\uC624 \uC774\uBBF8 \uC7AC\uC0DD \uC911");
              return;
            }
          } catch (err) {
            console.warn("[VideoTile] PIP \uC885\uB8CC \uD6C4 \uBE44\uB514\uC624 \uC7AC\uC0DD \uC2E4\uD328 (\uC2DC\uB3C4:", attempt + 1, "):", err);
            setTimeout(() => retryPlay(attempt + 1), 30);
          }
        };
        retryPlay();
        setTimeout(() => retryPlay(3), 100);
        setTimeout(() => retryPlay(6), 300);
      }
    };
    if (v2) {
      v2.addEventListener("leavepictureinpicture", handlePipLeave);
    }
    return () => {
      clearInterval(playRetryInterval);
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      if (v2) {
        v2.removeEventListener("leavepictureinpicture", handlePipLeave);
      }
    };
  }, [displayStream, shouldRenderVideo, displayStreamId]);
  const isSpeaking = !!safeUser.speaking;
  const isJoining = safeUser.isJoining;
  const isReconnecting = safeUser.isReconnecting;
  const showRoomReconnecting = roomReconnecting && !safeUser.isMe;
  const shouldShowReconnecting = isReconnecting;
  const peerId = safeUser?.id != null ? String(safeUser.id) : "";
  const peerName = safeUser?.name != null ? String(safeUser.name) : "";
  return /* @__PURE__ */ React.createElement(
    "div",
    {
      className: `video-tile ${isMain ? "main" : ""} ${safeUser.isMe ? "me" : ""} ${isSpeaking ? "speaking" : ""} ${isScreen ? "screen-share" : ""}`,
      "data-peer-id": peerId,
      "data-peer-name": peerName
    },
    shouldShowReconnecting && /* @__PURE__ */ React.createElement("div", { className: "reconnecting-overlay" }, /* @__PURE__ */ React.createElement(LoaderCircle, { className: "spinner" }), /* @__PURE__ */ React.createElement("p", null, "\uC7AC\uC811\uC18D \uC911...")),
    /* @__PURE__ */ React.createElement("div", { className: `video-content ${isScreen ? "screen-share" : ""}`, style: { position: "relative" } }, /* @__PURE__ */ React.createElement(
      "video",
      {
        ref: setVideoRef,
        autoPlay: true,
        playsInline: true,
        muted: true,
        "data-main-video": isMain ? "main" : "tile",
        "data-peer-id": peerId,
        "data-peer-name": peerName,
        className: `video-element ${isScreen ? "screen" : ""}`,
        style: {
          position: "absolute",
          width: "1px",
          height: "1px",
          opacity: 0,
          pointerEvents: "none"
        }
      }
    ), /* @__PURE__ */ React.createElement(
      "canvas",
      {
        ref: displayCanvasRef,
        className: `video-element ${isScreen ? "screen" : ""}`,
        style: {
          width: "100%",
          height: "100%",
          objectFit: isScreen ? "contain" : "cover",
          display: "block",
          //  shouldRenderVideo false canvas DOM  (  )
          // opacity  canvas  
          opacity: shouldRenderVideo ? 1 : 0,
          position: shouldRenderVideo ? "relative" : "absolute",
          pointerEvents: shouldRenderVideo ? "auto" : "none"
        }
      }
    ), !shouldRenderVideo && /* @__PURE__ */ React.createElement(
      "div",
      {
        className: "camera-off-placeholder",
        style: isMain ? { position: "absolute", zIndex: 1, top: "50%", left: "50%", transform: "translate(-50%, -50%)" } : { position: "relative", zIndex: 1 }
      },
      /* @__PURE__ */ React.createElement(UserAvatar, { name: safeUser.name, size: isMain ? "lg" : "md" }),
      /* @__PURE__ */ React.createElement("p", { className: "stream-label" }, safeUser.name)
    )),
    /* @__PURE__ */ React.createElement("div", { className: "video-overlay" }, safeUser.muted === true && /* @__PURE__ */ React.createElement(MicOff, { size: 16, className: "icon-red" }), showVideoOffIcon && /* @__PURE__ */ React.createElement(VideoOff, { size: 16, className: "icon-red" })),
    reaction && /* @__PURE__ */ React.createElement("div", { className: "reaction-overlay" }, reaction)
  );
};
function safeUUID() {
  if (typeof window !== "undefined" && window.crypto && typeof window.crypto.randomUUID === "function") {
    return window.crypto.randomUUID();
  }
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = Math.random() * 16 | 0;
    const v2 = c2 === "x" ? r2 : r2 & 3 | 8;
    return v2.toString(16);
  });
}
function MeetingPage({ portalRoomId }) {
  const params = useParams();
  const [searchParams] = useSearchParams();
  const location = useLocation();
  const navigate = useNavigate();
  const loggedRef = (0, import_react6.useRef)(false);
  const pathMatch = (0, import_react6.useMemo)(() => location.pathname.match(/\/lms\/([^/]+)\/MeetingRoom\/([^/]+)/), [location.pathname]);
  const subjectIdFromPath = pathMatch ? pathMatch[1] : null;
  const roomIdFromPath = pathMatch ? pathMatch[2] : null;
  const roomId = roomIdFromPath || params.roomId || portalRoomId || sessionStorage.getItem("pip.roomId");
  const subjectId = subjectIdFromPath || params.subjectId || sessionStorage.getItem("pip.subjectId");
  (0, import_react6.useEffect)(() => {
    if (!roomId) return;
    if (loggedRef.current) return;
    console.log("[CLIENT] roomId =", roomId, "(from:", params.roomId ? "URL" : "portal/session", ")");
    loggedRef.current = true;
  }, [roomId, params.roomId]);
  const {
    startMeeting,
    endMeeting,
    saveMeetingState,
    requestBrowserPip,
    isPipMode,
    isBrowserPipMode,
    customPipData,
    pipVideoRef
    //   PIP  video element ref
  } = useMeeting();
  const { roomTitle, email, user, room, roomNickname } = useLMS();
  const hostUserEmail = room?.hostUserEmail || "";
  const scheduleId = searchParams.get("scheduleId") ?? room?.scheduleId ?? (() => {
    try {
      const s2 = sessionStorage.getItem("pip.scheduleId");
      return s2 != null && s2 !== "" ? Number(s2) : null;
    } catch {
      return null;
    }
  })();
  const userEmail = (email || user?.email || sessionStorage.getItem("userEmail") || "").trim();
  const isHostLocal = !!userEmail && !!hostUserEmail && String(userEmail).toLowerCase() === String(hostUserEmail).trim().toLowerCase();
  (0, import_react6.useEffect)(() => {
    if (!roomId || !subjectId) return;
    unlockSharedAudioContext();
    console.log("[MeetingPage] startMeeting", { roomId, subjectId });
    startMeeting(roomId, subjectId);
  }, [roomId, subjectId, startMeeting]);
  const prevRoomIdRef = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(() => {
    if (!roomId) return;
    const prev = prevRoomIdRef.current;
    prevRoomIdRef.current = roomId;
    if (prev != null && prev !== roomId) {
      try {
        localStorage.removeItem("micOn");
        localStorage.removeItem("camOn");
      } catch {
      }
      setMicOn(true);
      setCamOn(true);
    }
  }, [roomId]);
  (0, import_react6.useEffect)(() => {
    if (subjectId) try {
      sessionStorage.setItem("pip.subjectId", subjectId);
    } catch (e2) {
    }
    if (scheduleId != null && scheduleId !== "") try {
      sessionStorage.setItem("pip.scheduleId", String(scheduleId));
    } catch (e2) {
    }
    if (roomId) try {
      sessionStorage.setItem("pip.roomId", roomId);
    } catch (e2) {
    }
  }, [subjectId, scheduleId, roomId]);
  (0, import_react6.useEffect)(() => {
    if (!pipVideoRef) return;
    if (pipVideoRef.current) {
      console.log("[MeetingPage] \uC228\uACA8\uC9C4 PIP video\uAC00 \uC774\uBBF8 \uC874\uC7AC\uD569\uB2C8\uB2E4.");
      return;
    }
    const hiddenVideo = document.createElement("video");
    hiddenVideo.autoplay = true;
    hiddenVideo.playsInline = true;
    hiddenVideo.muted = true;
    hiddenVideo.style.cssText = "position:fixed; bottom:-9999px; right:-9999px; width:1px; height:1px; opacity:0; pointer-events:none; z-index:-9999;";
    document.body.appendChild(hiddenVideo);
    pipVideoRef.current = hiddenVideo;
    console.log("[MeetingPage] \u2705 \uC228\uACA8\uC9C4 PIP video element \uC0DD\uC131 \uC644\uB8CC");
    const handleVisibilityChange = () => {
      if (!document.hidden && hiddenVideo && hiddenVideo.paused && hiddenVideo.srcObject) {
        console.log("[MeetingPage] \uD0ED\uC774 \uB2E4\uC2DC \uBCF4\uC784, \uC228\uACA8\uC9C4 PIP video \uC7AC\uC0DD \uC2DC\uB3C4");
        hiddenVideo.play().catch((err) => {
          console.warn("[MeetingPage] \uC228\uACA8\uC9C4 PIP video \uC7AC\uC0DD \uC2E4\uD328:", err);
        });
      }
    };
    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
      if (pipVideoRef.current) {
        try {
          pipVideoRef.current.pause();
          pipVideoRef.current.srcObject = null;
          pipVideoRef.current.remove();
        } catch (e2) {
          console.warn("[MeetingPage] \uC228\uACA8\uC9C4 PIP video cleanup \uC911 \uC624\uB958:", e2);
        }
        pipVideoRef.current = null;
      }
    };
  }, [pipVideoRef]);
  const [layoutMode, setLayoutMode] = (0, import_react6.useState)("speaker");
  const [sidebarView, setSidebarView] = (0, import_react6.useState)(() => {
    try {
      return localStorage.getItem("meeting.sidebarView") || "chat";
    } catch {
      return "chat";
    }
  });
  const [sidebarOpen, setSidebarOpen] = (0, import_react6.useState)(() => {
    try {
      const saved = localStorage.getItem("meeting.sidebarOpen");
      return saved !== null ? saved === "true" : true;
    } catch {
      return true;
    }
  });
  const [micOn, setMicOn] = (0, import_react6.useState)(() => {
    const saved = localStorage.getItem("micOn");
    return saved !== null ? saved === "true" : true;
  });
  const [camOn, setCamOn] = (0, import_react6.useState)(() => {
    const saved = localStorage.getItem("camOn");
    return saved !== null ? saved === "true" : true;
  });
  const [mutedByHostMe, setMutedByHostMe] = (0, import_react6.useState)(false);
  const [cameraOffByHostMe, setCameraOffByHostMe] = (0, import_react6.useState)(false);
  const primaryHostUserIdRef = (0, import_react6.useRef)(null);
  const [micPermission, setMicPermission] = (0, import_react6.useState)("prompt");
  const [camPermission, setCamPermission] = (0, import_react6.useState)("prompt");
  const [localStream, setLocalStream] = (0, import_react6.useState)(null);
  const localStreamRef = (0, import_react6.useRef)(null);
  const [isSpeaking, setIsSpeaking] = (0, import_react6.useState)(false);
  const [participants, setParticipants] = (0, import_react6.useState)(() => loadParticipantsSnapshot(roomId));
  const [activeSpeakerId, setActiveSpeakerId] = (0, import_react6.useState)(null);
  const participantMediaStateRef = (0, import_react6.useRef)(loadParticipantMediaStateCache(roomId));
  (0, import_react6.useEffect)(() => {
    participantMediaStateRef.current = loadParticipantMediaStateCache(roomId);
  }, [roomId]);
  const rememberParticipantMediaStateByKeys = (0, import_react6.useCallback)((keys, nextState) => {
    if (!Array.isArray(keys) || !nextState) return;
    const normalizedKeys = [...new Set(
      keys.map((k2) => k2 == null ? "" : String(k2).trim()).filter(Boolean)
    )];
    if (normalizedKeys.length === 0) return;
    const current = participantMediaStateRef.current || {};
    const nextMap = { ...current };
    const now = Date.now();
    let changed = false;
    for (const key of normalizedKeys) {
      const prev = nextMap[key] || {};
      const updated = { ...prev };
      let keyChanged = false;
      if (typeof nextState.muted === "boolean" && updated.muted !== nextState.muted) {
        updated.muted = nextState.muted;
        keyChanged = true;
      }
      if (typeof nextState.cameraOff === "boolean" && updated.cameraOff !== nextState.cameraOff) {
        updated.cameraOff = nextState.cameraOff;
        keyChanged = true;
      }
      if (keyChanged) {
        updated.updatedAt = now;
        nextMap[key] = updated;
        changed = true;
      }
    }
    if (!changed) return;
    participantMediaStateRef.current = nextMap;
    persistParticipantMediaStateCache(roomId, nextMap);
  }, [roomId]);
  const rememberParticipantMediaState = (0, import_react6.useCallback)((peerId, nextState) => {
    rememberParticipantMediaStateByKeys([peerId], nextState);
  }, [rememberParticipantMediaStateByKeys]);
  const getRememberedParticipantMediaState = (0, import_react6.useCallback)((...candidateKeys) => {
    if (!candidateKeys || candidateKeys.length === 0) return null;
    const state = participantMediaStateRef.current || {};
    for (const key of candidateKeys) {
      if (key == null) continue;
      const normalized = String(key).trim();
      if (!normalized) continue;
      if (state[normalized]) return state[normalized];
    }
    return null;
  }, []);
  const [streamVersion, setStreamVersion] = (0, import_react6.useState)(0);
  const [isLocalLoading, setIsLocalLoading] = (0, import_react6.useState)(true);
  const [recvTransportReady, setRecvTransportReady] = (0, import_react6.useState)(false);
  const [isFilterPreparing] = (0, import_react6.useState)(false);
  const [messages, setMessages] = (0, import_react6.useState)(() => {
    try {
      const saved = sessionStorage.getItem(`chat_${roomId}`);
      return saved ? JSON.parse(saved) : [];
    } catch {
      return [];
    }
  });
  const [roomReconnecting, setRoomReconnecting] = (0, import_react6.useState)(true);
  const [sfuReconnectKey, setSfuReconnectKey] = (0, import_react6.useState)(0);
  const [participantCount, setParticipantCount] = (0, import_react6.useState)(1);
  const [chatDraft, setChatDraft] = (0, import_react6.useState)("");
  const [roomStartedAt, setRoomStartedAt] = (0, import_react6.useState)(null);
  const [elapsedTimeDisplay, setElapsedTimeDisplay] = (0, import_react6.useState)("00:00:00");
  const [showReactions, setShowReactions] = (0, import_react6.useState)(false);
  const [myReaction, setMyReaction] = (0, import_react6.useState)(null);
  const [toastMessage, setToastMessage] = (0, import_react6.useState)("");
  const [showToast, setShowToast] = (0, import_react6.useState)(false);
  const [hostMenuTargetId, setHostMenuTargetId] = (0, import_react6.useState)(null);
  const [forceCameraOnRequest, setForceCameraOnRequest] = (0, import_react6.useState)(null);
  const [forceUnmuteRequest, setForceUnmuteRequest] = (0, import_react6.useState)(null);
  const [leaveConfirmModal, setLeaveConfirmModal] = (0, import_react6.useState)(false);
  const [faceEmoji, setFaceEmoji] = (0, import_react6.useState)(() => {
    try {
      return localStorage.getItem("faceEmoji") || sessionStorage.getItem("faceEmoji") || "";
    } catch {
      return "";
    }
  });
  const [faceMode, setFaceMode] = (0, import_react6.useState)(() => {
    try {
      return localStorage.getItem("faceMode") || sessionStorage.getItem("faceMode") || "";
    } catch {
      return "";
    }
  });
  const [bgRemove, setBgRemove] = (0, import_react6.useState)(() => {
    try {
      return localStorage.getItem("faceBgRemove") === "true" || sessionStorage.getItem("faceBgRemove") === "true";
    } catch {
      return false;
    }
  });
  (0, import_react6.useEffect)(() => {
    if (!faceMode && (faceEmoji || bgRemove)) {
      setFaceMode("emoji");
    }
  }, []);
  const wsRef = (0, import_react6.useRef)(null);
  const sfuWsRef = (0, import_react6.useRef)(null);
  const sfuDeviceRef = (0, import_react6.useRef)(null);
  const sendTransportRef = (0, import_react6.useRef)(null);
  const recvTransportRef = (0, import_react6.useRef)(null);
  const restartSendIceRef = (0, import_react6.useRef)(async () => false);
  const restartRecvIceRef = (0, import_react6.useRef)(async () => false);
  const transportIceRestartInFlightRef = (0, import_react6.useRef)({ send: false, recv: false });
  const transportIceRestartLastAtRef = (0, import_react6.useRef)({ send: 0, recv: 0 });
  const stalledVideoSinceRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const localSendStallSinceRef = (0, import_react6.useRef)(0);
  const pendingProducersRef = (0, import_react6.useRef)([]);
  const consumersRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const peerStreamsRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const producersRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const audioElsRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const userIdRef = (0, import_react6.useRef)(null);
  const userNameRef = (0, import_react6.useRef)(null);
  const peerIdToNameRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const effectAliveRef = (0, import_react6.useRef)(true);
  const chatEndRef = (0, import_react6.useRef)(null);
  const chatAreaRef = (0, import_react6.useRef)(null);
  const [chatConnected, setChatConnected] = (0, import_react6.useState)(false);
  const lastSpeakingRef = (0, import_react6.useRef)(null);
  const isInitialMountRef = (0, import_react6.useRef)(true);
  const reactionTimersRef = (0, import_react6.useRef)({});
  const micOnRef = (0, import_react6.useRef)(micOn);
  const camOnRef = (0, import_react6.useRef)(camOn);
  const micPermissionRef = (0, import_react6.useRef)(micPermission);
  const camPermissionRef = (0, import_react6.useRef)(camPermission);
  const isFilterPreparingRef = (0, import_react6.useRef)(isFilterPreparing);
  const lastCameraTrackRef = (0, import_react6.useRef)(null);
  const faceEmojiRef = (0, import_react6.useRef)(faceEmoji);
  const faceModeRef = (0, import_react6.useRef)(faceMode);
  const bgRemoveRef = (0, import_react6.useRef)(bgRemove);
  const faceFilterActiveRef = (0, import_react6.useRef)(false);
  const faceFilterRafRef = (0, import_react6.useRef)(null);
  const faceFilterVideoElRef = (0, import_react6.useRef)(null);
  const faceFilterCanvasRef = (0, import_react6.useRef)(null);
  const faceBgFrameCanvasRef = (0, import_react6.useRef)(null);
  const faceFilterLastGoodFrameCanvasRef = (0, import_react6.useRef)(null);
  const faceFilterLastGoodFrameAtRef = (0, import_react6.useRef)(0);
  const faceBgMaskCanvasRef = (0, import_react6.useRef)(null);
  const faceBgSegmenterRef = (0, import_react6.useRef)(null);
  const faceBgLastInferAtRef = (0, import_react6.useRef)(0);
  const faceFilterOutStreamRef = (0, import_react6.useRef)(null);
  const faceFilterOutTrackRef = (0, import_react6.useRef)(null);
  const faceFilterRawTrackRef = (0, import_react6.useRef)(null);
  const faceDetectorRef = (0, import_react6.useRef)(null);
  const lastFaceBoxRef = (0, import_react6.useRef)(null);
  const smoothedFaceBoxRef = (0, import_react6.useRef)(null);
  const hasEverDrawnEmojiRef = (0, import_react6.useRef)(false);
  const emojiBlackScreenStartedAtRef = (0, import_react6.useRef)(0);
  const emojiBlackScreenToastShownRef = (0, import_react6.useRef)(false);
  const lastDetectAtRef = (0, import_react6.useRef)(0);
  const lastFaceBoxAtRef = (0, import_react6.useRef)(0);
  const faceDetectorLoadingRef = (0, import_react6.useRef)(null);
  const faceDetectorLastAttemptAtRef = (0, import_react6.useRef)(0);
  const faceDetectInFlightRef = (0, import_react6.useRef)(false);
  const bottomStripRef = (0, import_react6.useRef)(null);
  const isDraggingRef = (0, import_react6.useRef)(false);
  const startXRef = (0, import_react6.useRef)(0);
  const scrollLeftRef = (0, import_react6.useRef)(0);
  const faceDetectSeqRef = (0, import_react6.useRef)(0);
  const faceDetectCanvasRef = (0, import_react6.useRef)(null);
  const faceDetectCtxRef = (0, import_react6.useRef)(null);
  const pipelineWarmupUntilRef = (0, import_react6.useRef)(0);
  const faceEmojiOpRef = (0, import_react6.useRef)(Promise.resolve());
  const normalizeFaceBox = (box, videoW, videoH) => {
    if (!box) return null;
    let x2 = Number(box.x);
    let y2 = Number(box.y);
    let w2 = Number(box.width);
    let h2 = Number(box.height);
    if (!Number.isFinite(x2) || !Number.isFinite(y2) || !Number.isFinite(w2) || !Number.isFinite(h2)) return null;
    if (w2 <= 0 || h2 <= 0) return null;
    const vw = Number(videoW) || 0;
    const vh = Number(videoH) || 0;
    const looksNormalized = vw > 0 && vh > 0 && w2 <= 1.5 && h2 <= 1.5;
    if (looksNormalized) {
      x2 = x2 * vw;
      y2 = y2 * vh;
      w2 = w2 * vw;
      h2 = h2 * vh;
    }
    if (w2 < 8 || h2 < 8) return null;
    if (vw > 0 && vh > 0) {
      const margin = 8;
      x2 = Math.max(-margin, Math.min(vw + margin, x2));
      y2 = Math.max(-margin, Math.min(vh + margin, y2));
      w2 = Math.max(0, Math.min(vw - x2, w2));
      h2 = Math.max(0, Math.min(vh - y2, h2));
      if (w2 < 8 || h2 < 8) return null;
    }
    return { x: x2, y: y2, width: w2, height: h2 };
  };
  const isValidFaceBox = (box, videoW, videoH) => {
    return !!normalizeFaceBox(box, videoW, videoH);
  };
  const ensureFaceDetector = (0, import_react6.useCallback)(async () => {
    if (faceDetectorRef.current) return faceDetectorRef.current;
    if (faceDetectorLoadingRef.current) return null;
    const now = Date.now();
    if (now - (faceDetectorLastAttemptAtRef.current || 0) < 2e3) return null;
    faceDetectorLastAttemptAtRef.current = now;
    const rawLoading = (async () => {
      if (typeof window !== "undefined" && "FaceDetector" in window) {
        try {
          const native = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
          return { kind: "native", detector: native };
        } catch {
        }
      }
      try {
        const { FaceDetector: MpFaceDetector, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
        );
        const mp = await MpFaceDetector.createFromOptions(vision, {
          baseOptions: {
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite",
            delegate: "CPU"
          },
          runningMode: "VIDEO",
          //   0.5      
          minDetectionConfidence: 0.5
        });
        return { kind: "mediapipe", detector: mp };
      } catch {
        return null;
      }
    })();
    const TIMEOUT_MS = 6e3;
    const loading2 = Promise.race([
      rawLoading,
      new Promise((resolve) => setTimeout(() => resolve(null), TIMEOUT_MS))
    ]);
    faceDetectorLoadingRef.current = loading2;
    const result = await loading2.catch(() => null);
    faceDetectorLoadingRef.current = null;
    if (result && !faceDetectorRef.current) {
      faceDetectorRef.current = result;
    }
    return result;
  }, []);
  const getFaceDetectCanvas = (videoW, videoH) => {
    const MAX_W = 256;
    const vw = Number(videoW) || 0;
    const vh = Number(videoH) || 0;
    const w2 = vw > 0 ? Math.min(MAX_W, vw) : MAX_W;
    const h2 = vw > 0 && vh > 0 ? Math.max(1, Math.round(w2 * (vh / vw))) : 240;
    let c2 = faceDetectCanvasRef.current;
    if (!c2) {
      c2 = document.createElement("canvas");
      faceDetectCanvasRef.current = c2;
    }
    if (c2.width !== w2) c2.width = w2;
    if (c2.height !== h2) c2.height = h2;
    let ctx = faceDetectCtxRef.current;
    if (!ctx) {
      ctx = c2.getContext("2d", { willReadFrequently: true });
      faceDetectCtxRef.current = ctx;
    }
    return { canvas: c2, ctx, detectW: w2, detectH: h2 };
  };
  const runFaceDetectOnce = (0, import_react6.useCallback)(async (videoEl, videoW, videoH) => {
    const det = faceDetectorRef.current || await ensureFaceDetector();
    if (!det) return null;
    const { canvas: c2, ctx, detectW, detectH } = getFaceDetectCanvas(videoW, videoH);
    if (!ctx) return null;
    try {
      ctx.drawImage(videoEl, 0, 0, detectW, detectH);
    } catch {
      return null;
    }
    const sx = (Number(videoW) || 1) / detectW;
    const sy = (Number(videoH) || 1) / detectH;
    try {
      if (det.kind === "native") {
        const faces = await det.detector.detect(c2).catch(() => null);
        const bb = faces?.[0]?.boundingBox;
        if (!bb) return null;
        const candidate = { x: bb.x * sx, y: bb.y * sy, width: bb.width * sx, height: bb.height * sy };
        return normalizeFaceBox(candidate, videoW, videoH);
      }
      if (det.kind === "mediapipe") {
        const res = det.detector.detectForVideo(c2, performance.now());
        const bb = res?.detections?.[0]?.boundingBox;
        if (!bb) return null;
        const candidate = {
          x: (bb.originX ?? bb.x ?? 0) * sx,
          y: (bb.originY ?? bb.y ?? 0) * sy,
          width: (bb.width ?? 0) * sx,
          height: (bb.height ?? 0) * sy
        };
        return normalizeFaceBox(candidate, videoW, videoH);
      }
    } catch {
    }
    return null;
  }, [ensureFaceDetector]);
  const canvasPipelineActiveRef = (0, import_react6.useRef)(false);
  const canvasPipelineRafRef = (0, import_react6.useRef)(null);
  const canvasPipelineVideoElRef = (0, import_react6.useRef)(null);
  const canvasPipelineCanvasRef = (0, import_react6.useRef)(null);
  const canvasPipelineOutTrackRef = (0, import_react6.useRef)(null);
  const canvasPipelineRawTrackRef = (0, import_react6.useRef)(null);
  const lastGoodFrameCanvasRef = (0, import_react6.useRef)(null);
  const lastGoodFrameAtRef = (0, import_react6.useRef)(0);
  const canvasPipelineVideoKickTimerRef = (0, import_react6.useRef)(null);
  const canvasPipelineDrawLoopRef = (0, import_react6.useRef)(null);
  const avatarFilterActiveRef = (0, import_react6.useRef)(false);
  const avatarFilterRafRef = (0, import_react6.useRef)(null);
  const avatarVideoElRef = (0, import_react6.useRef)(null);
  const avatarOutCanvasRef = (0, import_react6.useRef)(null);
  const avatarOutTrackRef = (0, import_react6.useRef)(null);
  const avatarRawTrackRef = (0, import_react6.useRef)(null);
  const faceLandmarkerRef = (0, import_react6.useRef)(null);
  const avatarThreeRef = (0, import_react6.useRef)(null);
  const lastAvatarFaceRef = (0, import_react6.useRef)({
    //   
    bbox: null,
    videoW: 0,
    videoH: 0
  });
  const reconnectTimeoutRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const reconnectHistoryRef = (0, import_react6.useRef)(/* @__PURE__ */ new Set());
  const reconnectCompletedTimeRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const missingSinceRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const joiningTimeoutRef = (0, import_react6.useRef)(/* @__PURE__ */ new Map());
  const everOnlineRef = (0, import_react6.useRef)(/* @__PURE__ */ new Set());
  const hasFinishedInitialSyncRef = (0, import_react6.useRef)(false);
  const lastActiveSpeakerRef = (0, import_react6.useRef)(null);
  const manuallySelectedRef = (0, import_react6.useRef)(false);
  const screenStreamRef = (0, import_react6.useRef)(null);
  const roomSyncHandlerRef = (0, import_react6.useRef)(null);
  const roomSyncRequestedRef = (0, import_react6.useRef)(false);
  const screenProducerRef = (0, import_react6.useRef)(null);
  const cameraWasOnBeforeScreenShareRef = (0, import_react6.useRef)(false);
  const faceEmojiWasOnBeforeScreenShareRef = (0, import_react6.useRef)(null);
  const faceModeWasOnBeforeScreenShareRef = (0, import_react6.useRef)(null);
  const bgRemoveWasOnBeforeScreenShareRef = (0, import_react6.useRef)(false);
  const isStoppingScreenShareRef = (0, import_react6.useRef)(false);
  const [isScreenSharing, setIsScreenSharing] = (0, import_react6.useState)(false);
  const isLeavingRef = (0, import_react6.useRef)(false);
  const isPageUnloadRef = (0, import_react6.useRef)(false);
  const mainStageRef = (0, import_react6.useRef)(null);
  const [isFullscreen, setIsFullscreen] = (0, import_react6.useState)(false);
  const [isStripVisible, setIsStripVisible] = (0, import_react6.useState)(false);
  const [showStripToggle, setShowStripToggle] = (0, import_react6.useState)(false);
  const [gridFullscreenId, setGridFullscreenId] = (0, import_react6.useState)(null);
  const [gridStripVisible, setGridStripVisible] = (0, import_react6.useState)(false);
  const [showGridStripToggle, setShowGridStripToggle] = (0, import_react6.useState)(false);
  const [isGridFullscreen, setIsGridFullscreen] = (0, import_react6.useState)(false);
  const gridFullscreenStageRef = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(() => {
    micOnRef.current = micOn;
  }, [micOn]);
  (0, import_react6.useEffect)(() => {
    camOnRef.current = camOn;
  }, [camOn]);
  (0, import_react6.useEffect)(() => {
    micPermissionRef.current = micPermission;
  }, [micPermission]);
  (0, import_react6.useEffect)(() => {
    camPermissionRef.current = camPermission;
  }, [camPermission]);
  (0, import_react6.useEffect)(() => {
    isFilterPreparingRef.current = isFilterPreparing;
  }, [isFilterPreparing]);
  const computeOutboundMediaState = (0, import_react6.useCallback)(() => {
    const muted = micPermissionRef.current !== "granted" || !micOnRef.current;
    const cameraOff = camPermissionRef.current !== "granted" || !camOnRef.current;
    return { muted, cameraOff };
  }, []);
  (0, import_react6.useEffect)(() => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
    const uid = userIdRef.current;
    if (!uid) return;
    const { muted, cameraOff } = computeOutboundMediaState();
    try {
      wsRef.current.send(JSON.stringify({
        type: "USER_STATE_CHANGE",
        userId: uid,
        changes: { muted, cameraOff }
      }));
    } catch (_2) {
    }
  }, [micPermission, camPermission, computeOutboundMediaState]);
  (0, import_react6.useEffect)(() => {
    try {
      const savedEmoji = localStorage.getItem("faceEmoji") || sessionStorage.getItem("faceEmoji");
      const savedBgRemove = localStorage.getItem("faceBgRemove") === "true" || sessionStorage.getItem("faceBgRemove") === "true";
      if (savedEmoji) {
        ensureFaceDetector().catch(() => {
        });
        console.log("[MeetingPage] Preloading FaceDetector for instant emoji");
      }
      if (savedBgRemove) {
        const cur = faceBgSegmenterRef.current;
        if (!cur?.segmenter && !cur?.loading) {
          const loading2 = (async () => {
            try {
              const { ImageSegmenter, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
              const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
              );
              const segmenter = await ImageSegmenter.createFromOptions(vision, {
                baseOptions: {
                  modelAssetPath: "https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/1/selfie_segmenter.tflite",
                  delegate: "CPU"
                },
                runningMode: "VIDEO",
                outputCategoryMask: true
              });
              return segmenter;
            } catch (e2) {
              console.warn("[MeetingPage] Failed to preload bg segmenter:", e2);
              return null;
            }
          })();
          faceBgSegmenterRef.current = { loading: loading2 };
          loading2.then((seg) => {
            if (seg) {
              faceBgSegmenterRef.current = { segmenter: seg };
              console.log("[MeetingPage] Preloaded bg segmenter for instant bg removal");
            } else {
              faceBgSegmenterRef.current = null;
            }
          });
        }
      }
    } catch (e2) {
      console.warn("[MeetingPage] Failed to preload models:", e2);
    }
  }, []);
  const [userNickname, setUserNickname] = (0, import_react6.useState)(null);
  (0, import_react6.useEffect)(() => {
    api_default.get("/users/me").then((res) => {
      const nickname = res.data.nickname?.trim() || "";
      const name = res.data.name?.trim() || "";
      const displayName = nickname || name || null;
      if (displayName) {
        setUserNickname(displayName);
        userNameRef.current = displayName;
        localStorage.setItem("userName", displayName);
      }
      if (res.data.userId) {
        localStorage.setItem("userId", res.data.userId);
        userIdRef.current = res.data.userId;
      }
    }).catch((err) => {
      console.error("\uC0AC\uC6A9\uC790 \uC815\uBCF4 \uAC00\uC838\uC624\uAE30 \uC2E4\uD328", err);
    });
  }, []);
  if (!userIdRef.current) {
    const sessionId = (sessionStorage.getItem("userId") || "").trim();
    const sessionName = (sessionStorage.getItem("nickname") || "").trim() || (sessionStorage.getItem("userName") || "").trim();
    const storedId = (localStorage.getItem("userId") || "").trim();
    const storedName = (localStorage.getItem("userName") || "").trim();
    const id = sessionId || storedId;
    const name = sessionName || storedName || "";
    if (id) {
      userIdRef.current = id;
      sessionStorage.setItem("userId", id);
      localStorage.setItem("userId", id);
    } else {
      userIdRef.current = safeUUID();
    }
    if (name) {
      userNameRef.current = name;
      sessionStorage.setItem("userName", name);
      localStorage.setItem("userName", name);
    }
  }
  const mainVideoRef = (0, import_react6.useRef)(null);
  const gridFullscreenVideoRef = (0, import_react6.useRef)(null);
  const gridTileVideoRefsRef = (0, import_react6.useRef)({});
  const gridTileRefStableRef = (0, import_react6.useRef)({});
  const getGridTileVideoRef = (0, import_react6.useCallback)((id) => {
    const idKey = String(id);
    if (!gridTileRefStableRef.current[idKey]) {
      gridTileRefStableRef.current[idKey] = {
        get current() {
          return gridTileVideoRefsRef.current[idKey];
        },
        set current(v2) {
          gridTileVideoRefsRef.current[idKey] = v2;
        }
      };
    }
    return gridTileRefStableRef.current[idKey];
  }, []);
  const userId = userIdRef.current;
  const preferredRoomNick = (roomNickname || "").trim();
  const userName = (preferredRoomNick ? preferredRoomNick : null) || userNickname || userNameRef.current;
  const { muted: selfMutedState, cameraOff: selfCameraOffState } = computeOutboundMediaState();
  const micMuted = selfMutedState;
  const camMuted = selfCameraOffState;
  const micDisabled = micPermission !== "granted" || mutedByHostMe;
  const camDisabled = camPermission !== "granted" || cameraOffByHostMe;
  const faceEmojis = (0, import_react6.useMemo)(
    () => ["\u{1F916}", "\u{1F47D}", "\u{1F47B}", "\u{1F63A}", "\u{1F638}", "\u{1F639}", "\u{1F648}", "\u{1F649}", "\u{1F64A}", "\u{1F435}"],
    []
  );
  const me2 = {
    id: userId,
    name: userName,
    muted: micMuted,
    cameraOff: camMuted,
    speaking: isSpeaking,
    isMe: true,
    stream: localStream,
    screenStream: isScreenSharing ? screenStreamRef.current : null,
    isScreenSharing,
    isLoading: isLocalLoading
  };
  const getMainUser = (0, import_react6.useCallback)(() => {
    const found = participants.find(
      (p2) => String(p2.id) === String(activeSpeakerId)
    );
    return found || me2;
  }, [participants, activeSpeakerId, me2]);
  const mainUser = getMainUser();
  const userForTile = (0, import_react6.useCallback)((u2) => {
    if (!u2) return u2;
    if (!u2.isMe) return u2;
    const { muted, cameraOff } = computeOutboundMediaState();
    return {
      ...u2,
      muted,
      cameraOff
    };
  }, [computeOutboundMediaState]);
  const mainStream = mainUser?.isScreenSharing && mainUser?.screenStream ? mainUser.screenStream : mainUser?.isMe ? localStream : mainUser?.stream;
  const mainStreamRef = (0, import_react6.useRef)(null);
  (0, import_react6.useEffect)(() => {
    mainStreamRef.current = mainStream;
  }, [mainStream]);
  const isMainScreenShare = !!mainUser?.isScreenSharing;
  const handleFullscreen = () => {
    if (!mainStageRef.current) return;
    if (!document.fullscreenElement) {
      mainStageRef.current.requestFullscreen().catch((err) => console.error("\uC804\uCCB4\uD654\uBA74 \uC804\uD658 \uC2E4\uD328:", err));
    } else {
      document.exitFullscreen();
    }
  };
  const toggleSidebar = (view) => {
    if (sidebarOpen && sidebarView === view) {
      setSidebarOpen(false);
    } else {
      setSidebarView(view);
      setSidebarOpen(true);
    }
  };
  const toggleSidebarOpen = (0, import_react6.useCallback)(() => {
    if (sidebarOpen) {
      setSidebarOpen(false);
    } else {
      if (!sidebarView) {
        setSidebarView("chat");
      }
      setSidebarOpen(true);
    }
  }, [sidebarOpen, sidebarView]);
  const handleInvite = async () => {
    const inviteUrl = window.location.href;
    try {
      await navigator.clipboard.writeText(inviteUrl);
      setToastMessage("\uB9C1\uD06C\uAC00 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      setShowToast(true);
    } catch (err) {
      console.error("\uD074\uB9BD\uBCF4\uB4DC \uBCF5\uC0AC \uC2E4\uD328:", err);
      const textArea = document.createElement("textarea");
      textArea.value = inviteUrl;
      document.body.appendChild(textArea);
      textArea.select();
      document.execCommand("copy");
      document.body.removeChild(textArea);
      setToastMessage("\uB9C1\uD06C\uAC00 \uBCF5\uC0AC\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
      setShowToast(true);
    }
  };
  const showToastMsg = (0, import_react6.useCallback)((msg) => {
    if (!msg) return;
    setToastMessage(String(msg));
    setShowToast(true);
  }, []);
  const amIHost = (0, import_react6.useMemo)(() => {
    const me3 = participants.find((p2) => p2.isMe);
    return me3?.isHost ?? false;
  }, [participants]);
  const handleForceMute = (0, import_react6.useCallback)((targetUserId) => {
    if (!amIHost) return showToastMsg("\uBC29\uC7A5\uB9CC \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return showToastMsg("\uC11C\uBC84 \uC5F0\uACB0\uC774 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    setParticipants(
      (prev) => prev.map((p2) => String(p2.id) === String(targetUserId) ? { ...p2, muted: true, mutedByHost: true } : p2)
    );
    wsRef.current.send(JSON.stringify({
      type: "FORCE_MUTE",
      targetUserId
    }));
    setHostMenuTargetId(null);
  }, [amIHost, showToastMsg]);
  const handleForceCameraOff = (0, import_react6.useCallback)((targetUserId) => {
    if (!amIHost) return showToastMsg("\uBC29\uC7A5\uB9CC \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return showToastMsg("\uC11C\uBC84 \uC5F0\uACB0\uC774 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    setParticipants(
      (prev) => prev.map((p2) => String(p2.id) === String(targetUserId) ? { ...p2, cameraOff: true, cameraOffByHost: true } : p2)
    );
    wsRef.current.send(JSON.stringify({
      type: "FORCE_CAMERA_OFF",
      targetUserId
    }));
    setHostMenuTargetId(null);
  }, [amIHost, showToastMsg]);
  const handleForceUnmute = (0, import_react6.useCallback)((targetUserId) => {
    if (!amIHost) return showToastMsg("\uBC29\uC7A5\uB9CC \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return showToastMsg("\uC11C\uBC84 \uC5F0\uACB0\uC774 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    setParticipants(
      (prev) => prev.map((p2) => String(p2.id) === String(targetUserId) ? { ...p2, muted: false, mutedByHost: false } : p2)
    );
    wsRef.current.send(JSON.stringify({
      type: "FORCE_UNMUTE",
      targetUserId
    }));
    setHostMenuTargetId(null);
  }, [amIHost, showToastMsg]);
  const handleForceCameraOn = (0, import_react6.useCallback)((targetUserId) => {
    if (!amIHost) return showToastMsg("\uBC29\uC7A5\uB9CC \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return showToastMsg("\uC11C\uBC84 \uC5F0\uACB0\uC774 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    setParticipants(
      (prev) => prev.map((p2) => String(p2.id) === String(targetUserId) ? { ...p2, cameraOff: false, cameraOffByHost: false } : p2)
    );
    wsRef.current.send(JSON.stringify({
      type: "FORCE_CAMERA_ON",
      targetUserId
    }));
    setHostMenuTargetId(null);
  }, [amIHost, showToastMsg]);
  const handleKick = (0, import_react6.useCallback)((targetUserId) => {
    if (!amIHost) return showToastMsg("\uBC29\uC7A5\uB9CC \uC0AC\uC6A9\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return showToastMsg("\uC11C\uBC84 \uC5F0\uACB0\uC774 \uC544\uC9C1 \uC900\uBE44\uB418\uC9C0 \uC54A\uC558\uC2B5\uB2C8\uB2E4.");
    const ok = window.confirm("\uC815\uB9D0 \uB0B4\uBCF4\uB0B4\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?");
    if (!ok) return;
    setParticipants((prev) => prev.filter((p2) => String(p2.id) !== String(targetUserId)));
    wsRef.current.send(JSON.stringify({
      type: "KICK",
      targetUserId
    }));
    setHostMenuTargetId(null);
  }, [amIHost, showToastMsg]);
  const toggleHostMenu = (0, import_react6.useCallback)((targetId) => {
    setHostMenuTargetId((prev) => prev === targetId ? null : targetId);
  }, []);
  (0, import_react6.useEffect)(() => {
    if (!hostMenuTargetId) return;
    const handleClickOutside = (e2) => {
      if (!e2.target.closest(".host-menu-dropdown") && !e2.target.closest(".more-btn")) {
        setHostMenuTargetId(null);
      }
    };
    document.addEventListener("click", handleClickOutside);
    return () => document.removeEventListener("click", handleClickOutside);
  }, [hostMenuTargetId]);
  const turnOffCamera = async () => {
    canvasPipelineActiveRef.current = false;
    if (canvasPipelineRafRef.current) {
      clearTimeout(canvasPipelineRafRef.current);
      canvasPipelineRafRef.current = null;
    }
    if (canvasPipelineVideoElRef.current) {
      try {
        canvasPipelineVideoElRef.current.pause();
      } catch {
      }
      try {
        canvasPipelineVideoElRef.current.srcObject = null;
      } catch {
      }
      try {
        canvasPipelineVideoElRef.current.remove();
      } catch {
      }
      canvasPipelineVideoElRef.current = null;
    }
    if (canvasPipelineVideoKickTimerRef.current) {
      try {
        document.removeEventListener("visibilitychange", canvasPipelineVideoKickTimerRef.current.kickVideo);
      } catch {
      }
      try {
        clearInterval(canvasPipelineVideoKickTimerRef.current.kickTimer);
      } catch {
      }
      canvasPipelineVideoKickTimerRef.current = null;
    }
    try {
      canvasPipelineOutTrackRef.current?.stop?.();
    } catch {
    }
    canvasPipelineOutTrackRef.current = null;
    try {
      canvasPipelineRawTrackRef.current?.stop?.();
    } catch {
    }
    canvasPipelineRawTrackRef.current = null;
    canvasPipelineCanvasRef.current = null;
    lastGoodFrameCanvasRef.current = null;
    if (faceModeRef.current === "avatar" || avatarFilterActiveRef.current) {
      await stopAvatarFilter();
    }
    if (faceModeRef.current === "emoji" || faceEmojiRef.current || faceFilterActiveRef.current) {
      await stopFaceEmojiFilter();
    }
    const producer = producersRef.current.get("camera");
    if (producer) {
      try {
        producer.close();
      } catch {
      }
      producersRef.current.delete("camera");
      console.log("[turnOffCamera] producer closed");
    }
    const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
    try {
      localStreamRef.current?.getVideoTracks?.()?.forEach((t2) => {
        try {
          t2.stop();
        } catch {
        }
      });
    } catch {
    }
    if (isLeavingRef.current) {
      console.log("[turnOffCamera] isLeaving=true, skipping setLocalStream");
      return;
    }
    const audioOnly = new MediaStream([...prevAudio]);
    localStreamRef.current = audioOnly;
    setLocalStream(audioOnly);
    setCamOn(false);
    localStorage.setItem("camOn", "false");
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: "USER_STATE_CHANGE",
        userId,
        changes: { cameraOff: true }
      }));
    }
    console.log("[turnOffCamera] camera and canvas pipeline stopped");
  };
  const turnOnCamera = async () => {
    const wantEmoji = !!faceEmojiRef.current && faceModeRef.current === "emoji";
    const wantBgRemove = !!bgRemoveRef.current;
    const needFiltersOnStart = wantEmoji || wantBgRemove;
    if (needFiltersOnStart) {
      console.log("[turnOnCamera] Filter settings detected, loading models in background");
    }
    if (wantEmoji) ensureFaceDetector().catch(() => {
    });
    const existingOutTrack = canvasPipelineOutTrackRef.current;
    const existingProducer = producersRef.current.get("camera");
    if (canvasPipelineActiveRef.current && existingOutTrack?.readyState === "live" && existingProducer && !existingProducer.closed) {
      console.log("[turnOnCamera] pipeline already active, reusing existing track/producer");
      setCamOn(true);
      localStorage.setItem("camOn", "true");
      return;
    }
    let stream;
    const needAudio = !localStreamRef.current?.getAudioTracks().some((t2) => t2.readyState === "live");
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 1280 }, height: { ideal: 720 }, frameRate: { ideal: 60, max: 60 } },
        audio: needAudio
      });
    } catch (err) {
      console.error("Camera permission denied or error", err);
      return;
    }
    const rawTrack = stream.getVideoTracks()[0];
    const newAudioTrack = stream.getAudioTracks()[0];
    console.log("[turnOnCamera] got camera track:", rawTrack.id, rawTrack.readyState, "audio:", needAudio ? newAudioTrack?.id : "reusing");
    if (isLikelyCameraTrack(rawTrack)) lastCameraTrackRef.current = rawTrack;
    canvasPipelineRawTrackRef.current = rawTrack;
    if (canvasPipelineRafRef.current) {
      clearTimeout(canvasPipelineRafRef.current);
      canvasPipelineRafRef.current = null;
    }
    if (canvasPipelineVideoElRef.current) {
      try {
        canvasPipelineVideoElRef.current.pause();
      } catch {
      }
      try {
        canvasPipelineVideoElRef.current.srcObject = null;
      } catch {
      }
      try {
        canvasPipelineVideoElRef.current.remove();
      } catch {
      }
      canvasPipelineVideoElRef.current = null;
    }
    const v2 = document.createElement("video");
    v2.autoplay = true;
    v2.playsInline = true;
    v2.muted = true;
    v2.style.cssText = "position:fixed; bottom:0; right:0; width:640px; height:480px; opacity:0.01; pointer-events:none; z-index:-999;";
    document.body.appendChild(v2);
    canvasPipelineVideoElRef.current = v2;
    v2.srcObject = new MediaStream([rawTrack]);
    v2.play().catch(() => {
    });
    const kickVideo = () => {
      try {
        if (v2 && v2.srcObject && v2.paused) {
          v2.play().catch(() => {
          });
        }
      } catch {
      }
    };
    document.addEventListener("visibilitychange", kickVideo);
    const kickTimer = setInterval(kickVideo, 500);
    canvasPipelineVideoKickTimerRef.current = { kickVideo, kickTimer };
    const videoW = 1280;
    const videoH = 720;
    const canvas = document.createElement("canvas");
    canvas.width = videoW;
    canvas.height = videoH;
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    canvasPipelineCanvasRef.current = canvas;
    const lastCanvas = document.createElement("canvas");
    lastCanvas.width = canvas.width;
    lastCanvas.height = canvas.height;
    lastGoodFrameCanvasRef.current = lastCanvas;
    const outStream = canvas.captureStream(60);
    const outTrack = outStream.getVideoTracks()[0];
    canvasPipelineOutTrackRef.current = outTrack;
    let producer = producersRef.current.get("camera");
    if (producer) {
      try {
        producer.close();
      } catch {
      }
      producersRef.current.delete("camera");
      producer = null;
    }
    setCamOn(true);
    localStorage.setItem("camOn", "true");
    const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
    const audioTracks = prevAudio.length > 0 ? prevAudio : newAudioTrack ? [newAudioTrack] : [];
    audioTracks.forEach((t2) => {
      t2.enabled = !!micOnRef.current;
    });
    const merged = new MediaStream([...audioTracks, outTrack]);
    localStreamRef.current = merged;
    setLocalStream(merged);
    bumpStreamVersion();
    setMicPermission("granted");
    setCamPermission("granted");
    setIsLocalLoading(false);
    let producerCreated = false;
    let producerCreating = false;
    canvasPipelineActiveRef.current = true;
    hasEverDrawnEmojiRef.current = false;
    emojiBlackScreenStartedAtRef.current = 0;
    emojiBlackScreenToastShownRef.current = false;
    let frameCount = 0;
    let bgFrameCanvas = null;
    let bgFrameCtx = null;
    let bgSegInputCanvas = null;
    let bgSegInputCtx = null;
    const getBgSegInput = (videoW2, videoH2) => {
      const MAX_W = 256;
      const vw = Number(videoW2) || 0;
      const vh = Number(videoH2) || 0;
      const w2 = vw > 0 ? Math.min(MAX_W, vw) : MAX_W;
      const h2 = vw > 0 && vh > 0 ? Math.max(1, Math.round(w2 * (vh / vw))) : 144;
      if (!bgSegInputCanvas) bgSegInputCanvas = document.createElement("canvas");
      if (bgSegInputCanvas.width !== w2) bgSegInputCanvas.width = w2;
      if (bgSegInputCanvas.height !== h2) bgSegInputCanvas.height = h2;
      if (!bgSegInputCtx) bgSegInputCtx = bgSegInputCanvas.getContext("2d", { willReadFrequently: true });
      return { canvas: bgSegInputCanvas, ctx: bgSegInputCtx, w: w2, h: h2 };
    };
    const ensureBgSegmenterForPipeline = () => {
      const cur = faceBgSegmenterRef.current;
      if (cur?.segmenter || cur?.loading) return;
      const loading2 = (async () => {
        try {
          const { ImageSegmenter, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
          );
          const segmenter = await ImageSegmenter.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/1/selfie_segmenter.tflite",
              delegate: "CPU"
            },
            runningMode: "VIDEO",
            outputCategoryMask: true
          });
          return segmenter;
        } catch (e2) {
          console.warn("[turnOnCamera bg-remove] segmenter init failed:", e2);
          return null;
        }
      })();
      faceBgSegmenterRef.current = { loading: loading2 };
      loading2.then((seg) => {
        if (!seg) {
          faceBgSegmenterRef.current = null;
          return;
        }
        faceBgSegmenterRef.current = { segmenter: seg };
        console.log("[turnOnCamera] bg segmenter loaded");
      });
    };
    const BASE_INTERVAL = 16;
    const FILTER_INTERVAL = 66;
    const drawLoop = async () => {
      if (!canvasPipelineActiveRef.current) return;
      const isHidden = document.hidden;
      const isBgRemoveOn = !!bgRemoveRef.current;
      const isEmojiOn = !!faceEmojiRef.current && faceModeRef.current === "emoji";
      const warmupDone = Date.now() > (pipelineWarmupUntilRef.current || 0);
      if (!isHidden) {
        try {
          if (isEmojiOn) {
            if (!faceDetectorRef.current) ensureFaceDetector().catch(() => {
            });
            const nowMs = Date.now();
            if (faceDetectorRef.current && nowMs - lastDetectAtRef.current > 80) {
              lastDetectAtRef.current = nowMs;
              if (!faceDetectInFlightRef.current) {
                faceDetectInFlightRef.current = true;
                faceDetectSeqRef.current++;
                const currentSeq = faceDetectSeqRef.current;
                const vw = v2.videoWidth || canvas.width;
                const vh = v2.videoHeight || canvas.height;
                runFaceDetectOnce(v2, vw, vh).then((normalized) => {
                  if (currentSeq !== faceDetectSeqRef.current) return;
                  if (normalized) {
                    lastFaceBoxRef.current = normalized;
                    lastFaceBoxAtRef.current = Date.now();
                  } else {
                    if (Date.now() - (lastFaceBoxAtRef.current || 0) > 1e3) {
                      lastFaceBoxRef.current = null;
                    }
                  }
                }).finally(() => {
                  if (currentSeq === faceDetectSeqRef.current) faceDetectInFlightRef.current = false;
                });
              }
            }
          }
        } catch {
        }
        if (isBgRemoveOn) ensureBgSegmenterForPipeline();
      }
      const videoReady = v2 && v2.videoWidth > 0 && v2.videoHeight > 0 && v2.readyState >= 2;
      if (videoReady) {
        const currentW = v2.videoWidth;
        const currentH = v2.videoHeight;
        if (canvas.width !== currentW || canvas.height !== currentH) {
          canvas.width = currentW;
          canvas.height = currentH;
          if (lastGoodFrameCanvasRef.current) {
            lastGoodFrameCanvasRef.current.width = currentW;
            lastGoodFrameCanvasRef.current.height = currentH;
          }
        }
      } else {
        const last = lastGoodFrameCanvasRef.current;
        if (last && lastGoodFrameAtRef.current > 0) {
          try {
            ctx.drawImage(last, 0, 0, canvas.width, canvas.height);
          } catch {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        } else {
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        const isHidden2 = document.hidden;
        const nextInterval2 = isHidden2 ? 200 : isEmojiOn || isBgRemoveOn ? 66 : 33;
        canvasPipelineRafRef.current = setTimeout(drawLoop, nextInterval2);
        return;
      }
      {
        const isEmojiReady = !isEmojiOn || isEmojiOn && !!lastFaceBoxRef.current;
        const isBgReady = !isBgRemoveOn || isBgRemoveOn && !!faceBgSegmenterRef.current?.segmenter;
        if (isBgRemoveOn && isBgReady && !isHidden) {
          if (!bgFrameCanvas) {
            bgFrameCanvas = document.createElement("canvas");
            bgFrameCanvas.width = canvas.width;
            bgFrameCanvas.height = canvas.height;
            bgFrameCtx = bgFrameCanvas.getContext("2d");
          }
          bgFrameCtx.drawImage(v2, 0, 0, bgFrameCanvas.width, bgFrameCanvas.height);
          const seg = faceBgSegmenterRef.current?.segmenter;
          const nowMs = performance.now();
          if (seg && nowMs - faceBgLastInferAtRef.current > 100) {
            faceBgLastInferAtRef.current = nowMs;
            try {
              const vw = v2.videoWidth || canvas.width;
              const vh = v2.videoHeight || canvas.height;
              const segInput = getBgSegInput(vw, vh);
              segInput.ctx.drawImage(v2, 0, 0, segInput.w, segInput.h);
              const res = seg.segmentForVideo(segInput.canvas, nowMs);
              const mask = res?.categoryMask;
              if (mask) {
                const maskW = mask.width;
                const maskH = mask.height;
                const dataU8 = mask.getAsUint8Array();
                let maskCanvas = faceBgMaskCanvasRef.current;
                if (!maskCanvas) {
                  maskCanvas = document.createElement("canvas");
                  faceBgMaskCanvasRef.current = maskCanvas;
                }
                maskCanvas.width = maskW;
                maskCanvas.height = maskH;
                const mctx = maskCanvas.getContext("2d");
                const img = mctx.createImageData(maskW, maskH);
                for (let i2 = 0; i2 < maskW * maskH; i2++) {
                  const isPerson = dataU8[i2] === 0;
                  const o2 = i2 * 4;
                  img.data[o2] = 255;
                  img.data[o2 + 1] = 255;
                  img.data[o2 + 2] = 255;
                  img.data[o2 + 3] = isPerson ? 255 : 0;
                }
                mctx.putImageData(img, 0, 0);
              }
            } catch {
            }
          }
          if (faceBgMaskCanvasRef.current) {
            bgFrameCtx.globalCompositeOperation = "destination-in";
            bgFrameCtx.drawImage(faceBgMaskCanvasRef.current, 0, 0, bgFrameCanvas.width, bgFrameCanvas.height);
            bgFrameCtx.globalCompositeOperation = "source-over";
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(bgFrameCanvas, 0, 0, canvas.width, canvas.height);
          } else {
            if (isEmojiOn) {
              if (!hasEverDrawnEmojiRef.current) {
                if (!emojiBlackScreenStartedAtRef.current) emojiBlackScreenStartedAtRef.current = Date.now();
                if (Date.now() - emojiBlackScreenStartedAtRef.current >= 3e3 && !emojiBlackScreenToastShownRef.current) {
                  emojiBlackScreenToastShownRef.current = true;
                  setToastMessage("\uC5BC\uAD74\uC774 \uBCF4\uC774\uAC8C \uD574\uC8FC\uC138\uC694.");
                  setShowToast(true);
                }
                ctx.fillStyle = "#000000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              } else {
                ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
              }
            } else {
              ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
            }
          }
        } else {
          if (isEmojiOn && !lastFaceBoxRef.current) {
            if (!hasEverDrawnEmojiRef.current) {
              if (!emojiBlackScreenStartedAtRef.current) emojiBlackScreenStartedAtRef.current = Date.now();
              if (Date.now() - emojiBlackScreenStartedAtRef.current >= 3e3 && !emojiBlackScreenToastShownRef.current) {
                emojiBlackScreenToastShownRef.current = true;
                setToastMessage("\uC5BC\uAD74\uC774 \uBCF4\uC774\uAC8C \uD574\uC8FC\uC138\uC694.");
                setShowToast(true);
              }
              ctx.fillStyle = "#000000";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
              ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
            }
          } else {
            ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
          }
        }
        if (isEmojiOn && lastFaceBoxRef.current) {
          const box = normalizeFaceBox(lastFaceBoxRef.current, v2.videoWidth, v2.videoHeight);
          if (box) {
            const scaleX = canvas.width / (v2.videoWidth || canvas.width);
            const scaleY = canvas.height / (v2.videoHeight || canvas.height);
            const maxSize = Math.floor(Math.min(canvas.width, canvas.height) * 0.5);
            const rawSize = Math.max(box.width * scaleX, box.height * scaleY) * 2.5;
            const size = Math.max(120, Math.min(maxSize, rawSize));
            const x2 = (box.x + box.width / 2) * scaleX;
            const y2 = (box.y + box.height / 2) * scaleY - size * 0.1;
            const prev = smoothedFaceBoxRef.current;
            const curr = { x: x2, y: y2, size };
            const isNewDetection = !prev || frameCount <= 10 || lastFaceBoxAtRef.current && Date.now() - lastFaceBoxAtRef.current < 300;
            const factor = isNewDetection ? 1 : 0.9;
            const smoothed = prev && !isNewDetection ? {
              x: prev.x + (curr.x - prev.x) * factor,
              y: prev.y + (curr.y - prev.y) * factor,
              size: prev.size + (curr.size - prev.size) * factor
            } : curr;
            smoothedFaceBoxRef.current = smoothed;
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.font = `${smoothed.size}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
            ctx.fillText(faceEmojiRef.current, smoothed.x, smoothed.y);
            hasEverDrawnEmojiRef.current = true;
            emojiBlackScreenStartedAtRef.current = 0;
            emojiBlackScreenToastShownRef.current = false;
          }
        }
      }
      frameCount++;
      if (!producerCreated && !producerCreating && videoReady) {
        producerCreating = true;
        try {
          const transport = sendTransportRef.current;
          if (transport && !transport.closed) {
            const newProducer = await transport.produce({
              track: outTrack,
              encodings: [{ maxBitrate: 25e5, scaleResolutionDownBy: 1 }],
              // 2.5Mbps  (60fps )
              appData: { type: "camera" }
            });
            producersRef.current.set("camera", newProducer);
            producerCreated = true;
            producerCreating = false;
            console.log("[turnOnCamera] producer created (frame:", frameCount, ")");
          } else {
            producerCreating = false;
          }
        } catch (e2) {
          console.error("[turnOnCamera] producer creation failed:", e2);
          producerCreating = false;
        }
      }
      const drewBlackForEmoji = isEmojiOn && !lastFaceBoxRef.current;
      try {
        const last = lastGoodFrameCanvasRef.current;
        if (last && canvas && !drewBlackForEmoji) {
          const lctx = last.getContext("2d");
          if (lctx) {
            lctx.drawImage(canvas, 0, 0, last.width, last.height);
            lastGoodFrameAtRef.current = Date.now();
          }
        }
      } catch {
      }
      const nextInterval = isHidden ? 200 : isEmojiOn || isBgRemoveOn ? 66 : 33;
      canvasPipelineRafRef.current = setTimeout(drawLoop, nextInterval);
    };
    canvasPipelineDrawLoopRef.current = drawLoop;
    drawLoop();
    setTimeout(() => {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: "USER_STATE_CHANGE",
          userId,
          changes: { cameraOff: false }
        }));
      }
    }, 0);
    console.log("[turnOnCamera] canvas pipeline started immediately, emoji mode:", faceModeRef.current, "emoji:", faceEmojiRef.current);
  };
  (0, import_react6.useEffect)(() => {
    const handleFullscreenChange = () => {
      const fullscreenEl = document.fullscreenElement;
      setIsFullscreen(!!fullscreenEl);
      if (fullscreenEl) {
        document.body.classList.add("fullscreen-active");
      } else {
        document.body.classList.remove("fullscreen-active");
        setIsGridFullscreen(false);
      }
    };
    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return () => document.removeEventListener("fullscreenchange", handleFullscreenChange);
  }, []);
  const handleSendMessage = (e2) => {
    e2.preventDefault();
    if (!chatDraft.trim()) return;
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(
        JSON.stringify({
          type: "CHAT",
          message: chatDraft
        })
      );
    }
    setChatDraft("");
  };
  const handleReaction = (emoji) => {
    setShowReactions(false);
    const oldTimer = reactionTimersRef.current.myReaction;
    if (oldTimer) {
      clearTimeout(oldTimer);
    }
    setMyReaction(emoji);
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(
        JSON.stringify({
          type: "REACTION",
          emoji
        })
      );
    }
    const timerId = setTimeout(() => {
      setMyReaction(null);
      delete reactionTimersRef.current.myReaction;
    }, 2500);
    reactionTimersRef.current.myReaction = timerId;
  };
  const handleHangup = () => {
    isLeavingRef.current = true;
    try {
      sessionStorage.removeItem("pip.roomId");
    } catch {
    }
    try {
      sessionStorage.removeItem("pip.subjectId");
    } catch {
    }
    try {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        wsRef.current.send(JSON.stringify({
          type: "USER_STATE_CHANGE",
          userId,
          changes: { cameraOff: true, muted: true }
        }));
      }
    } catch {
    }
    try {
      producersRef.current.forEach((p2) => {
        try {
          p2.close();
        } catch {
        }
        if (p2.appData?.type) safeSfuSend({ action: "closeProducer", data: { producerId: p2.id } });
      });
      producersRef.current.clear();
    } catch {
    }
    try {
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        const leaveMsg = JSON.stringify({ type: "LEAVE" });
        wsRef.current.send(leaveMsg);
        setTimeout(() => {
          if (wsRef.current?.readyState === WebSocket.OPEN) {
            try {
              wsRef.current.send(leaveMsg);
            } catch {
            }
          }
        }, 50);
      }
    } catch {
    }
    try {
      safeSfuSend({
        action: "leave",
        requestId: safeUUID(),
        data: { roomId, peerId: userId }
      });
    } catch {
    }
    try {
      sendSfuLeaveBeacon(roomId, userId);
    } catch {
    }
    setTimeout(() => {
      try {
        try {
          turnOffCamera();
        } catch {
        }
        stopFaceEmojiFilter().catch(() => {
        });
        stopAvatarFilter().catch(() => {
        });
        try {
          producersRef.current.forEach((p2) => p2.close());
          producersRef.current.clear();
          sendTransportRef.current?.close();
          recvTransportRef.current?.close();
        } catch {
        }
        if (localStreamRef.current) {
          localStreamRef.current.getTracks().forEach((t2) => t2.stop());
          localStreamRef.current = null;
        }
        if (screenStreamRef.current) {
          try {
            screenStreamRef.current.getTracks().forEach((t2) => {
              try {
                t2.stop();
              } catch {
              }
            });
          } catch {
          }
          screenStreamRef.current = null;
        }
        try {
          const extraTracks = [
            lastCameraTrackRef?.current,
            faceFilterRawTrackRef?.current,
            faceFilterOutTrackRef?.current,
            avatarRawTrackRef?.current,
            avatarOutTrackRef?.current,
            canvasPipelineRawTrackRef?.current,
            canvasPipelineOutTrackRef?.current
          ].filter(Boolean);
          extraTracks.forEach((t2) => {
            try {
              if (t2.readyState === "live") t2.stop();
            } catch {
            }
          });
        } catch {
        }
        try {
          lastCameraTrackRef.current = null;
        } catch {
        }
        try {
          faceFilterRawTrackRef.current = null;
        } catch {
        }
        try {
          faceFilterOutTrackRef.current = null;
        } catch {
        }
        try {
          avatarRawTrackRef.current = null;
        } catch {
        }
        try {
          avatarOutTrackRef.current = null;
        } catch {
        }
        try {
          canvasPipelineOutTrackRef.current = null;
        } catch {
        }
        try {
          document.querySelectorAll("video").forEach((v2) => {
            try {
              if (v2?.srcObject) v2.srcObject = null;
            } catch {
            }
          });
          document.querySelectorAll("audio").forEach((a2) => {
            try {
              if (a2?.srcObject) a2.srcObject = null;
            } catch {
            }
          });
        } catch {
        }
        setLocalStream(null);
        try {
          audioElsRef.current.forEach((a2) => {
            try {
              a2.pause();
            } catch {
            }
            try {
              a2.srcObject = null;
            } catch {
            }
          });
          audioElsRef.current.clear();
        } catch {
        }
        closeSharedAudioContext();
        try {
          wsRef.current?.close();
        } catch {
        }
        wsRef.current = null;
        closeSfuWsForLeave();
        sfuWsRef.current = null;
        setParticipants([]);
        setMessages([]);
        if (endMeeting) endMeeting();
        try {
          const allRefs = [
            localStreamRef,
            screenStreamRef,
            lastCameraTrackRef,
            faceFilterRawTrackRef,
            faceFilterOutTrackRef,
            avatarRawTrackRef,
            avatarOutTrackRef,
            canvasPipelineRawTrackRef,
            canvasPipelineOutTrackRef
          ];
          allRefs.forEach((ref) => {
            try {
              const val = ref?.current;
              if (!val) return;
              if (typeof val.getTracks === "function") {
                val.getTracks().forEach((t2) => {
                  try {
                    if (t2.readyState === "live") t2.stop();
                  } catch {
                  }
                });
              } else if (typeof val.stop === "function" && val.readyState === "live") {
                val.stop();
              }
            } catch {
            }
          });
        } catch {
        }
        closeSharedAudioContext();
        if (subjectId) {
          navigate(`/lms/${subjectId}/dashboard`, { replace: true });
        } else {
          navigate("/lmsMain", { replace: true });
        }
      } catch (e2) {
        console.warn("[handleHangup] Cleanup failed:", e2);
        navigate("/lmsMain", { replace: true });
      }
    }, 400);
  };
  const isIOSDevice = () => {
    const ua2 = navigator.userAgent || "";
    const isAppleMobileUA = /iPhone|iPad|iPod/i.test(ua2);
    const isIpadOS13Plus = /Macintosh/i.test(ua2) && navigator.maxTouchPoints > 1;
    return isAppleMobileUA || isIpadOS13Plus;
  };
  const isIOS = (0, import_react6.useMemo)(() => isIOSDevice(), []);
  const bumpStreamVersion = () => {
    setStreamVersion((v2) => v2 + 1);
  };
  const isCanvasLikeTrack = (t2) => {
    try {
      const label = (t2?.label || "").toLowerCase();
      return label.includes("canvas");
    } catch {
      return false;
    }
  };
  const isLikelyCameraTrack = (t2) => {
    if (!t2) return false;
    if (t2.kind !== "video") return false;
    if (t2.readyState !== "live") return false;
    try {
      const out1 = faceFilterOutTrackRef.current;
      const out2 = avatarOutTrackRef.current;
      if (out1 && t2.id === out1.id) return false;
      if (out2 && t2.id === out2.id) return false;
    } catch {
    }
    if (isCanvasLikeTrack(t2)) return false;
    try {
      const s2 = t2.getSettings?.();
      if (s2 && typeof s2.deviceId === "string" && s2.deviceId.length > 0) return true;
    } catch {
    }
    return true;
  };
  (0, import_react6.useEffect)(() => {
    faceEmojiRef.current = faceEmoji;
    faceModeRef.current = faceMode;
    bgRemoveRef.current = bgRemove;
    try {
      if (faceEmoji) localStorage.setItem("faceEmoji", faceEmoji);
      else localStorage.removeItem("faceEmoji");
      if (faceMode) localStorage.setItem("faceMode", faceMode);
      else localStorage.removeItem("faceMode");
      if (bgRemove) localStorage.setItem("faceBgRemove", String(bgRemove));
      else localStorage.removeItem("faceBgRemove");
      sessionStorage.setItem("faceBgRemove", String(bgRemove));
      try {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: {
              faceEmoji: faceEmoji || null,
              bgRemove: !!bgRemove
            }
          }));
        }
      } catch {
      }
    } catch {
    }
  }, [faceEmoji, faceMode, bgRemove]);
  const hasMountedRef = (0, import_react6.useRef)(false);
  (0, import_react6.useEffect)(() => {
    if (hasMountedRef.current) return;
    hasMountedRef.current = true;
    const savedMicOn = micOnRef.current;
    const savedCamOn = camOnRef.current;
    const savedEmoji = faceEmojiRef.current;
    const savedBgRemove = bgRemoveRef.current;
    if (savedMicOn || savedCamOn || savedEmoji || savedBgRemove) {
      const checkAndApply = async () => {
        let waited = 0;
        while ((!sendTransportRef.current || sendTransportRef.current.closed) && waited < 1e4) {
          await new Promise((r2) => setTimeout(r2, 50));
          waited += 50;
        }
        if (sendTransportRef.current && !sendTransportRef.current.closed) {
          console.log("[Auto-restore] sendTransport ready, restoring saved state:", {
            savedMicOn,
            savedCamOn,
            savedEmoji,
            savedBgRemove,
            waited
          });
          try {
            if (savedCamOn) {
              if (!canvasPipelineActiveRef.current) {
                pipelineWarmupUntilRef.current = Date.now() + 1e3;
                await turnOnCamera();
              }
            } else if ((savedCamOn || canvasPipelineActiveRef.current) && (savedEmoji || savedBgRemove)) {
              if (canvasPipelineActiveRef.current && savedEmoji) {
                await startFaceEmojiFilter(savedEmoji);
              }
            }
            if (savedMicOn) {
              const audioTracks = localStreamRef.current?.getAudioTracks() ?? [];
              audioTracks.forEach((t2) => {
                if (t2.enabled !== savedMicOn) {
                  t2.enabled = savedMicOn;
                  console.log("[Auto-restore] Audio track enabled set to", savedMicOn);
                }
              });
            }
          } catch (e2) {
            console.warn("[Auto-restore] Failed to restore state:", e2);
          }
        }
      };
      checkAndApply().catch((e2) => console.warn("[Auto-restore] error:", e2));
    }
  }, []);
  const enqueueFaceEmojiOp = (0, import_react6.useCallback)((op) => {
    const next = faceEmojiOpRef.current.then(op, op);
    faceEmojiOpRef.current = next.catch(() => {
    });
    return next;
  }, []);
  const stopFaceEmojiFilterCore = (0, import_react6.useCallback)(async () => {
    faceFilterActiveRef.current = false;
    if (faceFilterRafRef.current != null) {
      clearTimeout(faceFilterRafRef.current);
      cancelAnimationFrame(faceFilterRafRef.current);
      faceFilterRafRef.current = null;
    }
    const producer = producersRef.current.get("camera");
    let rawTrack = faceFilterRawTrackRef.current;
    const outTrack = faceFilterOutTrackRef.current;
    const lastTrack = lastCameraTrackRef.current;
    if ((!rawTrack || rawTrack.readyState !== "live") && isLikelyCameraTrack(lastTrack) && lastTrack.readyState === "live") {
      rawTrack = lastTrack;
    }
    if (producer?.replaceTrack && rawTrack && rawTrack.readyState === "live" && producer.track?.id !== rawTrack.id) {
      try {
        await producer.replaceTrack({ track: rawTrack });
        try {
          producer.resume?.();
        } catch {
        }
      } catch {
      }
    }
    if (!isLeavingRef.current && rawTrack && rawTrack.readyState === "live") {
      const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
      const merged = new MediaStream([...prevAudio, rawTrack]);
      localStreamRef.current = merged;
      setLocalStream(merged);
      bumpStreamVersion();
    }
    try {
      outTrack?.stop?.();
    } catch {
    }
    faceFilterOutTrackRef.current = null;
    faceFilterOutStreamRef.current = null;
    faceFilterCanvasRef.current = null;
    faceBgFrameCanvasRef.current = null;
    faceBgMaskCanvasRef.current = null;
    faceFilterLastGoodFrameCanvasRef.current = null;
    faceBgLastInferAtRef.current = 0;
    try {
      faceBgSegmenterRef.current?.segmenter?.close?.();
    } catch {
    }
    faceBgSegmenterRef.current = null;
    try {
      faceDetectorRef.current?.detector?.close?.();
    } catch {
    }
    faceDetectorRef.current = null;
    lastFaceBoxRef.current = null;
    lastDetectAtRef.current = 0;
    if (faceFilterVideoElRef.current) {
      try {
        faceFilterVideoElRef.current.srcObject = null;
      } catch {
      }
      try {
        faceFilterVideoElRef.current.remove();
      } catch {
      }
      faceFilterVideoElRef.current = null;
    }
    faceFilterRawTrackRef.current = null;
  }, []);
  const stopFaceEmojiFilter = (0, import_react6.useCallback)(() => {
    return enqueueFaceEmojiOp(() => stopFaceEmojiFilterCore());
  }, [enqueueFaceEmojiOp, stopFaceEmojiFilterCore]);
  const stopAvatarFilter = (0, import_react6.useCallback)(async () => {
    avatarFilterActiveRef.current = false;
    if (avatarFilterRafRef.current) {
      cancelAnimationFrame(avatarFilterRafRef.current);
      avatarFilterRafRef.current = null;
    }
    const producer = producersRef.current.get("camera");
    const rawTrack = avatarRawTrackRef.current;
    const outTrack = avatarOutTrackRef.current;
    if (producer?.replaceTrack && rawTrack && rawTrack.readyState === "live" && producer.track?.id !== rawTrack.id) {
      try {
        await producer.replaceTrack({ track: rawTrack });
      } catch {
      }
    }
    if (!isLeavingRef.current && rawTrack && rawTrack.readyState === "live") {
      const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
      const merged = new MediaStream([...prevAudio, rawTrack]);
      localStreamRef.current = merged;
      setLocalStream(merged);
    }
    try {
      outTrack?.stop?.();
    } catch {
    }
    avatarOutTrackRef.current = null;
    avatarOutCanvasRef.current = null;
    avatarRawTrackRef.current = null;
    if (avatarVideoElRef.current) {
      try {
        avatarVideoElRef.current.srcObject = null;
      } catch {
      }
      try {
        avatarVideoElRef.current.remove();
      } catch {
      }
      avatarVideoElRef.current = null;
    }
    try {
      faceLandmarkerRef.current?.close?.();
    } catch {
    }
    faceLandmarkerRef.current = null;
    if (avatarThreeRef.current) {
      const { renderer, vrm } = avatarThreeRef.current;
      try {
        if (vrm?.scene) VRMUtils.deepDispose(vrm.scene);
      } catch {
      }
      try {
        renderer?.dispose?.();
      } catch {
      }
      try {
        renderer?.domElement?.remove?.();
      } catch {
      }
      avatarThreeRef.current = null;
    }
    lastAvatarFaceRef.current = { bbox: null, videoW: 0, videoH: 0 };
  }, []);
  const startAvatarFilter = (0, import_react6.useCallback)(async () => {
    await stopFaceEmojiFilter();
    await stopAvatarFilter();
    const cameraProducer = producersRef.current.get("camera");
    if (!cameraProducer?.replaceTrack) return;
    const rawTrack = localStreamRef.current?.getVideoTracks?.()?.find((t2) => t2.readyState === "live") || cameraProducer.track;
    if (!rawTrack) return;
    avatarRawTrackRef.current = rawTrack;
    const v2 = document.createElement("video");
    v2.autoplay = true;
    v2.playsInline = true;
    v2.muted = true;
    v2.style.cssText = "position:fixed;top:-9999px;left:-9999px;width:640px;height:480px;opacity:0;pointer-events:none;";
    document.body.appendChild(v2);
    avatarVideoElRef.current = v2;
    v2.srcObject = new MediaStream([rawTrack]);
    try {
      await v2.play();
    } catch {
    }
    await new Promise((resolve) => {
      if (v2.videoWidth > 0 && v2.videoHeight > 0) return resolve();
      const onLoaded = () => {
        v2.removeEventListener("loadedmetadata", onLoaded);
        resolve();
      };
      v2.addEventListener("loadedmetadata", onLoaded);
      setTimeout(resolve, 1500);
    });
    const videoW = v2.videoWidth || 640;
    const videoH = v2.videoHeight || 480;
    const outCanvas = document.createElement("canvas");
    outCanvas.width = videoW;
    outCanvas.height = videoH;
    const outCtx = outCanvas.getContext("2d");
    avatarOutCanvasRef.current = outCanvas;
    const outStream = outCanvas.captureStream(15);
    const outTrack = outStream.getVideoTracks()[0];
    try {
      outTrack.requestFrame?.();
    } catch {
    }
    avatarOutTrackRef.current = outTrack;
    await new Promise((resolve) => {
      if (typeof outTrack.requestFrame === "function") {
        outTrack.requestFrame();
      }
      if (typeof v2.requestVideoFrameCallback === "function") {
        v2.requestVideoFrameCallback(() => resolve());
      } else {
        setTimeout(resolve, 120);
      }
    });
    try {
      await cameraProducer.replaceTrack({ track: outTrack });
    } catch {
      try {
        outTrack?.stop?.();
      } catch {
      }
      return;
    }
    const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
    const merged = new MediaStream([...prevAudio, outTrack]);
    localStreamRef.current = merged;
    setLocalStream(merged);
    const { FaceLandmarker, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
    const vision = await FilesetResolver.forVisionTasks(
      "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
    );
    const landmarker = await FaceLandmarker.createFromOptions(vision, {
      baseOptions: {
        modelAssetPath: "/mediapipe/face_landmarker.task",
        delegate: "CPU"
      },
      runningMode: "VIDEO",
      numFaces: 1,
      minFaceDetectionConfidence: 0.5,
      minFacePresenceConfidence: 0.5,
      minTrackingConfidence: 0.5,
      //  / (/)  
      outputFaceBlendshapes: false,
      outputFacialTransformationMatrixes: false
    });
    faceLandmarkerRef.current = landmarker;
    const renderer = new WebGLRenderer({
      alpha: true,
      antialias: true,
      preserveDrawingBuffer: true
    });
    renderer.setSize(512, 512, false);
    renderer.setClearColor(0, 0);
    try {
      renderer.outputColorSpace = SRGBColorSpace;
    } catch {
    }
    const scene = new Scene();
    const camera = new PerspectiveCamera(30, 1, 0.01, 10);
    camera.position.set(0, 1.45, 1.2);
    camera.lookAt(0, 1.45, 0);
    scene.add(new AmbientLight(16777215, 1));
    const dir = new DirectionalLight(16777215, 1);
    dir.position.set(1, 1.5, 1);
    scene.add(dir);
    const loader = new GLTFLoader();
    loader.register((parser) => new VRMLoaderPlugin(parser));
    const gltf = await loader.loadAsync("/avatars/default.vrm");
    const vrm = gltf.userData?.vrm;
    if (!vrm) return;
    try {
      VRMUtils.rotateVRM0(vrm);
    } catch {
    }
    try {
      vrm.scene.rotation.y = Math.PI;
    } catch {
    }
    scene.add(vrm.scene);
    const clock = new Clock();
    avatarThreeRef.current = { renderer, scene, camera, vrm, clock };
    avatarFilterActiveRef.current = true;
    let lastInferAt = 0;
    const tick = () => {
      if (!avatarFilterActiveRef.current) return;
      try {
        outCtx.drawImage(v2, 0, 0, outCanvas.width, outCanvas.height);
      } catch {
        avatarFilterRafRef.current = requestAnimationFrame(tick);
        return;
      }
      const now = performance.now();
      if (now - lastInferAt > 120) {
        lastInferAt = now;
        try {
          const res = landmarker.detectForVideo(v2, now);
          const lm = res?.faceLandmarks?.[0];
          if (lm?.length) {
            let minX = 1, minY = 1, maxX = 0, maxY = 0;
            for (const p2 of lm) {
              if (p2.x < minX) minX = p2.x;
              if (p2.y < minY) minY = p2.y;
              if (p2.x > maxX) maxX = p2.x;
              if (p2.y > maxY) maxY = p2.y;
            }
            const x2 = minX * videoW;
            const y2 = minY * videoH;
            const w2 = (maxX - minX) * videoW;
            const h2 = (maxY - minY) * videoH;
            lastAvatarFaceRef.current.bbox = { x: x2, y: y2, width: w2, height: h2 };
          } else {
            lastAvatarFaceRef.current.bbox = null;
          }
          lastAvatarFaceRef.current.videoW = videoW;
          lastAvatarFaceRef.current.videoH = videoH;
        } catch {
        }
      }
      const t2 = avatarThreeRef.current;
      const dt2 = t2?.clock?.getDelta?.() ?? 0.016;
      if (t2?.vrm) {
        try {
          t2.vrm.update(dt2);
        } catch {
        }
        try {
          t2.renderer.render(t2.scene, t2.camera);
        } catch {
        }
      }
      const bbox = lastAvatarFaceRef.current.bbox;
      if (bbox && t2?.renderer?.domElement) {
        const cx = bbox.x + bbox.width / 2;
        const cy = bbox.y + bbox.height / 2;
        const dw = Math.max(120, bbox.width * 2);
        const dh = Math.max(120, bbox.height * 2.2);
        const dx = cx - dw / 2;
        const dy = cy - dh * 0.6;
        outCtx.save();
        outCtx.beginPath();
        outCtx.ellipse(cx, cy, dw * 0.42, dh * 0.42, 0, 0, Math.PI * 2);
        outCtx.clip();
        outCtx.drawImage(t2.renderer.domElement, dx, dy, dw, dh);
        outCtx.restore();
      }
      avatarFilterRafRef.current = requestAnimationFrame(tick);
    };
    tick();
  }, [stopFaceEmojiFilter, stopAvatarFilter]);
  const startFaceEmojiFilterCore = (0, import_react6.useCallback)(async (emoji) => {
    const allowPassthrough = !!faceFilterActiveRef.current && !!faceFilterOutTrackRef.current;
    if (!emoji && !bgRemoveRef.current && !allowPassthrough) return;
    faceEmojiRef.current = emoji || "";
    await stopAvatarFilter();
    if (canvasPipelineActiveRef.current) {
      console.log("[startFaceEmojiFilter] cleaning up canvasPipeline first");
      canvasPipelineActiveRef.current = false;
      if (canvasPipelineRafRef.current) {
        clearTimeout(canvasPipelineRafRef.current);
        canvasPipelineRafRef.current = null;
      }
      if (canvasPipelineVideoElRef.current) {
        try {
          canvasPipelineVideoElRef.current.pause();
        } catch {
        }
        try {
          canvasPipelineVideoElRef.current.remove();
        } catch {
        }
        canvasPipelineVideoElRef.current = null;
      }
      canvasPipelineCanvasRef.current = null;
    }
    const cameraProducer = producersRef.current.get("camera");
    const existingOutTrack = faceFilterOutTrackRef.current;
    const rawTrackAlive = faceFilterRawTrackRef.current?.readyState === "live";
    const outTrackAlive = existingOutTrack?.readyState === "live";
    const producerUsingOutTrack = !!(cameraProducer?.track && existingOutTrack && cameraProducer.track.id === existingOutTrack.id);
    if (faceFilterActiveRef.current && rawTrackAlive && outTrackAlive && producerUsingOutTrack && faceFilterVideoElRef.current && faceFilterCanvasRef.current) {
      return;
    }
    await stopFaceEmojiFilterCore();
    const freshProducer = producersRef.current.get("camera");
    if (!freshProducer?.replaceTrack) return;
    console.log("[startFaceEmojiFilter] preparing tracks...");
    let rawTrack = null;
    const lastTrack = lastCameraTrackRef.current;
    const canvasPipelineRaw = canvasPipelineRawTrackRef.current;
    const localTracks = localStreamRef.current?.getVideoTracks?.() ?? [];
    const freshTrack = freshProducer.track;
    if (isLikelyCameraTrack(lastTrack) && lastTrack.readyState === "live") {
      console.log("[startFaceEmojiFilter] using lastCameraTrackRef:", lastTrack.id);
      rawTrack = lastTrack;
    } else if (isLikelyCameraTrack(canvasPipelineRaw) && canvasPipelineRaw.readyState === "live") {
      console.log("[startFaceEmojiFilter] using canvasPipelineRawTrackRef:", canvasPipelineRaw.id);
      rawTrack = canvasPipelineRaw;
      lastCameraTrackRef.current = canvasPipelineRaw;
    } else {
      const found = localTracks.find((t2) => isLikelyCameraTrack(t2) && t2.readyState === "live");
      if (found) {
        console.log("[startFaceEmojiFilter] found track in localStream:", found.id);
        rawTrack = found;
      } else if (isLikelyCameraTrack(freshTrack) && freshTrack.readyState === "live") {
        console.log("[startFaceEmojiFilter] using freshProducer.track:", freshTrack.id);
        rawTrack = freshTrack;
      }
    }
    if (!rawTrack && camOnRef.current) {
      console.log("[startFaceEmojiFilter] no reusable camera track, getting new camera track");
      try {
        const s2 = await navigator.mediaDevices.getUserMedia({ video: true });
        rawTrack = s2.getVideoTracks()[0];
        if (isLikelyCameraTrack(rawTrack)) lastCameraTrackRef.current = rawTrack;
      } catch (e2) {
        console.error("[startFaceEmojiFilter] failed to get camera track:", e2);
        return;
      }
    }
    if (!rawTrack) {
      console.warn("[startFaceEmojiFilter] aborted: no raw track found");
      return;
    }
    try {
      rawTrack.enabled = true;
    } catch {
    }
    faceFilterRawTrackRef.current = rawTrack;
    if (isLikelyCameraTrack(rawTrack)) lastCameraTrackRef.current = rawTrack;
    if (faceFilterVideoElRef.current) {
      try {
        faceFilterVideoElRef.current.pause();
      } catch {
      }
      try {
        faceFilterVideoElRef.current.srcObject = null;
      } catch {
      }
      try {
        faceFilterVideoElRef.current.remove();
      } catch {
      }
      faceFilterVideoElRef.current = null;
    }
    const v2 = document.createElement("video");
    v2.autoplay = true;
    v2.playsInline = true;
    v2.muted = true;
    v2.style.cssText = "position:fixed; bottom:0; right:0; width:640px; height:480px; opacity:0; pointer-events:none; z-index:-999;";
    document.body.appendChild(v2);
    faceFilterVideoElRef.current = v2;
    v2.srcObject = new MediaStream([rawTrack]);
    try {
      await v2.play();
    } catch (e2) {
      console.warn("[startFaceEmojiFilter] v.play() failed, retrying on interaction or continuing:", e2);
    }
    await new Promise((resolve) => {
      const checkReady = () => {
        if (v2.videoWidth > 0 && v2.videoHeight > 0 && v2.readyState >= 2) {
          resolve();
          return true;
        }
        return false;
      };
      if (checkReady()) return;
      const onLoaded = () => {
        v2.removeEventListener("loadedmetadata", onLoaded);
        v2.removeEventListener("canplay", onLoaded);
        if (!checkReady()) {
          setTimeout(resolve, 100);
        }
      };
      v2.addEventListener("loadedmetadata", onLoaded);
      v2.addEventListener("canplay", onLoaded);
      setTimeout(resolve, 2e3);
    });
    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });
    if (!ctx) {
      console.warn("[startFaceEmojiFilter] canvas 2d context unavailable");
      try {
        v2.pause();
      } catch {
      }
      try {
        v2.srcObject = null;
      } catch {
      }
      try {
        v2.remove();
      } catch {
      }
      faceFilterVideoElRef.current = null;
      return;
    }
    const w2 = v2.videoWidth || 640;
    const h2 = v2.videoHeight || 480;
    canvas.width = w2;
    canvas.height = h2;
    faceFilterCanvasRef.current = canvas;
    const faceFilterLastCanvas = document.createElement("canvas");
    faceFilterLastCanvas.width = canvas.width;
    faceFilterLastCanvas.height = canvas.height;
    faceFilterLastGoodFrameCanvasRef.current = faceFilterLastCanvas;
    const frameCanvas = document.createElement("canvas");
    frameCanvas.width = w2;
    frameCanvas.height = h2;
    const frameCtx = frameCanvas.getContext("2d");
    faceBgFrameCanvasRef.current = frameCanvas;
    faceFilterActiveRef.current = true;
    hasEverDrawnEmojiRef.current = false;
    emojiBlackScreenStartedAtRef.current = 0;
    emojiBlackScreenToastShownRef.current = false;
    let detectorState = null;
    if (typeof window !== "undefined" && "FaceDetector" in window) {
      try {
        const native = new window.FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
        detectorState = { kind: "native", detector: native };
      } catch {
      }
    }
    if (!detectorState) {
      try {
        const { FaceDetector: MpFaceDetector, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
        const vision = await FilesetResolver.forVisionTasks(
          "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
        );
        const mp = await MpFaceDetector.createFromOptions(vision, {
          baseOptions: {
            //  CDN  ( )
            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_detector/blaze_face_short_range/float16/1/blaze_face_short_range.tflite",
            delegate: "CPU"
          },
          runningMode: "VIDEO",
          minDetectionConfidence: 0.5
        });
        detectorState = { kind: "mediapipe", detector: mp };
      } catch (e2) {
        console.warn("[face-emoji] detector init failed:", e2);
      }
    }
    faceDetectorRef.current = detectorState;
    if (faceEmojiRef.current && faceModeRef.current === "emoji" && detectorState) {
      console.log("[startFaceEmojiFilter] \uC5BC\uAD74 \uAC10\uC9C0\uAE30 \uC989\uC2DC \uCD08\uAE30\uD654 \uC644\uB8CC, \uAC10\uC9C0 \uC2DC\uC791");
      lastDetectAtRef.current = 0;
    }
    const outStream = canvas.captureStream(15);
    const outTrack = outStream.getVideoTracks()[0];
    faceFilterOutStreamRef.current = outStream;
    faceFilterOutTrackRef.current = outTrack;
    const ensureBgSegmenter = () => {
      const cur = faceBgSegmenterRef.current;
      if (cur?.segmenter || cur?.loading) return;
      const loading2 = (async () => {
        try {
          const { ImageSegmenter, FilesetResolver } = await Promise.resolve().then(() => (init_vision_bundle(), vision_bundle_exports));
          const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.32/wasm"
          );
          const segmenter = await ImageSegmenter.createFromOptions(vision, {
            baseOptions: {
              modelAssetPath: "https://storage.googleapis.com/mediapipe-models/image_segmenter/selfie_segmenter/float16/1/selfie_segmenter.tflite",
              delegate: "CPU"
            },
            runningMode: "VIDEO",
            outputCategoryMask: true
          });
          return segmenter;
        } catch (e2) {
          console.warn("[bg-remove] segmenter init failed:", e2);
          return null;
        }
      })();
      faceBgSegmenterRef.current = { loading: loading2 };
      loading2.then((seg) => {
        if (!seg) {
          faceBgSegmenterRef.current = null;
          return;
        }
        faceBgSegmenterRef.current = { segmenter: seg };
      });
    };
    let hasReplacedTrack = false;
    let frameCount = 0;
    const filterStartTime = Date.now();
    let filteredFramesDrawn = 0;
    const draw = async () => {
      if (!faceFilterActiveRef.current) return;
      const videoReady = v2 && v2.videoWidth > 0 && v2.videoHeight > 0 && v2.readyState >= 2;
      if (!videoReady) {
        const last = faceFilterLastGoodFrameCanvasRef.current;
        if (last && faceFilterLastGoodFrameAtRef.current > 0) {
          try {
            ctx.drawImage(last, 0, 0, canvas.width, canvas.height);
          } catch {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        } else {
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        faceFilterRafRef.current = requestAnimationFrame(draw);
        return;
      }
      const wantBgRemove = !!bgRemoveRef.current;
      const wantEmoji = !!faceEmojiRef.current && faceModeRef.current === "emoji";
      let normalizedFaceBoxForEmoji = null;
      let canDrawEmoji = false;
      if (wantEmoji) {
        const box = lastFaceBoxRef.current;
        const videoW = v2.videoWidth || canvas.width;
        const videoH = v2.videoHeight || canvas.height;
        const isRecent = lastFaceBoxAtRef.current && Date.now() - lastFaceBoxAtRef.current < 1200;
        normalizedFaceBoxForEmoji = normalizeFaceBox(box, videoW, videoH);
        canDrawEmoji = !!normalizedFaceBoxForEmoji && isRecent;
      }
      const checkFiltersReady = () => {
        return true;
      };
      const filtersReady = checkFiltersReady();
      const bgSegActuallyReady = wantBgRemove ? !!faceBgSegmenterRef.current?.segmenter : true;
      if (isFilterPreparingRef.current && (wantBgRemove || wantEmoji)) {
        const last = faceFilterLastGoodFrameCanvasRef.current;
        if (last && faceFilterLastGoodFrameAtRef.current > 0) {
          try {
            ctx.drawImage(last, 0, 0, canvas.width, canvas.height);
          } catch {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        } else {
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        faceFilterRafRef.current = requestAnimationFrame(draw);
        return;
      }
      if (wantBgRemove && !bgSegActuallyReady) {
        const last = faceFilterLastGoodFrameCanvasRef.current;
        if (last && faceFilterLastGoodFrameAtRef.current > 0) {
          try {
            ctx.drawImage(last, 0, 0, canvas.width, canvas.height);
          } catch {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        } else {
          ctx.fillStyle = "#000000";
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        faceFilterRafRef.current = requestAnimationFrame(draw);
        return;
      }
      if (wantBgRemove) ensureBgSegmenter();
      try {
        if (isFilterPreparingRef.current && (wantBgRemove || wantEmoji)) {
        } else if (!wantBgRemove || !frameCtx) {
          if (wantEmoji && !canDrawEmoji) {
            if (!hasEverDrawnEmojiRef.current) {
              if (!emojiBlackScreenStartedAtRef.current) emojiBlackScreenStartedAtRef.current = Date.now();
              if (Date.now() - emojiBlackScreenStartedAtRef.current >= 3e3 && !emojiBlackScreenToastShownRef.current) {
                emojiBlackScreenToastShownRef.current = true;
                setToastMessage("\uC5BC\uAD74\uC774 \uBCF4\uC774\uAC8C \uD574\uC8FC\uC138\uC694.");
                setShowToast(true);
              }
              ctx.fillStyle = "#000000";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
              ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
            }
          } else {
            ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
          }
        } else {
          if (wantEmoji && !canDrawEmoji) {
            if (!hasEverDrawnEmojiRef.current) {
              if (!emojiBlackScreenStartedAtRef.current) emojiBlackScreenStartedAtRef.current = Date.now();
              if (Date.now() - emojiBlackScreenStartedAtRef.current >= 3e3 && !emojiBlackScreenToastShownRef.current) {
                emojiBlackScreenToastShownRef.current = true;
                setToastMessage("\uC5BC\uAD74\uC774 \uBCF4\uC774\uAC8C \uD574\uC8FC\uC138\uC694.");
                setShowToast(true);
              }
              ctx.fillStyle = "#000000";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
              ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
            }
          } else {
            frameCtx.globalCompositeOperation = "source-over";
            frameCtx.clearRect(0, 0, frameCanvas.width, frameCanvas.height);
            frameCtx.drawImage(v2, 0, 0, frameCanvas.width, frameCanvas.height);
            const seg = faceBgSegmenterRef.current?.segmenter;
            const nowMs = performance.now();
            if (seg && nowMs - faceBgLastInferAtRef.current > 140) {
              faceBgLastInferAtRef.current = nowMs;
              try {
                const res = seg.segmentForVideo(v2, nowMs);
                const mask = res?.categoryMask;
                if (mask) {
                  const maskW = mask.width ?? mask?.getAsUint8Array?.()?.length;
                  const maskH = mask.height ?? 0;
                  const dataU8 = mask.getAsUint8Array?.();
                  if (dataU8 && maskW && maskH && dataU8.length >= maskW * maskH) {
                    let maskCanvas2 = faceBgMaskCanvasRef.current;
                    if (!maskCanvas2) {
                      maskCanvas2 = document.createElement("canvas");
                      faceBgMaskCanvasRef.current = maskCanvas2;
                    }
                    if (maskCanvas2.width !== maskW || maskCanvas2.height !== maskH) {
                      maskCanvas2.width = maskW;
                      maskCanvas2.height = maskH;
                    }
                    const mctx = maskCanvas2.getContext("2d");
                    if (mctx) {
                      const img = mctx.createImageData(maskW, maskH);
                      for (let i2 = 0; i2 < maskW * maskH; i2++) {
                        const isPerson = dataU8[i2] === 0;
                        const o2 = i2 * 4;
                        img.data[o2] = 255;
                        img.data[o2 + 1] = 255;
                        img.data[o2 + 2] = 255;
                        img.data[o2 + 3] = isPerson ? 255 : 0;
                      }
                      mctx.putImageData(img, 0, 0);
                    }
                  }
                }
              } catch {
              }
            }
            const maskCanvas = faceBgMaskCanvasRef.current;
            if (maskCanvas) {
              const maskW = maskCanvas.width || 0;
              const maskH = maskCanvas.height || 0;
              if (maskW < 10 || maskH < 10) {
                ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
              } else {
                frameCtx.globalCompositeOperation = "destination-in";
                frameCtx.drawImage(maskCanvas, 0, 0, frameCanvas.width, frameCanvas.height);
                frameCtx.globalCompositeOperation = "source-over";
                try {
                  const sampleSize = 50;
                  const stepX = Math.max(1, Math.floor(frameCanvas.width / sampleSize));
                  const stepY = Math.max(1, Math.floor(frameCanvas.height / sampleSize));
                  const imageData = frameCtx.getImageData(0, 0, frameCanvas.width, frameCanvas.height);
                  const data2 = imageData.data;
                  let visiblePixels = 0;
                  let totalSamples = 0;
                  for (let y2 = 0; y2 < frameCanvas.height; y2 += stepY) {
                    for (let x2 = 0; x2 < frameCanvas.width; x2 += stepX) {
                      const idx = (y2 * frameCanvas.width + x2) * 4;
                      if (data2[idx + 3] > 10) {
                        visiblePixels++;
                      }
                      totalSamples++;
                    }
                  }
                  const visibleRatio = totalSamples > 0 ? visiblePixels / totalSamples : 0;
                  if (visibleRatio < 0.03) {
                    console.log("[BgRemove] \uC0AC\uB78C \uC601\uC5ED\uC774 \uAC70\uC758 \uC5C6\uC74C, \uC6D0\uBCF8 \uBE44\uB514\uC624 \uD45C\uC2DC:", visibleRatio);
                    ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
                  } else {
                    ctx.save();
                    ctx.fillStyle = "#ffffff";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(frameCanvas, 0, 0, canvas.width, canvas.height);
                    ctx.restore();
                    if (wantBgRemove) filteredFramesDrawn++;
                  }
                } catch (checkError) {
                  if (isFilterPreparingRef.current && (wantBgRemove || wantEmoji)) {
                    ctx.fillStyle = "#000000";
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                  } else {
                    console.warn("[BgRemove] \uB9C8\uC2A4\uD06C \uAC80\uC99D \uC2E4\uD328, \uC6D0\uBCF8 \uBE44\uB514\uC624 \uD45C\uC2DC:", checkError);
                    ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
                  }
                }
              }
            } else {
              if (isFilterPreparingRef.current && (wantBgRemove || wantEmoji)) {
                ctx.fillStyle = "#000000";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
              } else {
                ctx.drawImage(v2, 0, 0, canvas.width, canvas.height);
              }
            }
          }
        }
      } catch {
        if (isFilterPreparingRef.current && (wantBgRemove || wantEmoji)) {
          const last = faceFilterLastGoodFrameCanvasRef.current;
          if (last && faceFilterLastGoodFrameAtRef.current > 0) {
            try {
              ctx.drawImage(last, 0, 0, canvas.width, canvas.height);
            } catch {
              ctx.fillStyle = "#000000";
              ctx.fillRect(0, 0, canvas.width, canvas.height);
            }
          } else {
            ctx.fillStyle = "#000000";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
          }
        }
        faceFilterRafRef.current = requestAnimationFrame(draw);
        return;
      }
      const now = Date.now();
      const wantEmojiForDetect = !!faceEmojiRef.current && faceModeRef.current === "emoji";
      const shouldStartDetection = true;
      if (wantEmojiForDetect && shouldStartDetection && !faceDetectorRef.current) {
        ensureFaceDetector().catch(() => {
        });
      }
      const det = faceDetectorRef.current;
      const hasDetectedFace = !!lastFaceBoxRef.current && lastFaceBoxAtRef.current && Date.now() - lastFaceBoxAtRef.current < 1200;
      const detectInterval = isFilterPreparingRef.current || !hasDetectedFace ? 50 : 80;
      if (wantEmojiForDetect && shouldStartDetection && det && now - lastDetectAtRef.current > detectInterval) {
        lastDetectAtRef.current = now;
        if (!faceDetectInFlightRef.current) {
          faceDetectInFlightRef.current = true;
          const seq = ++faceDetectSeqRef.current;
          const vw = v2.videoWidth || canvas.width;
          const vh = v2.videoHeight || canvas.height;
          Promise.resolve(runFaceDetectOnce(v2, vw, vh)).then((normalized) => {
            if (seq !== faceDetectSeqRef.current) return;
            if (normalized) {
              lastFaceBoxRef.current = normalized;
              lastFaceBoxAtRef.current = Date.now();
            } else {
              if (!lastFaceBoxAtRef.current || Date.now() - lastFaceBoxAtRef.current > 900) {
                lastFaceBoxRef.current = null;
                lastFaceBoxAtRef.current = 0;
                smoothedFaceBoxRef.current = null;
              }
            }
          }).finally(() => {
            faceDetectInFlightRef.current = false;
          });
        }
      }
      const currentEmoji = faceEmojiRef.current;
      if (!canDrawEmoji) {
        smoothedFaceBoxRef.current = null;
      } else if (normalizedFaceBoxForEmoji) {
        const scaleX = canvas.width / (v2.videoWidth || canvas.width);
        const scaleY = canvas.height / (v2.videoHeight || canvas.height);
        const targetBox = {
          x: (normalizedFaceBoxForEmoji.x + normalizedFaceBoxForEmoji.width / 2) * scaleX,
          y: (normalizedFaceBoxForEmoji.y + normalizedFaceBoxForEmoji.height / 2) * scaleY - normalizedFaceBoxForEmoji.height * scaleY * 0.25,
          size: Math.max(normalizedFaceBoxForEmoji.width * scaleX, normalizedFaceBoxForEmoji.height * scaleY)
        };
        if (!Number.isFinite(targetBox.x) || !Number.isFinite(targetBox.y) || !Number.isFinite(targetBox.size)) {
          smoothedFaceBoxRef.current = null;
        } else {
          const smoothFactor = 0.75;
          const prev = smoothedFaceBoxRef.current;
          smoothedFaceBoxRef.current = prev ? {
            x: prev.x + (targetBox.x - prev.x) * smoothFactor,
            y: prev.y + (targetBox.y - prev.y) * smoothFactor,
            size: prev.size + (targetBox.size - prev.size) * smoothFactor
          } : targetBox;
          const smoothed = smoothedFaceBoxRef.current;
          const maxSize = Math.floor(Math.min(canvas.width, canvas.height) * 0.5);
          const size = Math.max(120, Math.min(maxSize, Math.floor(smoothed.size * 2.8)));
          ctx.save();
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = `${size}px "Apple Color Emoji","Segoe UI Emoji","Noto Color Emoji",sans-serif`;
          ctx.fillText(currentEmoji, smoothed.x, smoothed.y);
          ctx.restore();
          hasEverDrawnEmojiRef.current = true;
          emojiBlackScreenStartedAtRef.current = 0;
          emojiBlackScreenToastShownRef.current = false;
          if (wantEmoji) filteredFramesDrawn++;
        }
      }
      frameCount++;
      if (!hasReplacedTrack && frameCount >= 3) {
        const MAX_WAIT_MS = 100;
        const elapsed = Date.now() - filterStartTime;
        const isTimeout = elapsed >= MAX_WAIT_MS;
        const needFilters = wantBgRemove || wantEmoji;
        if (!needFilters || isTimeout) {
          hasReplacedTrack = true;
          try {
            try {
              outTrack.enabled = true;
            } catch {
            }
            const oldProducer = producersRef.current.get("camera");
            if (oldProducer) {
              try {
                oldProducer.close();
              } catch {
              }
              producersRef.current.delete("camera");
            }
            const transport = sendTransportRef.current;
            if (transport && !transport.closed) {
              const newProducer = await transport.produce({
                track: outTrack,
                appData: { type: "camera" }
              });
              producersRef.current.set("camera", newProducer);
              if (!needFilters) {
                console.log("[FaceEmoji] new producer created with canvas track (no filters needed)");
              } else if (filtersReady) {
                console.log("[FaceEmoji] new producer created with canvas track (filters ready)", elapsed, "ms");
              } else {
                console.log("[FaceEmoji] new producer created with canvas track (timeout after", elapsed, "ms)");
              }
            }
            const prevAudio = localStreamRef.current?.getAudioTracks().filter((t2) => t2.readyState === "live") ?? [];
            const merged = new MediaStream([...prevAudio, outTrack]);
            localStreamRef.current = merged;
            setLocalStream(merged);
            bumpStreamVersion();
          } catch (e2) {
            console.error("[FaceEmoji] new producer creation failed:", e2);
          }
        }
      }
      const drewBlackForEmoji = wantEmoji && !canDrawEmoji;
      try {
        const last = faceFilterLastGoodFrameCanvasRef.current;
        if (last && canvas && !drewBlackForEmoji) {
          const lctx = last.getContext("2d");
          if (lctx) {
            lctx.drawImage(canvas, 0, 0, last.width, last.height);
            faceFilterLastGoodFrameAtRef.current = Date.now();
          }
        }
      } catch {
      }
      if (wantBgRemove || wantEmoji) {
        faceFilterRafRef.current = setTimeout(() => requestAnimationFrame(draw), 50);
      } else {
        faceFilterRafRef.current = requestAnimationFrame(draw);
      }
    };
    draw();
  }, [stopAvatarFilter, stopFaceEmojiFilterCore]);
  const startFaceEmojiFilter = (0, import_react6.useCallback)((emoji) => {
    return enqueueFaceEmojiOp(() => startFaceEmojiFilterCore(emoji));
  }, [enqueueFaceEmojiOp, startFaceEmojiFilterCore]);
  (0, import_react6.useEffect)(() => {
    console.log("[PERMISSION]", {
      micPermission,
      camPermission,
      micDisabled,
      camDisabled
    });
  }, [micPermission, camPermission]);
  const createAvatarStream = (0, import_react6.useCallback)((name, width = 640, height = 480, showName = true) => {
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#f3f4f6";
    ctx.fillRect(0, 0, width, height);
    const centerX = width / 2;
    const centerY = showName ? height / 2 - 20 : height / 2;
    const radius = Math.min(width, height) * 0.25;
    const gradient = ctx.createLinearGradient(centerX - radius, centerY - radius, centerX + radius, centerY + radius);
    gradient.addColorStop(0, "#eef6f0");
    gradient.addColorStop(1, "#cfe8d6");
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
    ctx.fill();
    const initials = (name || "?").split(" ").map((n2) => n2[0]).join("").substring(0, 2).toUpperCase();
    ctx.fillStyle = "#97c793";
    ctx.font = `bold ${radius * 0.8}px Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(initials, centerX, centerY);
    if (showName) {
      const displayName = name || "\uCC38\uAC00\uC790";
      ctx.fillStyle = "#374151";
      const fontSize = Math.max(20, width * 0.05);
      ctx.font = `bold ${fontSize}px Pretendard, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif`;
      ctx.textAlign = "center";
      ctx.textBaseline = "top";
      const maxWidth = width * 0.85;
      let finalName = displayName;
      const metrics = ctx.measureText(displayName);
      if (metrics.width > maxWidth) {
        let truncated = displayName;
        while (ctx.measureText(truncated + "...").width > maxWidth && truncated.length > 0) {
          truncated = truncated.slice(0, -1);
        }
        finalName = truncated + "...";
      }
      ctx.fillText(finalName, centerX, centerY + radius + 15);
    }
    const stream = canvas.captureStream(30);
    return stream;
  }, []);
  const handleBrowserPip = (0, import_react6.useCallback)(async () => {
    const video = mainVideoRef.current;
    if (!video) return;
    if (!document.pictureInPictureElement) {
      const currentMainStream = mainStreamRef.current;
      let stream = video.srcObject || currentMainStream;
      const peerName = mainUser?.name || "\uCC38\uAC00\uC790";
      const peerId = mainUser?.id != null ? String(mainUser.id) : "";
      if (!stream || !stream.getVideoTracks().some((t2) => t2.readyState === "live")) {
        console.log("[PiP] \uBE44\uB514\uC624 \uC2A4\uD2B8\uB9BC\uC774 \uC5C6\uC5B4\uC11C \uC544\uBC14\uD0C0 \uC2A4\uD2B8\uB9BC \uC0DD\uC131");
        stream = createAvatarStream(peerName);
        video.srcObject = stream;
        video.muted = true;
        try {
          await video.play();
        } catch {
        }
      } else {
        if (!video.srcObject && currentMainStream) {
          console.log("[PiP] video.srcObject\uAC00 \uC5C6\uC5B4\uC11C \uAC15\uC81C \uC124\uC815");
          video.srcObject = currentMainStream;
          video.muted = true;
          try {
            await video.play();
          } catch {
          }
        }
        if (video.readyState < 2) {
          await new Promise((resolve) => {
            const onCanPlay = () => {
              video.removeEventListener("canplay", onCanPlay);
              resolve();
            };
            video.addEventListener("canplay", onCanPlay);
            setTimeout(resolve, 1e3);
          });
        }
      }
      console.log("[PiP] MeetingContext requestBrowserPip \uD638\uCD9C");
      const success = await requestBrowserPip(video, stream, peerName, peerId);
      if (!success) {
        console.log("[PiP] fallback: \uC9C1\uC811 requestPictureInPicture \uD638\uCD9C");
        video.requestPictureInPicture().catch((e2) => {
          console.warn("[PiP] requestPictureInPicture failed:", e2);
        });
      }
    }
  }, [requestBrowserPip, mainUser, createAvatarStream]);
  const startLocalMedia = async () => {
    if (localStreamRef.current) {
      try {
        const stream = localStreamRef.current;
        const at2 = stream.getAudioTracks()[0];
        if (at2) at2.enabled = !!micOnRef.current;
        const vt2 = stream.getVideoTracks()[0];
        if (vt2) vt2.enabled = !!camOnRef.current;
        if (isLikelyCameraTrack(vt2)) lastCameraTrackRef.current = vt2;
        setLocalStream(stream);
        setMicPermission("granted");
        setCamPermission("granted");
        try {
          if (typeof saveMeetingState === "function") {
            saveMeetingState({ localStream: stream });
          }
        } catch (e2) {
          console.warn("[startLocalMedia] meeting context error:", e2);
        }
        return stream;
      } finally {
        setIsLocalLoading(false);
      }
    }
    try {
      const shouldGetVideo = !!camOnRef.current;
      const shouldGetAudio = true;
      const stream = await navigator.mediaDevices.getUserMedia({
        video: shouldGetVideo,
        audio: shouldGetAudio
      });
      const at2 = stream.getAudioTracks()[0];
      if (at2) {
        at2.enabled = !!micOnRef.current;
      }
      const vt2 = stream.getVideoTracks()[0];
      if (vt2) {
        vt2.enabled = !!camOnRef.current;
      }
      if (isLikelyCameraTrack(vt2)) lastCameraTrackRef.current = vt2;
      localStreamRef.current = stream;
      setLocalStream(stream);
      setMicPermission("granted");
      setCamPermission("granted");
      try {
        if (typeof saveMeetingState === "function") {
          saveMeetingState({ localStream: stream });
        }
      } catch (e2) {
        console.warn("[startLocalMedia] meeting context error:", e2);
      }
      return stream;
    } catch (err) {
      console.error("[startLocalMedia] Failed to get media:", err);
      setMicPermission("denied");
      setCamPermission("denied");
      if (wsRef.current?.readyState === WebSocket.OPEN) {
        try {
          wsRef.current.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: { muted: true, cameraOff: true }
          }));
        } catch (_2) {
        }
      }
      return null;
    } finally {
      setIsLocalLoading(false);
    }
  };
  const ensureLocalProducers = async () => {
    const t2 = sendTransportRef.current;
    if (!t2 || t2.closed) return;
    const stream = localStreamRef.current;
    if (!stream) return;
    const audioTrack = stream.getAudioTracks().find((x2) => x2.readyState === "live");
    if (audioTrack) {
      const hasAudioProducer = producersRef.current.has("audio");
      if (!hasAudioProducer) {
        try {
          const p2 = await t2.produce({
            track: audioTrack,
            appData: { type: "audio" }
          });
          producersRef.current.set("audio", p2);
        } catch (e2) {
        }
      }
      audioTrack.enabled = !!micOnRef.current;
    }
    if (!camOnRef.current) {
      return;
    }
    if (isFilterPreparingRef.current) {
      console.log(`[ensureLocalProducers] Filter preparing, skipping camera producer`);
      return;
    }
    const videoTrack = stream.getVideoTracks().find((x2) => x2.readyState === "live");
    if (!videoTrack) {
      return;
    }
    const hasCameraProducer = producersRef.current.has("camera");
    if (!hasCameraProducer) {
      try {
        const p2 = await t2.produce({
          track: videoTrack,
          appData: { type: "camera" }
        });
        producersRef.current.set("camera", p2);
      } catch (e2) {
      }
    }
    videoTrack.enabled = !!camOnRef.current;
  };
  const safeSfuSend = (obj) => {
    const ws2 = sfuWsRef.current;
    if (!ws2 || ws2.readyState !== WebSocket.OPEN) {
      console.warn("SFU WS not open yet, skip send:", obj.action);
      return;
    }
    ws2.send(JSON.stringify(obj));
  };
  const closeSfuWsForLeave = (0, import_react6.useCallback)(() => {
    const ws2 = sfuWsRef.current;
    if (!ws2) return;
    try {
      if (ws2.readyState === WebSocket.OPEN) {
        ws2.close(4001, "leave");
      } else {
        ws2.close();
      }
    } catch {
      try {
        ws2.close();
      } catch {
      }
    }
  }, []);
  const ensureParticipant = (peerId) => {
    setParticipants((prev) => {
      const existingUser = prev.find((p2) => p2.id === peerId);
      if (existingUser) return prev;
      return [
        ...prev,
        {
          id: peerId,
          name: `User-${String(peerId).slice(0, 4)}`,
          isMe: false,
          muted: true,
          cameraOff: true,
          speaking: false,
          stream: null,
          isLoading: true
        }
      ];
    });
  };
  const safeClose = (obj) => {
    if (!obj) return;
    try {
      if (obj.closed) return;
      obj.close();
    } catch (e2) {
      console.warn("safeClose ignored:", e2?.message);
    }
  };
  const clearPeerStreamOnly = (peerId) => {
    peerStreamsRef.current.delete(peerId);
    setParticipants(
      (prev) => prev.map(
        (p2) => String(p2.id) === String(peerId) ? {
          ...p2,
          stream: null
          //  (cameraOff/muted) 
        } : p2
      )
    );
  };
  const startScreenShare = async () => {
    if (isIOS) {
      console.warn("iOS\uC5D0\uC11C\uB294 \uD654\uBA74 \uACF5\uC720\uB97C \uC9C0\uC6D0\uD558\uC9C0 \uC54A\uC2B5\uB2C8\uB2E4.");
      return;
    }
    if (!sendTransportRef.current || sendTransportRef.current.closed) return;
    if (producersRef.current.has("screen")) return;
    try {
      const stream = await navigator.mediaDevices.getDisplayMedia({
        video: true,
        audio: false
      });
      const track = stream.getVideoTracks()[0];
      if (!track || track.readyState === "ended") return;
      cameraWasOnBeforeScreenShareRef.current = camOnRef.current;
      faceEmojiWasOnBeforeScreenShareRef.current = faceEmojiRef.current || null;
      faceModeWasOnBeforeScreenShareRef.current = faceModeRef.current || null;
      bgRemoveWasOnBeforeScreenShareRef.current = bgRemoveRef.current || false;
      if (faceFilterActiveRef.current || faceEmojiRef.current || faceModeRef.current === "emoji") {
        console.log("[startScreenShare] Stopping emoji filter before screen share");
        await stopFaceEmojiFilter();
      }
      const cameraProducer = producersRef.current.get("camera");
      if (cameraProducer) {
        const id = cameraProducer.id;
        try {
          cameraProducer.close();
        } catch {
        }
        producersRef.current.delete("camera");
        safeSfuSend({ action: "closeProducer", data: { producerId: id } });
      }
      if (localStreamRef.current) {
        localStreamRef.current.getVideoTracks().forEach((t2) => {
          try {
            t2.stop();
          } catch {
          }
        });
        canvasPipelineActiveRef.current = false;
        if (canvasPipelineRafRef.current) {
          clearTimeout(canvasPipelineRafRef.current);
          canvasPipelineRafRef.current = null;
        }
        if (canvasPipelineVideoElRef.current) {
          try {
            canvasPipelineVideoElRef.current.pause();
          } catch {
          }
        }
        const audios = localStreamRef.current.getAudioTracks().filter((t2) => t2.readyState === "live");
        const audioOnly = new MediaStream([...audios]);
        localStreamRef.current = audioOnly;
        setLocalStream(audioOnly);
      } else {
        const audioOnly = new MediaStream();
        localStreamRef.current = audioOnly;
        setLocalStream(audioOnly);
      }
      const screenProducer = await sendTransportRef.current.produce({
        track,
        appData: { type: "screen" }
      });
      producersRef.current.set("screen", screenProducer);
      screenStreamRef.current = stream;
      setIsScreenSharing(true);
      setParticipants(
        (prev) => prev.map(
          (p2) => p2.isMe ? { ...p2, screenStream: stream, isScreenSharing: true } : p2
        )
      );
      track.onended = () => {
        if (isStoppingScreenShareRef.current) return;
        stopScreenShare(true);
      };
    } catch (e2) {
    }
  };
  const stopScreenShare = async (fromTrackEnded = false) => {
    if (isStoppingScreenShareRef.current) {
      return;
    }
    isStoppingScreenShareRef.current = true;
    try {
      const screenProducer = producersRef.current.get("screen");
      if (screenProducer) {
        try {
          screenProducer.close();
        } catch {
        }
        producersRef.current.delete("screen");
        safeSfuSend({
          action: "closeProducer",
          data: { producerId: screenProducer.id }
        });
      }
      if (screenStreamRef.current) {
        screenStreamRef.current.getTracks().forEach((t2) => {
          t2.onended = null;
          if (t2.readyState !== "ended") {
            try {
              t2.stop();
            } catch {
            }
          }
        });
        screenStreamRef.current = null;
      }
      setIsScreenSharing(false);
      setParticipants(
        (prev) => prev.map(
          (p2) => p2.isMe ? { ...p2, screenStream: null, isScreenSharing: false } : p2
        )
      );
      const shouldRestoreCamera = camOnRef.current;
      if (!shouldRestoreCamera) {
        const prevAudioTracks = localStreamRef.current ? localStreamRef.current.getAudioTracks().filter((t2) => t2.readyState !== "ended") : [];
        const audioOnly = new MediaStream([...prevAudioTracks]);
        localStreamRef.current = audioOnly;
        setLocalStream(audioOnly);
        setParticipants(
          (prev) => prev.map(
            (p2) => p2.isMe ? { ...p2, cameraOff: true, stream: audioOnly } : p2
          )
        );
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(
            JSON.stringify({
              type: "USER_STATE_CHANGE",
              userId,
              changes: { cameraOff: true }
            })
          );
        }
        return;
      }
      if (!sendTransportRef.current || sendTransportRef.current.closed) {
        console.warn("[restore] sendTransport not ready");
        return;
      }
      const savedEmoji = faceEmojiWasOnBeforeScreenShareRef.current;
      const savedMode = faceModeWasOnBeforeScreenShareRef.current;
      const savedBgRemove = bgRemoveWasOnBeforeScreenShareRef.current;
      const targetEmoji = faceEmojiRef.current;
      const targetMode = faceModeRef.current;
      const targetBgRemove = bgRemoveRef.current;
      const hasFilterConfig = targetEmoji || targetMode === "emoji" || targetBgRemove;
      if (hasFilterConfig) {
        console.log(`[stopScreenShare] Restoring camera with filter: emoji=${targetEmoji}, mode=${targetMode}, bgRemove=${targetBgRemove}`);
        if (targetEmoji) {
          faceEmojiRef.current = targetEmoji;
          setFaceEmoji(targetEmoji);
        }
        if (targetMode) {
          faceModeRef.current = targetMode;
          setFaceMode(targetMode);
        }
        if (targetBgRemove !== void 0) {
          bgRemoveRef.current = targetBgRemove;
          setBgRemove(targetBgRemove);
        }
        try {
          await turnOnCamera();
          console.log("[stopScreenShare] Camera restored with emoji filter via turnOnCamera");
        } catch (e2) {
          console.error("[stopScreenShare] Failed to restore camera with turnOnCamera:", e2);
          const prevAudioTracks = localStreamRef.current ? localStreamRef.current.getAudioTracks().filter((t2) => t2.readyState !== "ended") : [];
          const newStream = await navigator.mediaDevices.getUserMedia({
            video: true,
            audio: false
          });
          const newVideoTrack = newStream.getVideoTracks()[0];
          if (newVideoTrack && newVideoTrack.readyState === "live") {
            await produceCamera(newVideoTrack, true);
            const merged = new MediaStream([...prevAudioTracks, newVideoTrack]);
            localStreamRef.current = merged;
            setLocalStream(merged);
            setParticipants(
              (prev) => prev.map(
                (p2) => p2.isMe ? { ...p2, cameraOff: false, stream: merged } : p2
              )
            );
          }
        }
      } else {
        const prevAudioTracks = localStreamRef.current ? localStreamRef.current.getAudioTracks().filter((t2) => t2.readyState !== "ended") : [];
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: true,
          audio: false
        });
        const newVideoTrack = newStream.getVideoTracks()[0];
        if (!newVideoTrack || newVideoTrack.readyState !== "live") {
          console.warn("[restore] camera track not live, skip produce");
          return;
        }
        await produceCamera(newVideoTrack, true);
        const merged = new MediaStream([...prevAudioTracks, newVideoTrack]);
        localStreamRef.current = merged;
        setLocalStream(merged);
        setParticipants(
          (prev) => prev.map(
            (p2) => p2.isMe ? { ...p2, cameraOff: false, stream: merged } : p2
          )
        );
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(
            JSON.stringify({
              type: "USER_STATE_CHANGE",
              userId,
              changes: { cameraOff: false }
            })
          );
        }
      }
      faceEmojiWasOnBeforeScreenShareRef.current = null;
      faceModeWasOnBeforeScreenShareRef.current = null;
      bgRemoveWasOnBeforeScreenShareRef.current = false;
    } catch (e2) {
      console.error("[stopScreenShare] failed:", e2);
    } finally {
      isStoppingScreenShareRef.current = false;
    }
  };
  const produceCamera = async (track, forceEnabled = null) => {
    const t2 = sendTransportRef.current;
    if (!t2 || t2.closed) {
      console.warn("[produceCamera] transport not ready");
      return;
    }
    if (!track || track.readyState !== "live") {
      console.warn("[produceCamera] track not live");
      return;
    }
    const old = producersRef.current.get("camera");
    if (old) {
      try {
        old.close();
      } catch {
      }
      producersRef.current.delete("camera");
      safeSfuSend({ action: "closeProducer", data: { producerId: old.id } });
    }
    const enabledState = forceEnabled !== null ? forceEnabled : camOnRef.current;
    track.enabled = enabledState;
    const producer = await t2.produce({
      track,
      appData: { type: "camera" }
    });
    producersRef.current.set("camera", producer);
    return producer;
  };
  const consumeProducer = async (producerId, fallbackPeerId, targetAppData) => {
    if (!producerId) return;
    const myId = String(userIdRef.current);
    const peerIdStr = String(fallbackPeerId ?? "");
    if (peerIdStr === myId || peerIdStr.length >= 4 && myId.startsWith(peerIdStr)) return;
    if (consumersRef.current.has(producerId)) return;
    const device = sfuDeviceRef.current;
    const recvTransport = recvTransportRef.current;
    if (!device || !recvTransport) {
      pendingProducersRef.current.push({
        producerId,
        peerId: fallbackPeerId,
        appData: targetAppData
      });
      return;
    }
    const requestId = safeUUID();
    safeSfuSend({
      action: "consume",
      requestId,
      data: {
        transportId: recvTransport.id,
        producerId,
        rtpCapabilities: device.rtpCapabilities
      }
    });
    const handler = async (event) => {
      const msg = JSON.parse(event.data);
      if (msg.action !== "consume:response") return;
      if (msg.requestId !== requestId) return;
      sfuWsRef.current?.removeEventListener("message", handler);
      let consumer = null;
      try {
        const {
          consumerId,
          kind,
          rtpParameters,
          appData: serverAppData,
          peerId: serverPeerId
        } = msg.data;
        const peerId = serverPeerId ?? fallbackPeerId;
        const finalAppData = serverAppData ?? targetAppData ?? {};
        consumer = await recvTransport.consume({
          id: consumerId,
          producerId,
          kind,
          rtpParameters,
          appData: { ...finalAppData, peerId }
          //  peerId  -   
        });
        consumersRef.current.set(producerId, consumer);
        const isScreen = consumer.appData?.type === "screen";
        let mergedCameraStream = null;
        let screenStream = null;
        if (!isScreen) {
          const prev = peerStreamsRef.current.get(peerId);
          const next = new MediaStream();
          if (prev) {
            prev.getTracks().forEach((t2) => {
              if (t2.readyState !== "ended" && t2.kind !== consumer.track.kind) {
                next.addTrack(t2);
              }
            });
          }
          next.addTrack(consumer.track);
          peerStreamsRef.current.set(peerId, next);
          mergedCameraStream = next;
          console.log(`[consume] Peer ${peerId} - kind: ${kind}, merged stream:`, {
            videoTracks: next.getVideoTracks().length,
            audioTracks: next.getAudioTracks().length,
            audioTrackIds: next.getAudioTracks().map((t2) => t2.id),
            audioTrackStates: next.getAudioTracks().map((t2) => t2.readyState)
          });
        } else {
          screenStream = new MediaStream([consumer.track]);
        }
        const isVideoConsumer = kind === "video" && !isScreen;
        const rememberedMediaState = getRememberedParticipantMediaState(peerId);
        setParticipants((prev) => {
          const idx = prev.findIndex((p3) => String(p3.id) === String(peerId) || String(p3.userId) === String(peerId));
          const isMe = String(peerId) === String(userIdRef.current);
          if (idx === -1 && isMe) return prev;
          if (idx === -1) {
            const displayName = peerIdToNameRef.current.get(String(peerId)) || `User-${String(peerId).slice(0, 4)}`;
            return [
              ...prev,
              {
                id: peerId,
                userId: peerId,
                name: displayName,
                isMe: false,
                //   consumer  cameraOff: false
                //    cameraOff: true 
                muted: typeof rememberedMediaState?.muted === "boolean" ? rememberedMediaState.muted : false,
                cameraOff: isVideoConsumer ? false : typeof rememberedMediaState?.cameraOff === "boolean" ? rememberedMediaState.cameraOff : true,
                speaking: false,
                stream: isScreen ? null : mergedCameraStream,
                screenStream: isScreen ? screenStream : null,
                isScreenSharing: isScreen ? true : false,
                isJoining: false,
                isReconnecting: false,
                isLoading: false,
                lastUpdate: Date.now()
              }
            ];
          }
          const next = [...prev];
          const p2 = next[idx];
          const cameraStream = isScreen ? p2.stream : mergedCameraStream;
          next[idx] = {
            ...p2,
            //  screen stream  , camera  stream 
            stream: isScreen ? p2.stream : cameraStream,
            //  screen screenStream (  ),  
            screenStream: isScreen ? screenStream : p2.screenStream,
            //  screen  true  (   false)
            isScreenSharing: isScreen ? true : p2.isScreenSharing,
            //   consumer  cameraOff: false 
            //  consumer    
            cameraOff: isVideoConsumer ? false : p2.cameraOff,
            isLoading: false,
            isJoining: false,
            isReconnecting: false,
            lastUpdate: Date.now()
          };
          return next;
        });
        if (isVideoConsumer) {
          rememberParticipantMediaState(peerId, { cameraOff: false });
        }
        bumpStreamVersion();
        if (kind === "audio") {
          const audio = new Audio();
          audio.srcObject = new MediaStream([consumer.track]);
          audio.autoplay = true;
          audio.playsInline = true;
          audioElsRef.current.set(producerId, audio);
          audio.play().catch(() => {
          });
        }
        safeSfuSend({
          action: "resumeConsumer",
          requestId: safeUUID(),
          data: { consumerId }
        });
        if (kind === "audio") {
          const audio = audioElsRef.current.get(producerId);
          if (audio) {
            setTimeout(() => audio.play().catch(() => {
            }), 150);
            setTimeout(() => audio.play().catch(() => {
            }), 500);
          }
        }
        const cleanupThisConsumer = () => {
          const c2 = consumersRef.current.get(producerId);
          if (c2) {
            try {
              c2.close();
            } catch {
            }
          }
          consumersRef.current.delete(producerId);
          const a2 = audioElsRef.current.get(producerId);
          if (a2) {
            try {
              a2.srcObject = null;
            } catch {
            }
            audioElsRef.current.delete(producerId);
          }
          setParticipants(
            (prev) => prev.map((p2) => {
              if (String(p2.id) !== String(peerId)) return p2;
              const isScreen2 = finalAppData?.type === "screen";
              if (isScreen2) {
                return {
                  ...p2,
                  screenStream: null,
                  isScreenSharing: false,
                  lastUpdate: Date.now()
                };
              }
              const endedKind = consumer?.track?.kind;
              if (endedKind === "video") {
                return { ...p2, lastUpdate: Date.now() };
              }
              const cur = peerStreamsRef.current.get(peerId) || p2.stream;
              if (!cur) {
                return { ...p2, lastUpdate: Date.now() };
              }
              const aliveTracks = cur.getTracks().filter((t2) => t2.readyState !== "ended" && t2.id !== consumer?.track?.id);
              const rebuilt = aliveTracks.length ? new MediaStream(aliveTracks) : cur;
              try {
                peerStreamsRef.current.set(peerId, rebuilt);
              } catch {
              }
              return { ...p2, stream: rebuilt, lastUpdate: Date.now() };
            })
          );
          bumpStreamVersion();
        };
        consumer.track.onended = cleanupThisConsumer;
        consumer.on?.("producerclose", cleanupThisConsumer);
      } catch (e2) {
        console.error("[consume] Failed to consume remote stream", {
          producerId,
          peerId: fallbackPeerId,
          error: e2?.message || String(e2),
          hint: "ICE/DTLS \uC5F0\uACB0 \uC2E4\uD328\uC77C \uC218 \uC788\uC74C. SFU announcedIp \uBC0F UDP 40000-49999 \uD3EC\uD2B8 \uD655\uC778."
        });
        try {
          if (consumer) consumer.close();
        } catch {
        }
        consumersRef.current.delete(producerId);
      }
    };
    sfuWsRef.current.addEventListener("message", handler);
  };
  const hasCameraConsumer = (peerId) => {
    for (const c2 of consumersRef.current.values()) {
      if (c2.appData?.type === "camera" && String(c2.appData?.peerId) === String(peerId)) {
        return true;
      }
    }
    return false;
  };
  const hasLiveRemoteVideo = (stream) => {
    if (!stream) return false;
    return stream.getVideoTracks().some((t2) => t2.readyState === "live");
  };
  const toggleMic = async () => {
    if (mutedByHostMe) return;
    const newVal = !micOn;
    setMicOn(newVal);
    localStorage.setItem("micOn", String(newVal));
    console.log(`[toggleMic] newVal=${newVal}, micOn=${micOn}`);
    const audioProducer = producersRef.current.get("audio");
    const at2 = localStreamRef.current?.getAudioTracks()[0];
    if (!audioProducer) {
      console.error(`[toggleMic] No audio producer! This should not happen.`);
    } else {
      if (audioProducer.track) {
        audioProducer.track.enabled = newVal;
      }
    }
    if (at2) {
      at2.enabled = newVal;
    }
    setParticipants(
      (prev) => prev.map((p2) => p2.isMe ? { ...p2, muted: !newVal } : p2)
    );
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(
        JSON.stringify({
          type: "USER_STATE_CHANGE",
          userId,
          changes: { muted: !newVal }
        })
      );
    }
  };
  const handlePeerCameraOff = (peerId) => {
    const key = `${peerId}:camera`;
    const consumer = consumersRef.current.get(key);
    if (consumer) {
      consumer.close();
      consumersRef.current.delete(key);
    }
    const prevStream = peerStreamsRef.current.get(peerId);
    if (prevStream) peerStreamsRef.current.delete(peerId);
    setParticipants(
      (prev) => prev.map(
        (p2) => p2.id === peerId ? {
          ...p2,
          cameraOff: true,
          stream: null
        } : p2
      )
    );
  };
  const removeVideoConsumer = (peerId) => {
    for (const [producerId, c2] of consumersRef.current.entries()) {
      if (c2.appData?.type === "camera" && String(c2.appData?.peerId) === String(peerId)) {
        try {
          c2.close();
        } catch {
        }
        consumersRef.current.delete(producerId);
      }
    }
    peerStreamsRef.current.delete(peerId);
    setParticipants(
      (prev) => prev.map(
        (p2) => String(p2.id) === String(peerId) ? { ...p2, stream: null, cameraOff: true } : p2
      )
    );
  };
  const removeAudioConsumer = (peerId) => {
    for (const [producerId, c2] of consumersRef.current.entries()) {
      if (c2.appData?.type === "audio" && String(c2.appData?.peerId) === String(peerId)) {
        try {
          c2.close();
        } catch {
        }
        consumersRef.current.delete(producerId);
      }
    }
  };
  const canReopenPip = () => {
    const video = mainVideoRef.current;
    if (!video) return false;
    const stream = video.srcObject;
    const track = stream?.getVideoTracks?.()[0];
    return !!track && track.readyState === "live";
  };
  (0, import_react6.useEffect)(() => {
    const init = async () => {
      const savedEmoji = faceEmojiRef.current;
      const savedBgRemove = bgRemoveRef.current;
      const needFilters = !!(savedEmoji || savedBgRemove);
      if (needFilters && camOnRef.current) {
        if (camOnRef.current) {
          console.log("[Init] Filter settings detected and camera is ON, starting canvas pipeline directly");
          try {
            await turnOnCamera();
          } catch (e2) {
            console.warn("[Init] turnOnCamera failed, fallback to startLocalMedia:", e2);
            await startLocalMedia();
          }
        } else {
          console.log("[Init] Filter settings detected but camera is OFF, starting local media without camera");
          await startLocalMedia();
        }
      } else {
        console.log("[Init] Starting local media");
        await startLocalMedia();
      }
    };
    init();
  }, []);
  (0, import_react6.useEffect)(() => {
    return () => {
      const isInPipMode = !!document.pictureInPictureElement || sessionStorage.getItem("pip.roomId");
      if (isInPipMode) {
        console.log("[MeetingPage] PIP \uBAA8\uB4DC - cleanup/endMeeting \uBAA8\uB450 \uC2A4\uD0B5");
        return;
      }
      if (isPageUnloadRef.current) {
        console.log("[MeetingPage] page unload - skip explicit leave cleanup");
        return;
      }
      isLeavingRef.current = true;
      try {
        producersRef.current.forEach((p2) => {
          try {
            p2.close();
          } catch {
          }
          if (p2.appData?.type) safeSfuSend({ action: "closeProducer", data: { producerId: p2.id } });
        });
        producersRef.current.clear();
      } catch {
      }
      try {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: "LEAVE" }));
        }
      } catch {
      }
      try {
        safeSfuSend({
          action: "leave",
          requestId: safeUUID(),
          data: { roomId, peerId: userId }
        });
      } catch {
      }
      try {
        sendSfuLeaveBeacon(roomId, userId);
      } catch {
      }
      try {
        wsRef.current?.close();
      } catch {
      }
      closeSfuWsForLeave();
      stopFaceEmojiFilter().catch(() => {
      });
      stopAvatarFilter().catch(() => {
      });
      try {
        turnOffCamera();
      } catch {
      }
      try {
        if (localStreamRef.current) {
          localStreamRef.current.getTracks().forEach((t2) => {
            try {
              t2.stop();
            } catch {
            }
          });
          localStreamRef.current = null;
        }
      } catch {
      }
      try {
        if (screenStreamRef.current) {
          screenStreamRef.current.getTracks().forEach((t2) => {
            try {
              t2.stop();
            } catch {
            }
          });
          screenStreamRef.current = null;
        }
      } catch {
      }
      try {
        const extraTracks = [
          lastCameraTrackRef?.current,
          faceFilterRawTrackRef?.current,
          faceFilterOutTrackRef?.current,
          avatarRawTrackRef?.current,
          avatarOutTrackRef?.current,
          canvasPipelineRawTrackRef?.current,
          canvasPipelineOutTrackRef?.current
        ].filter(Boolean);
        extraTracks.forEach((t2) => {
          try {
            if (t2.readyState === "live") t2.stop();
          } catch {
          }
        });
      } catch {
      }
      try {
        lastCameraTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterRawTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterOutTrackRef.current = null;
      } catch {
      }
      try {
        avatarRawTrackRef.current = null;
      } catch {
      }
      try {
        avatarOutTrackRef.current = null;
      } catch {
      }
      try {
        canvasPipelineOutTrackRef.current = null;
      } catch {
      }
      try {
        document.querySelectorAll("video").forEach((v2) => {
          try {
            if (v2?.srcObject) v2.srcObject = null;
          } catch {
          }
        });
        document.querySelectorAll("audio").forEach((a2) => {
          try {
            if (a2?.srcObject) a2.srcObject = null;
          } catch {
          }
        });
      } catch {
      }
      try {
        audioElsRef.current.forEach((a2) => {
          try {
            a2.pause();
          } catch {
          }
          try {
            a2.srcObject = null;
          } catch {
          }
        });
        audioElsRef.current.clear();
      } catch {
      }
      closeSharedAudioContext();
      endMeeting();
    };
  }, [endMeeting, stopFaceEmojiFilter, stopAvatarFilter, roomId, userId, closeSfuWsForLeave]);
  (0, import_react6.useEffect)(() => {
    const handler = () => {
      const video = document.querySelector('video[data-main-video="main"]');
      if (video) {
        requestBrowserPip(video).catch(() => {
        });
      }
    };
    window.addEventListener("meeting:request-pip", handler);
    return () => window.removeEventListener("meeting:request-pip", handler);
  }, [requestBrowserPip]);
  (0, import_react6.useEffect)(() => {
    let lastPip = false;
    const interval = setInterval(() => {
      const nowPip = !!document.pictureInPictureElement;
      if (lastPip && !nowPip) {
        window.dispatchEvent(
          new CustomEvent("pip:exited")
        );
      }
      lastPip = nowPip;
    }, 300);
    return () => clearInterval(interval);
  }, []);
  (0, import_react6.useEffect)(() => {
    if (!roomReconnecting) {
      roomSyncRequestedRef.current = false;
      return;
    }
    const sfuWs = sfuWsRef.current;
    if (!sfuWs || sfuWs.readyState !== WebSocket.OPEN) {
      console.log("[room:sync] WebSocket not ready");
      return;
    }
    if (!recvTransportRef.current || !sfuDeviceRef.current) {
      console.log("[room:sync] recvTransport not ready, will retry when ready");
      return;
    }
    if (roomSyncRequestedRef.current) {
      console.log("[room:sync] Request already sent, skipping");
      return;
    }
    if (!roomSyncHandlerRef.current) {
      roomSyncHandlerRef.current = async (event) => {
        const msg = JSON.parse(event.data);
        if (msg.action !== "room:sync:response") return;
        console.log("[room:sync] Received room:sync:response", msg.data);
        const { peers, existingProducers } = msg.data || {};
        if (!Array.isArray(peers)) {
          console.warn("[room:sync] Invalid peers in response, but continuing");
        }
        if (Array.isArray(peers) && peers.length > 0) {
          peers.forEach((peer) => {
            const hasMicOn = typeof peer.micOn === "boolean";
            const hasCameraOn = typeof peer.cameraOn === "boolean";
            const hasMuted = typeof peer.muted === "boolean";
            const hasCameraOff = typeof peer.cameraOff === "boolean";
            const mutedFromPeer = hasMicOn ? !peer.micOn : hasMuted ? peer.muted : void 0;
            const cameraOffFromPeer = hasCameraOn ? !peer.cameraOn : hasCameraOff ? peer.cameraOff : void 0;
            const remembered = getRememberedParticipantMediaState(peer.peerId);
            const mergedMutedFromPeer = typeof mutedFromPeer === "boolean" ? resolveRemoteMutedState(mutedFromPeer, void 0, remembered?.muted) : void 0;
            if (typeof mergedMutedFromPeer === "boolean" || typeof cameraOffFromPeer === "boolean") {
              rememberParticipantMediaState(peer.peerId, {
                ...typeof mergedMutedFromPeer === "boolean" ? { muted: mergedMutedFromPeer } : {},
                ...typeof cameraOffFromPeer === "boolean" ? { cameraOff: cameraOffFromPeer } : {}
              });
            }
            setParticipants(
              (prev) => prev.map(
                (p2) => String(p2.id) === String(peer.peerId) ? {
                  ...p2,
                  ...typeof mergedMutedFromPeer === "boolean" ? {
                    muted: resolveRemoteMutedState(
                      mergedMutedFromPeer,
                      p2.muted,
                      remembered?.muted
                    )
                  } : {},
                  ...typeof cameraOffFromPeer === "boolean" ? { cameraOff: cameraOffFromPeer } : {},
                  isReconnecting: false,
                  isLoading: false
                } : p2
              )
            );
            const cameraIsOff = hasCameraOn && peer.cameraOn === false || hasCameraOff && peer.cameraOff === true;
            if (cameraIsOff) {
              removeVideoConsumer(peer.peerId);
            }
            const micIsOff = hasMicOn && peer.micOn === false || hasMuted && peer.muted === true;
            if (micIsOff) {
              removeAudioConsumer(peer.peerId);
            }
          });
        }
        if (existingProducers && Array.isArray(existingProducers)) {
          console.log(`[room:sync] Re-consuming ${existingProducers.length} producers`);
          for (const producer of existingProducers) {
            if (consumersRef.current.has(producer.producerId)) {
              console.log(`[room:sync] Producer ${producer.producerId} already consumed, skipping`);
              continue;
            }
            try {
              await consumeProducer(producer.producerId, producer.peerId, producer.appData || {});
            } catch (error2) {
              console.error(`[room:sync] Failed to consume producer ${producer.producerId}:`, error2);
            }
          }
        }
        hasFinishedInitialSyncRef.current = true;
        setRoomReconnecting(false);
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: "USER_RECONNECTING",
            userId,
            reconnecting: false
          }));
          console.log("[MeetingPage] \uC7AC\uC811\uC18D \uC644\uB8CC \uC54C\uB9BC \uC804\uC1A1");
        }
        setParticipants((prev) => prev.map((p2) => ({
          ...p2,
          isReconnecting: false,
          isLoading: false,
          reconnectStartedAt: void 0
        })));
        bumpStreamVersion();
        roomSyncRequestedRef.current = false;
        console.log("[room:sync] Room sync completed, roomReconnecting set to false");
        const currentSfuWs = sfuWsRef.current;
        if (currentSfuWs && roomSyncHandlerRef.current) {
          currentSfuWs.removeEventListener("message", roomSyncHandlerRef.current);
        }
        roomSyncHandlerRef.current = null;
      };
      sfuWs.addEventListener("message", roomSyncHandlerRef.current);
    }
    console.log("[room:sync] Sending room:sync request");
    roomSyncRequestedRef.current = true;
    if (sfuWs && sfuWs.readyState === WebSocket.OPEN) {
      sfuWs.send(JSON.stringify({
        action: "room:sync",
        requestId: safeUUID()
      }));
    } else {
      console.warn("[room:sync] SFU WebSocket not ready, skipping send");
    }
    const timeoutId = setTimeout(() => {
      if (roomSyncRequestedRef.current && roomReconnecting) {
        console.warn("[room:sync] Timeout waiting for response, will retry");
        roomSyncRequestedRef.current = false;
        setRecvTransportReady((prev) => !prev);
      }
    }, 1e4);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [roomReconnecting, recvTransportReady, rememberParticipantMediaState]);
  const prevScreenSharersRef = (0, import_react6.useRef)(/* @__PURE__ */ new Set());
  (0, import_react6.useEffect)(() => {
    const screenSharers = participants.filter((p2) => p2.isScreenSharing);
    const screenSharerIds = new Set(screenSharers.map((p2) => p2.id));
    const hasScreenSharer = screenSharers.length > 0;
    const wasScreenSharing = prevScreenSharersRef.current.has(activeSpeakerId);
    const isNowScreenSharing = screenSharerIds.has(activeSpeakerId);
    const selectedPersonStoppedSharing = wasScreenSharing && !isNowScreenSharing;
    if (hasScreenSharer) {
      if (!manuallySelectedRef.current) {
        const firstScreenSharer = screenSharers[0];
        if (!isNowScreenSharing) {
          if (!lastActiveSpeakerRef.current) {
            lastActiveSpeakerRef.current = activeSpeakerId;
          }
          setActiveSpeakerId(firstScreenSharer.id);
          setLayoutMode("speaker");
        }
      } else if (selectedPersonStoppedSharing) {
        const firstScreenSharer = screenSharers[0];
        setActiveSpeakerId(firstScreenSharer.id);
      }
    } else {
      manuallySelectedRef.current = false;
      lastActiveSpeakerRef.current = null;
    }
    prevScreenSharersRef.current = screenSharerIds;
  }, [participants, activeSpeakerId]);
  (0, import_react6.useEffect)(() => {
    const el = document.querySelector(".bottom-strip");
    if (el) {
      el.style.display = "none";
      el.offsetHeight;
      el.style.display = "";
    }
  }, [participants.some((p2) => p2.isScreenSharing)]);
  const handleStripItemClick = (0, import_react6.useCallback)((e2, participantId) => {
    if (isDraggingRef.current) {
      e2.preventDefault();
      e2.stopPropagation();
      return;
    }
    manuallySelectedRef.current = true;
    setActiveSpeakerId(participantId);
  }, []);
  (0, import_react6.useEffect)(() => {
    return () => {
      joiningTimeoutRef.current.forEach((t2) => clearTimeout(t2));
      joiningTimeoutRef.current.clear();
    };
  }, []);
  (0, import_react6.useEffect)(() => {
    const markPageUnload = () => {
      isPageUnloadRef.current = true;
      isLeavingRef.current = false;
      try {
        wsRef.current?.close();
      } catch {
      }
      closeSfuWsForLeave();
    };
    window.addEventListener("beforeunload", markPageUnload);
    window.addEventListener("pagehide", markPageUnload);
    return () => {
      window.removeEventListener("beforeunload", markPageUnload);
      window.removeEventListener("pagehide", markPageUnload);
    };
  }, [closeSfuWsForLeave]);
  (0, import_react6.useEffect)(() => {
    const handleLeaveAndNavigate = (e2) => {
      const path = (e2?.detail?.path || "/room").trim() || "/room";
      isLeavingRef.current = true;
      try {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({ type: "USER_STATE_CHANGE", userId, changes: { cameraOff: true, muted: true } }));
          wsRef.current.send(JSON.stringify({ type: "LEAVE" }));
        }
      } catch {
      }
      try {
        producersRef.current.forEach((p2) => {
          try {
            p2.close();
          } catch {
          }
          if (p2.appData?.type) safeSfuSend({ action: "closeProducer", data: { producerId: p2.id } });
        });
        producersRef.current.clear();
      } catch {
      }
      try {
        safeSfuSend({ action: "leave", requestId: safeUUID(), data: { roomId, peerId: userId } });
      } catch {
      }
      try {
        sendSfuLeaveBeacon(roomId, userId);
      } catch {
      }
      try {
        wsRef.current?.close();
      } catch {
      }
      closeSfuWsForLeave();
      wsRef.current = null;
      sfuWsRef.current = null;
      try {
        sessionStorage.removeItem("pip.roomId");
      } catch {
      }
      try {
        sessionStorage.removeItem("pip.subjectId");
      } catch {
      }
      try {
        turnOffCamera();
      } catch {
      }
      if (localStreamRef.current) {
        localStreamRef.current.getTracks().forEach((t2) => {
          try {
            t2.stop();
          } catch {
          }
        });
        localStreamRef.current = null;
      }
      if (screenStreamRef.current) {
        screenStreamRef.current.getTracks().forEach((t2) => {
          try {
            t2.stop();
          } catch {
          }
        });
        screenStreamRef.current = null;
      }
      try {
        [
          lastCameraTrackRef?.current,
          faceFilterRawTrackRef?.current,
          faceFilterOutTrackRef?.current,
          avatarRawTrackRef?.current,
          avatarOutTrackRef?.current,
          canvasPipelineRawTrackRef?.current,
          canvasPipelineOutTrackRef?.current
        ].filter(Boolean).forEach((t2) => {
          try {
            if (t2.readyState === "live") t2.stop();
          } catch {
          }
        });
      } catch {
      }
      try {
        lastCameraTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterRawTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterOutTrackRef.current = null;
      } catch {
      }
      try {
        avatarRawTrackRef.current = null;
      } catch {
      }
      try {
        avatarOutTrackRef.current = null;
      } catch {
      }
      try {
        canvasPipelineOutTrackRef.current = null;
      } catch {
      }
      try {
        document.querySelectorAll("video").forEach((v2) => {
          try {
            if (v2?.srcObject) v2.srcObject = null;
          } catch {
          }
        });
        document.querySelectorAll("audio").forEach((a2) => {
          try {
            if (a2?.srcObject) a2.srcObject = null;
          } catch {
          }
        });
      } catch {
      }
      try {
        audioElsRef.current.forEach((a2) => {
          try {
            a2.pause();
          } catch {
          }
          try {
            a2.srcObject = null;
          } catch {
          }
        });
        audioElsRef.current.clear();
      } catch {
      }
      closeSharedAudioContext();
      setLocalStream(null);
      setParticipants([]);
      setMessages([]);
      if (endMeeting) endMeeting();
      navigate(path);
    };
    window.addEventListener("meeting:leave-and-navigate", handleLeaveAndNavigate);
    return () => window.removeEventListener("meeting:leave-and-navigate", handleLeaveAndNavigate);
  }, [roomId, userId, navigate, endMeeting, closeSfuWsForLeave]);
  (0, import_react6.useEffect)(() => {
    const handleLeaveFromPip = () => {
      console.log("[MeetingPage] PIP\uC5D0\uC11C \uB098\uAC00\uAE30 \uC774\uBCA4\uD2B8 \uC218\uC2E0");
      isLeavingRef.current = true;
      try {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: { cameraOff: true, muted: true }
          }));
        }
      } catch {
      }
      try {
        producersRef.current.forEach((p2) => {
          try {
            p2.close();
          } catch {
          }
          if (p2.appData?.type) {
            safeSfuSend({ action: "closeProducer", data: { producerId: p2.id } });
          }
        });
        producersRef.current.clear();
      } catch {
      }
      try {
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          const leaveMsg = JSON.stringify({ type: "LEAVE" });
          wsRef.current.send(leaveMsg);
          setTimeout(() => {
            if (wsRef.current?.readyState === WebSocket.OPEN) {
              wsRef.current.send(leaveMsg);
            }
          }, 50);
        }
      } catch {
      }
      try {
        safeSfuSend({
          action: "leave",
          requestId: safeUUID(),
          data: { roomId, peerId: userId }
        });
      } catch {
      }
      try {
        sendSfuLeaveBeacon(roomId, userId);
      } catch {
      }
      try {
        sessionStorage.removeItem("pip.roomId");
      } catch {
      }
      try {
        sessionStorage.removeItem("pip.subjectId");
      } catch {
      }
      try {
        turnOffCamera();
      } catch {
      }
      try {
        [
          lastCameraTrackRef?.current,
          faceFilterRawTrackRef?.current,
          faceFilterOutTrackRef?.current,
          avatarRawTrackRef?.current,
          avatarOutTrackRef?.current,
          canvasPipelineRawTrackRef?.current,
          canvasPipelineOutTrackRef?.current
        ].filter(Boolean).forEach((t2) => {
          try {
            if (t2.readyState === "live") t2.stop();
          } catch {
          }
        });
      } catch {
      }
      try {
        lastCameraTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterRawTrackRef.current = null;
      } catch {
      }
      try {
        faceFilterOutTrackRef.current = null;
      } catch {
      }
      try {
        avatarRawTrackRef.current = null;
      } catch {
      }
      try {
        avatarOutTrackRef.current = null;
      } catch {
      }
      try {
        canvasPipelineOutTrackRef.current = null;
      } catch {
      }
      setTimeout(() => {
        try {
          if (localStreamRef.current) {
            localStreamRef.current.getTracks().forEach((t2) => {
              try {
                t2.stop();
              } catch {
              }
            });
            localStreamRef.current = null;
          }
          if (screenStreamRef.current) {
            screenStreamRef.current.getTracks().forEach((t2) => {
              try {
                t2.stop();
              } catch {
              }
            });
            screenStreamRef.current = null;
          }
          setLocalStream(null);
          try {
            document.querySelectorAll("video").forEach((v2) => {
              try {
                if (v2?.srcObject) v2.srcObject = null;
              } catch {
              }
            });
            document.querySelectorAll("audio").forEach((a2) => {
              try {
                if (a2?.srcObject) a2.srcObject = null;
              } catch {
              }
            });
          } catch {
          }
          try {
            audioElsRef.current.forEach((a2) => {
              try {
                a2.pause();
              } catch {
              }
              try {
                a2.srcObject = null;
              } catch {
              }
            });
            audioElsRef.current.clear();
          } catch {
          }
          closeSharedAudioContext();
          try {
            wsRef.current?.close();
          } catch {
          }
          wsRef.current = null;
          closeSfuWsForLeave();
          sfuWsRef.current = null;
          try {
            sendTransportRef.current?.close();
          } catch {
          }
          sendTransportRef.current = null;
          try {
            recvTransportRef.current?.close();
          } catch {
          }
          recvTransportRef.current = null;
          try {
            sfuDeviceRef.current?.close?.();
          } catch {
          }
          sfuDeviceRef.current = null;
          setParticipants([]);
          setMessages([]);
        } catch (e2) {
          console.warn("[MeetingPage] PIP \uB098\uAC00\uAE30 \uC815\uB9AC \uC911 \uC624\uB958:", e2);
        }
      }, 300);
    };
    window.addEventListener("meeting:leave-from-pip", handleLeaveFromPip);
    return () => {
      window.removeEventListener("meeting:leave-from-pip", handleLeaveFromPip);
    };
  }, [roomId, userId, closeSfuWsForLeave]);
  (0, import_react6.useEffect)(() => {
    if (!roomReconnecting) return;
    if (!isLocalLoading && recvTransportRef.current && hasFinishedInitialSyncRef.current) {
      setRoomReconnecting(false);
    }
  }, [isLocalLoading, streamVersion, roomReconnecting]);
  (0, import_react6.useEffect)(() => {
    const interval = setInterval(() => {
      setParticipants(
        (prev) => prev.map((p2) => {
          if (!p2.isReconnecting) return p2;
          const peerId = String(p2.id);
          if (p2.isMe) {
            return {
              ...p2,
              isReconnecting: false,
              isLoading: false,
              reconnectStartedAt: void 0
            };
          }
          const elapsed = Date.now() - (p2.reconnectStartedAt ?? 0);
          if (elapsed < 800) return p2;
          const hasLiveStream = p2.stream && p2.stream.getVideoTracks().some((t2) => t2.readyState === "live");
          if (hasLiveStream) {
            if (reconnectHistoryRef.current.has(peerId)) {
              console.log(`\u2705 [RECONNECT COMPLETED] ${p2.name} (${peerId}) - live stream detected`);
              reconnectHistoryRef.current.delete(peerId);
              reconnectCompletedTimeRef.current.set(peerId, Date.now());
            }
            return {
              ...p2,
              isReconnecting: false,
              isLoading: false,
              reconnectStartedAt: void 0
            };
          }
          if (reconnectHistoryRef.current.has(peerId)) {
            console.log(`\u2705 [RECONNECT COMPLETED] ${p2.name} (${peerId}) - elapsed=${elapsed}ms`);
            reconnectHistoryRef.current.delete(peerId);
            reconnectCompletedTimeRef.current.set(peerId, Date.now());
          }
          if (p2.stream || p2.cameraOff) {
            if (reconnectHistoryRef.current.has(peerId)) {
              reconnectHistoryRef.current.delete(peerId);
              reconnectCompletedTimeRef.current.set(peerId, Date.now());
            }
            return {
              ...p2,
              isReconnecting: false,
              isLoading: false,
              reconnectStartedAt: void 0
            };
          }
          if (elapsed > 5e3) {
            console.log(`\u26A0\uFE0F [RECONNECT TIMEOUT] ${p2.name} (${peerId}) - auto-clearing after ${elapsed}ms`);
            if (reconnectHistoryRef.current.has(peerId)) {
              reconnectHistoryRef.current.delete(peerId);
            }
            return {
              ...p2,
              isReconnecting: false,
              isLoading: false,
              reconnectStartedAt: void 0
            };
          }
          return p2;
        })
      );
    }, 100);
    return () => clearInterval(interval);
  }, []);
  (0, import_react6.useEffect)(() => {
    if (isGridFullscreen && gridFullscreenStageRef.current) {
      gridFullscreenStageRef.current.requestFullscreen().catch((err) => {
        console.error("\uC804\uCCB4\uD654\uBA74 \uC804\uD658 \uC2E4\uD328:", err);
      });
    }
  }, [isGridFullscreen]);
  (0, import_react6.useEffect)(() => {
    if (!localStreamRef.current) return;
    const vt2 = localStreamRef.current.getVideoTracks()[0];
    if (vt2) vt2.enabled = camOn;
    const at2 = localStreamRef.current.getAudioTracks()[0];
    if (at2) at2.enabled = micOn;
  }, [camOn, micOn]);
  (0, import_react6.useEffect)(() => {
    if (!localStream) return;
    ensureLocalProducers();
    const t1 = setTimeout(() => ensureLocalProducers(), 200);
    const t2 = setTimeout(() => ensureLocalProducers(), 600);
    const audioTrack = localStream.getAudioTracks()[0];
    if (!audioTrack) {
      return () => {
        clearTimeout(t1);
        clearTimeout(t2);
      };
    }
    const ctx = getSharedAudioContext();
    if (!ctx) return;
    const source = ctx.createMediaStreamSource(localStream);
    const analyser = ctx.createAnalyser();
    analyser.fftSize = 512;
    source.connect(analyser);
    const data2 = new Uint8Array(analyser.frequencyBinCount);
    let speaking = false;
    let rafId = null;
    const checkVolume = () => {
      if (ctx.state === "suspended") ctx.resume().catch(() => {
      });
      analyser.getByteFrequencyData(data2);
      const avg = data2.reduce((sum, v2) => sum + v2, 0) / data2.length;
      if (avg > 20) {
        if (!speaking) {
          speaking = true;
          setIsSpeaking(true);
        }
      } else {
        if (speaking) {
          speaking = false;
          setIsSpeaking(false);
        }
      }
      rafId = requestAnimationFrame(checkVolume);
    };
    checkVolume();
    return () => {
      clearTimeout(t1);
      clearTimeout(t2);
      if (rafId != null) cancelAnimationFrame(rafId);
      try {
        source.disconnect();
        analyser.disconnect();
      } catch {
      }
    };
  }, [localStream]);
  (0, import_react6.useEffect)(() => {
    if (!localStream) return;
    const vt2 = localStream.getVideoTracks()[0];
    if (vt2) {
      if (vt2.enabled !== camOn) vt2.enabled = camOn;
    }
    const at2 = localStream.getAudioTracks()[0];
    if (at2) {
      if (at2.enabled !== micOn) at2.enabled = micOn;
    }
  }, [camOn, micOn, localStream]);
  (0, import_react6.useEffect)(() => {
    if (!localStream) return;
    setParticipants(
      (prev) => prev.map(
        (p2) => p2.isMe ? { ...p2, stream: localStream, isLoading: false, isJoining: false } : p2
      )
    );
  }, [localStream]);
  (0, import_react6.useEffect)(() => {
    if (!roomId || !userEmail) {
      console.log("[WS] \uB300\uAE30 \uC911 - roomId:", roomId, "userEmail:", userEmail);
      return;
    }
    let ws2 = null;
    let pingInterval = null;
    const connect = () => {
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
      const wsRoomId = roomId;
      const base = toWsBackendUrl(`/ws/room/${wsRoomId}`, 8080);
      const initialFaceEmoji = faceEmojiRef.current || localStorage.getItem("faceEmoji") || "";
      const initialBgRemove = bgRemoveRef.current ?? localStorage.getItem("faceBgRemove") === "true";
      const { muted: initialMutedState, cameraOff: initialCameraOffState } = computeOutboundMediaState();
      const wsUrl = `${base}?userId=${encodeURIComponent(userId)}&userName=${encodeURIComponent(userName)}&userEmail=${encodeURIComponent(userEmail || "")}&muted=${initialMutedState}&cameraOff=${initialCameraOffState}&isHost=${isHostLocal}&title=${encodeURIComponent(roomTitle || "")}` + (subjectId ? `&subjectId=${encodeURIComponent(subjectId)}` : "") + (scheduleId != null && scheduleId !== "" ? `&scheduleId=${encodeURIComponent(String(scheduleId))}` : "") + (initialFaceEmoji ? `&faceEmoji=${encodeURIComponent(initialFaceEmoji)}` : "") + `&bgRemove=${!!initialBgRemove}`;
      if (!subjectId && roomId) {
        console.warn("[MeetingPage] WebSocket \uC5F0\uACB0 \uC2DC subjectId \uC5C6\uC74C \u2192 DB \uC800\uC7A5 \uC2DC subject_id \uBE44\uC5B4\uAC08 \uC218 \uC788\uC74C. roomId=", roomId);
      }
      ws2 = new WebSocket(wsUrl);
      wsRef.current = ws2;
      ws2.onopen = () => {
        console.log("\u2705 SPRING WS CONNECTED");
        setChatConnected(true);
        const sendInitialState = () => {
          if (!ws2 || ws2.readyState !== WebSocket.OPEN) return;
          const { muted, cameraOff } = computeOutboundMediaState();
          const faceEmojiState = faceEmojiRef.current || "";
          const bgRemoveState = !!bgRemoveRef.current;
          ws2.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: { muted, cameraOff, faceEmoji: faceEmojiState || null, bgRemove: bgRemoveState }
          }));
        };
        setTimeout(sendInitialState, 300);
        pingInterval = setInterval(() => {
          if (ws2.readyState === WebSocket.OPEN) {
            ws2.send(JSON.stringify({ type: "PING" }));
          }
        }, 3e4);
      };
      ws2.onclose = () => {
        console.log("\u274C WS CLOSED");
        setChatConnected(false);
        if (pingInterval) clearInterval(pingInterval);
      };
      ws2.onerror = (error2) => {
        console.error("\u274C WS ERROR", error2);
        setChatConnected(false);
      };
      ws2.onmessage = (event) => {
        const data2 = JSON.parse(event.data);
        if (data2.type === "PONG") return;
        if (data2.type === "REJECTED" && data2.reason === "KICKED_TODAY") {
          setToastMessage("\uC624\uB298 \uC774 \uBC29\uC5D0\uC11C \uB0B4\uBCF4\uB0B4\uAE30\uB418\uC5B4 \uC785\uC7A5\uD560 \uC218 \uC5C6\uC2B5\uB2C8\uB2E4.");
          setShowToast(true);
          isLeavingRef.current = true;
          try {
            wsRef.current?.close();
          } catch {
          }
          setTimeout(() => navigate(`/lms/${subjectId}`), 1500);
          return;
        }
        if (data2.type === "REACTION") {
          const { userId: fromUserId, emoji } = data2;
          setParticipants(
            (prev) => prev.map(
              (p2) => String(p2.id) === String(fromUserId) ? { ...p2, reaction: emoji } : p2
            )
          );
          const oldTimer = reactionTimersRef.current[fromUserId];
          if (oldTimer) {
            clearTimeout(oldTimer);
          }
          const timerId = setTimeout(() => {
            setParticipants(
              (prev) => prev.map(
                (p2) => String(p2.id) === String(fromUserId) ? { ...p2, reaction: null } : p2
              )
            );
            delete reactionTimersRef.current[fromUserId];
          }, 2500);
          reactionTimersRef.current[fromUserId] = timerId;
          return;
        }
        if (data2.type === "ROOM_ELAPSED" && data2.elapsedMs != null) {
          const totalSec = Math.max(0, Math.floor(Number(data2.elapsedMs) / 1e3));
          const h2 = Math.floor(totalSec / 3600);
          const m2 = Math.floor(totalSec % 3600 / 60);
          const s2 = totalSec % 60;
          setElapsedTimeDisplay([h2, m2, s2].map((n2) => String(n2).padStart(2, "0")).join(":"));
          return;
        }
        if (data2.type === "USERS_UPDATE" && Array.isArray(data2.users)) {
          data2.users.forEach((u2) => {
            const name = u2.userName || "";
            peerIdToNameRef.current.set(String(u2.userId), name);
            if (u2.connectionId != null) peerIdToNameRef.current.set(String(u2.connectionId), name);
            const mediaEmailKey = getParticipantMediaEmailKey(u2.userEmail || u2.email || "");
            if (u2.muted === true || typeof u2.cameraOff === "boolean") {
              const knownState = {
                ...u2.muted === true ? { muted: true } : {},
                ...typeof u2.cameraOff === "boolean" ? { cameraOff: u2.cameraOff } : {}
              };
              rememberParticipantMediaStateByKeys(
                [String(u2.userId), u2.connectionId != null ? String(u2.connectionId) : "", mediaEmailKey],
                knownState
              );
            }
          });
          if (data2.roomStartedAt != null) setRoomStartedAt(Number(data2.roomStartedAt));
          if (data2.roomElapsedMs != null) {
            const totalSec = Math.max(0, Math.floor(Number(data2.roomElapsedMs) / 1e3));
            const h2 = Math.floor(totalSec / 3600);
            const m2 = Math.floor(totalSec % 3600 / 60);
            const s2 = totalSec % 60;
            setElapsedTimeDisplay([h2, m2, s2].map((n2) => String(n2).padStart(2, "0")).join(":"));
          }
          setParticipants((prev) => {
            const selfState = computeOutboundMediaState();
            const prevMap = new Map(prev.map((p2) => [String(p2.id), p2]));
            const newServerIds = new Set(data2.users.map((u2) => {
              const cid = u2.connectionId != null ? String(u2.connectionId) : null;
              return cid || String(u2.userId);
            }));
            const now = Date.now();
            const updatedUsers = data2.users.map((u2) => {
              const participantId = u2.connectionId != null ? String(u2.connectionId) : String(u2.userId);
              const peerId = String(u2.userId);
              const mediaEmailKey = getParticipantMediaEmailKey(u2.userEmail || u2.email || "");
              const old = prevMap.get(participantId) || prevMap.get(peerId);
              const rememberedMediaState = getRememberedParticipantMediaState(peerId) || (u2.connectionId != null ? getRememberedParticipantMediaState(String(u2.connectionId)) : null) || getRememberedParticipantMediaState(mediaEmailKey);
              missingSinceRef.current.delete(peerId);
              if (!old && reconnectHistoryRef.current.has(peerId)) {
                reconnectHistoryRef.current.delete(peerId);
              }
              if (reconnectTimeoutRef.current.has(peerId)) {
                clearTimeout(reconnectTimeoutRef.current.get(peerId));
                reconnectTimeoutRef.current.delete(peerId);
              }
              const isMe = peerId === String(userId);
              const isOfflineFromServer = u2.online === false;
              const refStream = peerStreamsRef.current.get(peerId);
              const currentStream = refStream || old?.stream || null;
              if (!isMe && currentStream && !isOfflineFromServer) {
                const hasLiveStream2 = currentStream.getVideoTracks().some((t2) => t2.readyState === "live");
                if (hasLiveStream2) {
                  const resolvedMuted = typeof u2.muted === "boolean" ? resolveRemoteMutedState(u2.muted, old?.muted, rememberedMediaState?.muted) : resolveRemoteMutedState(void 0, old?.muted, rememberedMediaState?.muted);
                  const resolvedCameraOff = typeof u2.cameraOff === "boolean" ? u2.cameraOff : typeof old?.cameraOff === "boolean" ? old.cameraOff : typeof rememberedMediaState?.cameraOff === "boolean" ? rememberedMediaState.cameraOff : true;
                  return {
                    ...old,
                    id: participantId,
                    userId: peerId,
                    name: u2.userName,
                    joinAt: u2.joinAt,
                    isMe: false,
                    muted: resolvedMuted,
                    cameraOff: resolvedCameraOff,
                    mutedByHost: !!u2.mutedByHost || !!old?.mutedByHost,
                    cameraOffByHost: !!u2.cameraOffByHost || !!old?.cameraOffByHost,
                    faceEmoji: u2.faceEmoji != null ? u2.faceEmoji : old?.faceEmoji ?? null,
                    bgRemove: typeof u2.bgRemove === "boolean" ? u2.bgRemove : old?.bgRemove ?? false,
                    stream: currentStream,
                    screenStream: old?.screenStream ?? null,
                    isScreenSharing: old?.isScreenSharing ?? false,
                    reaction: old?.reaction ?? null,
                    speaking: typeof u2.speaking === "boolean" ? u2.speaking : old?.speaking ?? false,
                    isReconnecting: false,
                    isLoading: false,
                    isJoining: false,
                    lastUpdate: Date.now(),
                    reconnectStartedAt: void 0
                  };
                }
              }
              const isOnline = u2.online === true;
              if (isOnline) everOnlineRef.current.add(peerId);
              const isOffline = u2.online === false && everOnlineRef.current.has(peerId);
              const completedTime = reconnectCompletedTimeRef.current.get(peerId);
              const now2 = Date.now();
              const recentlyCompleted = completedTime && now2 - completedTime < 1e3;
              if (!isMe) {
                if (isOffline && !recentlyCompleted) {
                  if (!reconnectHistoryRef.current.has(peerId)) {
                    reconnectHistoryRef.current.add(peerId);
                    console.log(`\u2795 [ADD RECONNECT] ${u2.userName} (${peerId})`);
                  }
                } else if (isOnline && reconnectHistoryRef.current.has(peerId)) {
                  reconnectHistoryRef.current.delete(peerId);
                }
              }
              const hasLiveStream = currentStream && currentStream.getVideoTracks().some((t2) => t2.readyState === "live");
              const shouldShowReconnecting = !isMe && !!old && !recentlyCompleted && (isOfflineFromServer || isOffline && !hasLiveStream);
              const keepMediaWhileOffline = !!currentStream;
              const shouldKeepStream = keepMediaWhileOffline || hasLiveStream || old?.stream && old.stream.getVideoTracks().some((t2) => t2.readyState === "live");
              const finalStream = hasLiveStream ? currentStream || old?.stream || null : shouldShowReconnecting && !shouldKeepStream ? null : currentStream || old?.stream || null;
              const finalScreenStream = hasLiveStream ? old?.screenStream ?? null : shouldShowReconnecting && !shouldKeepStream ? null : old?.screenStream ?? null;
              const finalIsScreenSharing = hasLiveStream ? old?.isScreenSharing ?? false : shouldShowReconnecting && !shouldKeepStream ? false : old?.isScreenSharing ?? false;
              const myStream = isMe ? localStreamRef.current ?? old?.stream ?? null : finalStream;
              const myScreenStream = isMe ? screenStreamRef.current || null : finalScreenStream;
              const myIsScreenSharing = isMe ? !!screenStreamRef.current : finalIsScreenSharing;
              try {
                const hostEmailLower = (hostUserEmail || "").trim().toLowerCase();
                if (hostEmailLower) {
                  const userEmailFromServer = (u2.userEmail || u2.email || "").trim().toLowerCase();
                  if (userEmailFromServer && userEmailFromServer === hostEmailLower && u2.userId != null) {
                    primaryHostUserIdRef.current = String(u2.userId);
                  }
                }
              } catch {
              }
              const baseUser = {
                id: participantId,
                userId: peerId,
                name: u2.userName,
                email: u2.userEmail || u2.email || "",
                joinAt: u2.joinAt,
                isMe,
                //    (   )
                isHost: typeof u2.host === "boolean" ? u2.host : old?.isHost ?? false,
                //   muted/cameraOff ""    ,
                //         .
                muted: isMe ? selfState.muted : typeof u2.muted === "boolean" ? resolveRemoteMutedState(u2.muted, old?.muted, rememberedMediaState?.muted) : resolveRemoteMutedState(void 0, old?.muted, rememberedMediaState?.muted),
                cameraOff: isMe ? selfState.cameraOff : typeof u2.cameraOff === "boolean" ? u2.cameraOff : typeof old?.cameraOff === "boolean" ? old.cameraOff : typeof rememberedMediaState?.cameraOff === "boolean" ? rememberedMediaState.cameraOff : true,
                mutedByHost: !!u2.mutedByHost || !!old?.mutedByHost,
                cameraOffByHost: !!u2.cameraOffByHost || !!old?.cameraOffByHost,
                faceEmoji: u2.faceEmoji != null ? u2.faceEmoji : old?.faceEmoji ?? null,
                bgRemove: typeof u2.bgRemove === "boolean" ? u2.bgRemove : old?.bgRemove ?? false,
                //  : live stream   null   (  )
                //  isMe      
                stream: myStream,
                screenStream: myScreenStream,
                isScreenSharing: myIsScreenSharing,
                reaction: old?.reaction ?? null,
                //   USERS_UPDATE speaking    (A)  (B)     
                speaking: typeof u2.speaking === "boolean" ? u2.speaking : old?.speaking ?? false,
                isJoining: false,
                isReconnecting: shouldShowReconnecting,
                isLoading: shouldShowReconnecting,
                lastUpdate: Date.now(),
                reconnectStartedAt: shouldShowReconnecting ? old?.reconnectStartedAt ?? Date.now() : void 0
              };
              if (!old && !reconnectHistoryRef.current.has(peerId)) {
                const shouldStopLoading2 = isMe && localStreamRef.current;
                const skipJoiningSpinner = hasFinishedInitialSyncRef.current;
                return {
                  ...baseUser,
                  isJoining: !isMe && !skipJoiningSpinner,
                  isLoading: !isMe && !shouldStopLoading2 && !skipJoiningSpinner
                };
              }
              const shouldStopLoading = isMe && localStreamRef.current;
              return {
                ...baseUser,
                isLoading: !shouldStopLoading && baseUser.isLoading
              };
            });
            const meUser = data2.users.find((u2) => String(u2.userId) === String(userId));
            if (meUser) {
              setMutedByHostMe(!!meUser.mutedByHost);
              setCameraOffByHostMe(!!meUser.cameraOffByHost);
            }
            const retainedUsers = prev.filter((p2) => {
              const peerId = String(p2.id);
              if (newServerIds.has(peerId)) return false;
              if (p2.isMe) {
                const pid = String(p2.id);
                const uid = String(p2.userId ?? p2.id);
                return newServerIds.has(pid) || newServerIds.has(uid);
              }
              const hasLiveStream = p2.stream && p2.stream.getVideoTracks().some((t2) => t2.readyState === "live");
              if (hasLiveStream) {
                missingSinceRef.current.delete(peerId);
                console.log(`\u{1F6E1}\uFE0F [LIVE STREAM PROTECTED] ${p2.name} (${peerId}) - has live stream, keeping`);
                return true;
              }
              if (!missingSinceRef.current.has(peerId)) {
                missingSinceRef.current.set(peerId, now);
                console.log(`\u23F1\uFE0F [MISSING RECORDED] ${p2.name} (${peerId}) - first missing, starting timer`);
                return true;
              }
              const missingFor = now - missingSinceRef.current.get(peerId);
              if (missingFor < 3e3) {
                console.log(`\u23F3 [MISSING PROTECTED] ${p2.name} (${peerId}) - missing for ${missingFor}ms, keeping`);
                return true;
              }
              missingSinceRef.current.delete(peerId);
              console.log(`\u274C [REMOVING] ${p2.name} (${peerId}) - missing for ${missingFor}ms, removing`);
              return false;
            });
            const ghostUsers = retainedUsers.map((p2) => {
              const peerId = String(p2.id);
              const hasActiveConsumer = Array.from(consumersRef.current.values()).some(
                (c2) => String(c2.appData?.peerId) === peerId && !c2.closed
              );
              const hasLiveStream = p2.stream && p2.stream.getVideoTracks().some((t2) => t2.readyState === "live");
              const shouldBeReconnecting = p2.isMe ? false : p2.isReconnecting && !hasActiveConsumer && !hasLiveStream && !p2.cameraOff;
              return {
                ...p2,
                //  live  consumer    
                isReconnecting: shouldBeReconnecting,
                //  : live stream   null   (  )
                stream: p2.isMe ? p2.stream : hasLiveStream ? p2.stream : hasActiveConsumer ? p2.stream : null,
                screenStream: p2.isMe ? p2.screenStream : p2.isScreenSharing ? p2.screenStream : null,
                isScreenSharing: p2.isMe ? p2.isScreenSharing : p2.screenStream ? true : false,
                reconnectStartedAt: p2.isMe ? void 0 : shouldBeReconnecting ? p2.reconnectStartedAt || Date.now() : void 0
              };
            });
            const updatedMap = new Map(updatedUsers.map((u2) => [String(u2.id), u2]));
            const ghostMap = new Map(ghostUsers.map((u2) => [String(u2.id), u2]));
            const mergedUsers = [];
            const usedIds = /* @__PURE__ */ new Set();
            for (const p2 of prev) {
              const id = String(p2.id);
              const u2 = updatedMap.get(id) ?? ghostMap.get(id);
              if (u2) {
                mergedUsers.push(u2);
                usedIds.add(id);
              }
            }
            for (const u2 of updatedUsers) {
              const id = String(u2.id);
              if (!usedIds.has(id)) {
                mergedUsers.push(u2);
                usedIds.add(id);
              }
            }
            for (const u2 of ghostUsers) {
              const id = String(u2.id);
              if (!usedIds.has(id)) mergedUsers.push(u2);
            }
            setActiveSpeakerId((currentSpeakerId) => {
              const exists = mergedUsers.some((u2) => String(u2.id) === String(currentSpeakerId));
              return exists ? currentSpeakerId : String(mergedUsers[0]?.id ?? "") || null;
            });
            return mergedUsers;
          });
          return;
        }
        if (data2.type === "CHAT") {
          setMessages((prev) => [
            ...prev,
            {
              id: data2.timestamp,
              userId: data2.userId,
              userName: data2.userName,
              text: data2.message,
              time: new Date(data2.timestamp).toLocaleTimeString([], {
                hour: "2-digit",
                minute: "2-digit"
              }),
              isMe: String(data2.userId) === String(userId)
            }
          ]);
          return;
        }
        if (data2.type === "USER_STATE_CHANGE") {
          const messageUserId = String(data2.userId ?? "");
          if (!messageUserId) return;
          const selfId = String(userIdRef.current ?? userId ?? "");
          const isSelfStateChange = messageUserId === selfId;
          const selfState = computeOutboundMediaState();
          if (data2?.changes && (typeof data2.changes.muted === "boolean" || typeof data2.changes.cameraOff === "boolean")) {
            const matched = (participantsRef.current || []).find(
              (p2) => String(p2.id) === messageUserId || String(p2.userId ?? "") === messageUserId
            );
            rememberParticipantMediaStateByKeys(
              [
                messageUserId,
                matched?.id != null ? String(matched.id) : "",
                matched?.userId != null ? String(matched.userId) : "",
                getParticipantMediaEmailKey(matched?.email || "")
              ],
              {
                ...typeof data2.changes.muted === "boolean" ? { muted: data2.changes.muted } : {},
                ...typeof data2.changes.cameraOff === "boolean" ? { cameraOff: data2.changes.cameraOff } : {}
              }
            );
          }
          try {
            if (!isSelfStateChange && data2?.changes && data2.changes.cameraOff === true) {
              removeVideoConsumer(messageUserId);
              try {
                window.dispatchEvent(new CustomEvent("meeting:peer-camera-off", {
                  detail: { peerId: messageUserId }
                }));
              } catch {
              }
            }
          } catch {
          }
          setParticipants(
            (prev) => prev.map((p2) => {
              if (String(p2.id) === messageUserId || String(p2.userId ?? "") === messageUserId) {
                const safeChanges = { ...data2.changes };
                delete safeChanges.stream;
                delete safeChanges.screenStream;
                delete safeChanges.isScreenSharing;
                delete safeChanges.reaction;
                if (p2.isMe || isSelfStateChange) {
                  if (Object.prototype.hasOwnProperty.call(safeChanges, "muted")) {
                    safeChanges.muted = selfState.muted;
                  }
                  if (Object.prototype.hasOwnProperty.call(safeChanges, "cameraOff")) {
                    safeChanges.cameraOff = selfState.cameraOff;
                  }
                }
                return { ...p2, ...safeChanges };
              }
              return p2;
            })
          );
          return;
        }
        if (data2.type === "USER_RECONNECTING") {
          const peerId = String(data2.userId);
          if (peerId === String(userId)) return;
          const reconnecting = data2.reconnecting !== false;
          setParticipants(
            (prev) => prev.map((p2) => {
              if (String(p2.id) !== peerId) return p2;
              const hasLiveStream = p2.stream && p2.stream.getVideoTracks().some((t2) => t2.readyState === "live");
              if (hasLiveStream && reconnecting) {
                console.log(`[MeetingPage] USER_RECONNECTING \uBB34\uC2DC: ${peerId} - live stream exists`);
                return p2;
              }
              return {
                ...p2,
                isReconnecting: reconnecting,
                isLoading: reconnecting,
                //     
                reconnectStartedAt: reconnecting ? p2.reconnectStartedAt || Date.now() : void 0
              };
            })
          );
          console.log(`[MeetingPage] USER_RECONNECTING: ${peerId} = ${reconnecting}`);
          return;
        }
        if (data2.type === "HOST_CHANGED") {
          const { newHostUserId, newHostUserName } = data2;
          console.log(`\u{1F451} [HOST_CHANGED] \uC0C8 \uBC29\uC7A5: ${newHostUserName} (${newHostUserId})`);
          const targetId = String(newHostUserId);
          const primaryHostId = primaryHostUserIdRef.current ? String(primaryHostUserIdRef.current) : null;
          const primaryHostReconnecting = !!primaryHostId && participantsRef.current.some(
            (p2) => (String(p2.userId ?? p2.id) === primaryHostId || String(p2.id) === primaryHostId) && !!p2.isReconnecting
          );
          setParticipants(
            (prev) => prev.map((p2) => ({
              ...p2,
              isHost: String(p2.id) === targetId || String(p2.userId ?? "") === targetId
            }))
          );
          const suppressToastByPrimaryHostRefresh = !!primaryHostId && targetId !== primaryHostId && primaryHostReconnecting;
          if (!suppressToastByPrimaryHostRefresh) {
            setToastMessage(`${newHostUserName}\uB2D8\uC5D0\uAC8C \uBC29\uC7A5 \uAD8C\uD55C\uC774 \uC704\uC784\uB418\uC5C8\uC2B5\uB2C8\uB2E4.`);
            setShowToast(true);
          }
          return;
        }
        if (data2.type === "FORCE_MUTE") {
          const { targetUserId, hostName } = data2;
          console.log(`\u{1F507} [FORCE_MUTE] ${hostName}\uB2D8\uC774 ${targetUserId}\uC758 \uB9C8\uC774\uD06C\uB97C \uAED0\uC2B5\uB2C8\uB2E4.`);
          rememberParticipantMediaState(targetUserId, { muted: true });
          if (String(targetUserId) === String(userId)) {
            setMicOn(false);
            try {
              localStorage.setItem("micOn", "false");
            } catch {
            }
            setMutedByHostMe(true);
            setToastMessage(`${hostName}\uB2D8\uC774 \uB9C8\uC774\uD06C\uB97C \uAED0\uC2B5\uB2C8\uB2E4.`);
            setShowToast(true);
          }
          setParticipants(
            (prev) => prev.map(
              (p2) => String(p2.id) === String(targetUserId) ? { ...p2, muted: true, mutedByHost: true } : p2
            )
          );
          return;
        }
        if (data2.type === "FORCE_CAMERA_OFF") {
          const { targetUserId, hostName } = data2;
          console.log(`\u{1F4F7} [FORCE_CAMERA_OFF] ${hostName}\uB2D8\uC774 ${targetUserId}\uC758 \uCE74\uBA54\uB77C\uB97C \uAED0\uC2B5\uB2C8\uB2E4.`);
          rememberParticipantMediaState(targetUserId, { cameraOff: true });
          if (String(targetUserId) === String(userId)) {
            setCameraOffByHostMe(true);
            setToastMessage(`${hostName}\uB2D8\uC774 \uCE74\uBA54\uB77C\uB97C \uAED0\uC2B5\uB2C8\uB2E4.`);
            setShowToast(true);
            turnOffCamera();
          }
          setParticipants(
            (prev) => prev.map(
              (p2) => String(p2.id) === String(targetUserId) ? { ...p2, cameraOff: true, cameraOffByHost: true } : p2
            )
          );
          return;
        }
        if (data2.type === "FORCE_UNMUTE") {
          const { targetUserId, hostName } = data2;
          console.log(`\u{1F50A} [FORCE_UNMUTE] ${hostName}\uB2D8\uC774 ${targetUserId}\uC758 \uB9C8\uC774\uD06C\uB97C \uCF1C \uC8FC\uC5C8\uC2B5\uB2C8\uB2E4.`);
          rememberParticipantMediaState(targetUserId, { muted: false });
          setParticipants(
            (prev) => prev.map(
              (p2) => String(p2.id) === String(targetUserId) ? { ...p2, muted: false, mutedByHost: false } : p2
            )
          );
          if (String(targetUserId) === String(userId)) {
            setMutedByHostMe(false);
            setForceUnmuteRequest({ hostName });
          }
          return;
        }
        if (data2.type === "FORCE_CAMERA_ON") {
          const { targetUserId, hostName } = data2;
          console.log(`\u{1F4F7} [FORCE_CAMERA_ON] ${hostName}\uB2D8\uC774 ${targetUserId}\uC758 \uCE74\uBA54\uB77C\uB97C \uCF1C \uC8FC\uC5C8\uC2B5\uB2C8\uB2E4.`);
          rememberParticipantMediaState(targetUserId, { cameraOff: false });
          setParticipants(
            (prev) => prev.map(
              (p2) => String(p2.id) === String(targetUserId) ? { ...p2, cameraOff: false, cameraOffByHost: false } : p2
            )
          );
          if (String(targetUserId) === String(userId)) {
            setCameraOffByHostMe(false);
            setForceCameraOnRequest({ hostName });
          }
          return;
        }
        if (data2.type === "KICKED") {
          const { targetUserId, targetUserName, hostName } = data2;
          console.log(`\u{1F6AA} [KICKED] ${hostName}\uB2D8\uC774 ${targetUserName}\uC744 \uAC15\uD1F4\uD588\uC2B5\uB2C8\uB2E4.`);
          if (String(targetUserId) === String(userId)) {
            setToastMessage(`${hostName}\uB2D8\uC774 \uD68C\uC758\uC5D0\uC11C \uB0B4\uBCF4\uB0C8\uC2B5\uB2C8\uB2E4.`);
            setShowToast(true);
            setTimeout(() => {
              isLeavingRef.current = true;
              try {
                if (wsRef.current?.readyState === WebSocket.OPEN) {
                  wsRef.current.send(JSON.stringify({ type: "LEAVE" }));
                }
              } catch {
              }
              navigate(`/lms/${subjectId}`);
            }, 1500);
            return;
          }
          setToastMessage(`${targetUserName}\uB2D8\uC774 \uD68C\uC758\uC5D0\uC11C \uB098\uAC14\uC2B5\uB2C8\uB2E4.`);
          setShowToast(true);
          setParticipants(
            (prev) => prev.filter((p2) => String(p2.id) !== String(targetUserId))
          );
          return;
        }
      };
    };
    connect();
    return () => {
      if (!isLeavingRef.current) {
        console.log("[SPRING WS] unmount ignored (PiP / LMS \uC774\uB3D9)");
        return;
      }
      if (pingInterval) clearInterval(pingInterval);
      try {
        wsRef.current?.close();
      } catch {
      }
      wsRef.current = null;
    };
  }, [roomId, subjectId, userId, userName, userEmail, isHostLocal, roomTitle, computeOutboundMediaState, rememberParticipantMediaState, rememberParticipantMediaStateByKeys, getRememberedParticipantMediaState]);
  (0, import_react6.useEffect)(() => {
    setParticipants(
      (prev) => prev.map((p2) => p2.isMe ? { ...p2, speaking: isSpeaking } : p2)
    );
  }, [isSpeaking]);
  const handleSpeakingChange = (0, import_react6.useCallback)((peerId, value) => {
    if (peerId == null) return;
    setParticipants(
      (prev) => prev.map((p2) => String(p2.id) === String(peerId) ? { ...p2, speaking: !!value } : p2)
    );
  }, []);
  (0, import_react6.useEffect)(() => {
    effectAliveRef.current = true;
    if (!roomId) return;
    const resetSfuLocalState = () => {
      consumersRef.current.clear();
      producersRef.current.clear();
      peerStreamsRef.current.clear();
      pendingProducersRef.current = [];
      audioElsRef.current.forEach((a2) => {
        try {
          a2.srcObject = null;
        } catch {
        }
      });
      audioElsRef.current.clear();
      sendTransportRef.current = null;
      recvTransportRef.current = null;
      restartSendIceRef.current = async () => false;
      restartRecvIceRef.current = async () => false;
      transportIceRestartInFlightRef.current = { send: false, recv: false };
      transportIceRestartLastAtRef.current = { send: 0, recv: 0 };
      stalledVideoSinceRef.current.clear();
      localSendStallSinceRef.current = 0;
      setRecvTransportReady(false);
      sfuDeviceRef.current = null;
    };
    resetSfuLocalState();
    hasFinishedInitialSyncRef.current = false;
    setRoomReconnecting(true);
    if (wsRef.current?.readyState === WebSocket.OPEN) {
      wsRef.current.send(JSON.stringify({
        type: "USER_RECONNECTING",
        userId,
        reconnecting: true
      }));
      console.log("[MeetingPage] \uC7AC\uC811\uC18D \uC2DC\uC791 \uC54C\uB9BC \uC804\uC1A1");
    }
    if (sfuWsRef.current != null) {
      try {
        sendTransportRef.current?.close();
      } catch {
      }
      try {
        recvTransportRef.current?.close();
      } catch {
      }
      try {
        sfuDeviceRef.current?.close?.();
      } catch {
      }
      sendTransportRef.current = null;
      recvTransportRef.current = null;
      sfuDeviceRef.current = null;
    }
    const sfuWsUrl = getSfuWsUrl();
    if (true) {
      console.log("[SFU] Connecting to", sfuWsUrl, "(no :4000 \u2013 nginx proxy)");
    }
    const sfuWs = new WebSocket(sfuWsUrl);
    sfuWsRef.current = sfuWs;
    const drainPending = async () => {
      if (!recvTransportRef.current || !sfuDeviceRef.current) return;
      const pending = pendingProducersRef.current;
      if (!pending.length) return;
      const uniq = /* @__PURE__ */ new Map();
      for (const p2 of pending) uniq.set(p2.producerId, p2);
      pendingProducersRef.current = [];
      for (const p2 of uniq.values()) {
        await consumeProducer(p2.producerId, p2.peerId, p2.appData);
      }
    };
    const requestTransportIceRestart = async (transport, direction, reason = "unknown") => {
      if (!transport || transport.closed) return false;
      if (!sfuWsRef.current || sfuWsRef.current.readyState !== WebSocket.OPEN) return false;
      const inFlight = transportIceRestartInFlightRef.current[direction];
      if (inFlight) return false;
      const now = Date.now();
      const lastAt = transportIceRestartLastAtRef.current[direction] || 0;
      if (now - lastAt < 5e3) return false;
      transportIceRestartInFlightRef.current[direction] = true;
      const reqId = safeUUID();
      return await new Promise((resolve) => {
        let settled = false;
        const cleanup = () => {
          if (settled) return;
          settled = true;
          transportIceRestartInFlightRef.current[direction] = false;
          try {
            sfuWs.removeEventListener("message", onMessage);
          } catch {
          }
          clearTimeout(timeoutId);
        };
        const finish = (ok) => {
          cleanup();
          if (ok) {
            transportIceRestartLastAtRef.current[direction] = Date.now();
          }
          resolve(ok);
        };
        const onMessage = async (e2) => {
          let m2 = null;
          try {
            m2 = JSON.parse(e2.data);
          } catch {
            return;
          }
          if (m2.requestId !== reqId) return;
          if (m2.action === "restartIce:response") {
            try {
              const iceParameters = m2?.data?.iceParameters;
              if (!iceParameters) throw new Error("restartIce: missing iceParameters");
              await transport.restartIce({ iceParameters });
              console.log(`[transport:${direction}] ICE restart applied (${reason})`);
              finish(true);
              return;
            } catch (err) {
              console.error(`[transport:${direction}] ICE restart apply failed`, err);
              finish(false);
              return;
            }
          }
          if (m2.action === "restartIce:error") {
            console.error(`[transport:${direction}] ICE restart request failed`, m2.error);
            finish(false);
          }
        };
        const timeoutId = setTimeout(() => {
          console.warn(`[transport:${direction}] ICE restart timeout (${reason})`);
          finish(false);
        }, 7e3);
        try {
          sfuWs.addEventListener("message", onMessage);
        } catch {
        }
        safeSfuSend({
          action: "restartIce",
          requestId: reqId,
          data: { transportId: transport.id }
        });
      });
    };
    const bindTransportRecovery = (transport, direction) => {
      if (!transport) return;
      const runRestart = async (reason) => {
        const ok = await requestTransportIceRestart(transport, direction, reason);
        if (ok) return true;
        if (isLeavingRef.current) return false;
        try {
          sfuWsRef.current?.close();
        } catch {
        }
        return false;
      };
      if (direction === "send") {
        restartSendIceRef.current = runRestart;
      } else if (direction === "recv") {
        restartRecvIceRef.current = runRestart;
      }
      transport.on("connectionstatechange", (state) => {
        console.log(`[transport:${direction}] connectionstate=${state}`);
        if (state === "connected") return;
        if (state === "disconnected" || state === "failed") {
          runRestart(`connectionstate:${state}`).catch(() => {
          });
          return;
        }
        if (state === "closed" && !isLeavingRef.current) {
          try {
            sfuWsRef.current?.close();
          } catch {
          }
        }
      });
    };
    sfuWs.onopen = () => {
      const sfuRoomId = roomId;
      safeSfuSend({
        action: "join",
        requestId: safeUUID(),
        data: { roomId: sfuRoomId, peerId: userId }
      });
    };
    sfuWs.onmessage = async (event) => {
      if (!effectAliveRef.current) return;
      const msg = JSON.parse(event.data);
      if (msg.action === "peerCount") {
        setParticipantCount(msg.data.count);
        return;
      }
      if (msg.action === "join:response") {
        const { rtpCapabilities, existingProducers } = msg.data;
        const device = new mediasoupClient.Device();
        await device.load({ routerRtpCapabilities: rtpCapabilities });
        sfuDeviceRef.current = device;
        sfuDeviceRef.current._existingProducers = existingProducers || [];
        safeSfuSend({ action: "createTransport", requestId: safeUUID(), data: { direction: "send" } });
        safeSfuSend({ action: "createTransport", requestId: safeUUID(), data: { direction: "recv" } });
        return;
      }
      if (msg.action === "createTransport:response") {
        const { transportId, direction, iceParameters, iceCandidates, dtlsParameters } = msg.data;
        const device = sfuDeviceRef.current;
        if (!device) return;
        const transportOptions = {
          id: transportId,
          iceParameters,
          iceCandidates,
          dtlsParameters,
          iceServers: ICE_SERVERS,
          pcConfig: { iceServers: ICE_SERVERS }
        };
        if (true) {
          console.log(`[transport] Creating ${direction} transport with ICE_SERVERS:`, {
            stun: ICE_SERVERS.find((s2) => s2.urls.includes("stun:")),
            turn: ICE_SERVERS.find((s2) => Array.isArray(s2.urls) && s2.urls.some((u2) => u2.includes("turn:")))
          });
        }
        if (direction === "send") {
          const sendTransport = device.createSendTransport(transportOptions);
          bindTransportRecovery(sendTransport, "send");
          if (sendTransport?._handler?._pc) {
            const pc2 = sendTransport._handler._pc;
            const currentConfig = pc2.getConfiguration();
            pc2.setConfiguration({
              ...currentConfig,
              iceServers: ICE_SERVERS
            });
            console.log("\u2705 TURN injected into sendTransport PC");
          }
          sendTransport.on("connect", ({ dtlsParameters: dtlsParameters2 }, cb) => {
            const reqId = safeUUID();
            const handler = (e2) => {
              const m2 = JSON.parse(e2.data);
              if (m2.action === "connectTransport:response" && m2.requestId === reqId) {
                cb();
                sfuWs.removeEventListener("message", handler);
              }
            };
            sfuWs.addEventListener("message", handler);
            safeSfuSend({ action: "connectTransport", requestId: reqId, data: { transportId, dtlsParameters: dtlsParameters2 } });
          });
          sendTransport.on("produce", ({ kind, rtpParameters, appData }, cb, errback) => {
            const reqId = safeUUID();
            const handler = (e2) => {
              const m2 = JSON.parse(e2.data);
              if (m2.action === "produce:response" && m2.requestId === reqId) {
                cb({ id: m2.data.producerId });
                sfuWs.removeEventListener("message", handler);
              }
              if (m2.action === "produce:error" && m2.requestId === reqId) {
                errback(m2.error);
                sfuWs.removeEventListener("message", handler);
              }
            };
            sfuWs.addEventListener("message", handler);
            safeSfuSend({ action: "produce", requestId: reqId, data: { transportId, kind, rtpParameters, appData } });
          });
          sendTransportRef.current = sendTransport;
          ensureLocalProducers();
          setTimeout(() => ensureLocalProducers(), 100);
          setTimeout(() => ensureLocalProducers(), 500);
          setTimeout(() => ensureLocalProducers(), 1200);
        }
        if (direction === "recv") {
          const recvTransport = device.createRecvTransport(transportOptions);
          bindTransportRecovery(recvTransport, "recv");
          if (recvTransport?._handler?._pc) {
            const pc2 = recvTransport._handler._pc;
            const currentConfig = pc2.getConfiguration();
            pc2.setConfiguration({
              ...currentConfig,
              iceServers: ICE_SERVERS
            });
            console.log("\u2705 TURN injected into recvTransport PC");
          }
          recvTransport.on("connect", ({ dtlsParameters: dtlsParameters2 }, cb) => {
            const reqId = safeUUID();
            const handler = (e2) => {
              const m2 = JSON.parse(e2.data);
              if (m2.action === "connectTransport:response" && m2.requestId === reqId) {
                cb();
                sfuWs.removeEventListener("message", handler);
              }
            };
            sfuWs.addEventListener("message", handler);
            safeSfuSend({ action: "connectTransport", requestId: reqId, data: { transportId, dtlsParameters: dtlsParameters2 } });
          });
          recvTransportRef.current = recvTransport;
          setRecvTransportReady(true);
          const producers = sfuDeviceRef.current?._existingProducers || [];
          for (const p2 of producers) {
            await consumeProducer(p2.producerId, p2.peerId, p2.appData);
          }
          await drainPending();
          bumpStreamVersion();
        }
        return;
      }
      if (msg.action === "newProducer") {
        const { producerId, peerId, appData } = msg.data;
        if (!recvTransportRef.current || !sfuDeviceRef.current) {
          pendingProducersRef.current.push({ producerId, peerId, appData });
          return;
        }
        await consumeProducer(producerId, peerId, appData);
        return;
      }
      if (msg.action === "producerClosed") {
        const { producerId, peerId, appData } = msg.data || {};
        const isScreen = appData?.type === "screen";
        setParticipants(
          (prev) => prev.map((p2) => {
            if (String(p2.id) !== String(peerId)) return p2;
            if (isScreen) {
              return {
                ...p2,
                screenStream: null,
                isScreenSharing: false,
                lastUpdate: Date.now()
              };
            }
            return { ...p2, lastUpdate: Date.now() };
          })
        );
        const c2 = consumersRef.current.get(producerId);
        if (c2) {
          try {
            c2.close();
          } catch {
          }
        }
        consumersRef.current.delete(producerId);
        bumpStreamVersion();
        return;
      }
      if (msg.action === "peerLeft") {
        const { peerId } = msg.data || {};
        if (!peerId) return;
        console.log(`[SFU] peerLeft received for ${peerId}. Removing immediately.`);
        for (const [key, c2] of consumersRef.current.entries()) {
          if (String(c2?.appData?.peerId) === String(peerId)) {
            try {
              c2.close();
            } catch {
            }
            consumersRef.current.delete(key);
          }
        }
        peerStreamsRef.current.delete(String(peerId));
        bumpStreamVersion();
        setParticipants((prev) => prev.filter((p2) => String(p2.id) !== String(peerId)));
        reconnectHistoryRef.current.delete(String(peerId));
        if (reconnectTimeoutRef.current.has(String(peerId))) {
          clearTimeout(reconnectTimeoutRef.current.get(String(peerId)));
          reconnectTimeoutRef.current.delete(String(peerId));
        }
        return;
      }
    };
    sfuWs.onerror = (error2) => {
      const urlUsed = getSfuWsUrl();
      console.error("\u274C SFU WS ERROR", {
        error: error2,
        url: urlUsed,
        expected: "wss://onsil.study/sfu",
        readyState: sfuWs.readyState,
        hint: "1) nginx location /sfu/ \uD504\uB85D\uC2DC \uD655\uC778 2) SFU \uC11C\uBC84(4000) \uC2E4\uD589 \uD655\uC778 3) \uBE4C\uB4DC \uD6C4 \uC7AC\uBC30\uD3EC \uD655\uC778"
      });
      setRoomReconnecting(false);
    };
    sfuWs.onclose = () => {
      consumersRef.current.forEach((c2) => safeClose(c2));
      consumersRef.current.clear();
      producersRef.current.forEach((p2) => safeClose(p2));
      producersRef.current.clear();
      peerStreamsRef.current.clear();
      pendingProducersRef.current = [];
      audioElsRef.current.forEach((a2) => {
        try {
          a2.srcObject = null;
        } catch {
        }
      });
      audioElsRef.current.clear();
      restartSendIceRef.current = async () => false;
      restartRecvIceRef.current = async () => false;
      transportIceRestartInFlightRef.current = { send: false, recv: false };
      localSendStallSinceRef.current = 0;
      if (!isLeavingRef.current) {
        setRoomReconnecting(true);
        setSfuReconnectKey((prev) => prev + 1);
      }
    };
    return () => {
      if (!isLeavingRef.current) {
        console.log("[SFU] unmount ignored (PiP / LMS \uC774\uB3D9)");
        return;
      }
      effectAliveRef.current = false;
      try {
        safeSfuSend({
          action: "leave",
          requestId: safeUUID(),
          data: { roomId, peerId: userId }
        });
      } catch {
      }
      try {
        sendSfuLeaveBeacon(roomId, userId);
      } catch {
      }
      producersRef.current.forEach((p2) => safeClose(p2));
      consumersRef.current.forEach((c2) => safeClose(c2));
      producersRef.current.clear();
      consumersRef.current.clear();
      closeSfuWsForLeave();
      sfuWsRef.current = null;
    };
  }, [roomId, userId, sfuReconnectKey, closeSfuWsForLeave]);
  (0, import_react6.useEffect)(() => {
    try {
      localStorage.setItem("meeting.sidebarOpen", String(sidebarOpen));
    } catch (e2) {
      console.warn("[MeetingPage] localStorage \uC800\uC7A5 \uC2E4\uD328:", e2);
    }
    sessionStorage.setItem("sidebarOpen", String(sidebarOpen));
  }, [sidebarOpen]);
  (0, import_react6.useEffect)(() => {
    try {
      localStorage.setItem("meeting.sidebarView", sidebarView);
    } catch (e2) {
      console.warn("[MeetingPage] localStorage \uC800\uC7A5 \uC2E4\uD328:", e2);
    }
    sessionStorage.setItem("sidebarView", sidebarView);
  }, [sidebarView]);
  (0, import_react6.useEffect)(() => {
    if (isInitialMountRef.current) {
      isInitialMountRef.current = false;
      return;
    }
    if (messages.length > 0 && chatAreaRef.current) {
      chatAreaRef.current.scrollTop = chatAreaRef.current.scrollHeight;
    }
  }, [messages]);
  (0, import_react6.useEffect)(() => {
    sessionStorage.setItem(`chat_${roomId}`, JSON.stringify(messages));
  }, [messages, roomId]);
  (0, import_react6.useEffect)(() => {
    if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
    if (lastSpeakingRef.current === isSpeaking) return;
    lastSpeakingRef.current = isSpeaking;
    wsRef.current.send(
      JSON.stringify({
        type: "SPEAKING",
        speaking: isSpeaking
      })
    );
  }, [isSpeaking]);
  (0, import_react6.useEffect)(() => {
    if (!isFullscreen) {
      setShowStripToggle(false);
      return;
    }
    const handleMouseMove = (e2) => {
      const threshold = window.innerHeight - 120;
      setShowStripToggle(e2.clientY > threshold);
    };
    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [isFullscreen]);
  (0, import_react6.useEffect)(() => {
    if (!isGridFullscreen) {
      setShowGridStripToggle(false);
      return;
    }
    const handleMouseMove = (e2) => {
      const threshold = window.innerHeight - 120;
      setShowGridStripToggle(e2.clientY > threshold);
    };
    window.addEventListener("mousemove", handleMouseMove);
    return () => window.removeEventListener("mousemove", handleMouseMove);
  }, [isGridFullscreen]);
  const getStoredOrder = () => {
    try {
      const stored = localStorage.getItem(`participant_order_${roomId}`);
      return stored ? JSON.parse(stored) : {};
    } catch {
      return {};
    }
  };
  const saveOrder = (orderMap) => {
    try {
      localStorage.setItem(`participant_order_${roomId}`, JSON.stringify(orderMap));
    } catch {
    }
  };
  (0, import_react6.useEffect)(() => {
    if (roomStartedAt == null) setElapsedTimeDisplay("00:00:00");
  }, [roomStartedAt]);
  const participantsRef = (0, import_react6.useRef)(participants);
  (0, import_react6.useEffect)(() => {
    participantsRef.current = participants;
  }, [participants]);
  (0, import_react6.useEffect)(() => {
    for (const p2 of participants) {
      if (!p2 || p2.id == null) continue;
      const promotedState = {};
      if (p2.muted === true) promotedState.muted = true;
      if (p2.cameraOff === true) promotedState.cameraOff = true;
      if (!Object.keys(promotedState).length) continue;
      rememberParticipantMediaStateByKeys(
        [
          String(p2.id),
          p2.userId != null ? String(p2.userId) : "",
          getParticipantMediaEmailKey(p2.email || "")
        ],
        promotedState
      );
    }
  }, [participants, rememberParticipantMediaStateByKeys]);
  (0, import_react6.useEffect)(() => {
    if (!roomId) return;
    try {
      const serializable = participants.filter((p2) => p2 && p2.id != null).map((p2) => ({
        id: String(p2.id),
        userId: p2.userId != null ? String(p2.userId) : String(p2.id),
        name: p2.name || "\uCC38\uC5EC\uC790",
        email: p2.email || "",
        joinAt: Number(p2.joinAt || Date.now()),
        isMe: !!p2.isMe,
        isHost: !!p2.isHost,
        muted: !!p2.muted,
        cameraOff: !!p2.cameraOff,
        mutedByHost: !!p2.mutedByHost,
        cameraOffByHost: !!p2.cameraOffByHost,
        faceEmoji: p2.faceEmoji ?? null,
        bgRemove: !!p2.bgRemove
      }));
      if (serializable.length === 0) return;
      sessionStorage.setItem(
        getParticipantsSnapshotKey(roomId),
        JSON.stringify({
          savedAt: Date.now(),
          participants: serializable
        })
      );
    } catch {
    }
  }, [participants, roomId]);
  (0, import_react6.useEffect)(() => {
    const intervalId = setInterval(() => {
      if (isLeavingRef.current) return;
      if (!sfuWsRef.current || sfuWsRef.current.readyState !== WebSocket.OPEN) return;
      const now = Date.now();
      const peers = participantsRef.current || [];
      const activePeerKeys = /* @__PURE__ */ new Set();
      let stalledCount = 0;
      for (const p2 of peers) {
        if (!p2 || p2.isMe) continue;
        const key = String(p2.userId ?? p2.id);
        activePeerKeys.add(key);
        if (p2.cameraOff || p2.isReconnecting || p2.isLoading) {
          stalledVideoSinceRef.current.delete(key);
          continue;
        }
        const hasLiveVideo = !!p2.stream?.getVideoTracks?.().some((t2) => t2.readyState === "live");
        if (hasLiveVideo) {
          stalledVideoSinceRef.current.delete(key);
          continue;
        }
        if (!stalledVideoSinceRef.current.has(key)) {
          stalledVideoSinceRef.current.set(key, now);
          continue;
        }
        const stalledFor = now - (stalledVideoSinceRef.current.get(key) || now);
        if (stalledFor >= 1e4) stalledCount += 1;
      }
      for (const key of [...stalledVideoSinceRef.current.keys()]) {
        if (!activePeerKeys.has(key)) stalledVideoSinceRef.current.delete(key);
      }
      if (stalledCount > 0) {
        restartRecvIceRef.current?.(`video-stall:${stalledCount}`).catch(() => {
        });
      }
    }, 3e3);
    return () => clearInterval(intervalId);
  }, []);
  (0, import_react6.useEffect)(() => {
    const intervalId = setInterval(() => {
      if (isLeavingRef.current) return;
      if (!sfuWsRef.current || sfuWsRef.current.readyState !== WebSocket.OPEN) return;
      if (!sendTransportRef.current || sendTransportRef.current.closed) return;
      const needAudio = micOnRef.current && micPermissionRef.current === "granted";
      const needVideo = camOnRef.current && camPermissionRef.current === "granted";
      const audioProducer = producersRef.current.get("audio");
      const cameraProducer = producersRef.current.get("camera");
      const audioHealthy = !needAudio || !!(audioProducer && !audioProducer.closed && audioProducer.track && audioProducer.track.readyState === "live");
      const videoHealthy = !needVideo || !!(cameraProducer && !cameraProducer.closed && cameraProducer.track && cameraProducer.track.readyState === "live");
      if (audioHealthy && videoHealthy) {
        localSendStallSinceRef.current = 0;
        return;
      }
      if (!localSendStallSinceRef.current) {
        localSendStallSinceRef.current = Date.now();
        return;
      }
      if (Date.now() - localSendStallSinceRef.current < 1e4) return;
      localSendStallSinceRef.current = Date.now();
      ensureLocalProducers();
      restartSendIceRef.current?.("local-producer-stall").catch(() => {
      });
    }, 3e3);
    return () => clearInterval(intervalId);
  }, []);
  (0, import_react6.useEffect)(() => {
    const ctx = getSharedAudioContext();
    if (!ctx) return;
    const peerAnalysers = /* @__PURE__ */ new Map();
    const checkAudioLevels = () => {
      if (ctx.state === "suspended") ctx.resume().catch(() => {
      });
      const targets = [];
      if (localStreamRef.current) {
        const meParticipant = participantsRef.current?.find((p2) => p2.isMe);
        const myId = meParticipant != null ? String(meParticipant.id) : user?.id != null ? String(user.id) : String(userIdRef.current || "");
        if (myId) targets.push({ id: myId, stream: localStreamRef.current });
      }
      const remoteAudioByPeerId = /* @__PURE__ */ new Map();
      consumersRef.current.forEach((consumer, producerId) => {
        if (consumer.track?.kind !== "audio" || consumer.track?.readyState !== "live") return;
        const peerId = consumer.appData?.peerId;
        if (!peerId) return;
        if (String(peerId) === String(user?.id) || String(peerId) === String(userIdRef.current)) return;
        if (remoteAudioByPeerId.has(String(peerId))) return;
        const audioStream = new MediaStream([consumer.track]);
        remoteAudioByPeerId.set(String(peerId), audioStream);
      });
      remoteAudioByPeerId.forEach((stream, peerId) => {
        targets.push({ id: peerId, stream });
      });
      peerStreamsRef.current.forEach((stream, peerId) => {
        if (remoteAudioByPeerId.has(String(peerId))) return;
        if (String(peerId) === String(user?.id)) return;
        targets.push({ id: String(peerId), stream });
      });
      const shouldLog = Date.now() % 5e3 < 150;
      if (shouldLog) {
        console.log("[Audio Debug] Targets:", targets.map((t2) => ({
          id: t2.id,
          hasStream: !!t2.stream,
          audioTracks: t2.stream?.getAudioTracks()?.length || 0,
          audioTrackStates: t2.stream?.getAudioTracks()?.map((tr2) => tr2.readyState) || []
        })));
        console.log("[Audio Debug] consumersRef:", [...consumersRef.current.entries()].map(([producerId, c2]) => ({
          producerId,
          kind: c2.track?.kind,
          peerId: c2.appData?.peerId,
          trackState: c2.track?.readyState
        })));
        console.log("[Audio Debug] peerStreamsRef size:", peerStreamsRef.current.size);
      }
      const updates = /* @__PURE__ */ new Map();
      const now = Date.now();
      let maxVol = 0;
      let currentActiveSpeaker = null;
      targets.forEach(({ id, stream }) => {
        const audioTrack = stream.getAudioTracks().find((t2) => t2.readyState === "live");
        if (!audioTrack) {
          if (peerAnalysers.has(id)) {
            const rec2 = peerAnalysers.get(id);
            try {
              rec2.source.disconnect();
              rec2.analyser.disconnect();
            } catch {
            }
            peerAnalysers.delete(id);
            updates.set(id, false);
          }
          return;
        }
        let rec = peerAnalysers.get(id);
        if (rec && rec.trackId !== audioTrack.id) {
          try {
            rec.source.disconnect();
            rec.analyser.disconnect();
          } catch {
          }
          rec = null;
        }
        if (!rec) {
          try {
            const analyser = ctx.createAnalyser();
            analyser.fftSize = 256;
            const trackStream2 = new MediaStream([audioTrack]);
            const source = ctx.createMediaStreamSource(trackStream2);
            source.connect(analyser);
            rec = {
              streamId: stream.id,
              trackId: audioTrack.id,
              analyser,
              source,
              dataArray: new Uint8Array(analyser.frequencyBinCount),
              ema: 0,
              lastSpeaking: false,
              holdOffTimer: 0
            };
            peerAnalysers.set(id, rec);
          } catch (e2) {
            return;
          }
        }
        try {
          rec.analyser.getByteFrequencyData(rec.dataArray);
          const sum = rec.dataArray.reduce((a2, b2) => a2 + b2, 0);
          const avg = sum / rec.dataArray.length;
          const ALPHA = 0.25;
          rec.ema = rec.ema * (1 - ALPHA) + avg * ALPHA;
          const ON_TH = 10;
          const OFF_TH = 6;
          const HOLD = 400;
          let isSpeaking2 = rec.lastSpeaking;
          if (rec.ema > ON_TH) {
            isSpeaking2 = true;
            rec.holdOffTimer = 0;
            if (rec.ema > maxVol) {
              maxVol = rec.ema;
              currentActiveSpeaker = id;
            }
          } else if (rec.ema < OFF_TH) {
            if (isSpeaking2) {
              if (rec.holdOffTimer === 0) {
                rec.holdOffTimer = now;
              } else if (now - rec.holdOffTimer > HOLD) {
                isSpeaking2 = false;
                rec.holdOffTimer = 0;
              }
            }
          } else {
            if (isSpeaking2 && rec.holdOffTimer > 0 && rec.ema > OFF_TH + 1) {
              rec.holdOffTimer = 0;
            }
          }
          if (isSpeaking2 !== rec.lastSpeaking) {
            rec.lastSpeaking = isSpeaking2;
            updates.set(id, isSpeaking2);
            console.log(`[Audio] Speaking state changed: ${id} = ${isSpeaking2}, EMA: ${rec.ema.toFixed(1)}`);
          }
          if (rec.ema > 5 && shouldLog) {
            console.log(`[Audio] EMA for ${id}: ${rec.ema.toFixed(1)} (threshold: ${ON_TH})`);
          }
          if (isSpeaking2 && rec.ema > maxVol) {
            maxVol = rec.ema;
            currentActiveSpeaker = id;
          }
        } catch (e2) {
        }
      });
      if (updates.size > 0) {
        setParticipants((prev) => {
          let changed = false;
          const next = prev.map((p2) => {
            const idStr = String(p2.id);
            const userIdStr = p2.userId != null ? String(p2.userId) : null;
            const matchedKey = updates.has(idStr) ? idStr : userIdStr && updates.has(userIdStr) ? userIdStr : null;
            if (matchedKey != null) {
              const newState = updates.get(matchedKey);
              if (!!p2.speaking !== newState) {
                changed = true;
                return { ...p2, speaking: newState };
              }
            }
            return p2;
          });
          return changed ? next : prev;
        });
      }
    };
    const intervalId = setInterval(checkAudioLevels, 100);
    return () => {
      clearInterval(intervalId);
      peerAnalysers.forEach((rec) => {
        try {
          rec.source.disconnect();
          rec.analyser.disconnect();
        } catch {
        }
      });
    };
  }, []);
  const orderedParticipants = (0, import_react6.useMemo)(() => {
    const seenIds = /* @__PURE__ */ new Set();
    let hasMe = false;
    const uniqueParticipants = participants.filter((p2) => {
      const id = String(p2.id);
      if (seenIds.has(id)) return false;
      if (p2.isMe) {
        if (hasMe) return false;
        hasMe = true;
      }
      seenIds.add(id);
      return true;
    });
    const storedOrder = getStoredOrder();
    let orderChanged = false;
    let maxOrder = Math.max(0, ...Object.values(storedOrder));
    uniqueParticipants.forEach((p2) => {
      const idStr = String(p2.id);
      if (storedOrder[idStr] === void 0) {
        maxOrder += 1;
        storedOrder[idStr] = maxOrder;
        orderChanged = true;
      }
    });
    if (orderChanged) {
      saveOrder(storedOrder);
    }
    return [...uniqueParticipants].sort((a2, b2) => {
      if (a2.isMe) return -1;
      if (b2.isMe) return 1;
      const orderA = storedOrder[String(a2.id)] ?? Infinity;
      const orderB = storedOrder[String(b2.id)] ?? Infinity;
      return orderA - orderB;
    });
  }, [participants, roomId]);
  const gridFullscreenUser = orderedParticipants.find((p2) => p2.id === gridFullscreenId) || orderedParticipants[0];
  const gridFullscreenStream = gridFullscreenUser?.isScreenSharing && gridFullscreenUser?.screenStream ? gridFullscreenUser.screenStream : gridFullscreenUser?.isMe ? localStream : gridFullscreenUser?.stream;
  const isGridScreenShare = !!gridFullscreenUser?.isScreenSharing;
  const handleGridBrowserPip = (0, import_react6.useCallback)(async () => {
    const video = gridFullscreenVideoRef.current;
    if (!video) return;
    if (!document.pictureInPictureElement) {
      const stream = video.srcObject || gridFullscreenStream;
      const peerName = gridFullscreenUser?.name || "\uCC38\uAC00\uC790";
      const peerId = gridFullscreenUser?.id != null ? String(gridFullscreenUser.id) : "";
      if (!stream || !stream.getVideoTracks().some((t2) => t2.readyState === "live")) {
        const avatarStream = createAvatarStream(peerName);
        video.srcObject = avatarStream;
        video.muted = true;
        try {
          await video.play();
        } catch {
        }
      } else {
        if (!video.srcObject && gridFullscreenStream) {
          video.srcObject = gridFullscreenStream;
          video.muted = true;
          try {
            await video.play();
          } catch {
          }
        }
        if (video.readyState < 2) {
          await new Promise((resolve) => {
            const onCanPlay = () => {
              video.removeEventListener("canplay", onCanPlay);
              resolve();
            };
            video.addEventListener("canplay", onCanPlay);
            setTimeout(resolve, 1e3);
          });
        }
      }
      const success = await requestBrowserPip(video, video.srcObject || stream, peerName, peerId);
      if (!success) {
        video.requestPictureInPicture().catch((e2) => console.warn("[PiP] grid fullscreen failed:", e2));
      }
    }
  }, [requestBrowserPip, gridFullscreenUser, gridFullscreenStream, createAvatarStream]);
  const handleGridTileBrowserPip = (0, import_react6.useCallback)(
    async (p2) => {
      const video = gridTileVideoRefsRef.current[String(p2.id)];
      if (!video) return;
      if (!document.pictureInPictureElement) {
        const stream = p2.isScreenSharing ? p2.screenStream : p2.isMe ? localStream : p2.stream;
        const peerName = p2?.name || "\uCC38\uAC00\uC790";
        const peerId = p2?.id != null ? String(p2.id) : "";
        if (!stream || !stream.getVideoTracks().some((t2) => t2.readyState === "live")) {
          const avatarStream = createAvatarStream(peerName);
          video.srcObject = avatarStream;
          video.muted = true;
          try {
            await video.play();
          } catch {
          }
        } else {
          if (!video.srcObject && stream) {
            video.srcObject = stream;
            video.muted = true;
            try {
              await video.play();
            } catch {
            }
          }
          if (video.readyState < 2) {
            await new Promise((resolve) => {
              const onCanPlay = () => {
                video.removeEventListener("canplay", onCanPlay);
                resolve();
              };
              video.addEventListener("canplay", onCanPlay);
              setTimeout(resolve, 1e3);
            });
          }
        }
        const success = await requestBrowserPip(
          video,
          video.srcObject || stream,
          peerName,
          peerId
        );
        if (!success) {
          video.requestPictureInPicture().catch(
            (e2) => console.warn("[PiP] grid tile failed:", e2)
          );
        }
      }
    },
    [requestBrowserPip, localStream, createAvatarStream]
  );
  const _sv = streamVersion;
  return /* @__PURE__ */ React.createElement("div", { className: "meeting-page" }, /* @__PURE__ */ React.createElement("div", { className: "meet-layout" }, /* @__PURE__ */ React.createElement("main", { className: "meet-main" }, /* @__PURE__ */ React.createElement("div", { className: "floating-info-badge" }, /* @__PURE__ */ React.createElement(Users, { size: 14 }), /* @__PURE__ */ React.createElement("span", null, participants.length, "\uBA85 \uC811\uC18D \uC911"), /* @__PURE__ */ React.createElement("span", { className: "badge-dot" }), /* @__PURE__ */ React.createElement("span", null, elapsedTimeDisplay)), /* @__PURE__ */ React.createElement("div", { className: "floating-layout-toggle" }, /* @__PURE__ */ React.createElement(
    "button",
    {
      onClick: () => setLayoutMode("speaker"),
      className: `view-btn ${layoutMode === "speaker" ? "active" : ""}`,
      title: "\uBC1C\uD45C\uC790 \uBCF4\uAE30"
    },
    /* @__PURE__ */ React.createElement(Monitor, { size: 18 })
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      onClick: () => setLayoutMode("grid"),
      className: `view-btn ${layoutMode === "grid" ? "active" : ""}`,
      title: "\uADF8\uB9AC\uB4DC \uBCF4\uAE30"
    },
    /* @__PURE__ */ React.createElement(LayoutGrid, { size: 18 })
  )), /* @__PURE__ */ React.createElement("div", { className: "meet-stage" }, layoutMode === "speaker" ? /* @__PURE__ */ React.createElement("div", { className: "layout-speaker" }, /* @__PURE__ */ React.createElement("div", { className: `main-stage ${isFullscreen && sidebarOpen ? "sidebar-open" : ""}`, ref: mainStageRef }, /* @__PURE__ */ React.createElement("div", { className: "main-video-area" }, isBrowserPipMode && /* @__PURE__ */ React.createElement("div", { className: "pip-mode-overlay" }, /* @__PURE__ */ React.createElement("div", { className: "pip-mode-banner" }, "PiP \uBAA8\uB4DC \uC774\uC6A9\uC911")), /* @__PURE__ */ React.createElement("div", { style: {
    opacity: isBrowserPipMode ? 0 : 1,
    pointerEvents: isBrowserPipMode ? "none" : "auto",
    width: "100%",
    height: "100%"
  } }, /* @__PURE__ */ React.createElement(
    VideoTile,
    {
      user: userForTile(mainUser?.isMe ? { ...mainUser, speaking: isSpeaking } : mainUser),
      isMain: true,
      stream: mainStream,
      roomReconnecting,
      isScreen: isMainScreenShare,
      reaction: mainUser?.reaction,
      videoRef: mainVideoRef,
      isFilterPreparing,
      isBrowserPipMode,
      onSpeakingChange: handleSpeakingChange
    }
  )), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "pip-btn",
      onClick: handleBrowserPip,
      title: "PiP",
      type: "button"
    },
    /* @__PURE__ */ React.createElement(PictureInPicture2, { size: 22 })
  ), /* @__PURE__ */ React.createElement("button", { className: "fullscreen-btn", onClick: handleFullscreen, title: isFullscreen ? "\uC804\uCCB4\uD654\uBA74 \uC885\uB8CC" : "\uC804\uCCB4\uD654\uBA74" }, isFullscreen ? /* @__PURE__ */ React.createElement(Minimize, { size: 20 }) : /* @__PURE__ */ React.createElement(Maximize, { size: 20 }))), isFullscreen && /* @__PURE__ */ React.createElement(React.Fragment, null, showReactions && /* @__PURE__ */ React.createElement("div", { className: "fullscreen-reaction-popup" }, /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "reaction-btn",
      onClick: () => {
        setFaceMode("");
        faceModeRef.current = "";
        setFaceEmoji("");
        faceEmojiRef.current = "";
        setBgRemove(false);
        bgRemoveRef.current = false;
        stopAvatarFilter().catch(() => {
        });
        setShowReactions(false);
        setToastMessage("\uC5BC\uAD74 \uD544\uD130\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
      }
    },
    "\u274C"
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: `reaction-btn ${bgRemove ? "active" : ""}`,
      onClick: async () => {
        const next = !bgRemoveRef.current;
        setBgRemove(next);
        bgRemoveRef.current = next;
        setShowReactions(false);
        setToastMessage(next ? "\uBC30\uACBD\uC774 \uC81C\uAC70\uB418\uC5C8\uC2B5\uB2C8\uB2E4." : "\uBC30\uACBD \uC81C\uAC70\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
      },
      title: "\uBC30\uACBD \uC9C0\uC6B0\uAE30"
    },
    "\u{1F9F9}"
  ), faceEmojis.map((emoji) => /* @__PURE__ */ React.createElement(
    "button",
    {
      key: emoji,
      onClick: async () => {
        setFaceMode("emoji");
        faceModeRef.current = "emoji";
        setFaceEmoji(emoji);
        faceEmojiRef.current = emoji;
        setShowReactions(false);
        if (!canvasPipelineActiveRef.current) {
          setToastMessage("\uC774\uBAA8\uC9C0\uAC00 \uC120\uD0DD\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uCE74\uBA54\uB77C\uB97C \uCF1C\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.");
        } else {
          setToastMessage("\uC5BC\uAD74 \uC774\uBAA8\uC9C0 \uD544\uD130\uAC00 \uC801\uC6A9\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        }
        setShowToast(true);
      },
      className: "reaction-btn"
    },
    emoji
  ))), /* @__PURE__ */ React.createElement("div", { className: `fullscreen-sidebar ${sidebarOpen ? "open" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "fullscreen-sidebar-inner" }, /* @__PURE__ */ React.createElement("div", { className: "fullscreen-sidebar-header" }, /* @__PURE__ */ React.createElement("h2", { className: "sidebar-title" }, "\uCC38\uC5EC\uC790 \uBAA9\uB85D"), /* @__PURE__ */ React.createElement("button", { onClick: () => setSidebarOpen(false), className: "close-btn" }, /* @__PURE__ */ React.createElement(X, { size: 20 }))), /* @__PURE__ */ React.createElement("div", { className: "fullscreen-participants-area custom-scrollbar" }, /* @__PURE__ */ React.createElement("div", { className: "section-label" }, "\uCC38\uC5EC \uC911 (", participants.length, ")"), participants.map((p2) => /* @__PURE__ */ React.createElement("div", { key: p2.id, className: `participant-card ${p2.isMe ? "me" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "p-info" }, /* @__PURE__ */ React.createElement(UserAvatar, { name: p2.name }), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { className: `p-name ${p2.isMe ? "me" : ""}` }, p2.name, " ", p2.isMe ? "(\uB098)" : "", " ", p2.isHost ? "\u{1F451}" : ""), /* @__PURE__ */ React.createElement("div", { className: "p-role" }, p2.isHost ? "\uBC29\uC7A5" : p2.isMe ? "\uB098" : "\uCC38\uC5EC\uC790"))), /* @__PURE__ */ React.createElement("div", { className: "p-status" }, p2.muted ? /* @__PURE__ */ React.createElement(MicOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Mic, { size: 16 }), p2.cameraOff ? /* @__PURE__ */ React.createElement(VideoOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Video, { size: 16 }), !p2.isMe && amIHost && /* @__PURE__ */ React.createElement("div", { className: "host-menu-container" }, /* @__PURE__ */ React.createElement("button", { className: "more-btn", onClick: () => toggleHostMenu(p2.id) }, /* @__PURE__ */ React.createElement(Ellipsis, { size: 16 })), hostMenuTargetId === p2.id && /* @__PURE__ */ React.createElement("div", { className: "host-menu-dropdown" }, !p2.muted ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceMute(p2.id) }, /* @__PURE__ */ React.createElement(MicOff, { size: 14 }), " \uB9C8\uC774\uD06C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceUnmute(p2.id) }, /* @__PURE__ */ React.createElement(Mic, { size: 14 }), " \uB9C8\uC774\uD06C \uCF1C\uAE30"), !p2.cameraOff ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOff(p2.id) }, /* @__PURE__ */ React.createElement(VideoOff, { size: 14 }), " \uCE74\uBA54\uB77C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOn(p2.id) }, /* @__PURE__ */ React.createElement(Video, { size: 14 }), " \uCE74\uBA54\uB77C \uCF1C\uAE30"), /* @__PURE__ */ React.createElement("button", { className: "kick-btn", onClick: () => handleKick(p2.id) }, /* @__PURE__ */ React.createElement(X, { size: 14 }), " \uB0B4\uBCF4\uB0B4\uAE30")))))), amIHost && /* @__PURE__ */ React.createElement("div", { className: "invite-section" }, /* @__PURE__ */ React.createElement("button", { className: "invite-btn", onClick: handleInvite }, /* @__PURE__ */ React.createElement(Share, { size: 16 }), " \uCD08\uB300\uD558\uAE30"))), /* @__PURE__ */ React.createElement("div", { className: "sidebar-chat-divider" }, /* @__PURE__ */ React.createElement("span", null, "\uCC44\uD305")), /* @__PURE__ */ React.createElement("div", { className: "fullscreen-chat-area custom-scrollbar", ref: chatAreaRef }, messages.map((msg) => /* @__PURE__ */ React.createElement("div", { key: msg.id, className: `chat-msg ${msg.isMe ? "me" : "others"}` }, /* @__PURE__ */ React.createElement("div", { className: "msg-content-wrapper" }, !msg.isMe && /* @__PURE__ */ React.createElement(UserAvatar, { name: msg.userName, size: "sm" }), /* @__PURE__ */ React.createElement("div", { className: "msg-bubble" }, msg.text)), /* @__PURE__ */ React.createElement("span", { className: "msg-time" }, msg.userName, ", ", msg.time))), /* @__PURE__ */ React.createElement("div", { ref: chatEndRef })), /* @__PURE__ */ React.createElement("div", { className: "fullscreen-chat-input-area" }, /* @__PURE__ */ React.createElement("form", { onSubmit: handleSendMessage, className: "chat-form" }, /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "text",
      value: chatDraft,
      onChange: (e2) => setChatDraft(e2.target.value),
      placeholder: "\uBA54\uC2DC\uC9C0\uB97C \uC785\uB825\uD558\uC138\uC694...",
      className: "chat-input"
    }
  ), /* @__PURE__ */ React.createElement("button", { type: "submit", className: "send-btn", disabled: !chatDraft.trim() }, /* @__PURE__ */ React.createElement(Send, { size: 16 })))))), /* @__PURE__ */ React.createElement(
    "div",
    {
      className: `fullscreen-media-controls ${isStripVisible ? "visible" : "hidden"}`
    },
    /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: micOn ? "\uB9C8\uC774\uD06C \uB044\uAE30" : "\uB9C8\uC774\uD06C \uCF1C\uAE30",
        icon: Mic,
        active: !micOn,
        disabled: micDisabled,
        onClick: toggleMic
      }
    ),
    /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: camOn ? "\uCE74\uBA54\uB77C \uB044\uAE30" : "\uCE74\uBA54\uB77C \uCF1C\uAE30",
        icon: Video,
        active: !camOn,
        disabled: camDisabled,
        onClick: () => {
          if (camOn) {
            turnOffCamera();
          } else {
            turnOnCamera();
          }
        }
      }
    ),
    /* @__PURE__ */ React.createElement("div", { className: "divider" }),
    !isIOS && /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: isScreenSharing ? "\uD654\uBA74 \uACF5\uC720 \uC911\uC9C0" : "\uD654\uBA74 \uACF5\uC720",
        icon: Monitor,
        active: isScreenSharing,
        onClick: () => {
          if (isScreenSharing) {
            stopScreenShare();
          } else {
            startScreenShare();
          }
        }
      }
    ),
    /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: "\uC5BC\uAD74",
        icon: Smile,
        active: showReactions,
        onClick: () => setShowReactions(!showReactions)
      }
    ),
    /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: sidebarOpen ? "\uC0AC\uC774\uB4DC\uBC14 \uB2EB\uAE30" : "\uC0AC\uC774\uB4DC\uBC14 \uC5F4\uAE30",
        icon: sidebarOpen ? PanelRightClose : PanelRightOpen,
        active: sidebarOpen,
        onClick: toggleSidebarOpen
      }
    ),
    /* @__PURE__ */ React.createElement("div", { className: "divider" }),
    /* @__PURE__ */ React.createElement(
      ButtonControl,
      {
        label: "\uD1B5\uD654 \uC885\uB8CC",
        danger: true,
        icon: Phone,
        onClick: () => setLeaveConfirmModal(true)
      }
    )
  ), /* @__PURE__ */ React.createElement(
    "div",
    {
      className: `fullscreen-strip-wrapper ${isStripVisible ? "visible" : "hidden"}`
    },
    /* @__PURE__ */ React.createElement("div", { className: "fullscreen-strip custom-scrollbar" }, orderedParticipants.map((p2) => /* @__PURE__ */ React.createElement(
      "div",
      {
        key: p2.id,
        className: `strip-item ${activeSpeakerId === p2.id ? "active-strip" : ""} ${p2.isScreenSharing ? "screen-sharing" : ""}`,
        onClick: () => {
          manuallySelectedRef.current = true;
          setActiveSpeakerId(p2.id);
        }
      },
      /* @__PURE__ */ React.createElement(
        VideoTile,
        {
          user: userForTile(p2),
          stream: p2.isScreenSharing ? p2.screenStream : p2.isMe ? localStream : p2.stream,
          roomReconnecting,
          isScreen: p2.isScreenSharing,
          reaction: p2.reaction,
          isBrowserPipMode,
          isFilterPreparing,
          onSpeakingChange: handleSpeakingChange
        }
      ),
      /* @__PURE__ */ React.createElement("span", { className: "strip-name" }, p2.isMe ? "(\uB098)" : p2.name)
    )))
  ), showStripToggle && /* @__PURE__ */ React.createElement(
    "button",
    {
      className: `fullscreen-strip-toggle-btn show ${isStripVisible ? "down" : "up"}`,
      onClick: () => setIsStripVisible((v2) => !v2),
      title: isStripVisible ? "\uCC38\uAC00\uC790 \uC228\uAE30\uAE30" : "\uCC38\uAC00\uC790 \uBCF4\uAE30"
    },
    isStripVisible ? /* @__PURE__ */ React.createElement(ChevronDown, null) : /* @__PURE__ */ React.createElement(ChevronUp, null)
  ))), /* @__PURE__ */ React.createElement("div", { ref: bottomStripRef, className: "bottom-strip" }, orderedParticipants.map((p2) => /* @__PURE__ */ React.createElement(
    "div",
    {
      key: p2.id,
      className: `strip-item ${activeSpeakerId === p2.id ? "active-strip" : ""} ${p2.isScreenSharing ? "screen-sharing" : ""}`,
      onClick: (e2) => handleStripItemClick(e2, p2.id)
    },
    /* @__PURE__ */ React.createElement(
      VideoTile,
      {
        user: userForTile(p2),
        stream: p2.isScreenSharing ? p2.screenStream : p2.isMe ? localStream : p2.stream,
        roomReconnecting,
        isScreen: p2.isScreenSharing,
        reaction: p2.reaction,
        isFilterPreparing,
        onSpeakingChange: handleSpeakingChange
      }
    ),
    /* @__PURE__ */ React.createElement("span", { className: "strip-name" }, p2.isMe ? "(\uB098)" : p2.name)
  )))) : (
    /* Grid  */
    /* @__PURE__ */ React.createElement("div", { className: `layout-grid custom-scrollbar ${isGridFullscreen ? "fullscreen-active" : ""}` }, isGridFullscreen && /* @__PURE__ */ React.createElement(
      "div",
      {
        ref: gridFullscreenStageRef,
        className: `grid-fullscreen-container active ${isGridScreenShare ? "screen-share-active" : ""} ${sidebarOpen ? "sidebar-open" : ""}`
      },
      /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-video-area" }, isBrowserPipMode && String(gridFullscreenUser?.id) === String(customPipData?.peerId) && /* @__PURE__ */ React.createElement("div", { className: "pip-mode-overlay" }, /* @__PURE__ */ React.createElement("div", { className: "pip-mode-banner" }, "PiP \uBAA8\uB4DC \uC774\uC6A9\uC911")), /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            opacity: isBrowserPipMode && String(gridFullscreenUser?.id) === String(customPipData?.peerId) ? 0 : 1,
            pointerEvents: isBrowserPipMode && String(gridFullscreenUser?.id) === String(customPipData?.peerId) ? "none" : "auto",
            position: "absolute",
            inset: 0
          }
        },
        /* @__PURE__ */ React.createElement(
          VideoTile,
          {
            user: userForTile(gridFullscreenUser),
            isMain: true,
            stream: gridFullscreenStream,
            roomReconnecting,
            isScreen: isGridScreenShare,
            reaction: gridFullscreenUser?.isMe ? myReaction : gridFullscreenUser?.reaction,
            videoRef: gridFullscreenVideoRef,
            isFilterPreparing,
            isBrowserPipMode,
            onSpeakingChange: handleSpeakingChange
          }
        )
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "grid-fullscreen-pip-btn",
          onClick: handleGridBrowserPip,
          title: "PiP",
          type: "button"
        },
        /* @__PURE__ */ React.createElement(PictureInPicture2, { size: 22 })
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "grid-fullscreen-btn",
          onClick: () => {
            if (document.fullscreenElement) {
              document.exitFullscreen();
            } else {
              gridFullscreenStageRef.current?.requestFullscreen().catch((err) => {
                console.error("\uC804\uCCB4\uD654\uBA74 \uC804\uD658 \uC2E4\uD328:", err);
              });
            }
          },
          title: "\uC804\uCCB4\uD654\uBA74 \uC885\uB8CC"
        },
        /* @__PURE__ */ React.createElement(Minimize, { size: 18 })
      )),
      /* @__PURE__ */ React.createElement(React.Fragment, null, showReactions && /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-reaction-popup" }, /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "reaction-btn",
          onClick: () => {
            setFaceMode("");
            faceModeRef.current = "";
            setFaceEmoji("");
            faceEmojiRef.current = "";
            setBgRemove(false);
            bgRemoveRef.current = false;
            setShowReactions(false);
            setToastMessage("\uC5BC\uAD74 \uD544\uD130\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
            setShowToast(true);
          }
        },
        "\u274C"
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          className: `reaction-btn ${bgRemove ? "active" : ""}`,
          onClick: async () => {
            const next = !bgRemoveRef.current;
            setBgRemove(next);
            bgRemoveRef.current = next;
            setShowReactions(false);
            setToastMessage(next ? "\uBC30\uACBD\uC774 \uC81C\uAC70\uB418\uC5C8\uC2B5\uB2C8\uB2E4." : "\uBC30\uACBD \uC81C\uAC70\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
            setShowToast(true);
          },
          title: "\uBC30\uACBD \uC9C0\uC6B0\uAE30"
        },
        "\u{1F9F9}"
      ), faceEmojis.map((emoji) => /* @__PURE__ */ React.createElement(
        "button",
        {
          key: emoji,
          onClick: async () => {
            setFaceMode("emoji");
            faceModeRef.current = "emoji";
            setFaceEmoji(emoji);
            faceEmojiRef.current = emoji;
            setShowReactions(false);
            if (!canvasPipelineActiveRef.current) {
              setToastMessage("\uC774\uBAA8\uC9C0\uAC00 \uC120\uD0DD\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uCE74\uBA54\uB77C\uB97C \uCF1C\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.");
            } else {
              setToastMessage("\uC5BC\uAD74 \uC774\uBAA8\uC9C0 \uD544\uD130\uAC00 \uC801\uC6A9\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
            }
            setShowToast(true);
          },
          className: "reaction-btn"
        },
        emoji
      ))), /* @__PURE__ */ React.createElement("div", { className: `grid-fullscreen-sidebar ${sidebarOpen ? "open" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-sidebar-inner" }, /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-sidebar-header" }, /* @__PURE__ */ React.createElement("h2", { className: "sidebar-title" }, "\uCC38\uC5EC\uC790 \uBAA9\uB85D"), /* @__PURE__ */ React.createElement("button", { onClick: () => setSidebarOpen(false), className: "close-btn" }, /* @__PURE__ */ React.createElement(X, { size: 20 }))), /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-participants-area custom-scrollbar" }, /* @__PURE__ */ React.createElement("div", { className: "section-label" }, "\uCC38\uC5EC \uC911 (", participants.length, ")"), participants.map((part) => /* @__PURE__ */ React.createElement("div", { key: part.id, className: `participant-card ${part.isMe ? "me" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "p-info" }, /* @__PURE__ */ React.createElement(UserAvatar, { name: part.name }), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { className: `p-name ${part.isMe ? "me" : ""}` }, part.name, " ", part.isMe ? "(\uB098)" : "", " ", part.isHost ? "\u{1F451}" : ""), /* @__PURE__ */ React.createElement("div", { className: "p-role" }, part.isHost ? "\uBC29\uC7A5" : part.isMe ? "\uB098" : "\uCC38\uC5EC\uC790"))), /* @__PURE__ */ React.createElement("div", { className: "p-status" }, part.muted ? /* @__PURE__ */ React.createElement(MicOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Mic, { size: 16 }), part.cameraOff ? /* @__PURE__ */ React.createElement(VideoOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Video, { size: 16 }), !part.isMe && amIHost && /* @__PURE__ */ React.createElement("div", { className: "host-menu-container" }, /* @__PURE__ */ React.createElement("button", { className: "more-btn", onClick: () => toggleHostMenu(part.id) }, /* @__PURE__ */ React.createElement(Ellipsis, { size: 16 })), hostMenuTargetId === part.id && /* @__PURE__ */ React.createElement("div", { className: "host-menu-dropdown" }, !part.muted ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceMute(part.id) }, /* @__PURE__ */ React.createElement(MicOff, { size: 14 }), " \uB9C8\uC774\uD06C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceUnmute(part.id) }, /* @__PURE__ */ React.createElement(Mic, { size: 14 }), " \uB9C8\uC774\uD06C \uCF1C\uAE30"), !part.cameraOff ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOff(part.id) }, /* @__PURE__ */ React.createElement(VideoOff, { size: 14 }), " \uCE74\uBA54\uB77C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOn(part.id) }, /* @__PURE__ */ React.createElement(Video, { size: 14 }), " \uCE74\uBA54\uB77C \uCF1C\uAE30"), /* @__PURE__ */ React.createElement("button", { className: "kick-btn", onClick: () => handleKick(part.id) }, /* @__PURE__ */ React.createElement(X, { size: 14 }), " \uB0B4\uBCF4\uB0B4\uAE30")))))), amIHost && /* @__PURE__ */ React.createElement("div", { className: "invite-section" }, /* @__PURE__ */ React.createElement("button", { className: "invite-btn", onClick: handleInvite }, /* @__PURE__ */ React.createElement(Share, { size: 16 }), " \uCD08\uB300\uD558\uAE30"))), /* @__PURE__ */ React.createElement("div", { className: "sidebar-chat-divider" }, /* @__PURE__ */ React.createElement("span", null, "\uCC44\uD305")), /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-chat-area custom-scrollbar", ref: chatAreaRef }, messages.map((msg) => /* @__PURE__ */ React.createElement("div", { key: msg.id, className: `chat-msg ${msg.isMe ? "me" : "others"}` }, /* @__PURE__ */ React.createElement("div", { className: "msg-content-wrapper" }, !msg.isMe && /* @__PURE__ */ React.createElement(UserAvatar, { name: msg.userName, size: "sm" }), /* @__PURE__ */ React.createElement("div", { className: "msg-bubble" }, msg.text)), /* @__PURE__ */ React.createElement("span", { className: "msg-time" }, msg.userName, ", ", msg.time))), /* @__PURE__ */ React.createElement("div", { ref: chatEndRef })), /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-chat-input-area" }, /* @__PURE__ */ React.createElement("form", { onSubmit: handleSendMessage, className: "chat-form" }, /* @__PURE__ */ React.createElement(
        "input",
        {
          type: "text",
          value: chatDraft,
          onChange: (e2) => setChatDraft(e2.target.value),
          placeholder: "\uBA54\uC2DC\uC9C0\uB97C \uC785\uB825\uD558\uC138\uC694...",
          className: "chat-input"
        }
      ), /* @__PURE__ */ React.createElement("button", { type: "submit", className: "send-btn", disabled: !chatDraft.trim() }, /* @__PURE__ */ React.createElement(Send, { size: 16 })))))), /* @__PURE__ */ React.createElement("div", { className: `grid-fullscreen-media-controls ${gridStripVisible ? "visible" : "hidden"}` }, /* @__PURE__ */ React.createElement(ButtonControl, { label: micOn ? "\uB9C8\uC774\uD06C \uB044\uAE30" : "\uB9C8\uC774\uD06C \uCF1C\uAE30", icon: Mic, active: !micOn, disabled: micDisabled, onClick: toggleMic }), /* @__PURE__ */ React.createElement(ButtonControl, { label: camOn ? "\uCE74\uBA54\uB77C \uB044\uAE30" : "\uCE74\uBA54\uB77C \uCF1C\uAE30", icon: Video, active: !camOn, disabled: camDisabled, onClick: () => camOn ? turnOffCamera() : turnOnCamera() }), /* @__PURE__ */ React.createElement("div", { className: "divider" }), !isIOS && /* @__PURE__ */ React.createElement(
        ButtonControl,
        {
          label: isScreenSharing ? "\uD654\uBA74 \uACF5\uC720 \uC911\uC9C0" : "\uD654\uBA74 \uACF5\uC720",
          icon: Monitor,
          active: isScreenSharing,
          onClick: () => isScreenSharing ? stopScreenShare() : startScreenShare()
        }
      ), /* @__PURE__ */ React.createElement(ButtonControl, { label: "\uC5BC\uAD74", icon: Smile, active: showReactions, onClick: () => setShowReactions(!showReactions) }), /* @__PURE__ */ React.createElement(
        ButtonControl,
        {
          label: sidebarOpen ? "\uC0AC\uC774\uB4DC\uBC14 \uB2EB\uAE30" : "\uC0AC\uC774\uB4DC\uBC14 \uC5F4\uAE30",
          icon: sidebarOpen ? PanelRightClose : PanelRightOpen,
          active: sidebarOpen,
          onClick: toggleSidebarOpen
        }
      ), /* @__PURE__ */ React.createElement("div", { className: "divider" }), /* @__PURE__ */ React.createElement(ButtonControl, { label: "\uD1B5\uD654 \uC885\uB8CC", danger: true, icon: Phone, onClick: () => setLeaveConfirmModal(true) })), /* @__PURE__ */ React.createElement("div", { className: `grid-fullscreen-strip-wrapper ${gridStripVisible ? "visible" : "hidden"}` }, /* @__PURE__ */ React.createElement("div", { className: "grid-fullscreen-strip" }, orderedParticipants.map((part) => /* @__PURE__ */ React.createElement(
        "div",
        {
          key: part.id,
          className: `strip-item ${gridFullscreenId === part.id ? "active-strip" : ""} ${part.isScreenSharing ? "screen-sharing" : ""}`,
          onClick: () => setGridFullscreenId(part.id)
        },
        /* @__PURE__ */ React.createElement(
          VideoTile,
          {
            user: userForTile(part),
            stream: part.isScreenSharing ? part.screenStream : part.isMe ? localStream : part.stream,
            roomReconnecting,
            isScreen: part.isScreenSharing,
            reaction: part.reaction,
            isFilterPreparing,
            isBrowserPipMode,
            onSpeakingChange: handleSpeakingChange
          }
        ),
        /* @__PURE__ */ React.createElement("span", { className: "strip-name" }, part.isMe ? "(\uB098)" : part.name)
      )))), showGridStripToggle && /* @__PURE__ */ React.createElement(
        "button",
        {
          className: `grid-fullscreen-strip-toggle-btn show ${gridStripVisible ? "down" : "up"}`,
          onClick: () => setGridStripVisible((v2) => !v2),
          title: gridStripVisible ? "\uCC38\uAC00\uC790 \uC228\uAE30\uAE30" : "\uCC38\uAC00\uC790 \uBCF4\uAE30"
        },
        gridStripVisible ? /* @__PURE__ */ React.createElement(ChevronDown, null) : /* @__PURE__ */ React.createElement(ChevronUp, null)
      ))
    ), !isGridFullscreen && orderedParticipants.map((p2) => {
      const isThisTilePip = isBrowserPipMode && String(p2.id) === String(customPipData?.peerId);
      return /* @__PURE__ */ React.createElement("div", { key: p2.id, className: "grid-tile" }, /* @__PURE__ */ React.createElement("div", { className: "grid-video-area" }, isThisTilePip && /* @__PURE__ */ React.createElement("div", { className: "grid-tile-pip-mode-overlay" }, /* @__PURE__ */ React.createElement("span", { className: "pip-mode-banner" }, "PiP \uBAA8\uB4DC \uC774\uC6A9\uC911")), /* @__PURE__ */ React.createElement(
        "div",
        {
          style: {
            opacity: isThisTilePip ? 0 : 1,
            pointerEvents: isThisTilePip ? "none" : "auto",
            position: "absolute",
            inset: 0
          }
        },
        /* @__PURE__ */ React.createElement(
          VideoTile,
          {
            user: userForTile(p2),
            stream: p2.isScreenSharing ? p2.screenStream : p2.isMe ? localStream : p2.stream,
            videoRef: getGridTileVideoRef(p2.id),
            roomReconnecting,
            isScreen: p2.isScreenSharing,
            reaction: p2.isMe ? myReaction : null,
            isFilterPreparing,
            isBrowserPipMode,
            onSpeakingChange: handleSpeakingChange
          }
        )
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "grid-tile-pip-btn",
          onClick: (e2) => {
            e2.stopPropagation();
            handleGridTileBrowserPip(p2);
          },
          title: "PiP",
          type: "button"
        },
        /* @__PURE__ */ React.createElement(PictureInPicture2, { size: 18 })
      ), /* @__PURE__ */ React.createElement(
        "button",
        {
          className: "grid-fullscreen-btn",
          onClick: () => {
            setGridFullscreenId(p2.id);
            setIsGridFullscreen(true);
          },
          title: "\uC804\uCCB4\uD654\uBA74"
        },
        /* @__PURE__ */ React.createElement(Maximize, { size: 18 })
      )));
    }))
  )), /* @__PURE__ */ React.createElement("div", { className: "meet-controls-container" }, showReactions && /* @__PURE__ */ React.createElement("div", { className: "reaction-popup glass-panel" }, /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "reaction-btn",
      onClick: () => {
        setFaceMode("");
        faceModeRef.current = "";
        setFaceEmoji("");
        faceEmojiRef.current = "";
        setBgRemove(false);
        bgRemoveRef.current = false;
        setShowReactions(false);
        setToastMessage("\uC5BC\uAD74 \uD544\uD130\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
      }
    },
    "\u274C"
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: `reaction-btn ${bgRemove ? "active" : ""}`,
      onClick: async () => {
        const next = !bgRemoveRef.current;
        setBgRemove(next);
        bgRemoveRef.current = next;
        setShowReactions(false);
        setToastMessage(next ? "\uBC30\uACBD\uC774 \uC81C\uAC70\uB418\uC5C8\uC2B5\uB2C8\uB2E4." : "\uBC30\uACBD \uC81C\uAC70\uAC00 \uD574\uC81C\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
      },
      title: "\uBC30\uACBD \uC9C0\uC6B0\uAE30"
    },
    "\u{1F9F9}"
  ), faceEmojis.map((emoji) => /* @__PURE__ */ React.createElement(
    "button",
    {
      key: emoji,
      onClick: async () => {
        setFaceMode("emoji");
        faceModeRef.current = "emoji";
        setFaceEmoji(emoji);
        faceEmojiRef.current = emoji;
        setShowReactions(false);
        if (!canvasPipelineActiveRef.current) {
          setToastMessage("\uC774\uBAA8\uC9C0\uAC00 \uC120\uD0DD\uB418\uC5C8\uC2B5\uB2C8\uB2E4. \uCE74\uBA54\uB77C\uB97C \uCF1C\uBA74 \uC801\uC6A9\uB429\uB2C8\uB2E4.");
        } else {
          setToastMessage("\uC5BC\uAD74 \uC774\uBAA8\uC9C0 \uD544\uD130\uAC00 \uC801\uC6A9\uB418\uC5C8\uC2B5\uB2C8\uB2E4.");
        }
        setShowToast(true);
      },
      className: "reaction-btn"
    },
    emoji
  ))), /* @__PURE__ */ React.createElement("div", { className: "controls-toolbar glass-panel" }, /* @__PURE__ */ React.createElement(
    ButtonControl,
    {
      label: micOn ? "\uB9C8\uC774\uD06C \uB044\uAE30" : "\uB9C8\uC774\uD06C \uCF1C\uAE30",
      icon: Mic,
      active: !micOn,
      disabled: micDisabled,
      onClick: toggleMic
    }
  ), /* @__PURE__ */ React.createElement(
    ButtonControl,
    {
      label: camOn ? "\uCE74\uBA54\uB77C \uB044\uAE30" : "\uCE74\uBA54\uB77C \uCF1C\uAE30",
      icon: Video,
      active: !camOn,
      disabled: camDisabled,
      onClick: camOn ? turnOffCamera : turnOnCamera
    }
  ), /* @__PURE__ */ React.createElement("div", { className: "divider" }), !isIOS && /* @__PURE__ */ React.createElement(
    ButtonControl,
    {
      label: isScreenSharing ? "\uD654\uBA74 \uACF5\uC720 \uC911\uC9C0" : "\uD654\uBA74 \uACF5\uC720",
      icon: Monitor,
      active: isScreenSharing,
      onClick: () => {
        if (isScreenSharing) {
          stopScreenShare();
        } else {
          startScreenShare();
        }
      }
    }
  ), /* @__PURE__ */ React.createElement(ButtonControl, { label: "\uC5BC\uAD74", icon: Smile, active: showReactions, onClick: () => setShowReactions(!showReactions) }), /* @__PURE__ */ React.createElement(
    ButtonControl,
    {
      label: sidebarOpen ? "\uC0AC\uC774\uB4DC\uBC14 \uB2EB\uAE30" : "\uC0AC\uC774\uB4DC\uBC14 \uC5F4\uAE30",
      icon: sidebarOpen ? PanelRightClose : PanelRightOpen,
      active: sidebarOpen,
      onClick: toggleSidebarOpen
    }
  ), /* @__PURE__ */ React.createElement("div", { className: "divider" }), /* @__PURE__ */ React.createElement(ButtonControl, { label: "\uD1B5\uD654 \uC885\uB8CC", danger: true, icon: Phone, onClick: () => setLeaveConfirmModal(true) })))), /* @__PURE__ */ React.createElement("aside", { className: `meet-sidebar ${sidebarOpen && !isGridFullscreen && !isFullscreen ? "open" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: `sidebar-inner ${!amIHost ? "sidebar-inner--guest" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "sidebar-header" }, /* @__PURE__ */ React.createElement("h2", { className: "sidebar-title" }, "\uCC38\uC5EC\uC790 \uBAA9\uB85D")), /* @__PURE__ */ React.createElement("div", { className: "participants-area" }, /* @__PURE__ */ React.createElement("div", { className: "section-label" }, "\uCC38\uC5EC \uC911 (", participants.length, ")"), participants.map((p2) => /* @__PURE__ */ React.createElement("div", { key: p2.id, className: `participant-card ${p2.isMe ? "me" : ""}` }, /* @__PURE__ */ React.createElement("div", { className: "p-info" }, /* @__PURE__ */ React.createElement(UserAvatar, { name: p2.name }), /* @__PURE__ */ React.createElement("div", null, /* @__PURE__ */ React.createElement("div", { className: `p-name ${p2.isMe ? "me" : ""}` }, p2.name, " ", p2.isMe ? "(\uB098)" : "", " ", p2.isHost ? "\u{1F451}" : ""), /* @__PURE__ */ React.createElement("div", { className: "p-role" }, p2.isHost ? "\uBC29\uC7A5" : p2.isMe ? "\uB098" : "\uCC38\uC5EC\uC790"))), /* @__PURE__ */ React.createElement("div", { className: "p-status" }, p2.muted ? /* @__PURE__ */ React.createElement(MicOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Mic, { size: 16, className: "icon-hidden" }), p2.cameraOff ? /* @__PURE__ */ React.createElement(VideoOff, { size: 16, className: "icon-red" }) : /* @__PURE__ */ React.createElement(Video, { size: 16, className: "icon-hidden" }), !p2.isMe && amIHost && /* @__PURE__ */ React.createElement("div", { className: "host-menu-container" }, /* @__PURE__ */ React.createElement("button", { className: "more-btn", onClick: () => toggleHostMenu(p2.id) }, /* @__PURE__ */ React.createElement(Ellipsis, { size: 16 })), hostMenuTargetId === p2.id && /* @__PURE__ */ React.createElement("div", { className: "host-menu-dropdown" }, !p2.muted ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceMute(p2.id) }, /* @__PURE__ */ React.createElement(MicOff, { size: 14 }), " \uB9C8\uC774\uD06C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceUnmute(p2.id) }, /* @__PURE__ */ React.createElement(Mic, { size: 14 }), " \uB9C8\uC774\uD06C \uCF1C\uAE30"), !p2.cameraOff ? /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOff(p2.id) }, /* @__PURE__ */ React.createElement(VideoOff, { size: 14 }), " \uCE74\uBA54\uB77C \uB044\uAE30") : /* @__PURE__ */ React.createElement("button", { onClick: () => handleForceCameraOn(p2.id) }, /* @__PURE__ */ React.createElement(Video, { size: 14 }), " \uCE74\uBA54\uB77C \uCF1C\uAE30"), /* @__PURE__ */ React.createElement("button", { className: "kick-btn", onClick: () => handleKick(p2.id) }, /* @__PURE__ */ React.createElement(X, { size: 14 }), " \uB0B4\uBCF4\uB0B4\uAE30")))))), amIHost && /* @__PURE__ */ React.createElement("div", { className: "invite-section" }, /* @__PURE__ */ React.createElement("button", { className: "invite-btn", onClick: handleInvite }, /* @__PURE__ */ React.createElement(Share, { size: 16 }), " \uCD08\uB300\uD558\uAE30"))), /* @__PURE__ */ React.createElement("div", { className: "sidebar-chat-divider" }, /* @__PURE__ */ React.createElement("span", null, "\uCC44\uD305")), /* @__PURE__ */ React.createElement("div", { className: "chat-area custom-scrollbar", ref: chatAreaRef }, messages.map((msg) => /* @__PURE__ */ React.createElement("div", { key: msg.id, className: `chat-msg ${msg.isMe ? "me" : "others"}` }, /* @__PURE__ */ React.createElement("div", { className: "msg-content-wrapper" }, !msg.isMe && /* @__PURE__ */ React.createElement(UserAvatar, { name: msg.userName, size: "sm" }), /* @__PURE__ */ React.createElement("div", { className: "msg-bubble" }, msg.text)), /* @__PURE__ */ React.createElement("span", { className: "msg-time" }, msg.userName, ", ", msg.time))), /* @__PURE__ */ React.createElement("div", { ref: chatEndRef })), /* @__PURE__ */ React.createElement("div", { className: "chat-input-area" }, /* @__PURE__ */ React.createElement("form", { onSubmit: handleSendMessage, className: "chat-form" }, /* @__PURE__ */ React.createElement(
    "input",
    {
      type: "text",
      value: chatDraft,
      onChange: (e2) => setChatDraft(e2.target.value),
      placeholder: "\uBA54\uC2DC\uC9C0\uB97C \uC785\uB825\uD558\uC138\uC694...",
      className: "chat-input"
    }
  ), /* @__PURE__ */ React.createElement("button", { type: "submit", className: "send-btn", disabled: !chatDraft.trim() }, /* @__PURE__ */ React.createElement(Send, { size: 16 }))))))), leaveConfirmModal && /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-overlay", onClick: () => setLeaveConfirmModal(false) }, /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal", onClick: (e2) => e2.stopPropagation() }, /* @__PURE__ */ React.createElement("p", { className: "force-camera-on-modal-title" }, "\uD1B5\uD654\uB97C \uC885\uB8CC\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C?"), /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-actions", style: { marginTop: "1rem" } }, /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn allow",
      onClick: () => {
        setLeaveConfirmModal(false);
        handleHangup();
      }
    },
    "\uD655\uC778"
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn reject",
      onClick: () => setLeaveConfirmModal(false)
    },
    "\uCDE8\uC18C"
  )))), forceUnmuteRequest && /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-overlay", onClick: () => setForceUnmuteRequest(null) }, /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal", onClick: (e2) => e2.stopPropagation() }, /* @__PURE__ */ React.createElement("p", { className: "force-camera-on-modal-title" }, forceUnmuteRequest.hostName, "\uB2D8\uC774 \uB9C8\uC774\uD06C\uB97C \uCF1C\uB824\uACE0 \uD569\uB2C8\uB2E4."), /* @__PURE__ */ React.createElement("p", { className: "force-camera-on-modal-desc" }, "\uD5C8\uC6A9\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? \uAC70\uC808\uD558\uC2DC\uBA74 \uC6D0\uD558\uC2E4 \uB54C \uC9C1\uC811 \uCF24 \uC218 \uC788\uC2B5\uB2C8\uB2E4."), /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-actions" }, /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn allow",
      onClick: () => {
        const { hostName } = forceUnmuteRequest;
        setForceUnmuteRequest(null);
        setMicOn(true);
        try {
          localStorage.setItem("micOn", "true");
        } catch {
        }
        setToastMessage(`${hostName}\uB2D8\uC774 \uB9C8\uC774\uD06C\uB97C \uCF1C \uC8FC\uC5C8\uC2B5\uB2C8\uB2E4.`);
        setShowToast(true);
        const audioProducer = producersRef.current?.get?.("audio");
        if (audioProducer?.track) audioProducer.track.enabled = true;
        const at2 = localStreamRef.current?.getAudioTracks?.()[0];
        if (at2) at2.enabled = true;
      }
    },
    "\uD5C8\uC6A9"
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn reject",
      onClick: () => {
        setForceUnmuteRequest(null);
        setToastMessage("\uB9C8\uC774\uD06C \uCF1C\uAE30\uB97C \uAC70\uC808\uD588\uC2B5\uB2C8\uB2E4. \uC6D0\uD558\uC2E4 \uB54C \uC9C1\uC811 \uCF24 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: { muted: true }
          }));
        }
        setParticipants(
          (prev) => prev.map((p2) => p2.isMe ? { ...p2, muted: true } : p2)
        );
      }
    },
    "\uAC70\uC808"
  )))), forceCameraOnRequest && /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-overlay", onClick: () => setForceCameraOnRequest(null) }, /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal", onClick: (e2) => e2.stopPropagation() }, /* @__PURE__ */ React.createElement("p", { className: "force-camera-on-modal-title" }, forceCameraOnRequest.hostName, "\uB2D8\uC774 \uCE74\uBA54\uB77C\uB97C \uCF1C\uB824\uACE0 \uD569\uB2C8\uB2E4."), /* @__PURE__ */ React.createElement("p", { className: "force-camera-on-modal-desc" }, "\uD5C8\uC6A9\uD558\uC2DC\uACA0\uC2B5\uB2C8\uAE4C? \uAC70\uC808\uD558\uC2DC\uBA74 \uC5BC\uAD74\uC744 \uBCF4\uC5EC\uC8FC\uC9C0 \uC54A\uACE0 \uCC38\uC5EC\uD560 \uC218 \uC788\uC2B5\uB2C8\uB2E4."), /* @__PURE__ */ React.createElement("div", { className: "force-camera-on-modal-actions" }, /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn allow",
      onClick: () => {
        const { hostName } = forceCameraOnRequest;
        setForceCameraOnRequest(null);
        setCamOn(true);
        try {
          localStorage.setItem("camOn", "true");
        } catch {
        }
        setToastMessage(`${hostName}\uB2D8\uC774 \uCE74\uBA54\uB77C\uB97C \uCF1C \uC8FC\uC5C8\uC2B5\uB2C8\uB2E4.`);
        setShowToast(true);
        turnOnCamera().catch((e2) => console.warn("[FORCE_CAMERA_ON] turnOnCamera failed:", e2));
      }
    },
    "\uD5C8\uC6A9"
  ), /* @__PURE__ */ React.createElement(
    "button",
    {
      className: "force-camera-on-modal-btn reject",
      onClick: () => {
        setForceCameraOnRequest(null);
        setToastMessage("\uCE74\uBA54\uB77C \uCF1C\uAE30\uB97C \uAC70\uC808\uD588\uC2B5\uB2C8\uB2E4. \uC6D0\uD558\uC2E4 \uB54C \uC9C1\uC811 \uCF24 \uC218 \uC788\uC2B5\uB2C8\uB2E4.");
        setShowToast(true);
        if (wsRef.current?.readyState === WebSocket.OPEN) {
          wsRef.current.send(JSON.stringify({
            type: "USER_STATE_CHANGE",
            userId,
            changes: { cameraOff: true }
          }));
        }
        setParticipants(
          (prev) => prev.map((p2) => p2.isMe ? { ...p2, cameraOff: true } : p2)
        );
      }
    },
    "\uAC70\uC808"
  )))), /* @__PURE__ */ React.createElement(
    Toast_default,
    {
      message: toastMessage,
      visible: showToast,
      onClose: () => setShowToast(false)
    }
  ));
}
var MeetingPage_default = MeetingPage;
export {
  MeetingPage_default as default
};
/*! Bundled license information:

react/cjs/react.development.js:
  (**
   * @license React
   * react.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

lucide-react/dist/esm/shared/src/utils.js:
lucide-react/dist/esm/defaultAttributes.js:
lucide-react/dist/esm/Icon.js:
lucide-react/dist/esm/createLucideIcon.js:
lucide-react/dist/esm/icons/chevron-down.js:
lucide-react/dist/esm/icons/chevron-up.js:
lucide-react/dist/esm/icons/ellipsis.js:
lucide-react/dist/esm/icons/layout-grid.js:
lucide-react/dist/esm/icons/loader-circle.js:
lucide-react/dist/esm/icons/maximize.js:
lucide-react/dist/esm/icons/mic-off.js:
lucide-react/dist/esm/icons/mic.js:
lucide-react/dist/esm/icons/minimize.js:
lucide-react/dist/esm/icons/monitor.js:
lucide-react/dist/esm/icons/panel-right-close.js:
lucide-react/dist/esm/icons/panel-right-open.js:
lucide-react/dist/esm/icons/phone.js:
lucide-react/dist/esm/icons/picture-in-picture-2.js:
lucide-react/dist/esm/icons/send.js:
lucide-react/dist/esm/icons/share.js:
lucide-react/dist/esm/icons/smile.js:
lucide-react/dist/esm/icons/users.js:
lucide-react/dist/esm/icons/video-off.js:
lucide-react/dist/esm/icons/video.js:
lucide-react/dist/esm/icons/x.js:
lucide-react/dist/esm/lucide-react.js:
  (**
   * @license lucide-react v0.562.0 - ISC
   *
   * This source code is licensed under the ISC license.
   * See the LICENSE file in the root directory of this source tree.
   *)

react-router/dist/development/chunk-JZWAC4HX.mjs:
react-router/dist/development/index.mjs:
  (**
   * react-router v7.13.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

three/build/three.core.js:
three/build/three.module.js:
  (**
   * @license
   * Copyright 2010-2025 Three.js Authors
   * SPDX-License-Identifier: MIT
   *)

@pixiv/three-vrm/lib/three-vrm.module.js:
  (*!
   * @pixiv/three-vrm v3.4.5
   * VRM file loader for three.js.
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)

@pixiv/three-vrm/lib/three-vrm.module.js:
  (*!
   * @pixiv/three-vrm-core v3.4.5
   * The implementation of core features of VRM, for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-core is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
  (*!
   * @pixiv/three-vrm-materials-mtoon v3.4.5
   * MToon (toon material) module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-materials-mtoon is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
  (*!
   * @pixiv/three-vrm-materials-hdr-emissive-multiplier v3.4.5
   * Support VRMC_hdr_emissiveMultiplier for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-materials-hdr-emissive-multiplier is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
  (*!
   * @pixiv/three-vrm-materials-v0compat v3.4.5
   * VRM0.0 materials compatibility layer plugin for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-materials-v0compat is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
  (*!
   * @pixiv/three-vrm-node-constraint v3.4.5
   * Node constraint module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-node-constraint is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
  (*!
   * @pixiv/three-vrm-springbone v3.4.5
   * Spring bone module for @pixiv/three-vrm
   *
   * Copyright (c) 2019-2026 pixiv Inc.
   * @pixiv/three-vrm-springbone is distributed under MIT License
   * https://github.com/pixiv/three-vrm/blob/release/LICENSE
   *)
*/
